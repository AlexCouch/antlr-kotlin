// Generated from java-escape by ANTLR 4.7.1
package me.tomassetti.minicalc;
import com.strumenta.kotlinmultiplatform.Arrays
import com.strumenta.kotlinmultiplatform.getType
import com.strumenta.kotlinmultiplatform.TypeDeclarator
import org.antlr.v4.runtime.misc.Utils;
import org.antlr.v4.kotlinruntime.*
import org.antlr.v4.kotlinruntime.atn.*
import org.antlr.v4.kotlinruntime.atn.ATNDeserializer
import org.antlr.v4.kotlinruntime.atn.ParserATNSimulator
import org.antlr.v4.kotlinruntime.atn.PredictionContextCache
import org.antlr.v4.kotlinruntime.dfa.*
import org.antlr.v4.kotlinruntime.tree.ParseTreeListener
import org.antlr.v4.kotlinruntime.tree.TerminalNode
import org.antlr.v4.kotlinruntime.atn.ATN.Companion.INVALID_ALT_NUMBER
import org.antlr.v4.kotlinruntime.tree.ParseTreeVisitor
import kotlin.reflect.KClass

class Cobol85Parser(input: TokenStream) : Parser(input) {

    object solver : TypeDeclarator {
        override val classesByName : List<KClass<*>> = listOf(Cobol85Parser.StartRuleContext::class,
                                                              Cobol85Parser.CompilationUnitContext::class,
                                                              Cobol85Parser.ProgramUnitContext::class,
                                                              Cobol85Parser.EndProgramStatementContext::class,
                                                              Cobol85Parser.IdentificationDivisionContext::class,
                                                              Cobol85Parser.IdentificationDivisionBodyContext::class,
                                                              Cobol85Parser.ProgramIdParagraphContext::class,
                                                              Cobol85Parser.AuthorParagraphContext::class,
                                                              Cobol85Parser.InstallationParagraphContext::class,
                                                              Cobol85Parser.DateWrittenParagraphContext::class,
                                                              Cobol85Parser.DateCompiledParagraphContext::class,
                                                              Cobol85Parser.SecurityParagraphContext::class,
                                                              Cobol85Parser.RemarksParagraphContext::class,
                                                              Cobol85Parser.EnvironmentDivisionContext::class,
                                                              Cobol85Parser.EnvironmentDivisionBodyContext::class,
                                                              Cobol85Parser.ConfigurationSectionContext::class,
                                                              Cobol85Parser.ConfigurationSectionParagraphContext::class,
                                                              Cobol85Parser.SourceComputerParagraphContext::class,
                                                              Cobol85Parser.ObjectComputerParagraphContext::class,
                                                              Cobol85Parser.ObjectComputerClauseContext::class,
                                                              Cobol85Parser.MemorySizeClauseContext::class,
                                                              Cobol85Parser.DiskSizeClauseContext::class,
                                                              Cobol85Parser.CollatingSequenceClauseContext::class,
                                                              Cobol85Parser.CollatingSequenceClauseAlphanumericContext::class,
                                                              Cobol85Parser.CollatingSequenceClauseNationalContext::class,
                                                              Cobol85Parser.SegmentLimitClauseContext::class,
                                                              Cobol85Parser.CharacterSetClauseContext::class,
                                                              Cobol85Parser.SpecialNamesParagraphContext::class,
                                                              Cobol85Parser.SpecialNameClauseContext::class,
                                                              Cobol85Parser.AlphabetClauseContext::class,
                                                              Cobol85Parser.AlphabetClauseFormat1Context::class,
                                                              Cobol85Parser.AlphabetLiteralsContext::class,
                                                              Cobol85Parser.AlphabetThroughContext::class,
                                                              Cobol85Parser.AlphabetAlsoContext::class,
                                                              Cobol85Parser.AlphabetClauseFormat2Context::class,
                                                              Cobol85Parser.ChannelClauseContext::class,
                                                              Cobol85Parser.ClassClauseContext::class,
                                                              Cobol85Parser.ClassClauseThroughContext::class,
                                                              Cobol85Parser.ClassClauseFromContext::class,
                                                              Cobol85Parser.ClassClauseToContext::class,
                                                              Cobol85Parser.CurrencySignClauseContext::class,
                                                              Cobol85Parser.DecimalPointClauseContext::class,
                                                              Cobol85Parser.DefaultComputationalSignClauseContext::class,
                                                              Cobol85Parser.DefaultDisplaySignClauseContext::class,
                                                              Cobol85Parser.EnvironmentSwitchNameClauseContext::class,
                                                              Cobol85Parser.EnvironmentSwitchNameSpecialNamesStatusPhraseContext::class,
                                                              Cobol85Parser.OdtClauseContext::class,
                                                              Cobol85Parser.ReserveNetworkClauseContext::class,
                                                              Cobol85Parser.SymbolicCharactersClauseContext::class,
                                                              Cobol85Parser.SymbolicCharactersContext::class,
                                                              Cobol85Parser.InputOutputSectionContext::class,
                                                              Cobol85Parser.InputOutputSectionParagraphContext::class,
                                                              Cobol85Parser.FileControlParagraphContext::class,
                                                              Cobol85Parser.FileControlEntryContext::class,
                                                              Cobol85Parser.SelectClauseContext::class,
                                                              Cobol85Parser.FileControlClauseContext::class,
                                                              Cobol85Parser.AssignClauseContext::class,
                                                              Cobol85Parser.ReserveClauseContext::class,
                                                              Cobol85Parser.OrganizationClauseContext::class,
                                                              Cobol85Parser.PaddingCharacterClauseContext::class,
                                                              Cobol85Parser.RecordDelimiterClauseContext::class,
                                                              Cobol85Parser.AccessModeClauseContext::class,
                                                              Cobol85Parser.RecordKeyClauseContext::class,
                                                              Cobol85Parser.AlternateRecordKeyClauseContext::class,
                                                              Cobol85Parser.PasswordClauseContext::class,
                                                              Cobol85Parser.FileStatusClauseContext::class,
                                                              Cobol85Parser.RelativeKeyClauseContext::class,
                                                              Cobol85Parser.IoControlParagraphContext::class,
                                                              Cobol85Parser.IoControlClauseContext::class,
                                                              Cobol85Parser.RerunClauseContext::class,
                                                              Cobol85Parser.RerunEveryRecordsContext::class,
                                                              Cobol85Parser.RerunEveryOfContext::class,
                                                              Cobol85Parser.RerunEveryClockContext::class,
                                                              Cobol85Parser.SameClauseContext::class,
                                                              Cobol85Parser.MultipleFileClauseContext::class,
                                                              Cobol85Parser.MultipleFilePositionContext::class,
                                                              Cobol85Parser.CommitmentControlClauseContext::class,
                                                              Cobol85Parser.DataDivisionContext::class,
                                                              Cobol85Parser.DataDivisionSectionContext::class,
                                                              Cobol85Parser.FileSectionContext::class,
                                                              Cobol85Parser.FileDescriptionEntryContext::class,
                                                              Cobol85Parser.FileDescriptionEntryClauseContext::class,
                                                              Cobol85Parser.ExternalClauseContext::class,
                                                              Cobol85Parser.GlobalClauseContext::class,
                                                              Cobol85Parser.BlockContainsClauseContext::class,
                                                              Cobol85Parser.BlockContainsToContext::class,
                                                              Cobol85Parser.RecordContainsClauseContext::class,
                                                              Cobol85Parser.RecordContainsClauseFormat1Context::class,
                                                              Cobol85Parser.RecordContainsClauseFormat2Context::class,
                                                              Cobol85Parser.RecordContainsClauseFormat3Context::class,
                                                              Cobol85Parser.RecordContainsToContext::class,
                                                              Cobol85Parser.LabelRecordsClauseContext::class,
                                                              Cobol85Parser.ValueOfClauseContext::class,
                                                              Cobol85Parser.ValuePairContext::class,
                                                              Cobol85Parser.DataRecordsClauseContext::class,
                                                              Cobol85Parser.LinageClauseContext::class,
                                                              Cobol85Parser.LinageAtContext::class,
                                                              Cobol85Parser.LinageFootingAtContext::class,
                                                              Cobol85Parser.LinageLinesAtTopContext::class,
                                                              Cobol85Parser.LinageLinesAtBottomContext::class,
                                                              Cobol85Parser.RecordingModeClauseContext::class,
                                                              Cobol85Parser.ModeStatementContext::class,
                                                              Cobol85Parser.CodeSetClauseContext::class,
                                                              Cobol85Parser.ReportClauseContext::class,
                                                              Cobol85Parser.DataBaseSectionContext::class,
                                                              Cobol85Parser.DataBaseSectionEntryContext::class,
                                                              Cobol85Parser.WorkingStorageSectionContext::class,
                                                              Cobol85Parser.LinkageSectionContext::class,
                                                              Cobol85Parser.CommunicationSectionContext::class,
                                                              Cobol85Parser.CommunicationDescriptionEntryContext::class,
                                                              Cobol85Parser.CommunicationDescriptionEntryFormat1Context::class,
                                                              Cobol85Parser.CommunicationDescriptionEntryFormat2Context::class,
                                                              Cobol85Parser.CommunicationDescriptionEntryFormat3Context::class,
                                                              Cobol85Parser.DestinationCountClauseContext::class,
                                                              Cobol85Parser.DestinationTableClauseContext::class,
                                                              Cobol85Parser.EndKeyClauseContext::class,
                                                              Cobol85Parser.ErrorKeyClauseContext::class,
                                                              Cobol85Parser.MessageCountClauseContext::class,
                                                              Cobol85Parser.MessageDateClauseContext::class,
                                                              Cobol85Parser.MessageTimeClauseContext::class,
                                                              Cobol85Parser.StatusKeyClauseContext::class,
                                                              Cobol85Parser.SymbolicDestinationClauseContext::class,
                                                              Cobol85Parser.SymbolicQueueClauseContext::class,
                                                              Cobol85Parser.SymbolicSourceClauseContext::class,
                                                              Cobol85Parser.SymbolicTerminalClauseContext::class,
                                                              Cobol85Parser.SymbolicSubQueueClauseContext::class,
                                                              Cobol85Parser.TextLengthClauseContext::class,
                                                              Cobol85Parser.LocalStorageSectionContext::class,
                                                              Cobol85Parser.ScreenSectionContext::class,
                                                              Cobol85Parser.ScreenDescriptionEntryContext::class,
                                                              Cobol85Parser.ScreenDescriptionBlankClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionBellClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionBlinkClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionEraseClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionLightClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionGridClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionReverseVideoClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionUnderlineClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionSizeClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionLineClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionColumnClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionForegroundColorClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionBackgroundColorClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionControlClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionValueClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionPictureClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionFromClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionToClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionUsingClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionUsageClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionBlankWhenZeroClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionJustifiedClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionSignClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionAutoClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionSecureClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionRequiredClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionPromptClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionPromptOccursClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionFullClauseContext::class,
                                                              Cobol85Parser.ScreenDescriptionZeroFillClauseContext::class,
                                                              Cobol85Parser.ReportSectionContext::class,
                                                              Cobol85Parser.ReportDescriptionContext::class,
                                                              Cobol85Parser.ReportDescriptionEntryContext::class,
                                                              Cobol85Parser.ReportDescriptionGlobalClauseContext::class,
                                                              Cobol85Parser.ReportDescriptionPageLimitClauseContext::class,
                                                              Cobol85Parser.ReportDescriptionHeadingClauseContext::class,
                                                              Cobol85Parser.ReportDescriptionFirstDetailClauseContext::class,
                                                              Cobol85Parser.ReportDescriptionLastDetailClauseContext::class,
                                                              Cobol85Parser.ReportDescriptionFootingClauseContext::class,
                                                              Cobol85Parser.ReportGroupDescriptionEntryContext::class,
                                                              Cobol85Parser.ReportGroupDescriptionEntryFormat1Context::class,
                                                              Cobol85Parser.ReportGroupDescriptionEntryFormat2Context::class,
                                                              Cobol85Parser.ReportGroupDescriptionEntryFormat3Context::class,
                                                              Cobol85Parser.ReportGroupBlankWhenZeroClauseContext::class,
                                                              Cobol85Parser.ReportGroupColumnNumberClauseContext::class,
                                                              Cobol85Parser.ReportGroupIndicateClauseContext::class,
                                                              Cobol85Parser.ReportGroupJustifiedClauseContext::class,
                                                              Cobol85Parser.ReportGroupLineNumberClauseContext::class,
                                                              Cobol85Parser.ReportGroupLineNumberNextPageContext::class,
                                                              Cobol85Parser.ReportGroupLineNumberPlusContext::class,
                                                              Cobol85Parser.ReportGroupNextGroupClauseContext::class,
                                                              Cobol85Parser.ReportGroupNextGroupPlusContext::class,
                                                              Cobol85Parser.ReportGroupNextGroupNextPageContext::class,
                                                              Cobol85Parser.ReportGroupPictureClauseContext::class,
                                                              Cobol85Parser.ReportGroupResetClauseContext::class,
                                                              Cobol85Parser.ReportGroupSignClauseContext::class,
                                                              Cobol85Parser.ReportGroupSourceClauseContext::class,
                                                              Cobol85Parser.ReportGroupSumClauseContext::class,
                                                              Cobol85Parser.ReportGroupTypeClauseContext::class,
                                                              Cobol85Parser.ReportGroupTypeReportHeadingContext::class,
                                                              Cobol85Parser.ReportGroupTypePageHeadingContext::class,
                                                              Cobol85Parser.ReportGroupTypeControlHeadingContext::class,
                                                              Cobol85Parser.ReportGroupTypeDetailContext::class,
                                                              Cobol85Parser.ReportGroupTypeControlFootingContext::class,
                                                              Cobol85Parser.ReportGroupUsageClauseContext::class,
                                                              Cobol85Parser.ReportGroupTypePageFootingContext::class,
                                                              Cobol85Parser.ReportGroupTypeReportFootingContext::class,
                                                              Cobol85Parser.ReportGroupValueClauseContext::class,
                                                              Cobol85Parser.ProgramLibrarySectionContext::class,
                                                              Cobol85Parser.LibraryDescriptionEntryContext::class,
                                                              Cobol85Parser.LibraryDescriptionEntryFormat1Context::class,
                                                              Cobol85Parser.LibraryDescriptionEntryFormat2Context::class,
                                                              Cobol85Parser.LibraryAttributeClauseFormat1Context::class,
                                                              Cobol85Parser.LibraryAttributeClauseFormat2Context::class,
                                                              Cobol85Parser.LibraryAttributeFunctionContext::class,
                                                              Cobol85Parser.LibraryAttributeParameterContext::class,
                                                              Cobol85Parser.LibraryAttributeTitleContext::class,
                                                              Cobol85Parser.LibraryEntryProcedureClauseFormat1Context::class,
                                                              Cobol85Parser.LibraryEntryProcedureClauseFormat2Context::class,
                                                              Cobol85Parser.LibraryEntryProcedureForClauseContext::class,
                                                              Cobol85Parser.LibraryEntryProcedureGivingClauseContext::class,
                                                              Cobol85Parser.LibraryEntryProcedureUsingClauseContext::class,
                                                              Cobol85Parser.LibraryEntryProcedureUsingNameContext::class,
                                                              Cobol85Parser.LibraryEntryProcedureWithClauseContext::class,
                                                              Cobol85Parser.LibraryEntryProcedureWithNameContext::class,
                                                              Cobol85Parser.LibraryIsCommonClauseContext::class,
                                                              Cobol85Parser.LibraryIsGlobalClauseContext::class,
                                                              Cobol85Parser.DataDescriptionEntryContext::class,
                                                              Cobol85Parser.DataDescriptionEntryFormat1Context::class,
                                                              Cobol85Parser.DataDescriptionEntryFormat2Context::class,
                                                              Cobol85Parser.DataDescriptionEntryFormat3Context::class,
                                                              Cobol85Parser.DataDescriptionEntryExecSqlContext::class,
                                                              Cobol85Parser.DataAlignedClauseContext::class,
                                                              Cobol85Parser.DataBlankWhenZeroClauseContext::class,
                                                              Cobol85Parser.DataCommonOwnLocalClauseContext::class,
                                                              Cobol85Parser.DataExternalClauseContext::class,
                                                              Cobol85Parser.DataGlobalClauseContext::class,
                                                              Cobol85Parser.DataIntegerStringClauseContext::class,
                                                              Cobol85Parser.DataJustifiedClauseContext::class,
                                                              Cobol85Parser.DataOccursClauseContext::class,
                                                              Cobol85Parser.DataOccursToContext::class,
                                                              Cobol85Parser.DataOccursSortContext::class,
                                                              Cobol85Parser.DataPictureClauseContext::class,
                                                              Cobol85Parser.PictureStringContext::class,
                                                              Cobol85Parser.PictureCharsContext::class,
                                                              Cobol85Parser.PictureCardinalityContext::class,
                                                              Cobol85Parser.DataReceivedByClauseContext::class,
                                                              Cobol85Parser.DataRecordAreaClauseContext::class,
                                                              Cobol85Parser.DataRedefinesClauseContext::class,
                                                              Cobol85Parser.DataRenamesClauseContext::class,
                                                              Cobol85Parser.DataSignClauseContext::class,
                                                              Cobol85Parser.DataSynchronizedClauseContext::class,
                                                              Cobol85Parser.DataThreadLocalClauseContext::class,
                                                              Cobol85Parser.DataTypeClauseContext::class,
                                                              Cobol85Parser.DataTypeDefClauseContext::class,
                                                              Cobol85Parser.DataUsageClauseContext::class,
                                                              Cobol85Parser.DataUsingClauseContext::class,
                                                              Cobol85Parser.DataValueClauseContext::class,
                                                              Cobol85Parser.DataValueIntervalContext::class,
                                                              Cobol85Parser.DataValueIntervalFromContext::class,
                                                              Cobol85Parser.DataValueIntervalToContext::class,
                                                              Cobol85Parser.DataWithLowerBoundsClauseContext::class,
                                                              Cobol85Parser.ProcedureDivisionContext::class,
                                                              Cobol85Parser.ProcedureDivisionUsingClauseContext::class,
                                                              Cobol85Parser.ProcedureDivisionGivingClauseContext::class,
                                                              Cobol85Parser.ProcedureDivisionUsingParameterContext::class,
                                                              Cobol85Parser.ProcedureDivisionByReferencePhraseContext::class,
                                                              Cobol85Parser.ProcedureDivisionByReferenceContext::class,
                                                              Cobol85Parser.ProcedureDivisionByValuePhraseContext::class,
                                                              Cobol85Parser.ProcedureDivisionByValueContext::class,
                                                              Cobol85Parser.ProcedureDeclarativesContext::class,
                                                              Cobol85Parser.ProcedureDeclarativeContext::class,
                                                              Cobol85Parser.ProcedureSectionHeaderContext::class,
                                                              Cobol85Parser.ProcedureDivisionBodyContext::class,
                                                              Cobol85Parser.ProcedureSectionContext::class,
                                                              Cobol85Parser.ParagraphsContext::class,
                                                              Cobol85Parser.ParagraphContext::class,
                                                              Cobol85Parser.SentenceContext::class,
                                                              Cobol85Parser.StatementContext::class,
                                                              Cobol85Parser.AcceptStatementContext::class,
                                                              Cobol85Parser.AcceptFromDateStatementContext::class,
                                                              Cobol85Parser.AcceptFromMnemonicStatementContext::class,
                                                              Cobol85Parser.AcceptFromEscapeKeyStatementContext::class,
                                                              Cobol85Parser.AcceptMessageCountStatementContext::class,
                                                              Cobol85Parser.AddStatementContext::class,
                                                              Cobol85Parser.AddToStatementContext::class,
                                                              Cobol85Parser.AddToGivingStatementContext::class,
                                                              Cobol85Parser.AddCorrespondingStatementContext::class,
                                                              Cobol85Parser.AddFromContext::class,
                                                              Cobol85Parser.AddToContext::class,
                                                              Cobol85Parser.AddToGivingContext::class,
                                                              Cobol85Parser.AddGivingContext::class,
                                                              Cobol85Parser.AlteredGoToContext::class,
                                                              Cobol85Parser.AlterStatementContext::class,
                                                              Cobol85Parser.AlterProceedToContext::class,
                                                              Cobol85Parser.CallStatementContext::class,
                                                              Cobol85Parser.CallUsingPhraseContext::class,
                                                              Cobol85Parser.CallUsingParameterContext::class,
                                                              Cobol85Parser.CallByReferencePhraseContext::class,
                                                              Cobol85Parser.CallByReferenceContext::class,
                                                              Cobol85Parser.CallByValuePhraseContext::class,
                                                              Cobol85Parser.CallByValueContext::class,
                                                              Cobol85Parser.CallByContentPhraseContext::class,
                                                              Cobol85Parser.CallByContentContext::class,
                                                              Cobol85Parser.CallGivingPhraseContext::class,
                                                              Cobol85Parser.CancelStatementContext::class,
                                                              Cobol85Parser.CancelCallContext::class,
                                                              Cobol85Parser.CloseStatementContext::class,
                                                              Cobol85Parser.CloseFileContext::class,
                                                              Cobol85Parser.CloseReelUnitStatementContext::class,
                                                              Cobol85Parser.CloseRelativeStatementContext::class,
                                                              Cobol85Parser.ClosePortFileIOStatementContext::class,
                                                              Cobol85Parser.ClosePortFileIOUsingContext::class,
                                                              Cobol85Parser.ClosePortFileIOUsingCloseDispositionContext::class,
                                                              Cobol85Parser.ClosePortFileIOUsingAssociatedDataContext::class,
                                                              Cobol85Parser.ClosePortFileIOUsingAssociatedDataLengthContext::class,
                                                              Cobol85Parser.ComputeStatementContext::class,
                                                              Cobol85Parser.ComputeStoreContext::class,
                                                              Cobol85Parser.ContinueStatementContext::class,
                                                              Cobol85Parser.DeleteStatementContext::class,
                                                              Cobol85Parser.DisableStatementContext::class,
                                                              Cobol85Parser.DisplayStatementContext::class,
                                                              Cobol85Parser.DisplayOperandContext::class,
                                                              Cobol85Parser.DisplayAtContext::class,
                                                              Cobol85Parser.DisplayUponContext::class,
                                                              Cobol85Parser.DisplayWithContext::class,
                                                              Cobol85Parser.DivideStatementContext::class,
                                                              Cobol85Parser.DivideIntoStatementContext::class,
                                                              Cobol85Parser.DivideIntoGivingStatementContext::class,
                                                              Cobol85Parser.DivideByGivingStatementContext::class,
                                                              Cobol85Parser.DivideGivingPhraseContext::class,
                                                              Cobol85Parser.DivideIntoContext::class,
                                                              Cobol85Parser.DivideGivingContext::class,
                                                              Cobol85Parser.DivideRemainderContext::class,
                                                              Cobol85Parser.EnableStatementContext::class,
                                                              Cobol85Parser.EntryStatementContext::class,
                                                              Cobol85Parser.EvaluateStatementContext::class,
                                                              Cobol85Parser.EvaluateSelectContext::class,
                                                              Cobol85Parser.EvaluateAlsoSelectContext::class,
                                                              Cobol85Parser.EvaluateWhenPhraseContext::class,
                                                              Cobol85Parser.EvaluateWhenContext::class,
                                                              Cobol85Parser.EvaluateConditionContext::class,
                                                              Cobol85Parser.EvaluateThroughContext::class,
                                                              Cobol85Parser.EvaluateAlsoConditionContext::class,
                                                              Cobol85Parser.EvaluateWhenOtherContext::class,
                                                              Cobol85Parser.EvaluateValueContext::class,
                                                              Cobol85Parser.ExecCicsStatementContext::class,
                                                              Cobol85Parser.ExecSqlStatementContext::class,
                                                              Cobol85Parser.ExecSqlImsStatementContext::class,
                                                              Cobol85Parser.ExhibitStatementContext::class,
                                                              Cobol85Parser.ExhibitOperandContext::class,
                                                              Cobol85Parser.ExitStatementContext::class,
                                                              Cobol85Parser.GenerateStatementContext::class,
                                                              Cobol85Parser.GobackStatementContext::class,
                                                              Cobol85Parser.GoToStatementContext::class,
                                                              Cobol85Parser.GoToStatementSimpleContext::class,
                                                              Cobol85Parser.GoToDependingOnStatementContext::class,
                                                              Cobol85Parser.IfStatementContext::class,
                                                              Cobol85Parser.IfThenContext::class,
                                                              Cobol85Parser.IfElseContext::class,
                                                              Cobol85Parser.InitializeStatementContext::class,
                                                              Cobol85Parser.InitializeReplacingPhraseContext::class,
                                                              Cobol85Parser.InitializeReplacingByContext::class,
                                                              Cobol85Parser.InitiateStatementContext::class,
                                                              Cobol85Parser.InspectStatementContext::class,
                                                              Cobol85Parser.InspectTallyingPhraseContext::class,
                                                              Cobol85Parser.InspectReplacingPhraseContext::class,
                                                              Cobol85Parser.InspectTallyingReplacingPhraseContext::class,
                                                              Cobol85Parser.InspectConvertingPhraseContext::class,
                                                              Cobol85Parser.InspectForContext::class,
                                                              Cobol85Parser.InspectCharactersContext::class,
                                                              Cobol85Parser.InspectReplacingCharactersContext::class,
                                                              Cobol85Parser.InspectAllLeadingsContext::class,
                                                              Cobol85Parser.InspectReplacingAllLeadingsContext::class,
                                                              Cobol85Parser.InspectAllLeadingContext::class,
                                                              Cobol85Parser.InspectReplacingAllLeadingContext::class,
                                                              Cobol85Parser.InspectByContext::class,
                                                              Cobol85Parser.InspectToContext::class,
                                                              Cobol85Parser.InspectBeforeAfterContext::class,
                                                              Cobol85Parser.MergeStatementContext::class,
                                                              Cobol85Parser.MergeOnKeyClauseContext::class,
                                                              Cobol85Parser.MergeCollatingSequencePhraseContext::class,
                                                              Cobol85Parser.MergeCollatingAlphanumericContext::class,
                                                              Cobol85Parser.MergeCollatingNationalContext::class,
                                                              Cobol85Parser.MergeUsingContext::class,
                                                              Cobol85Parser.MergeOutputProcedurePhraseContext::class,
                                                              Cobol85Parser.MergeOutputThroughContext::class,
                                                              Cobol85Parser.MergeGivingPhraseContext::class,
                                                              Cobol85Parser.MergeGivingContext::class,
                                                              Cobol85Parser.MoveStatementContext::class,
                                                              Cobol85Parser.MoveToStatementContext::class,
                                                              Cobol85Parser.MoveToSendingAreaContext::class,
                                                              Cobol85Parser.MoveCorrespondingToStatementContext::class,
                                                              Cobol85Parser.MoveCorrespondingToSendingAreaContext::class,
                                                              Cobol85Parser.MultiplyStatementContext::class,
                                                              Cobol85Parser.MultiplyRegularContext::class,
                                                              Cobol85Parser.MultiplyRegularOperandContext::class,
                                                              Cobol85Parser.MultiplyGivingContext::class,
                                                              Cobol85Parser.MultiplyGivingOperandContext::class,
                                                              Cobol85Parser.MultiplyGivingResultContext::class,
                                                              Cobol85Parser.OpenStatementContext::class,
                                                              Cobol85Parser.OpenInputStatementContext::class,
                                                              Cobol85Parser.OpenInputContext::class,
                                                              Cobol85Parser.OpenOutputStatementContext::class,
                                                              Cobol85Parser.OpenOutputContext::class,
                                                              Cobol85Parser.OpenIOStatementContext::class,
                                                              Cobol85Parser.OpenExtendStatementContext::class,
                                                              Cobol85Parser.PerformStatementContext::class,
                                                              Cobol85Parser.PerformInlineStatementContext::class,
                                                              Cobol85Parser.PerformProcedureStatementContext::class,
                                                              Cobol85Parser.PerformTypeContext::class,
                                                              Cobol85Parser.PerformTimesContext::class,
                                                              Cobol85Parser.PerformUntilContext::class,
                                                              Cobol85Parser.PerformVaryingContext::class,
                                                              Cobol85Parser.PerformVaryingClauseContext::class,
                                                              Cobol85Parser.PerformVaryingPhraseContext::class,
                                                              Cobol85Parser.PerformAfterContext::class,
                                                              Cobol85Parser.PerformFromContext::class,
                                                              Cobol85Parser.PerformByContext::class,
                                                              Cobol85Parser.PerformTestClauseContext::class,
                                                              Cobol85Parser.PurgeStatementContext::class,
                                                              Cobol85Parser.ReadStatementContext::class,
                                                              Cobol85Parser.ReadIntoContext::class,
                                                              Cobol85Parser.ReadWithContext::class,
                                                              Cobol85Parser.ReadKeyContext::class,
                                                              Cobol85Parser.ReceiveStatementContext::class,
                                                              Cobol85Parser.ReceiveFromStatementContext::class,
                                                              Cobol85Parser.ReceiveFromContext::class,
                                                              Cobol85Parser.ReceiveIntoStatementContext::class,
                                                              Cobol85Parser.ReceiveNoDataContext::class,
                                                              Cobol85Parser.ReceiveWithDataContext::class,
                                                              Cobol85Parser.ReceiveBeforeContext::class,
                                                              Cobol85Parser.ReceiveWithContext::class,
                                                              Cobol85Parser.ReceiveThreadContext::class,
                                                              Cobol85Parser.ReceiveSizeContext::class,
                                                              Cobol85Parser.ReceiveStatusContext::class,
                                                              Cobol85Parser.ReleaseStatementContext::class,
                                                              Cobol85Parser.ReturnStatementContext::class,
                                                              Cobol85Parser.ReturnIntoContext::class,
                                                              Cobol85Parser.RewriteStatementContext::class,
                                                              Cobol85Parser.RewriteFromContext::class,
                                                              Cobol85Parser.SearchStatementContext::class,
                                                              Cobol85Parser.SearchVaryingContext::class,
                                                              Cobol85Parser.SearchWhenContext::class,
                                                              Cobol85Parser.SendStatementContext::class,
                                                              Cobol85Parser.SendStatementSyncContext::class,
                                                              Cobol85Parser.SendStatementAsyncContext::class,
                                                              Cobol85Parser.SendFromPhraseContext::class,
                                                              Cobol85Parser.SendWithPhraseContext::class,
                                                              Cobol85Parser.SendReplacingPhraseContext::class,
                                                              Cobol85Parser.SendAdvancingPhraseContext::class,
                                                              Cobol85Parser.SendAdvancingPageContext::class,
                                                              Cobol85Parser.SendAdvancingLinesContext::class,
                                                              Cobol85Parser.SendAdvancingMnemonicContext::class,
                                                              Cobol85Parser.SetStatementContext::class,
                                                              Cobol85Parser.SetToStatementContext::class,
                                                              Cobol85Parser.SetUpDownByStatementContext::class,
                                                              Cobol85Parser.SetToContext::class,
                                                              Cobol85Parser.SetToValueContext::class,
                                                              Cobol85Parser.SetByValueContext::class,
                                                              Cobol85Parser.SortStatementContext::class,
                                                              Cobol85Parser.SortOnKeyClauseContext::class,
                                                              Cobol85Parser.SortDuplicatesPhraseContext::class,
                                                              Cobol85Parser.SortCollatingSequencePhraseContext::class,
                                                              Cobol85Parser.SortCollatingAlphanumericContext::class,
                                                              Cobol85Parser.SortCollatingNationalContext::class,
                                                              Cobol85Parser.SortInputProcedurePhraseContext::class,
                                                              Cobol85Parser.SortInputThroughContext::class,
                                                              Cobol85Parser.SortUsingContext::class,
                                                              Cobol85Parser.SortOutputProcedurePhraseContext::class,
                                                              Cobol85Parser.SortOutputThroughContext::class,
                                                              Cobol85Parser.SortGivingPhraseContext::class,
                                                              Cobol85Parser.SortGivingContext::class,
                                                              Cobol85Parser.StartStatementContext::class,
                                                              Cobol85Parser.StartKeyContext::class,
                                                              Cobol85Parser.StopStatementContext::class,
                                                              Cobol85Parser.StringStatementContext::class,
                                                              Cobol85Parser.StringSendingPhraseContext::class,
                                                              Cobol85Parser.StringSendingContext::class,
                                                              Cobol85Parser.StringDelimitedByPhraseContext::class,
                                                              Cobol85Parser.StringForPhraseContext::class,
                                                              Cobol85Parser.StringIntoPhraseContext::class,
                                                              Cobol85Parser.StringWithPointerPhraseContext::class,
                                                              Cobol85Parser.SubtractStatementContext::class,
                                                              Cobol85Parser.SubtractFromStatementContext::class,
                                                              Cobol85Parser.SubtractFromGivingStatementContext::class,
                                                              Cobol85Parser.SubtractCorrespondingStatementContext::class,
                                                              Cobol85Parser.SubtractSubtrahendContext::class,
                                                              Cobol85Parser.SubtractMinuendContext::class,
                                                              Cobol85Parser.SubtractMinuendGivingContext::class,
                                                              Cobol85Parser.SubtractGivingContext::class,
                                                              Cobol85Parser.SubtractMinuendCorrespondingContext::class,
                                                              Cobol85Parser.TerminateStatementContext::class,
                                                              Cobol85Parser.UnstringStatementContext::class,
                                                              Cobol85Parser.UnstringSendingPhraseContext::class,
                                                              Cobol85Parser.UnstringDelimitedByPhraseContext::class,
                                                              Cobol85Parser.UnstringOrAllPhraseContext::class,
                                                              Cobol85Parser.UnstringIntoPhraseContext::class,
                                                              Cobol85Parser.UnstringIntoContext::class,
                                                              Cobol85Parser.UnstringDelimiterInContext::class,
                                                              Cobol85Parser.UnstringCountInContext::class,
                                                              Cobol85Parser.UnstringWithPointerPhraseContext::class,
                                                              Cobol85Parser.UnstringTallyingPhraseContext::class,
                                                              Cobol85Parser.UseStatementContext::class,
                                                              Cobol85Parser.UseAfterClauseContext::class,
                                                              Cobol85Parser.UseAfterOnContext::class,
                                                              Cobol85Parser.UseDebugClauseContext::class,
                                                              Cobol85Parser.UseDebugOnContext::class,
                                                              Cobol85Parser.WriteStatementContext::class,
                                                              Cobol85Parser.WriteFromPhraseContext::class,
                                                              Cobol85Parser.WriteAdvancingPhraseContext::class,
                                                              Cobol85Parser.WriteAdvancingPageContext::class,
                                                              Cobol85Parser.WriteAdvancingLinesContext::class,
                                                              Cobol85Parser.WriteAdvancingMnemonicContext::class,
                                                              Cobol85Parser.WriteAtEndOfPagePhraseContext::class,
                                                              Cobol85Parser.WriteNotAtEndOfPagePhraseContext::class,
                                                              Cobol85Parser.AtEndPhraseContext::class,
                                                              Cobol85Parser.NotAtEndPhraseContext::class,
                                                              Cobol85Parser.InvalidKeyPhraseContext::class,
                                                              Cobol85Parser.NotInvalidKeyPhraseContext::class,
                                                              Cobol85Parser.OnOverflowPhraseContext::class,
                                                              Cobol85Parser.NotOnOverflowPhraseContext::class,
                                                              Cobol85Parser.OnSizeErrorPhraseContext::class,
                                                              Cobol85Parser.NotOnSizeErrorPhraseContext::class,
                                                              Cobol85Parser.OnExceptionClauseContext::class,
                                                              Cobol85Parser.NotOnExceptionClauseContext::class,
                                                              Cobol85Parser.ArithmeticExpressionContext::class,
                                                              Cobol85Parser.PlusMinusContext::class,
                                                              Cobol85Parser.MultDivsContext::class,
                                                              Cobol85Parser.MultDivContext::class,
                                                              Cobol85Parser.PowersContext::class,
                                                              Cobol85Parser.PowerContext::class,
                                                              Cobol85Parser.BasisContext::class,
                                                              Cobol85Parser.ConditionContext::class,
                                                              Cobol85Parser.AndOrConditionContext::class,
                                                              Cobol85Parser.CombinableConditionContext::class,
                                                              Cobol85Parser.SimpleConditionContext::class,
                                                              Cobol85Parser.ClassConditionContext::class,
                                                              Cobol85Parser.ConditionNameReferenceContext::class,
                                                              Cobol85Parser.ConditionNameSubscriptReferenceContext::class,
                                                              Cobol85Parser.RelationConditionContext::class,
                                                              Cobol85Parser.RelationSignConditionContext::class,
                                                              Cobol85Parser.RelationArithmeticComparisonContext::class,
                                                              Cobol85Parser.RelationCombinedComparisonContext::class,
                                                              Cobol85Parser.RelationCombinedConditionContext::class,
                                                              Cobol85Parser.RelationalOperatorContext::class,
                                                              Cobol85Parser.AbbreviationContext::class,
                                                              Cobol85Parser.IdentifierContext::class,
                                                              Cobol85Parser.TableCallContext::class,
                                                              Cobol85Parser.FunctionCallContext::class,
                                                              Cobol85Parser.ReferenceModifierContext::class,
                                                              Cobol85Parser.CharacterPositionContext::class,
                                                              Cobol85Parser.LengthContext::class,
                                                              Cobol85Parser.SubscriptContext::class,
                                                              Cobol85Parser.ArgumentContext::class,
                                                              Cobol85Parser.QualifiedDataNameContext::class,
                                                              Cobol85Parser.QualifiedDataNameFormat1Context::class,
                                                              Cobol85Parser.QualifiedDataNameFormat2Context::class,
                                                              Cobol85Parser.QualifiedDataNameFormat3Context::class,
                                                              Cobol85Parser.QualifiedDataNameFormat4Context::class,
                                                              Cobol85Parser.QualifiedInDataContext::class,
                                                              Cobol85Parser.InDataContext::class,
                                                              Cobol85Parser.InFileContext::class,
                                                              Cobol85Parser.InMnemonicContext::class,
                                                              Cobol85Parser.InSectionContext::class,
                                                              Cobol85Parser.InLibraryContext::class,
                                                              Cobol85Parser.InTableContext::class,
                                                              Cobol85Parser.AlphabetNameContext::class,
                                                              Cobol85Parser.AssignmentNameContext::class,
                                                              Cobol85Parser.BasisNameContext::class,
                                                              Cobol85Parser.CdNameContext::class,
                                                              Cobol85Parser.ClassNameContext::class,
                                                              Cobol85Parser.ComputerNameContext::class,
                                                              Cobol85Parser.ConditionNameContext::class,
                                                              Cobol85Parser.DataNameContext::class,
                                                              Cobol85Parser.DataDescNameContext::class,
                                                              Cobol85Parser.EnvironmentNameContext::class,
                                                              Cobol85Parser.FileNameContext::class,
                                                              Cobol85Parser.FunctionNameContext::class,
                                                              Cobol85Parser.IndexNameContext::class,
                                                              Cobol85Parser.LanguageNameContext::class,
                                                              Cobol85Parser.LibraryNameContext::class,
                                                              Cobol85Parser.LocalNameContext::class,
                                                              Cobol85Parser.MnemonicNameContext::class,
                                                              Cobol85Parser.ParagraphNameContext::class,
                                                              Cobol85Parser.ProcedureNameContext::class,
                                                              Cobol85Parser.ProgramNameContext::class,
                                                              Cobol85Parser.RecordNameContext::class,
                                                              Cobol85Parser.ReportNameContext::class,
                                                              Cobol85Parser.RoutineNameContext::class,
                                                              Cobol85Parser.ScreenNameContext::class,
                                                              Cobol85Parser.SectionNameContext::class,
                                                              Cobol85Parser.SystemNameContext::class,
                                                              Cobol85Parser.SymbolicCharacterContext::class,
                                                              Cobol85Parser.TextNameContext::class,
                                                              Cobol85Parser.CobolWordContext::class,
                                                              Cobol85Parser.LiteralContext::class,
                                                              Cobol85Parser.BooleanLiteralContext::class,
                                                              Cobol85Parser.NumericLiteralContext::class,
                                                              Cobol85Parser.IntegerLiteralContext::class,
                                                              Cobol85Parser.CicsDfhRespLiteralContext::class,
                                                              Cobol85Parser.CicsDfhValueLiteralContext::class,
                                                              Cobol85Parser.FigurativeConstantContext::class,
                                                              Cobol85Parser.SpecialRegisterContext::class,
                                                              Cobol85Parser.CommentEntryContext::class)
    }

	// TODO verify version of runtime is compatible

    override val grammarFileName: String
        get() = "Cobol85.g4"

    override val tokenNames: Array<String?>?
        get() = Cobol85Parser.Companion.tokenNames
    override val ruleNames: Array<String>?
        get() = Cobol85Parser.Companion.ruleNames
    override val atn: ATN
        get() = Cobol85Parser.Companion.ATN

    enum class Tokens(val id: Int) {
        EOF(-1),
        ABORT(1),
        ACCEPT(2),
        ACCESS(3),
        ADD(4),
        ADDRESS(5),
        ADVANCING(6),
        AFTER(7),
        ALIGNED(8),
        ALL(9),
        ALPHABET(10),
        ALPHABETIC(11),
        ALPHABETIC_LOWER(12),
        ALPHABETIC_UPPER(13),
        ALPHANUMERIC(14),
        ALPHANUMERIC_EDITED(15),
        ALSO(16),
        ALTER(17),
        ALTERNATE(18),
        AND(19),
        ANY(20),
        ARE(21),
        AREA(22),
        AREAS(23),
        AS(24),
        ASCENDING(25),
        ASCII(26),
        ASSIGN(27),
        ASSOCIATED_DATA(28),
        ASSOCIATED_DATA_LENGTH(29),
        AT(30),
        ATTRIBUTE(31),
        AUTHOR(32),
        AUTO(33),
        AUTO_SKIP(34),
        BACKGROUND_COLOR(35),
        BACKGROUND_COLOUR(36),
        BASIS(37),
        BEEP(38),
        BEFORE(39),
        BEGINNING(40),
        BELL(41),
        BINARY(42),
        BIT(43),
        BLANK(44),
        BLINK(45),
        BLOCK(46),
        BOUNDS(47),
        BOTTOM(48),
        BY(49),
        BYFUNCTION(50),
        BYTITLE(51),
        CALL(52),
        CANCEL(53),
        CAPABLE(54),
        CCSVERSION(55),
        CD(56),
        CF(57),
        CH(58),
        CHAINING(59),
        CHANGED(60),
        CHANNEL(61),
        CHARACTER(62),
        CHARACTERS(63),
        CLASS(64),
        CLASS_ID(65),
        CLOCK_UNITS(66),
        CLOSE(67),
        CLOSE_DISPOSITION(68),
        COBOL(69),
        CODE(70),
        CODE_SET(71),
        COLLATING(72),
        COL(73),
        COLUMN(74),
        COM_REG(75),
        COMMA(76),
        COMMITMENT(77),
        COMMON(78),
        COMMUNICATION(79),
        COMP(80),
        COMP_1(81),
        COMP_2(82),
        COMP_3(83),
        COMP_4(84),
        COMP_5(85),
        COMPUTATIONAL(86),
        COMPUTATIONAL_1(87),
        COMPUTATIONAL_2(88),
        COMPUTATIONAL_3(89),
        COMPUTATIONAL_4(90),
        COMPUTATIONAL_5(91),
        COMPUTE(92),
        CONFIGURATION(93),
        CONTAINS(94),
        CONTENT(95),
        CONTINUE(96),
        CONTROL(97),
        CONTROL_POINT(98),
        CONTROLS(99),
        CONVENTION(100),
        CONVERTING(101),
        COPY(102),
        CORR(103),
        CORRESPONDING(104),
        COUNT(105),
        CRUNCH(106),
        CURRENCY(107),
        CURSOR(108),
        DATA(109),
        DATA_BASE(110),
        DATE(111),
        DATE_COMPILED(112),
        DATE_WRITTEN(113),
        DAY(114),
        DAY_OF_WEEK(115),
        DBCS(116),
        DE(117),
        DEBUG_CONTENTS(118),
        DEBUG_ITEM(119),
        DEBUG_LINE(120),
        DEBUG_NAME(121),
        DEBUG_SUB_1(122),
        DEBUG_SUB_2(123),
        DEBUG_SUB_3(124),
        DEBUGGING(125),
        DECIMAL_POINT(126),
        DECLARATIVES(127),
        DEFAULT(128),
        DEFAULT_DISPLAY(129),
        DEFINITION(130),
        DELETE(131),
        DELIMITED(132),
        DELIMITER(133),
        DEPENDING(134),
        DESCENDING(135),
        DESTINATION(136),
        DETAIL(137),
        DFHRESP(138),
        DFHVALUE(139),
        DISABLE(140),
        DISK(141),
        DISPLAY(142),
        DISPLAY_1(143),
        DIVIDE(144),
        DIVISION(145),
        DONTCARE(146),
        DOUBLE(147),
        DOWN(148),
        DUPLICATES(149),
        DYNAMIC(150),
        EBCDIC(151),
        EGCS(152),
        EGI(153),
        ELSE(154),
        EMI(155),
        EMPTY_CHECK(156),
        ENABLE(157),
        END(158),
        END_ACCEPT(159),
        END_ADD(160),
        END_CALL(161),
        END_COMPUTE(162),
        END_DELETE(163),
        END_DIVIDE(164),
        END_EVALUATE(165),
        END_IF(166),
        END_MULTIPLY(167),
        END_OF_PAGE(168),
        END_PERFORM(169),
        END_READ(170),
        END_RECEIVE(171),
        END_RETURN(172),
        END_REWRITE(173),
        END_SEARCH(174),
        END_START(175),
        END_STRING(176),
        END_SUBTRACT(177),
        END_UNSTRING(178),
        END_WRITE(179),
        ENDING(180),
        ENTER(181),
        ENTRY(182),
        ENTRY_PROCEDURE(183),
        ENVIRONMENT(184),
        EOP(185),
        EQUAL(186),
        ERASE(187),
        ERROR(188),
        EOL(189),
        EOS(190),
        ESCAPE(191),
        ESI(192),
        EVALUATE(193),
        EVENT(194),
        EVERY(195),
        EXCEPTION(196),
        EXCLUSIVE(197),
        EXHIBIT(198),
        EXIT(199),
        EXPORT(200),
        EXTEND(201),
        EXTENDED(202),
        EXTERNAL(203),
        FALSE(204),
        FD(205),
        FILE(206),
        FILE_CONTROL(207),
        FILLER(208),
        FINAL(209),
        FIRST(210),
        FOOTING(211),
        FOR(212),
        FOREGROUND_COLOR(213),
        FOREGROUND_COLOUR(214),
        FROM(215),
        FULL(216),
        FUNCTION(217),
        FUNCTIONNAME(218),
        FUNCTION_POINTER(219),
        GENERATE(220),
        GOBACK(221),
        GIVING(222),
        GLOBAL(223),
        GO(224),
        GREATER(225),
        GRID(226),
        GROUP(227),
        HEADING(228),
        HIGHLIGHT(229),
        HIGH_VALUE(230),
        HIGH_VALUES(231),
        I_O(232),
        I_O_CONTROL(233),
        ID(234),
        IDENTIFICATION(235),
        IF(236),
        IMPLICIT(237),
        IMPORT(238),
        IN(239),
        INDEX(240),
        INDEXED(241),
        INDICATE(242),
        INITIAL(243),
        INITIALIZE(244),
        INITIATE(245),
        INPUT(246),
        INPUT_OUTPUT(247),
        INSPECT(248),
        INSTALLATION(249),
        INTEGER(250),
        INTO(251),
        INVALID(252),
        INVOKE(253),
        IS(254),
        JUST(255),
        JUSTIFIED(256),
        KANJI(257),
        KEPT(258),
        KEY(259),
        KEYBOARD(260),
        LABEL(261),
        LANGUAGE(262),
        LAST(263),
        LB(264),
        LD(265),
        LEADING(266),
        LEFT(267),
        LEFTLINE(268),
        LENGTH(269),
        LENGTH_CHECK(270),
        LESS(271),
        LIBACCESS(272),
        LIBPARAMETER(273),
        LIBRARY(274),
        LIMIT(275),
        LIMITS(276),
        LINAGE(277),
        LINAGE_COUNTER(278),
        LINE(279),
        LINES(280),
        LINE_COUNTER(281),
        LINKAGE(282),
        LIST(283),
        LOCAL(284),
        LOCAL_STORAGE(285),
        LOCK(286),
        LONG_DATE(287),
        LONG_TIME(288),
        LOWER(289),
        LOWLIGHT(290),
        LOW_VALUE(291),
        LOW_VALUES(292),
        MEMORY(293),
        MERGE(294),
        MESSAGE(295),
        MMDDYYYY(296),
        MODE(297),
        MODULES(298),
        MORE_LABELS(299),
        MOVE(300),
        MULTIPLE(301),
        MULTIPLY(302),
        NAMED(303),
        NATIONAL(304),
        NATIONAL_EDITED(305),
        NATIVE(306),
        NEGATIVE(307),
        NETWORK(308),
        NEXT(309),
        NO(310),
        NO_ECHO(311),
        NOT(312),
        NULL(313),
        NULLS(314),
        NUMBER(315),
        NUMERIC(316),
        NUMERIC_DATE(317),
        NUMERIC_EDITED(318),
        NUMERIC_TIME(319),
        OBJECT_COMPUTER(320),
        OCCURS(321),
        ODT(322),
        OF(323),
        OFF(324),
        OMITTED(325),
        ON(326),
        OPEN(327),
        OPTIONAL(328),
        OR(329),
        ORDER(330),
        ORDERLY(331),
        ORGANIZATION(332),
        OTHER(333),
        OUTPUT(334),
        OVERFLOW(335),
        OVERLINE(336),
        OWN(337),
        PACKED_DECIMAL(338),
        PADDING(339),
        PAGE(340),
        PAGE_COUNTER(341),
        PASSWORD(342),
        PERFORM(343),
        PF(344),
        PH(345),
        PIC(346),
        PICTURE(347),
        PLUS(348),
        POINTER(349),
        POSITION(350),
        POSITIVE(351),
        PORT(352),
        PRINTER(353),
        PRINTING(354),
        PRIVATE(355),
        PROCEDURE(356),
        PROCEDURE_POINTER(357),
        PROCEDURES(358),
        PROCEED(359),
        PROCESS(360),
        PROGRAM(361),
        PROGRAM_ID(362),
        PROGRAM_LIBRARY(363),
        PROMPT(364),
        PURGE(365),
        QUEUE(366),
        QUOTE(367),
        QUOTES(368),
        RANDOM(369),
        READER(370),
        REMOTE(371),
        RD(372),
        REAL(373),
        READ(374),
        RECEIVE(375),
        RECEIVED(376),
        RECORD(377),
        RECORDING(378),
        RECORDS(379),
        RECURSIVE(380),
        REDEFINES(381),
        REEL(382),
        REF(383),
        REFERENCE(384),
        REFERENCES(385),
        RELATIVE(386),
        RELEASE(387),
        REMAINDER(388),
        REMARKS(389),
        REMOVAL(390),
        REMOVE(391),
        RENAMES(392),
        REPLACE(393),
        REPLACING(394),
        REPORT(395),
        REPORTING(396),
        REPORTS(397),
        REQUIRED(398),
        RERUN(399),
        RESERVE(400),
        REVERSE_VIDEO(401),
        RESET(402),
        RETURN(403),
        RETURN_CODE(404),
        RETURNING(405),
        REVERSED(406),
        REWIND(407),
        REWRITE(408),
        RF(409),
        RH(410),
        RIGHT(411),
        ROUNDED(412),
        RUN(413),
        SAME(414),
        SAVE(415),
        SCREEN(416),
        SD(417),
        SEARCH(418),
        SECTION(419),
        SECURE(420),
        SECURITY(421),
        SEGMENT(422),
        SEGMENT_LIMIT(423),
        SELECT(424),
        SEND(425),
        SENTENCE(426),
        SEPARATE(427),
        SEQUENCE(428),
        SEQUENTIAL(429),
        SET(430),
        SHARED(431),
        SHAREDBYALL(432),
        SHAREDBYRUNUNIT(433),
        SHARING(434),
        SHIFT_IN(435),
        SHIFT_OUT(436),
        SHORT_DATE(437),
        SIGN(438),
        SIZE(439),
        SORT(440),
        SORT_CONTROL(441),
        SORT_CORE_SIZE(442),
        SORT_FILE_SIZE(443),
        SORT_MERGE(444),
        SORT_MESSAGE(445),
        SORT_MODE_SIZE(446),
        SORT_RETURN(447),
        SOURCE(448),
        SOURCE_COMPUTER(449),
        SPACE(450),
        SPACES(451),
        SPECIAL_NAMES(452),
        STANDARD(453),
        STANDARD_1(454),
        STANDARD_2(455),
        START(456),
        STATUS(457),
        STOP(458),
        STRING(459),
        SUB_QUEUE_1(460),
        SUB_QUEUE_2(461),
        SUB_QUEUE_3(462),
        SUBTRACT(463),
        SUM(464),
        SUPPRESS(465),
        SYMBOL(466),
        SYMBOLIC(467),
        SYNC(468),
        SYNCHRONIZED(469),
        TABLE(470),
        TALLY(471),
        TALLYING(472),
        TASK(473),
        TAPE(474),
        TERMINAL(475),
        TERMINATE(476),
        TEST(477),
        TEXT(478),
        THAN(479),
        THEN(480),
        THREAD(481),
        THREAD_LOCAL(482),
        THROUGH(483),
        THRU(484),
        TIME(485),
        TIMER(486),
        TIMES(487),
        TITLE(488),
        TO(489),
        TODAYS_DATE(490),
        TODAYS_NAME(491),
        TOP(492),
        TRAILING(493),
        TRUE(494),
        TRUNCATED(495),
        TYPE(496),
        TYPEDEF(497),
        UNDERLINE(498),
        UNIT(499),
        UNSTRING(500),
        UNTIL(501),
        UP(502),
        UPON(503),
        USAGE(504),
        USE(505),
        USING(506),
        VALUE(507),
        VALUES(508),
        VARYING(509),
        VIRTUAL(510),
        WAIT(511),
        WHEN(512),
        WHEN_COMPILED(513),
        WITH(514),
        WORDS(515),
        WORKING_STORAGE(516),
        WRITE(517),
        YEAR(518),
        YYYYMMDD(519),
        YYYYDDD(520),
        ZERO(521),
        ZERO_FILL(522),
        ZEROS(523),
        ZEROES(524),
        AMPCHAR(525),
        ASTERISKCHAR(526),
        DOUBLEASTERISKCHAR(527),
        COLONCHAR(528),
        COMMACHAR(529),
        COMMENTENTRYTAG(530),
        COMMENTTAG(531),
        DOLLARCHAR(532),
        DOUBLEQUOTE(533),
        DOT_FS(534),
        DOT(535),
        EQUALCHAR(536),
        EXECCICSTAG(537),
        EXECSQLTAG(538),
        EXECSQLIMSTAG(539),
        LESSTHANCHAR(540),
        LESSTHANOREQUAL(541),
        LPARENCHAR(542),
        MINUSCHAR(543),
        MORETHANCHAR(544),
        MORETHANOREQUAL(545),
        NOTEQUALCHAR(546),
        PLUSCHAR(547),
        SINGLEQUOTE(548),
        RPARENCHAR(549),
        SLASHCHAR(550),
        NONNUMERICLITERAL(551),
        LEVEL_NUMBER_66(552),
        LEVEL_NUMBER_77(553),
        LEVEL_NUMBER_88(554),
        INTEGERLITERAL(555),
        NUMERICLITERAL(556),
        IDENTIFIER(557),
        NEWLINE(558),
        EXECCICSLINE(559),
        EXECSQLIMSLINE(560),
        EXECSQLLINE(561),
        COMMENTENTRYLINE(562),
        COMMENTLINE(563),
        WS(564),
        SEPARATOR(565)
    }

    enum class Rules(val id: Int) {
        RULE_startRule(0),
        RULE_compilationUnit(1),
        RULE_programUnit(2),
        RULE_endProgramStatement(3),
        RULE_identificationDivision(4),
        RULE_identificationDivisionBody(5),
        RULE_programIdParagraph(6),
        RULE_authorParagraph(7),
        RULE_installationParagraph(8),
        RULE_dateWrittenParagraph(9),
        RULE_dateCompiledParagraph(10),
        RULE_securityParagraph(11),
        RULE_remarksParagraph(12),
        RULE_environmentDivision(13),
        RULE_environmentDivisionBody(14),
        RULE_configurationSection(15),
        RULE_configurationSectionParagraph(16),
        RULE_sourceComputerParagraph(17),
        RULE_objectComputerParagraph(18),
        RULE_objectComputerClause(19),
        RULE_memorySizeClause(20),
        RULE_diskSizeClause(21),
        RULE_collatingSequenceClause(22),
        RULE_collatingSequenceClauseAlphanumeric(23),
        RULE_collatingSequenceClauseNational(24),
        RULE_segmentLimitClause(25),
        RULE_characterSetClause(26),
        RULE_specialNamesParagraph(27),
        RULE_specialNameClause(28),
        RULE_alphabetClause(29),
        RULE_alphabetClauseFormat1(30),
        RULE_alphabetLiterals(31),
        RULE_alphabetThrough(32),
        RULE_alphabetAlso(33),
        RULE_alphabetClauseFormat2(34),
        RULE_channelClause(35),
        RULE_classClause(36),
        RULE_classClauseThrough(37),
        RULE_classClauseFrom(38),
        RULE_classClauseTo(39),
        RULE_currencySignClause(40),
        RULE_decimalPointClause(41),
        RULE_defaultComputationalSignClause(42),
        RULE_defaultDisplaySignClause(43),
        RULE_environmentSwitchNameClause(44),
        RULE_environmentSwitchNameSpecialNamesStatusPhrase(45),
        RULE_odtClause(46),
        RULE_reserveNetworkClause(47),
        RULE_symbolicCharactersClause(48),
        RULE_symbolicCharacters(49),
        RULE_inputOutputSection(50),
        RULE_inputOutputSectionParagraph(51),
        RULE_fileControlParagraph(52),
        RULE_fileControlEntry(53),
        RULE_selectClause(54),
        RULE_fileControlClause(55),
        RULE_assignClause(56),
        RULE_reserveClause(57),
        RULE_organizationClause(58),
        RULE_paddingCharacterClause(59),
        RULE_recordDelimiterClause(60),
        RULE_accessModeClause(61),
        RULE_recordKeyClause(62),
        RULE_alternateRecordKeyClause(63),
        RULE_passwordClause(64),
        RULE_fileStatusClause(65),
        RULE_relativeKeyClause(66),
        RULE_ioControlParagraph(67),
        RULE_ioControlClause(68),
        RULE_rerunClause(69),
        RULE_rerunEveryRecords(70),
        RULE_rerunEveryOf(71),
        RULE_rerunEveryClock(72),
        RULE_sameClause(73),
        RULE_multipleFileClause(74),
        RULE_multipleFilePosition(75),
        RULE_commitmentControlClause(76),
        RULE_dataDivision(77),
        RULE_dataDivisionSection(78),
        RULE_fileSection(79),
        RULE_fileDescriptionEntry(80),
        RULE_fileDescriptionEntryClause(81),
        RULE_externalClause(82),
        RULE_globalClause(83),
        RULE_blockContainsClause(84),
        RULE_blockContainsTo(85),
        RULE_recordContainsClause(86),
        RULE_recordContainsClauseFormat1(87),
        RULE_recordContainsClauseFormat2(88),
        RULE_recordContainsClauseFormat3(89),
        RULE_recordContainsTo(90),
        RULE_labelRecordsClause(91),
        RULE_valueOfClause(92),
        RULE_valuePair(93),
        RULE_dataRecordsClause(94),
        RULE_linageClause(95),
        RULE_linageAt(96),
        RULE_linageFootingAt(97),
        RULE_linageLinesAtTop(98),
        RULE_linageLinesAtBottom(99),
        RULE_recordingModeClause(100),
        RULE_modeStatement(101),
        RULE_codeSetClause(102),
        RULE_reportClause(103),
        RULE_dataBaseSection(104),
        RULE_dataBaseSectionEntry(105),
        RULE_workingStorageSection(106),
        RULE_linkageSection(107),
        RULE_communicationSection(108),
        RULE_communicationDescriptionEntry(109),
        RULE_communicationDescriptionEntryFormat1(110),
        RULE_communicationDescriptionEntryFormat2(111),
        RULE_communicationDescriptionEntryFormat3(112),
        RULE_destinationCountClause(113),
        RULE_destinationTableClause(114),
        RULE_endKeyClause(115),
        RULE_errorKeyClause(116),
        RULE_messageCountClause(117),
        RULE_messageDateClause(118),
        RULE_messageTimeClause(119),
        RULE_statusKeyClause(120),
        RULE_symbolicDestinationClause(121),
        RULE_symbolicQueueClause(122),
        RULE_symbolicSourceClause(123),
        RULE_symbolicTerminalClause(124),
        RULE_symbolicSubQueueClause(125),
        RULE_textLengthClause(126),
        RULE_localStorageSection(127),
        RULE_screenSection(128),
        RULE_screenDescriptionEntry(129),
        RULE_screenDescriptionBlankClause(130),
        RULE_screenDescriptionBellClause(131),
        RULE_screenDescriptionBlinkClause(132),
        RULE_screenDescriptionEraseClause(133),
        RULE_screenDescriptionLightClause(134),
        RULE_screenDescriptionGridClause(135),
        RULE_screenDescriptionReverseVideoClause(136),
        RULE_screenDescriptionUnderlineClause(137),
        RULE_screenDescriptionSizeClause(138),
        RULE_screenDescriptionLineClause(139),
        RULE_screenDescriptionColumnClause(140),
        RULE_screenDescriptionForegroundColorClause(141),
        RULE_screenDescriptionBackgroundColorClause(142),
        RULE_screenDescriptionControlClause(143),
        RULE_screenDescriptionValueClause(144),
        RULE_screenDescriptionPictureClause(145),
        RULE_screenDescriptionFromClause(146),
        RULE_screenDescriptionToClause(147),
        RULE_screenDescriptionUsingClause(148),
        RULE_screenDescriptionUsageClause(149),
        RULE_screenDescriptionBlankWhenZeroClause(150),
        RULE_screenDescriptionJustifiedClause(151),
        RULE_screenDescriptionSignClause(152),
        RULE_screenDescriptionAutoClause(153),
        RULE_screenDescriptionSecureClause(154),
        RULE_screenDescriptionRequiredClause(155),
        RULE_screenDescriptionPromptClause(156),
        RULE_screenDescriptionPromptOccursClause(157),
        RULE_screenDescriptionFullClause(158),
        RULE_screenDescriptionZeroFillClause(159),
        RULE_reportSection(160),
        RULE_reportDescription(161),
        RULE_reportDescriptionEntry(162),
        RULE_reportDescriptionGlobalClause(163),
        RULE_reportDescriptionPageLimitClause(164),
        RULE_reportDescriptionHeadingClause(165),
        RULE_reportDescriptionFirstDetailClause(166),
        RULE_reportDescriptionLastDetailClause(167),
        RULE_reportDescriptionFootingClause(168),
        RULE_reportGroupDescriptionEntry(169),
        RULE_reportGroupDescriptionEntryFormat1(170),
        RULE_reportGroupDescriptionEntryFormat2(171),
        RULE_reportGroupDescriptionEntryFormat3(172),
        RULE_reportGroupBlankWhenZeroClause(173),
        RULE_reportGroupColumnNumberClause(174),
        RULE_reportGroupIndicateClause(175),
        RULE_reportGroupJustifiedClause(176),
        RULE_reportGroupLineNumberClause(177),
        RULE_reportGroupLineNumberNextPage(178),
        RULE_reportGroupLineNumberPlus(179),
        RULE_reportGroupNextGroupClause(180),
        RULE_reportGroupNextGroupPlus(181),
        RULE_reportGroupNextGroupNextPage(182),
        RULE_reportGroupPictureClause(183),
        RULE_reportGroupResetClause(184),
        RULE_reportGroupSignClause(185),
        RULE_reportGroupSourceClause(186),
        RULE_reportGroupSumClause(187),
        RULE_reportGroupTypeClause(188),
        RULE_reportGroupTypeReportHeading(189),
        RULE_reportGroupTypePageHeading(190),
        RULE_reportGroupTypeControlHeading(191),
        RULE_reportGroupTypeDetail(192),
        RULE_reportGroupTypeControlFooting(193),
        RULE_reportGroupUsageClause(194),
        RULE_reportGroupTypePageFooting(195),
        RULE_reportGroupTypeReportFooting(196),
        RULE_reportGroupValueClause(197),
        RULE_programLibrarySection(198),
        RULE_libraryDescriptionEntry(199),
        RULE_libraryDescriptionEntryFormat1(200),
        RULE_libraryDescriptionEntryFormat2(201),
        RULE_libraryAttributeClauseFormat1(202),
        RULE_libraryAttributeClauseFormat2(203),
        RULE_libraryAttributeFunction(204),
        RULE_libraryAttributeParameter(205),
        RULE_libraryAttributeTitle(206),
        RULE_libraryEntryProcedureClauseFormat1(207),
        RULE_libraryEntryProcedureClauseFormat2(208),
        RULE_libraryEntryProcedureForClause(209),
        RULE_libraryEntryProcedureGivingClause(210),
        RULE_libraryEntryProcedureUsingClause(211),
        RULE_libraryEntryProcedureUsingName(212),
        RULE_libraryEntryProcedureWithClause(213),
        RULE_libraryEntryProcedureWithName(214),
        RULE_libraryIsCommonClause(215),
        RULE_libraryIsGlobalClause(216),
        RULE_dataDescriptionEntry(217),
        RULE_dataDescriptionEntryFormat1(218),
        RULE_dataDescriptionEntryFormat2(219),
        RULE_dataDescriptionEntryFormat3(220),
        RULE_dataDescriptionEntryExecSql(221),
        RULE_dataAlignedClause(222),
        RULE_dataBlankWhenZeroClause(223),
        RULE_dataCommonOwnLocalClause(224),
        RULE_dataExternalClause(225),
        RULE_dataGlobalClause(226),
        RULE_dataIntegerStringClause(227),
        RULE_dataJustifiedClause(228),
        RULE_dataOccursClause(229),
        RULE_dataOccursTo(230),
        RULE_dataOccursSort(231),
        RULE_dataPictureClause(232),
        RULE_pictureString(233),
        RULE_pictureChars(234),
        RULE_pictureCardinality(235),
        RULE_dataReceivedByClause(236),
        RULE_dataRecordAreaClause(237),
        RULE_dataRedefinesClause(238),
        RULE_dataRenamesClause(239),
        RULE_dataSignClause(240),
        RULE_dataSynchronizedClause(241),
        RULE_dataThreadLocalClause(242),
        RULE_dataTypeClause(243),
        RULE_dataTypeDefClause(244),
        RULE_dataUsageClause(245),
        RULE_dataUsingClause(246),
        RULE_dataValueClause(247),
        RULE_dataValueInterval(248),
        RULE_dataValueIntervalFrom(249),
        RULE_dataValueIntervalTo(250),
        RULE_dataWithLowerBoundsClause(251),
        RULE_procedureDivision(252),
        RULE_procedureDivisionUsingClause(253),
        RULE_procedureDivisionGivingClause(254),
        RULE_procedureDivisionUsingParameter(255),
        RULE_procedureDivisionByReferencePhrase(256),
        RULE_procedureDivisionByReference(257),
        RULE_procedureDivisionByValuePhrase(258),
        RULE_procedureDivisionByValue(259),
        RULE_procedureDeclaratives(260),
        RULE_procedureDeclarative(261),
        RULE_procedureSectionHeader(262),
        RULE_procedureDivisionBody(263),
        RULE_procedureSection(264),
        RULE_paragraphs(265),
        RULE_paragraph(266),
        RULE_sentence(267),
        RULE_statement(268),
        RULE_acceptStatement(269),
        RULE_acceptFromDateStatement(270),
        RULE_acceptFromMnemonicStatement(271),
        RULE_acceptFromEscapeKeyStatement(272),
        RULE_acceptMessageCountStatement(273),
        RULE_addStatement(274),
        RULE_addToStatement(275),
        RULE_addToGivingStatement(276),
        RULE_addCorrespondingStatement(277),
        RULE_addFrom(278),
        RULE_addTo(279),
        RULE_addToGiving(280),
        RULE_addGiving(281),
        RULE_alteredGoTo(282),
        RULE_alterStatement(283),
        RULE_alterProceedTo(284),
        RULE_callStatement(285),
        RULE_callUsingPhrase(286),
        RULE_callUsingParameter(287),
        RULE_callByReferencePhrase(288),
        RULE_callByReference(289),
        RULE_callByValuePhrase(290),
        RULE_callByValue(291),
        RULE_callByContentPhrase(292),
        RULE_callByContent(293),
        RULE_callGivingPhrase(294),
        RULE_cancelStatement(295),
        RULE_cancelCall(296),
        RULE_closeStatement(297),
        RULE_closeFile(298),
        RULE_closeReelUnitStatement(299),
        RULE_closeRelativeStatement(300),
        RULE_closePortFileIOStatement(301),
        RULE_closePortFileIOUsing(302),
        RULE_closePortFileIOUsingCloseDisposition(303),
        RULE_closePortFileIOUsingAssociatedData(304),
        RULE_closePortFileIOUsingAssociatedDataLength(305),
        RULE_computeStatement(306),
        RULE_computeStore(307),
        RULE_continueStatement(308),
        RULE_deleteStatement(309),
        RULE_disableStatement(310),
        RULE_displayStatement(311),
        RULE_displayOperand(312),
        RULE_displayAt(313),
        RULE_displayUpon(314),
        RULE_displayWith(315),
        RULE_divideStatement(316),
        RULE_divideIntoStatement(317),
        RULE_divideIntoGivingStatement(318),
        RULE_divideByGivingStatement(319),
        RULE_divideGivingPhrase(320),
        RULE_divideInto(321),
        RULE_divideGiving(322),
        RULE_divideRemainder(323),
        RULE_enableStatement(324),
        RULE_entryStatement(325),
        RULE_evaluateStatement(326),
        RULE_evaluateSelect(327),
        RULE_evaluateAlsoSelect(328),
        RULE_evaluateWhenPhrase(329),
        RULE_evaluateWhen(330),
        RULE_evaluateCondition(331),
        RULE_evaluateThrough(332),
        RULE_evaluateAlsoCondition(333),
        RULE_evaluateWhenOther(334),
        RULE_evaluateValue(335),
        RULE_execCicsStatement(336),
        RULE_execSqlStatement(337),
        RULE_execSqlImsStatement(338),
        RULE_exhibitStatement(339),
        RULE_exhibitOperand(340),
        RULE_exitStatement(341),
        RULE_generateStatement(342),
        RULE_gobackStatement(343),
        RULE_goToStatement(344),
        RULE_goToStatementSimple(345),
        RULE_goToDependingOnStatement(346),
        RULE_ifStatement(347),
        RULE_ifThen(348),
        RULE_ifElse(349),
        RULE_initializeStatement(350),
        RULE_initializeReplacingPhrase(351),
        RULE_initializeReplacingBy(352),
        RULE_initiateStatement(353),
        RULE_inspectStatement(354),
        RULE_inspectTallyingPhrase(355),
        RULE_inspectReplacingPhrase(356),
        RULE_inspectTallyingReplacingPhrase(357),
        RULE_inspectConvertingPhrase(358),
        RULE_inspectFor(359),
        RULE_inspectCharacters(360),
        RULE_inspectReplacingCharacters(361),
        RULE_inspectAllLeadings(362),
        RULE_inspectReplacingAllLeadings(363),
        RULE_inspectAllLeading(364),
        RULE_inspectReplacingAllLeading(365),
        RULE_inspectBy(366),
        RULE_inspectTo(367),
        RULE_inspectBeforeAfter(368),
        RULE_mergeStatement(369),
        RULE_mergeOnKeyClause(370),
        RULE_mergeCollatingSequencePhrase(371),
        RULE_mergeCollatingAlphanumeric(372),
        RULE_mergeCollatingNational(373),
        RULE_mergeUsing(374),
        RULE_mergeOutputProcedurePhrase(375),
        RULE_mergeOutputThrough(376),
        RULE_mergeGivingPhrase(377),
        RULE_mergeGiving(378),
        RULE_moveStatement(379),
        RULE_moveToStatement(380),
        RULE_moveToSendingArea(381),
        RULE_moveCorrespondingToStatement(382),
        RULE_moveCorrespondingToSendingArea(383),
        RULE_multiplyStatement(384),
        RULE_multiplyRegular(385),
        RULE_multiplyRegularOperand(386),
        RULE_multiplyGiving(387),
        RULE_multiplyGivingOperand(388),
        RULE_multiplyGivingResult(389),
        RULE_openStatement(390),
        RULE_openInputStatement(391),
        RULE_openInput(392),
        RULE_openOutputStatement(393),
        RULE_openOutput(394),
        RULE_openIOStatement(395),
        RULE_openExtendStatement(396),
        RULE_performStatement(397),
        RULE_performInlineStatement(398),
        RULE_performProcedureStatement(399),
        RULE_performType(400),
        RULE_performTimes(401),
        RULE_performUntil(402),
        RULE_performVarying(403),
        RULE_performVaryingClause(404),
        RULE_performVaryingPhrase(405),
        RULE_performAfter(406),
        RULE_performFrom(407),
        RULE_performBy(408),
        RULE_performTestClause(409),
        RULE_purgeStatement(410),
        RULE_readStatement(411),
        RULE_readInto(412),
        RULE_readWith(413),
        RULE_readKey(414),
        RULE_receiveStatement(415),
        RULE_receiveFromStatement(416),
        RULE_receiveFrom(417),
        RULE_receiveIntoStatement(418),
        RULE_receiveNoData(419),
        RULE_receiveWithData(420),
        RULE_receiveBefore(421),
        RULE_receiveWith(422),
        RULE_receiveThread(423),
        RULE_receiveSize(424),
        RULE_receiveStatus(425),
        RULE_releaseStatement(426),
        RULE_returnStatement(427),
        RULE_returnInto(428),
        RULE_rewriteStatement(429),
        RULE_rewriteFrom(430),
        RULE_searchStatement(431),
        RULE_searchVarying(432),
        RULE_searchWhen(433),
        RULE_sendStatement(434),
        RULE_sendStatementSync(435),
        RULE_sendStatementAsync(436),
        RULE_sendFromPhrase(437),
        RULE_sendWithPhrase(438),
        RULE_sendReplacingPhrase(439),
        RULE_sendAdvancingPhrase(440),
        RULE_sendAdvancingPage(441),
        RULE_sendAdvancingLines(442),
        RULE_sendAdvancingMnemonic(443),
        RULE_setStatement(444),
        RULE_setToStatement(445),
        RULE_setUpDownByStatement(446),
        RULE_setTo(447),
        RULE_setToValue(448),
        RULE_setByValue(449),
        RULE_sortStatement(450),
        RULE_sortOnKeyClause(451),
        RULE_sortDuplicatesPhrase(452),
        RULE_sortCollatingSequencePhrase(453),
        RULE_sortCollatingAlphanumeric(454),
        RULE_sortCollatingNational(455),
        RULE_sortInputProcedurePhrase(456),
        RULE_sortInputThrough(457),
        RULE_sortUsing(458),
        RULE_sortOutputProcedurePhrase(459),
        RULE_sortOutputThrough(460),
        RULE_sortGivingPhrase(461),
        RULE_sortGiving(462),
        RULE_startStatement(463),
        RULE_startKey(464),
        RULE_stopStatement(465),
        RULE_stringStatement(466),
        RULE_stringSendingPhrase(467),
        RULE_stringSending(468),
        RULE_stringDelimitedByPhrase(469),
        RULE_stringForPhrase(470),
        RULE_stringIntoPhrase(471),
        RULE_stringWithPointerPhrase(472),
        RULE_subtractStatement(473),
        RULE_subtractFromStatement(474),
        RULE_subtractFromGivingStatement(475),
        RULE_subtractCorrespondingStatement(476),
        RULE_subtractSubtrahend(477),
        RULE_subtractMinuend(478),
        RULE_subtractMinuendGiving(479),
        RULE_subtractGiving(480),
        RULE_subtractMinuendCorresponding(481),
        RULE_terminateStatement(482),
        RULE_unstringStatement(483),
        RULE_unstringSendingPhrase(484),
        RULE_unstringDelimitedByPhrase(485),
        RULE_unstringOrAllPhrase(486),
        RULE_unstringIntoPhrase(487),
        RULE_unstringInto(488),
        RULE_unstringDelimiterIn(489),
        RULE_unstringCountIn(490),
        RULE_unstringWithPointerPhrase(491),
        RULE_unstringTallyingPhrase(492),
        RULE_useStatement(493),
        RULE_useAfterClause(494),
        RULE_useAfterOn(495),
        RULE_useDebugClause(496),
        RULE_useDebugOn(497),
        RULE_writeStatement(498),
        RULE_writeFromPhrase(499),
        RULE_writeAdvancingPhrase(500),
        RULE_writeAdvancingPage(501),
        RULE_writeAdvancingLines(502),
        RULE_writeAdvancingMnemonic(503),
        RULE_writeAtEndOfPagePhrase(504),
        RULE_writeNotAtEndOfPagePhrase(505),
        RULE_atEndPhrase(506),
        RULE_notAtEndPhrase(507),
        RULE_invalidKeyPhrase(508),
        RULE_notInvalidKeyPhrase(509),
        RULE_onOverflowPhrase(510),
        RULE_notOnOverflowPhrase(511),
        RULE_onSizeErrorPhrase(512),
        RULE_notOnSizeErrorPhrase(513),
        RULE_onExceptionClause(514),
        RULE_notOnExceptionClause(515),
        RULE_arithmeticExpression(516),
        RULE_plusMinus(517),
        RULE_multDivs(518),
        RULE_multDiv(519),
        RULE_powers(520),
        RULE_power(521),
        RULE_basis(522),
        RULE_condition(523),
        RULE_andOrCondition(524),
        RULE_combinableCondition(525),
        RULE_simpleCondition(526),
        RULE_classCondition(527),
        RULE_conditionNameReference(528),
        RULE_conditionNameSubscriptReference(529),
        RULE_relationCondition(530),
        RULE_relationSignCondition(531),
        RULE_relationArithmeticComparison(532),
        RULE_relationCombinedComparison(533),
        RULE_relationCombinedCondition(534),
        RULE_relationalOperator(535),
        RULE_abbreviation(536),
        RULE_identifier(537),
        RULE_tableCall(538),
        RULE_functionCall(539),
        RULE_referenceModifier(540),
        RULE_characterPosition(541),
        RULE_length(542),
        RULE_subscript(543),
        RULE_argument(544),
        RULE_qualifiedDataName(545),
        RULE_qualifiedDataNameFormat1(546),
        RULE_qualifiedDataNameFormat2(547),
        RULE_qualifiedDataNameFormat3(548),
        RULE_qualifiedDataNameFormat4(549),
        RULE_qualifiedInData(550),
        RULE_inData(551),
        RULE_inFile(552),
        RULE_inMnemonic(553),
        RULE_inSection(554),
        RULE_inLibrary(555),
        RULE_inTable(556),
        RULE_alphabetName(557),
        RULE_assignmentName(558),
        RULE_basisName(559),
        RULE_cdName(560),
        RULE_className(561),
        RULE_computerName(562),
        RULE_conditionName(563),
        RULE_dataName(564),
        RULE_dataDescName(565),
        RULE_environmentName(566),
        RULE_fileName(567),
        RULE_functionName(568),
        RULE_indexName(569),
        RULE_languageName(570),
        RULE_libraryName(571),
        RULE_localName(572),
        RULE_mnemonicName(573),
        RULE_paragraphName(574),
        RULE_procedureName(575),
        RULE_programName(576),
        RULE_recordName(577),
        RULE_reportName(578),
        RULE_routineName(579),
        RULE_screenName(580),
        RULE_sectionName(581),
        RULE_systemName(582),
        RULE_symbolicCharacter(583),
        RULE_textName(584),
        RULE_cobolWord(585),
        RULE_literal(586),
        RULE_booleanLiteral(587),
        RULE_numericLiteral(588),
        RULE_integerLiteral(589),
        RULE_cicsDfhRespLiteral(590),
        RULE_cicsDfhValueLiteral(591),
        RULE_figurativeConstant(592),
        RULE_specialRegister(593),
        RULE_commentEntry(594)
    }

	companion object {
	    protected val decisionToDFA : Array<DFA>
    	protected val sharedContextCache = PredictionContextCache()

        val ruleNames = arrayOf("startRule", "compilationUnit", "programUnit", 
                                "endProgramStatement", "identificationDivision", 
                                "identificationDivisionBody", "programIdParagraph", 
                                "authorParagraph", "installationParagraph", 
                                "dateWrittenParagraph", "dateCompiledParagraph", 
                                "securityParagraph", "remarksParagraph", 
                                "environmentDivision", "environmentDivisionBody", 
                                "configurationSection", "configurationSectionParagraph", 
                                "sourceComputerParagraph", "objectComputerParagraph", 
                                "objectComputerClause", "memorySizeClause", 
                                "diskSizeClause", "collatingSequenceClause", 
                                "collatingSequenceClauseAlphanumeric", "collatingSequenceClauseNational", 
                                "segmentLimitClause", "characterSetClause", 
                                "specialNamesParagraph", "specialNameClause", 
                                "alphabetClause", "alphabetClauseFormat1", 
                                "alphabetLiterals", "alphabetThrough", "alphabetAlso", 
                                "alphabetClauseFormat2", "channelClause", 
                                "classClause", "classClauseThrough", "classClauseFrom", 
                                "classClauseTo", "currencySignClause", "decimalPointClause", 
                                "defaultComputationalSignClause", "defaultDisplaySignClause", 
                                "environmentSwitchNameClause", "environmentSwitchNameSpecialNamesStatusPhrase", 
                                "odtClause", "reserveNetworkClause", "symbolicCharactersClause", 
                                "symbolicCharacters", "inputOutputSection", 
                                "inputOutputSectionParagraph", "fileControlParagraph", 
                                "fileControlEntry", "selectClause", "fileControlClause", 
                                "assignClause", "reserveClause", "organizationClause", 
                                "paddingCharacterClause", "recordDelimiterClause", 
                                "accessModeClause", "recordKeyClause", "alternateRecordKeyClause", 
                                "passwordClause", "fileStatusClause", "relativeKeyClause", 
                                "ioControlParagraph", "ioControlClause", 
                                "rerunClause", "rerunEveryRecords", "rerunEveryOf", 
                                "rerunEveryClock", "sameClause", "multipleFileClause", 
                                "multipleFilePosition", "commitmentControlClause", 
                                "dataDivision", "dataDivisionSection", "fileSection", 
                                "fileDescriptionEntry", "fileDescriptionEntryClause", 
                                "externalClause", "globalClause", "blockContainsClause", 
                                "blockContainsTo", "recordContainsClause", 
                                "recordContainsClauseFormat1", "recordContainsClauseFormat2", 
                                "recordContainsClauseFormat3", "recordContainsTo", 
                                "labelRecordsClause", "valueOfClause", "valuePair", 
                                "dataRecordsClause", "linageClause", "linageAt", 
                                "linageFootingAt", "linageLinesAtTop", "linageLinesAtBottom", 
                                "recordingModeClause", "modeStatement", 
                                "codeSetClause", "reportClause", "dataBaseSection", 
                                "dataBaseSectionEntry", "workingStorageSection", 
                                "linkageSection", "communicationSection", 
                                "communicationDescriptionEntry", "communicationDescriptionEntryFormat1", 
                                "communicationDescriptionEntryFormat2", 
                                "communicationDescriptionEntryFormat3", 
                                "destinationCountClause", "destinationTableClause", 
                                "endKeyClause", "errorKeyClause", "messageCountClause", 
                                "messageDateClause", "messageTimeClause", 
                                "statusKeyClause", "symbolicDestinationClause", 
                                "symbolicQueueClause", "symbolicSourceClause", 
                                "symbolicTerminalClause", "symbolicSubQueueClause", 
                                "textLengthClause", "localStorageSection", 
                                "screenSection", "screenDescriptionEntry", 
                                "screenDescriptionBlankClause", "screenDescriptionBellClause", 
                                "screenDescriptionBlinkClause", "screenDescriptionEraseClause", 
                                "screenDescriptionLightClause", "screenDescriptionGridClause", 
                                "screenDescriptionReverseVideoClause", "screenDescriptionUnderlineClause", 
                                "screenDescriptionSizeClause", "screenDescriptionLineClause", 
                                "screenDescriptionColumnClause", "screenDescriptionForegroundColorClause", 
                                "screenDescriptionBackgroundColorClause", 
                                "screenDescriptionControlClause", "screenDescriptionValueClause", 
                                "screenDescriptionPictureClause", "screenDescriptionFromClause", 
                                "screenDescriptionToClause", "screenDescriptionUsingClause", 
                                "screenDescriptionUsageClause", "screenDescriptionBlankWhenZeroClause", 
                                "screenDescriptionJustifiedClause", "screenDescriptionSignClause", 
                                "screenDescriptionAutoClause", "screenDescriptionSecureClause", 
                                "screenDescriptionRequiredClause", "screenDescriptionPromptClause", 
                                "screenDescriptionPromptOccursClause", "screenDescriptionFullClause", 
                                "screenDescriptionZeroFillClause", "reportSection", 
                                "reportDescription", "reportDescriptionEntry", 
                                "reportDescriptionGlobalClause", "reportDescriptionPageLimitClause", 
                                "reportDescriptionHeadingClause", "reportDescriptionFirstDetailClause", 
                                "reportDescriptionLastDetailClause", "reportDescriptionFootingClause", 
                                "reportGroupDescriptionEntry", "reportGroupDescriptionEntryFormat1", 
                                "reportGroupDescriptionEntryFormat2", "reportGroupDescriptionEntryFormat3", 
                                "reportGroupBlankWhenZeroClause", "reportGroupColumnNumberClause", 
                                "reportGroupIndicateClause", "reportGroupJustifiedClause", 
                                "reportGroupLineNumberClause", "reportGroupLineNumberNextPage", 
                                "reportGroupLineNumberPlus", "reportGroupNextGroupClause", 
                                "reportGroupNextGroupPlus", "reportGroupNextGroupNextPage", 
                                "reportGroupPictureClause", "reportGroupResetClause", 
                                "reportGroupSignClause", "reportGroupSourceClause", 
                                "reportGroupSumClause", "reportGroupTypeClause", 
                                "reportGroupTypeReportHeading", "reportGroupTypePageHeading", 
                                "reportGroupTypeControlHeading", "reportGroupTypeDetail", 
                                "reportGroupTypeControlFooting", "reportGroupUsageClause", 
                                "reportGroupTypePageFooting", "reportGroupTypeReportFooting", 
                                "reportGroupValueClause", "programLibrarySection", 
                                "libraryDescriptionEntry", "libraryDescriptionEntryFormat1", 
                                "libraryDescriptionEntryFormat2", "libraryAttributeClauseFormat1", 
                                "libraryAttributeClauseFormat2", "libraryAttributeFunction", 
                                "libraryAttributeParameter", "libraryAttributeTitle", 
                                "libraryEntryProcedureClauseFormat1", "libraryEntryProcedureClauseFormat2", 
                                "libraryEntryProcedureForClause", "libraryEntryProcedureGivingClause", 
                                "libraryEntryProcedureUsingClause", "libraryEntryProcedureUsingName", 
                                "libraryEntryProcedureWithClause", "libraryEntryProcedureWithName", 
                                "libraryIsCommonClause", "libraryIsGlobalClause", 
                                "dataDescriptionEntry", "dataDescriptionEntryFormat1", 
                                "dataDescriptionEntryFormat2", "dataDescriptionEntryFormat3", 
                                "dataDescriptionEntryExecSql", "dataAlignedClause", 
                                "dataBlankWhenZeroClause", "dataCommonOwnLocalClause", 
                                "dataExternalClause", "dataGlobalClause", 
                                "dataIntegerStringClause", "dataJustifiedClause", 
                                "dataOccursClause", "dataOccursTo", "dataOccursSort", 
                                "dataPictureClause", "pictureString", "pictureChars", 
                                "pictureCardinality", "dataReceivedByClause", 
                                "dataRecordAreaClause", "dataRedefinesClause", 
                                "dataRenamesClause", "dataSignClause", "dataSynchronizedClause", 
                                "dataThreadLocalClause", "dataTypeClause", 
                                "dataTypeDefClause", "dataUsageClause", 
                                "dataUsingClause", "dataValueClause", "dataValueInterval", 
                                "dataValueIntervalFrom", "dataValueIntervalTo", 
                                "dataWithLowerBoundsClause", "procedureDivision", 
                                "procedureDivisionUsingClause", "procedureDivisionGivingClause", 
                                "procedureDivisionUsingParameter", "procedureDivisionByReferencePhrase", 
                                "procedureDivisionByReference", "procedureDivisionByValuePhrase", 
                                "procedureDivisionByValue", "procedureDeclaratives", 
                                "procedureDeclarative", "procedureSectionHeader", 
                                "procedureDivisionBody", "procedureSection", 
                                "paragraphs", "paragraph", "sentence", "statement", 
                                "acceptStatement", "acceptFromDateStatement", 
                                "acceptFromMnemonicStatement", "acceptFromEscapeKeyStatement", 
                                "acceptMessageCountStatement", "addStatement", 
                                "addToStatement", "addToGivingStatement", 
                                "addCorrespondingStatement", "addFrom", 
                                "addTo", "addToGiving", "addGiving", "alteredGoTo", 
                                "alterStatement", "alterProceedTo", "callStatement", 
                                "callUsingPhrase", "callUsingParameter", 
                                "callByReferencePhrase", "callByReference", 
                                "callByValuePhrase", "callByValue", "callByContentPhrase", 
                                "callByContent", "callGivingPhrase", "cancelStatement", 
                                "cancelCall", "closeStatement", "closeFile", 
                                "closeReelUnitStatement", "closeRelativeStatement", 
                                "closePortFileIOStatement", "closePortFileIOUsing", 
                                "closePortFileIOUsingCloseDisposition", 
                                "closePortFileIOUsingAssociatedData", "closePortFileIOUsingAssociatedDataLength", 
                                "computeStatement", "computeStore", "continueStatement", 
                                "deleteStatement", "disableStatement", "displayStatement", 
                                "displayOperand", "displayAt", "displayUpon", 
                                "displayWith", "divideStatement", "divideIntoStatement", 
                                "divideIntoGivingStatement", "divideByGivingStatement", 
                                "divideGivingPhrase", "divideInto", "divideGiving", 
                                "divideRemainder", "enableStatement", "entryStatement", 
                                "evaluateStatement", "evaluateSelect", "evaluateAlsoSelect", 
                                "evaluateWhenPhrase", "evaluateWhen", "evaluateCondition", 
                                "evaluateThrough", "evaluateAlsoCondition", 
                                "evaluateWhenOther", "evaluateValue", "execCicsStatement", 
                                "execSqlStatement", "execSqlImsStatement", 
                                "exhibitStatement", "exhibitOperand", "exitStatement", 
                                "generateStatement", "gobackStatement", 
                                "goToStatement", "goToStatementSimple", 
                                "goToDependingOnStatement", "ifStatement", 
                                "ifThen", "ifElse", "initializeStatement", 
                                "initializeReplacingPhrase", "initializeReplacingBy", 
                                "initiateStatement", "inspectStatement", 
                                "inspectTallyingPhrase", "inspectReplacingPhrase", 
                                "inspectTallyingReplacingPhrase", "inspectConvertingPhrase", 
                                "inspectFor", "inspectCharacters", "inspectReplacingCharacters", 
                                "inspectAllLeadings", "inspectReplacingAllLeadings", 
                                "inspectAllLeading", "inspectReplacingAllLeading", 
                                "inspectBy", "inspectTo", "inspectBeforeAfter", 
                                "mergeStatement", "mergeOnKeyClause", "mergeCollatingSequencePhrase", 
                                "mergeCollatingAlphanumeric", "mergeCollatingNational", 
                                "mergeUsing", "mergeOutputProcedurePhrase", 
                                "mergeOutputThrough", "mergeGivingPhrase", 
                                "mergeGiving", "moveStatement", "moveToStatement", 
                                "moveToSendingArea", "moveCorrespondingToStatement", 
                                "moveCorrespondingToSendingArea", "multiplyStatement", 
                                "multiplyRegular", "multiplyRegularOperand", 
                                "multiplyGiving", "multiplyGivingOperand", 
                                "multiplyGivingResult", "openStatement", 
                                "openInputStatement", "openInput", "openOutputStatement", 
                                "openOutput", "openIOStatement", "openExtendStatement", 
                                "performStatement", "performInlineStatement", 
                                "performProcedureStatement", "performType", 
                                "performTimes", "performUntil", "performVarying", 
                                "performVaryingClause", "performVaryingPhrase", 
                                "performAfter", "performFrom", "performBy", 
                                "performTestClause", "purgeStatement", "readStatement", 
                                "readInto", "readWith", "readKey", "receiveStatement", 
                                "receiveFromStatement", "receiveFrom", "receiveIntoStatement", 
                                "receiveNoData", "receiveWithData", "receiveBefore", 
                                "receiveWith", "receiveThread", "receiveSize", 
                                "receiveStatus", "releaseStatement", "returnStatement", 
                                "returnInto", "rewriteStatement", "rewriteFrom", 
                                "searchStatement", "searchVarying", "searchWhen", 
                                "sendStatement", "sendStatementSync", "sendStatementAsync", 
                                "sendFromPhrase", "sendWithPhrase", "sendReplacingPhrase", 
                                "sendAdvancingPhrase", "sendAdvancingPage", 
                                "sendAdvancingLines", "sendAdvancingMnemonic", 
                                "setStatement", "setToStatement", "setUpDownByStatement", 
                                "setTo", "setToValue", "setByValue", "sortStatement", 
                                "sortOnKeyClause", "sortDuplicatesPhrase", 
                                "sortCollatingSequencePhrase", "sortCollatingAlphanumeric", 
                                "sortCollatingNational", "sortInputProcedurePhrase", 
                                "sortInputThrough", "sortUsing", "sortOutputProcedurePhrase", 
                                "sortOutputThrough", "sortGivingPhrase", 
                                "sortGiving", "startStatement", "startKey", 
                                "stopStatement", "stringStatement", "stringSendingPhrase", 
                                "stringSending", "stringDelimitedByPhrase", 
                                "stringForPhrase", "stringIntoPhrase", "stringWithPointerPhrase", 
                                "subtractStatement", "subtractFromStatement", 
                                "subtractFromGivingStatement", "subtractCorrespondingStatement", 
                                "subtractSubtrahend", "subtractMinuend", 
                                "subtractMinuendGiving", "subtractGiving", 
                                "subtractMinuendCorresponding", "terminateStatement", 
                                "unstringStatement", "unstringSendingPhrase", 
                                "unstringDelimitedByPhrase", "unstringOrAllPhrase", 
                                "unstringIntoPhrase", "unstringInto", "unstringDelimiterIn", 
                                "unstringCountIn", "unstringWithPointerPhrase", 
                                "unstringTallyingPhrase", "useStatement", 
                                "useAfterClause", "useAfterOn", "useDebugClause", 
                                "useDebugOn", "writeStatement", "writeFromPhrase", 
                                "writeAdvancingPhrase", "writeAdvancingPage", 
                                "writeAdvancingLines", "writeAdvancingMnemonic", 
                                "writeAtEndOfPagePhrase", "writeNotAtEndOfPagePhrase", 
                                "atEndPhrase", "notAtEndPhrase", "invalidKeyPhrase", 
                                "notInvalidKeyPhrase", "onOverflowPhrase", 
                                "notOnOverflowPhrase", "onSizeErrorPhrase", 
                                "notOnSizeErrorPhrase", "onExceptionClause", 
                                "notOnExceptionClause", "arithmeticExpression", 
                                "plusMinus", "multDivs", "multDiv", "powers", 
                                "power", "basis", "condition", "andOrCondition", 
                                "combinableCondition", "simpleCondition", 
                                "classCondition", "conditionNameReference", 
                                "conditionNameSubscriptReference", "relationCondition", 
                                "relationSignCondition", "relationArithmeticComparison", 
                                "relationCombinedComparison", "relationCombinedCondition", 
                                "relationalOperator", "abbreviation", "identifier", 
                                "tableCall", "functionCall", "referenceModifier", 
                                "characterPosition", "length", "subscript", 
                                "argument", "qualifiedDataName", "qualifiedDataNameFormat1", 
                                "qualifiedDataNameFormat2", "qualifiedDataNameFormat3", 
                                "qualifiedDataNameFormat4", "qualifiedInData", 
                                "inData", "inFile", "inMnemonic", "inSection", 
                                "inLibrary", "inTable", "alphabetName", 
                                "assignmentName", "basisName", "cdName", 
                                "className", "computerName", "conditionName", 
                                "dataName", "dataDescName", "environmentName", 
                                "fileName", "functionName", "indexName", 
                                "languageName", "libraryName", "localName", 
                                "mnemonicName", "paragraphName", "procedureName", 
                                "programName", "recordName", "reportName", 
                                "routineName", "screenName", "sectionName", 
                                "systemName", "symbolicCharacter", "textName", 
                                "cobolWord", "literal", "booleanLiteral", 
                                "numericLiteral", "integerLiteral", "cicsDfhRespLiteral", 
                                "cicsDfhValueLiteral", "figurativeConstant", 
                                "specialRegister", "commentEntry")

        private val LITERAL_NAMES = Arrays.asList<String?>(null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           "'&'", "'*'", 
                                                           "'**'", "':'", 
                                                           "','", "'*>CE'", 
                                                           "'*>'", "'$'", 
                                                           "'\"'", null, 
                                                           "'.'", "'='", 
                                                           "'*>EXECCICS'", 
                                                           "'*>EXECSQL'", 
                                                           "'*>EXECSQLIMS'", 
                                                           "'<'", "'<='", 
                                                           "'('", "'-'", 
                                                           "'>'", "'>='", 
                                                           "'<>'", "'+'", 
                                                           "'''", "')'", 
                                                           "'/'", null, 
                                                           "'66'", "'77'", 
                                                           "'88'", null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           null, null, null, 
                                                           "', '")
        private val SYMBOLIC_NAMES = Arrays.asList<String?>(null, "ABORT", 
                                                            "ACCEPT", "ACCESS", 
                                                            "ADD", "ADDRESS", 
                                                            "ADVANCING", 
                                                            "AFTER", "ALIGNED", 
                                                            "ALL", "ALPHABET", 
                                                            "ALPHABETIC", 
                                                            "ALPHABETIC_LOWER", 
                                                            "ALPHABETIC_UPPER", 
                                                            "ALPHANUMERIC", 
                                                            "ALPHANUMERIC_EDITED", 
                                                            "ALSO", "ALTER", 
                                                            "ALTERNATE", 
                                                            "AND", "ANY", 
                                                            "ARE", "AREA", 
                                                            "AREAS", "AS", 
                                                            "ASCENDING", 
                                                            "ASCII", "ASSIGN", 
                                                            "ASSOCIATED_DATA", 
                                                            "ASSOCIATED_DATA_LENGTH", 
                                                            "AT", "ATTRIBUTE", 
                                                            "AUTHOR", "AUTO", 
                                                            "AUTO_SKIP", 
                                                            "BACKGROUND_COLOR", 
                                                            "BACKGROUND_COLOUR", 
                                                            "BASIS", "BEEP", 
                                                            "BEFORE", "BEGINNING", 
                                                            "BELL", "BINARY", 
                                                            "BIT", "BLANK", 
                                                            "BLINK", "BLOCK", 
                                                            "BOUNDS", "BOTTOM", 
                                                            "BY", "BYFUNCTION", 
                                                            "BYTITLE", "CALL", 
                                                            "CANCEL", "CAPABLE", 
                                                            "CCSVERSION", 
                                                            "CD", "CF", 
                                                            "CH", "CHAINING", 
                                                            "CHANGED", "CHANNEL", 
                                                            "CHARACTER", 
                                                            "CHARACTERS", 
                                                            "CLASS", "CLASS_ID", 
                                                            "CLOCK_UNITS", 
                                                            "CLOSE", "CLOSE_DISPOSITION", 
                                                            "COBOL", "CODE", 
                                                            "CODE_SET", 
                                                            "COLLATING", 
                                                            "COL", "COLUMN", 
                                                            "COM_REG", "COMMA", 
                                                            "COMMITMENT", 
                                                            "COMMON", "COMMUNICATION", 
                                                            "COMP", "COMP_1", 
                                                            "COMP_2", "COMP_3", 
                                                            "COMP_4", "COMP_5", 
                                                            "COMPUTATIONAL", 
                                                            "COMPUTATIONAL_1", 
                                                            "COMPUTATIONAL_2", 
                                                            "COMPUTATIONAL_3", 
                                                            "COMPUTATIONAL_4", 
                                                            "COMPUTATIONAL_5", 
                                                            "COMPUTE", "CONFIGURATION", 
                                                            "CONTAINS", 
                                                            "CONTENT", "CONTINUE", 
                                                            "CONTROL", "CONTROL_POINT", 
                                                            "CONTROLS", 
                                                            "CONVENTION", 
                                                            "CONVERTING", 
                                                            "COPY", "CORR", 
                                                            "CORRESPONDING", 
                                                            "COUNT", "CRUNCH", 
                                                            "CURRENCY", 
                                                            "CURSOR", "DATA", 
                                                            "DATA_BASE", 
                                                            "DATE", "DATE_COMPILED", 
                                                            "DATE_WRITTEN", 
                                                            "DAY", "DAY_OF_WEEK", 
                                                            "DBCS", "DE", 
                                                            "DEBUG_CONTENTS", 
                                                            "DEBUG_ITEM", 
                                                            "DEBUG_LINE", 
                                                            "DEBUG_NAME", 
                                                            "DEBUG_SUB_1", 
                                                            "DEBUG_SUB_2", 
                                                            "DEBUG_SUB_3", 
                                                            "DEBUGGING", 
                                                            "DECIMAL_POINT", 
                                                            "DECLARATIVES", 
                                                            "DEFAULT", "DEFAULT_DISPLAY", 
                                                            "DEFINITION", 
                                                            "DELETE", "DELIMITED", 
                                                            "DELIMITER", 
                                                            "DEPENDING", 
                                                            "DESCENDING", 
                                                            "DESTINATION", 
                                                            "DETAIL", "DFHRESP", 
                                                            "DFHVALUE", 
                                                            "DISABLE", "DISK", 
                                                            "DISPLAY", "DISPLAY_1", 
                                                            "DIVIDE", "DIVISION", 
                                                            "DONTCARE", 
                                                            "DOUBLE", "DOWN", 
                                                            "DUPLICATES", 
                                                            "DYNAMIC", "EBCDIC", 
                                                            "EGCS", "EGI", 
                                                            "ELSE", "EMI", 
                                                            "EMPTY_CHECK", 
                                                            "ENABLE", "END", 
                                                            "END_ACCEPT", 
                                                            "END_ADD", "END_CALL", 
                                                            "END_COMPUTE", 
                                                            "END_DELETE", 
                                                            "END_DIVIDE", 
                                                            "END_EVALUATE", 
                                                            "END_IF", "END_MULTIPLY", 
                                                            "END_OF_PAGE", 
                                                            "END_PERFORM", 
                                                            "END_READ", 
                                                            "END_RECEIVE", 
                                                            "END_RETURN", 
                                                            "END_REWRITE", 
                                                            "END_SEARCH", 
                                                            "END_START", 
                                                            "END_STRING", 
                                                            "END_SUBTRACT", 
                                                            "END_UNSTRING", 
                                                            "END_WRITE", 
                                                            "ENDING", "ENTER", 
                                                            "ENTRY", "ENTRY_PROCEDURE", 
                                                            "ENVIRONMENT", 
                                                            "EOP", "EQUAL", 
                                                            "ERASE", "ERROR", 
                                                            "EOL", "EOS", 
                                                            "ESCAPE", "ESI", 
                                                            "EVALUATE", 
                                                            "EVENT", "EVERY", 
                                                            "EXCEPTION", 
                                                            "EXCLUSIVE", 
                                                            "EXHIBIT", "EXIT", 
                                                            "EXPORT", "EXTEND", 
                                                            "EXTENDED", 
                                                            "EXTERNAL", 
                                                            "FALSE", "FD", 
                                                            "FILE", "FILE_CONTROL", 
                                                            "FILLER", "FINAL", 
                                                            "FIRST", "FOOTING", 
                                                            "FOR", "FOREGROUND_COLOR", 
                                                            "FOREGROUND_COLOUR", 
                                                            "FROM", "FULL", 
                                                            "FUNCTION", 
                                                            "FUNCTIONNAME", 
                                                            "FUNCTION_POINTER", 
                                                            "GENERATE", 
                                                            "GOBACK", "GIVING", 
                                                            "GLOBAL", "GO", 
                                                            "GREATER", "GRID", 
                                                            "GROUP", "HEADING", 
                                                            "HIGHLIGHT", 
                                                            "HIGH_VALUE", 
                                                            "HIGH_VALUES", 
                                                            "I_O", "I_O_CONTROL", 
                                                            "ID", "IDENTIFICATION", 
                                                            "IF", "IMPLICIT", 
                                                            "IMPORT", "IN", 
                                                            "INDEX", "INDEXED", 
                                                            "INDICATE", 
                                                            "INITIAL", "INITIALIZE", 
                                                            "INITIATE", 
                                                            "INPUT", "INPUT_OUTPUT", 
                                                            "INSPECT", "INSTALLATION", 
                                                            "INTEGER", "INTO", 
                                                            "INVALID", "INVOKE", 
                                                            "IS", "JUST", 
                                                            "JUSTIFIED", 
                                                            "KANJI", "KEPT", 
                                                            "KEY", "KEYBOARD", 
                                                            "LABEL", "LANGUAGE", 
                                                            "LAST", "LB", 
                                                            "LD", "LEADING", 
                                                            "LEFT", "LEFTLINE", 
                                                            "LENGTH", "LENGTH_CHECK", 
                                                            "LESS", "LIBACCESS", 
                                                            "LIBPARAMETER", 
                                                            "LIBRARY", "LIMIT", 
                                                            "LIMITS", "LINAGE", 
                                                            "LINAGE_COUNTER", 
                                                            "LINE", "LINES", 
                                                            "LINE_COUNTER", 
                                                            "LINKAGE", "LIST", 
                                                            "LOCAL", "LOCAL_STORAGE", 
                                                            "LOCK", "LONG_DATE", 
                                                            "LONG_TIME", 
                                                            "LOWER", "LOWLIGHT", 
                                                            "LOW_VALUE", 
                                                            "LOW_VALUES", 
                                                            "MEMORY", "MERGE", 
                                                            "MESSAGE", "MMDDYYYY", 
                                                            "MODE", "MODULES", 
                                                            "MORE_LABELS", 
                                                            "MOVE", "MULTIPLE", 
                                                            "MULTIPLY", 
                                                            "NAMED", "NATIONAL", 
                                                            "NATIONAL_EDITED", 
                                                            "NATIVE", "NEGATIVE", 
                                                            "NETWORK", "NEXT", 
                                                            "NO", "NO_ECHO", 
                                                            "NOT", "NULL", 
                                                            "NULLS", "NUMBER", 
                                                            "NUMERIC", "NUMERIC_DATE", 
                                                            "NUMERIC_EDITED", 
                                                            "NUMERIC_TIME", 
                                                            "OBJECT_COMPUTER", 
                                                            "OCCURS", "ODT", 
                                                            "OF", "OFF", 
                                                            "OMITTED", "ON", 
                                                            "OPEN", "OPTIONAL", 
                                                            "OR", "ORDER", 
                                                            "ORDERLY", "ORGANIZATION", 
                                                            "OTHER", "OUTPUT", 
                                                            "OVERFLOW", 
                                                            "OVERLINE", 
                                                            "OWN", "PACKED_DECIMAL", 
                                                            "PADDING", "PAGE", 
                                                            "PAGE_COUNTER", 
                                                            "PASSWORD", 
                                                            "PERFORM", "PF", 
                                                            "PH", "PIC", 
                                                            "PICTURE", "PLUS", 
                                                            "POINTER", "POSITION", 
                                                            "POSITIVE", 
                                                            "PORT", "PRINTER", 
                                                            "PRINTING", 
                                                            "PRIVATE", "PROCEDURE", 
                                                            "PROCEDURE_POINTER", 
                                                            "PROCEDURES", 
                                                            "PROCEED", "PROCESS", 
                                                            "PROGRAM", "PROGRAM_ID", 
                                                            "PROGRAM_LIBRARY", 
                                                            "PROMPT", "PURGE", 
                                                            "QUEUE", "QUOTE", 
                                                            "QUOTES", "RANDOM", 
                                                            "READER", "REMOTE", 
                                                            "RD", "REAL", 
                                                            "READ", "RECEIVE", 
                                                            "RECEIVED", 
                                                            "RECORD", "RECORDING", 
                                                            "RECORDS", "RECURSIVE", 
                                                            "REDEFINES", 
                                                            "REEL", "REF", 
                                                            "REFERENCE", 
                                                            "REFERENCES", 
                                                            "RELATIVE", 
                                                            "RELEASE", "REMAINDER", 
                                                            "REMARKS", "REMOVAL", 
                                                            "REMOVE", "RENAMES", 
                                                            "REPLACE", "REPLACING", 
                                                            "REPORT", "REPORTING", 
                                                            "REPORTS", "REQUIRED", 
                                                            "RERUN", "RESERVE", 
                                                            "REVERSE_VIDEO", 
                                                            "RESET", "RETURN", 
                                                            "RETURN_CODE", 
                                                            "RETURNING", 
                                                            "REVERSED", 
                                                            "REWIND", "REWRITE", 
                                                            "RF", "RH", 
                                                            "RIGHT", "ROUNDED", 
                                                            "RUN", "SAME", 
                                                            "SAVE", "SCREEN", 
                                                            "SD", "SEARCH", 
                                                            "SECTION", "SECURE", 
                                                            "SECURITY", 
                                                            "SEGMENT", "SEGMENT_LIMIT", 
                                                            "SELECT", "SEND", 
                                                            "SENTENCE", 
                                                            "SEPARATE", 
                                                            "SEQUENCE", 
                                                            "SEQUENTIAL", 
                                                            "SET", "SHARED", 
                                                            "SHAREDBYALL", 
                                                            "SHAREDBYRUNUNIT", 
                                                            "SHARING", "SHIFT_IN", 
                                                            "SHIFT_OUT", 
                                                            "SHORT_DATE", 
                                                            "SIGN", "SIZE", 
                                                            "SORT", "SORT_CONTROL", 
                                                            "SORT_CORE_SIZE", 
                                                            "SORT_FILE_SIZE", 
                                                            "SORT_MERGE", 
                                                            "SORT_MESSAGE", 
                                                            "SORT_MODE_SIZE", 
                                                            "SORT_RETURN", 
                                                            "SOURCE", "SOURCE_COMPUTER", 
                                                            "SPACE", "SPACES", 
                                                            "SPECIAL_NAMES", 
                                                            "STANDARD", 
                                                            "STANDARD_1", 
                                                            "STANDARD_2", 
                                                            "START", "STATUS", 
                                                            "STOP", "STRING", 
                                                            "SUB_QUEUE_1", 
                                                            "SUB_QUEUE_2", 
                                                            "SUB_QUEUE_3", 
                                                            "SUBTRACT", 
                                                            "SUM", "SUPPRESS", 
                                                            "SYMBOL", "SYMBOLIC", 
                                                            "SYNC", "SYNCHRONIZED", 
                                                            "TABLE", "TALLY", 
                                                            "TALLYING", 
                                                            "TASK", "TAPE", 
                                                            "TERMINAL", 
                                                            "TERMINATE", 
                                                            "TEST", "TEXT", 
                                                            "THAN", "THEN", 
                                                            "THREAD", "THREAD_LOCAL", 
                                                            "THROUGH", "THRU", 
                                                            "TIME", "TIMER", 
                                                            "TIMES", "TITLE", 
                                                            "TO", "TODAYS_DATE", 
                                                            "TODAYS_NAME", 
                                                            "TOP", "TRAILING", 
                                                            "TRUE", "TRUNCATED", 
                                                            "TYPE", "TYPEDEF", 
                                                            "UNDERLINE", 
                                                            "UNIT", "UNSTRING", 
                                                            "UNTIL", "UP", 
                                                            "UPON", "USAGE", 
                                                            "USE", "USING", 
                                                            "VALUE", "VALUES", 
                                                            "VARYING", "VIRTUAL", 
                                                            "WAIT", "WHEN", 
                                                            "WHEN_COMPILED", 
                                                            "WITH", "WORDS", 
                                                            "WORKING_STORAGE", 
                                                            "WRITE", "YEAR", 
                                                            "YYYYMMDD", 
                                                            "YYYYDDD", "ZERO", 
                                                            "ZERO_FILL", 
                                                            "ZEROS", "ZEROES", 
                                                            "AMPCHAR", "ASTERISKCHAR", 
                                                            "DOUBLEASTERISKCHAR", 
                                                            "COLONCHAR", 
                                                            "COMMACHAR", 
                                                            "COMMENTENTRYTAG", 
                                                            "COMMENTTAG", 
                                                            "DOLLARCHAR", 
                                                            "DOUBLEQUOTE", 
                                                            "DOT_FS", "DOT", 
                                                            "EQUALCHAR", 
                                                            "EXECCICSTAG", 
                                                            "EXECSQLTAG", 
                                                            "EXECSQLIMSTAG", 
                                                            "LESSTHANCHAR", 
                                                            "LESSTHANOREQUAL", 
                                                            "LPARENCHAR", 
                                                            "MINUSCHAR", 
                                                            "MORETHANCHAR", 
                                                            "MORETHANOREQUAL", 
                                                            "NOTEQUALCHAR", 
                                                            "PLUSCHAR", 
                                                            "SINGLEQUOTE", 
                                                            "RPARENCHAR", 
                                                            "SLASHCHAR", 
                                                            "NONNUMERICLITERAL", 
                                                            "LEVEL_NUMBER_66", 
                                                            "LEVEL_NUMBER_77", 
                                                            "LEVEL_NUMBER_88", 
                                                            "INTEGERLITERAL", 
                                                            "NUMERICLITERAL", 
                                                            "IDENTIFIER", 
                                                            "NEWLINE", "EXECCICSLINE", 
                                                            "EXECSQLIMSLINE", 
                                                            "EXECSQLLINE", 
                                                            "COMMENTENTRYLINE", 
                                                            "COMMENTLINE", 
                                                            "WS", "SEPARATOR")

        val VOCABULARY = VocabularyImpl(LITERAL_NAMES.toTypedArray(), SYMBOLIC_NAMES.toTypedArray())

        val tokenNames: Array<String?> = Array<String?>(SYMBOLIC_NAMES.size) {
            var el = VOCABULARY.getLiteralName(it)
            if (el == null) {
                el = VOCABULARY.getSymbolicName(it)
            }

            if (el == null) {
                el = "<INVALID>"
            }
            el
        }

        private const val serializedATNSegment0 : String =
        	"\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\u0003\u0237\u1892\u0004\u0002\u0009\u0002\u0004\u0003\u0009\u0003\u0004\u0004\u0009\u0004\u0004\u0005\u0009\u0005\u0004\u0006\u0009\u0006\u0004\u0007\u0009\u0007\u0004\u0008\u0009\u0008\u0004\u0009\u0009\u0009\u0004\u000a\u0009\u000a\u0004\u000b\u0009\u000b\u0004\u000c\u0009\u000c\u0004\u000d\u0009\u000d\u0004\u000e\u0009\u000e\u0004\u000f\u0009\u000f\u0004\u0010\u0009\u0010\u0004\u0011\u0009\u0011\u0004\u0012\u0009\u0012\u0004\u0013\u0009\u0013\u0004\u0014\u0009\u0014\u0004\u0015\u0009\u0015\u0004\u0016\u0009\u0016\u0004\u0017\u0009\u0017\u0004\u0018\u0009\u0018\u0004\u0019\u0009\u0019\u0004\u001a\u0009\u001a\u0004\u001b\u0009\u001b\u0004\u001c\u0009\u001c\u0004\u001d\u0009\u001d\u0004\u001e\u0009\u001e\u0004\u001f\u0009\u001f\u0004\u0020\u0009\u0020\u0004\u0021\u0009\u0021\u0004\u0022\u0009\u0022\u0004\u0023\u0009\u0023\u0004\u0024\u0009\u0024\u0004\u0025\u0009\u0025\u0004\u0026\u0009\u0026\u0004\u0027\u0009\u0027\u0004\u0028\u0009\u0028\u0004\u0029\u0009\u0029\u0004\u002a\u0009\u002a\u0004\u002b\u0009\u002b\u0004\u002c\u0009\u002c\u0004\u002d\u0009\u002d\u0004\u002e\u0009\u002e\u0004\u002f\u0009\u002f\u0004\u0030\u0009\u0030\u0004\u0031\u0009\u0031\u0004\u0032\u0009\u0032\u0004\u0033\u0009\u0033\u0004\u0034\u0009\u0034\u0004\u0035\u0009\u0035\u0004\u0036\u0009\u0036\u0004\u0037\u0009\u0037\u0004\u0038\u0009\u0038\u0004\u0039\u0009\u0039\u0004\u003a\u0009\u003a\u0004\u003b\u0009\u003b\u0004\u003c\u0009\u003c\u0004\u003d\u0009\u003d\u0004\u003e\u0009\u003e\u0004\u003f\u0009\u003f\u0004\u0040\u0009\u0040\u0004\u0041\u0009\u0041\u0004\u0042\u0009\u0042\u0004\u0043\u0009\u0043\u0004\u0044\u0009\u0044\u0004\u0045\u0009\u0045\u0004\u0046\u0009\u0046\u0004\u0047\u0009\u0047\u0004\u0048\u0009\u0048\u0004\u0049\u0009\u0049\u0004\u004a\u0009\u004a\u0004\u004b\u0009\u004b\u0004\u004c\u0009\u004c\u0004\u004d\u0009\u004d\u0004\u004e\u0009\u004e\u0004\u004f\u0009\u004f\u0004\u0050\u0009\u0050\u0004\u0051\u0009\u0051\u0004\u0052\u0009\u0052\u0004\u0053\u0009\u0053\u0004\u0054\u0009\u0054\u0004\u0055\u0009\u0055\u0004\u0056\u0009\u0056\u0004\u0057\u0009\u0057\u0004\u0058\u0009\u0058\u0004\u0059\u0009\u0059\u0004\u005a\u0009\u005a\u0004\u005b\u0009\u005b\u0004\u005c\u0009\u005c\u0004\u005d\u0009\u005d\u0004\u005e\u0009\u005e\u0004\u005f\u0009\u005f\u0004\u0060\u0009\u0060\u0004\u0061\u0009\u0061\u0004\u0062\u0009\u0062\u0004\u0063\u0009\u0063\u0004\u0064\u0009\u0064\u0004\u0065\u0009\u0065\u0004\u0066\u0009\u0066\u0004\u0067\u0009\u0067\u0004\u0068\u0009\u0068\u0004\u0069\u0009\u0069\u0004\u006a\u0009\u006a\u0004\u006b\u0009\u006b\u0004\u006c\u0009\u006c\u0004\u006d\u0009\u006d\u0004\u006e\u0009\u006e\u0004\u006f\u0009\u006f\u0004\u0070\u0009\u0070\u0004\u0071\u0009\u0071\u0004\u0072\u0009\u0072\u0004\u0073\u0009\u0073\u0004\u0074\u0009\u0074\u0004\u0075\u0009\u0075\u0004\u0076\u0009\u0076\u0004\u0077\u0009\u0077\u0004\u0078\u0009\u0078\u0004\u0079\u0009\u0079\u0004\u007a\u0009\u007a\u0004\u007b\u0009\u007b\u0004\u007c\u0009\u007c\u0004\u007d\u0009\u007d\u0004\u007e\u0009\u007e\u0004\u007f\u0009\u007f\u0004\u0080\u0009\u0080\u0004\u0081\u0009\u0081\u0004\u0082\u0009\u0082\u0004\u0083\u0009\u0083\u0004\u0084\u0009\u0084\u0004\u0085\u0009\u0085\u0004\u0086\u0009\u0086\u0004\u0087\u0009\u0087\u0004\u0088\u0009\u0088\u0004\u0089\u0009\u0089\u0004\u008a\u0009\u008a\u0004\u008b\u0009\u008b\u0004\u008c\u0009\u008c\u0004\u008d\u0009\u008d\u0004\u008e\u0009\u008e\u0004\u008f\u0009\u008f\u0004\u0090\u0009\u0090\u0004\u0091\u0009\u0091\u0004\u0092\u0009\u0092\u0004\u0093\u0009\u0093\u0004\u0094\u0009\u0094\u0004\u0095\u0009\u0095\u0004\u0096\u0009\u0096\u0004\u0097\u0009\u0097\u0004\u0098\u0009\u0098\u0004\u0099\u0009\u0099\u0004\u009a\u0009\u009a\u0004\u009b\u0009\u009b\u0004\u009c\u0009\u009c\u0004\u009d\u0009\u009d\u0004\u009e\u0009\u009e\u0004\u009f\u0009\u009f\u0004\u00a0\u0009\u00a0\u0004\u00a1\u0009\u00a1\u0004\u00a2\u0009\u00a2\u0004\u00a3\u0009\u00a3\u0004\u00a4\u0009\u00a4\u0004\u00a5\u0009\u00a5\u0004\u00a6\u0009\u00a6\u0004\u00a7\u0009\u00a7\u0004\u00a8\u0009\u00a8\u0004\u00a9\u0009\u00a9\u0004\u00aa\u0009\u00aa\u0004\u00ab\u0009\u00ab\u0004\u00ac\u0009\u00ac\u0004\u00ad\u0009\u00ad\u0004\u00ae\u0009\u00ae\u0004\u00af\u0009\u00af\u0004\u00b0\u0009\u00b0\u0004\u00b1\u0009\u00b1\u0004\u00b2\u0009\u00b2\u0004\u00b3\u0009\u00b3\u0004\u00b4\u0009\u00b4\u0004\u00b5\u0009\u00b5\u0004\u00b6\u0009\u00b6\u0004\u00b7\u0009\u00b7\u0004\u00b8\u0009\u00b8\u0004\u00b9\u0009\u00b9\u0004\u00ba\u0009\u00ba\u0004\u00bb\u0009\u00bb\u0004\u00bc\u0009\u00bc\u0004\u00bd\u0009\u00bd\u0004\u00be\u0009\u00be\u0004\u00bf\u0009\u00bf\u0004\u00c0\u0009\u00c0\u0004\u00c1\u0009\u00c1\u0004\u00c2\u0009\u00c2\u0004\u00c3\u0009\u00c3\u0004\u00c4\u0009\u00c4\u0004\u00c5\u0009\u00c5\u0004\u00c6\u0009\u00c6\u0004\u00c7\u0009\u00c7\u0004\u00c8\u0009\u00c8\u0004\u00c9\u0009\u00c9\u0004\u00ca\u0009\u00ca\u0004\u00cb\u0009\u00cb\u0004\u00cc\u0009\u00cc\u0004\u00cd\u0009\u00cd\u0004\u00ce\u0009\u00ce\u0004\u00cf\u0009\u00cf\u0004\u00d0\u0009\u00d0\u0004\u00d1\u0009\u00d1\u0004\u00d2\u0009\u00d2\u0004\u00d3\u0009\u00d3\u0004\u00d4\u0009\u00d4\u0004\u00d5\u0009\u00d5\u0004\u00d6\u0009\u00d6\u0004\u00d7\u0009\u00d7\u0004\u00d8\u0009\u00d8\u0004\u00d9\u0009\u00d9\u0004\u00da\u0009\u00da\u0004\u00db\u0009\u00db\u0004\u00dc\u0009\u00dc\u0004\u00dd\u0009\u00dd\u0004\u00de\u0009\u00de\u0004\u00df\u0009\u00df\u0004\u00e0\u0009\u00e0\u0004\u00e1\u0009\u00e1\u0004\u00e2\u0009\u00e2\u0004\u00e3\u0009\u00e3\u0004\u00e4\u0009\u00e4\u0004\u00e5\u0009\u00e5\u0004\u00e6\u0009\u00e6\u0004\u00e7\u0009\u00e7\u0004\u00e8\u0009\u00e8\u0004\u00e9\u0009\u00e9\u0004\u00ea\u0009\u00ea\u0004\u00eb\u0009\u00eb\u0004\u00ec\u0009\u00ec\u0004\u00ed\u0009\u00ed\u0004\u00ee\u0009\u00ee\u0004\u00ef\u0009\u00ef\u0004\u00f0\u0009\u00f0\u0004\u00f1\u0009\u00f1\u0004\u00f2\u0009\u00f2\u0004\u00f3\u0009\u00f3\u0004\u00f4\u0009\u00f4\u0004\u00f5\u0009\u00f5\u0004\u00f6\u0009\u00f6\u0004\u00f7\u0009\u00f7\u0004\u00f8\u0009\u00f8\u0004\u00f9\u0009\u00f9\u0004\u00fa\u0009\u00fa\u0004\u00fb\u0009\u00fb\u0004\u00fc\u0009\u00fc\u0004\u00fd\u0009\u00fd\u0004\u00fe\u0009\u00fe\u0004\u00ff\u0009\u00ff\u0004\u0100\u0009\u0100\u0004\u0101\u0009\u0101\u0004\u0102\u0009\u0102\u0004\u0103\u0009\u0103\u0004\u0104\u0009\u0104\u0004\u0105\u0009\u0105\u0004\u0106\u0009\u0106\u0004\u0107\u0009\u0107\u0004\u0108\u0009\u0108\u0004\u0109\u0009\u0109\u0004\u010a\u0009\u010a\u0004\u010b\u0009\u010b\u0004\u010c\u0009\u010c\u0004\u010d\u0009\u010d\u0004\u010e\u0009\u010e\u0004\u010f\u0009\u010f\u0004\u0110\u0009\u0110\u0004\u0111\u0009\u0111\u0004\u0112\u0009\u0112\u0004\u0113\u0009\u0113\u0004\u0114\u0009\u0114\u0004\u0115\u0009\u0115\u0004\u0116\u0009\u0116\u0004\u0117\u0009\u0117\u0004\u0118\u0009\u0118\u0004\u0119\u0009\u0119\u0004\u011a\u0009\u011a\u0004\u011b\u0009\u011b\u0004\u011c\u0009\u011c\u0004\u011d\u0009\u011d\u0004\u011e\u0009\u011e\u0004\u011f\u0009\u011f\u0004\u0120\u0009\u0120\u0004\u0121\u0009\u0121\u0004\u0122\u0009\u0122\u0004\u0123\u0009\u0123\u0004\u0124\u0009\u0124\u0004\u0125\u0009\u0125\u0004\u0126\u0009\u0126\u0004\u0127\u0009\u0127\u0004\u0128\u0009\u0128\u0004\u0129\u0009\u0129\u0004\u012a\u0009\u012a\u0004\u012b\u0009\u012b\u0004\u012c\u0009\u012c\u0004\u012d\u0009\u012d\u0004\u012e\u0009\u012e\u0004\u012f\u0009\u012f\u0004\u0130\u0009\u0130\u0004\u0131\u0009\u0131\u0004\u0132\u0009\u0132\u0004\u0133\u0009\u0133\u0004\u0134\u0009\u0134\u0004\u0135\u0009\u0135\u0004\u0136\u0009\u0136\u0004\u0137\u0009\u0137\u0004\u0138\u0009\u0138\u0004\u0139\u0009\u0139\u0004\u013a\u0009\u013a\u0004\u013b\u0009\u013b\u0004\u013c\u0009\u013c\u0004\u013d\u0009\u013d\u0004\u013e\u0009\u013e\u0004\u013f\u0009\u013f\u0004\u0140\u0009\u0140\u0004\u0141\u0009\u0141\u0004\u0142\u0009\u0142\u0004\u0143\u0009\u0143\u0004\u0144\u0009\u0144\u0004\u0145\u0009\u0145\u0004\u0146\u0009\u0146\u0004\u0147\u0009\u0147\u0004\u0148\u0009\u0148\u0004\u0149\u0009\u0149\u0004\u014a\u0009\u014a\u0004\u014b\u0009\u014b\u0004\u014c\u0009\u014c\u0004\u014d\u0009\u014d\u0004\u014e\u0009\u014e\u0004\u014f\u0009\u014f\u0004\u0150\u0009\u0150\u0004\u0151\u0009\u0151\u0004\u0152\u0009\u0152\u0004\u0153\u0009\u0153\u0004\u0154\u0009\u0154\u0004\u0155\u0009\u0155\u0004\u0156\u0009\u0156\u0004\u0157\u0009\u0157\u0004\u0158\u0009\u0158\u0004\u0159\u0009\u0159\u0004\u015a\u0009\u015a\u0004\u015b\u0009\u015b\u0004\u015c\u0009\u015c\u0004\u015d\u0009\u015d\u0004\u015e\u0009\u015e\u0004\u015f\u0009\u015f\u0004\u0160\u0009\u0160\u0004\u0161\u0009\u0161\u0004\u0162\u0009\u0162\u0004\u0163\u0009\u0163\u0004\u0164\u0009\u0164\u0004\u0165\u0009\u0165\u0004\u0166\u0009\u0166\u0004\u0167\u0009\u0167\u0004\u0168\u0009\u0168\u0004\u0169\u0009\u0169\u0004\u016a\u0009\u016a\u0004\u016b\u0009\u016b\u0004\u016c\u0009\u016c\u0004\u016d\u0009\u016d\u0004\u016e\u0009\u016e\u0004\u016f\u0009\u016f\u0004\u0170\u0009\u0170\u0004\u0171\u0009\u0171\u0004\u0172\u0009\u0172\u0004\u0173\u0009\u0173\u0004\u0174\u0009\u0174\u0004\u0175\u0009\u0175\u0004\u0176\u0009\u0176\u0004\u0177\u0009\u0177\u0004\u0178\u0009\u0178\u0004\u0179\u0009\u0179\u0004\u017a\u0009\u017a\u0004\u017b\u0009\u017b\u0004\u017c\u0009\u017c\u0004\u017d\u0009\u017d\u0004\u017e\u0009\u017e\u0004\u017f\u0009\u017f\u0004\u0180\u0009\u0180\u0004\u0181\u0009\u0181\u0004\u0182\u0009\u0182\u0004\u0183\u0009\u0183\u0004\u0184\u0009\u0184\u0004\u0185\u0009\u0185\u0004\u0186\u0009\u0186\u0004\u0187\u0009\u0187\u0004\u0188\u0009\u0188\u0004\u0189\u0009\u0189\u0004\u018a\u0009\u018a\u0004\u018b\u0009\u018b\u0004\u018c\u0009\u018c\u0004\u018d\u0009\u018d\u0004\u018e\u0009\u018e\u0004\u018f\u0009\u018f\u0004\u0190\u0009\u0190\u0004\u0191\u0009\u0191\u0004\u0192\u0009\u0192\u0004\u0193\u0009\u0193\u0004\u0194\u0009\u0194\u0004\u0195\u0009\u0195\u0004\u0196\u0009\u0196\u0004\u0197\u0009\u0197\u0004\u0198\u0009\u0198\u0004\u0199\u0009\u0199\u0004\u019a\u0009\u019a\u0004\u019b\u0009\u019b\u0004\u019c\u0009\u019c\u0004\u019d\u0009\u019d\u0004\u019e\u0009\u019e\u0004\u019f\u0009\u019f\u0004\u01a0\u0009\u01a0\u0004\u01a1\u0009\u01a1\u0004\u01a2\u0009\u01a2\u0004\u01a3\u0009\u01a3\u0004\u01a4\u0009\u01a4\u0004\u01a5\u0009\u01a5\u0004\u01a6\u0009\u01a6\u0004\u01a7\u0009\u01a7\u0004\u01a8\u0009\u01a8\u0004\u01a9\u0009\u01a9\u0004\u01aa\u0009\u01aa\u0004\u01ab\u0009\u01ab\u0004\u01ac\u0009\u01ac\u0004\u01ad\u0009\u01ad\u0004\u01ae\u0009\u01ae\u0004\u01af\u0009\u01af\u0004\u01b0\u0009\u01b0\u0004\u01b1\u0009\u01b1\u0004\u01b2\u0009\u01b2\u0004\u01b3\u0009\u01b3\u0004\u01b4\u0009\u01b4\u0004\u01b5\u0009\u01b5\u0004\u01b6\u0009\u01b6\u0004\u01b7\u0009\u01b7\u0004\u01b8\u0009\u01b8\u0004\u01b9\u0009\u01b9\u0004\u01ba\u0009\u01ba\u0004\u01bb\u0009\u01bb\u0004\u01bc\u0009\u01bc\u0004\u01bd\u0009\u01bd\u0004\u01be\u0009\u01be\u0004\u01bf\u0009\u01bf\u0004\u01c0\u0009\u01c0\u0004\u01c1\u0009\u01c1\u0004\u01c2\u0009\u01c2\u0004\u01c3\u0009\u01c3\u0004\u01c4\u0009\u01c4\u0004\u01c5\u0009\u01c5\u0004\u01c6\u0009\u01c6\u0004\u01c7\u0009\u01c7\u0004\u01c8\u0009\u01c8\u0004\u01c9\u0009\u01c9\u0004\u01ca\u0009\u01ca\u0004\u01cb\u0009\u01cb\u0004\u01cc\u0009\u01cc\u0004\u01cd\u0009\u01cd\u0004\u01ce\u0009\u01ce\u0004\u01cf\u0009\u01cf\u0004\u01d0\u0009\u01d0\u0004\u01d1\u0009\u01d1\u0004\u01d2\u0009\u01d2\u0004\u01d3\u0009\u01d3\u0004\u01d4\u0009\u01d4\u0004\u01d5\u0009\u01d5\u0004\u01d6\u0009\u01d6\u0004\u01d7\u0009\u01d7\u0004\u01d8\u0009\u01d8\u0004\u01d9\u0009\u01d9\u0004\u01da\u0009\u01da\u0004\u01db\u0009\u01db\u0004\u01dc\u0009\u01dc\u0004\u01dd\u0009\u01dd\u0004\u01de\u0009\u01de\u0004\u01df\u0009\u01df\u0004\u01e0\u0009\u01e0\u0004\u01e1\u0009\u01e1\u0004\u01e2\u0009\u01e2\u0004\u01e3\u0009\u01e3\u0004\u01e4\u0009\u01e4\u0004\u01e5\u0009\u01e5\u0004\u01e6\u0009\u01e6\u0004\u01e7\u0009\u01e7\u0004\u01e8\u0009\u01e8\u0004\u01e9\u0009\u01e9\u0004\u01ea\u0009\u01ea\u0004\u01eb\u0009\u01eb\u0004\u01ec\u0009\u01ec\u0004\u01ed\u0009\u01ed\u0004\u01ee\u0009\u01ee\u0004\u01ef\u0009\u01ef\u0004\u01f0\u0009\u01f0\u0004\u01f1\u0009\u01f1\u0004\u01f2\u0009\u01f2\u0004\u01f3\u0009\u01f3\u0004\u01f4\u0009\u01f4\u0004\u01f5\u0009\u01f5\u0004\u01f6\u0009\u01f6\u0004\u01f7\u0009\u01f7\u0004\u01f8\u0009\u01f8\u0004\u01f9\u0009\u01f9\u0004\u01fa\u0009\u01fa\u0004\u01fb\u0009\u01fb\u0004\u01fc\u0009\u01fc\u0004\u01fd\u0009\u01fd\u0004\u01fe\u0009\u01fe\u0004\u01ff\u0009\u01ff\u0004\u0200\u0009\u0200\u0004\u0201\u0009\u0201\u0004\u0202\u0009\u0202\u0004\u0203\u0009\u0203\u0004\u0204\u0009\u0204\u0004\u0205\u0009\u0205\u0004\u0206\u0009\u0206\u0004\u0207\u0009\u0207\u0004\u0208\u0009\u0208\u0004\u0209\u0009\u0209\u0004\u020a\u0009\u020a\u0004\u020b\u0009\u020b\u0004\u020c\u0009\u020c\u0004\u020d\u0009\u020d\u0004\u020e\u0009\u020e\u0004\u020f\u0009\u020f\u0004\u0210\u0009\u0210\u0004\u0211\u0009\u0211\u0004\u0212\u0009\u0212\u0004\u0213\u0009\u0213\u0004\u0214\u0009\u0214\u0004\u0215\u0009\u0215\u0004\u0216\u0009\u0216\u0004\u0217\u0009\u0217\u0004\u0218\u0009\u0218\u0004\u0219\u0009\u0219\u0004\u021a\u0009\u021a\u0004\u021b\u0009\u021b\u0004\u021c\u0009\u021c\u0004\u021d\u0009\u021d\u0004\u021e\u0009\u021e\u0004\u021f\u0009\u021f\u0004\u0220\u0009\u0220\u0004\u0221\u0009\u0221\u0004\u0222\u0009\u0222\u0004\u0223\u0009\u0223\u0004\u0224\u0009\u0224\u0004\u0225\u0009\u0225\u0004\u0226\u0009\u0226\u0004\u0227\u0009\u0227\u0004\u0228\u0009\u0228\u0004\u0229\u0009\u0229\u0004\u022a\u0009\u022a\u0004\u022b\u0009\u022b\u0004\u022c\u0009\u022c\u0004\u022d\u0009\u022d\u0004\u022e\u0009\u022e\u0004\u022f\u0009\u022f\u0004\u0230\u0009\u0230\u0004\u0231\u0009\u0231\u0004\u0232\u0009\u0232\u0004\u0233\u0009\u0233\u0004\u0234\u0009\u0234\u0004\u0235\u0009\u0235\u0004\u0236\u0009\u0236\u0004\u0237\u0009\u0237\u0004\u0238\u0009\u0238\u0004\u0239\u0009\u0239\u0004\u023a\u0009\u023a\u0004\u023b\u0009\u023b\u0004\u023c\u0009\u023c\u0004\u023d\u0009\u023d\u0004\u023e\u0009\u023e\u0004\u023f\u0009\u023f\u0004\u0240\u0009\u0240\u0004\u0241\u0009\u0241\u0004\u0242\u0009\u0242\u0004\u0243\u0009\u0243\u0004\u0244\u0009\u0244\u0004\u0245\u0009\u0245\u0004\u0246\u0009\u0246\u0004\u0247\u0009\u0247\u0004\u0248\u0009\u0248\u0004\u0249\u0009\u0249\u0004\u024a\u0009\u024a\u0004\u024b\u0009\u024b\u0004\u024c\u0009\u024c\u0004\u024d\u0009\u024d\u0004\u024e\u0009\u024e\u0004\u024f\u0009\u024f\u0004\u0250\u0009\u0250\u0004\u0251\u0009\u0251\u0004\u0252\u0009\u0252\u0004\u0253\u0009\u0253\u0004\u0254\u0009\u0254\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0003\u0006\u0003\u04ad\u000a\u0003\u000d\u0003\u000e\u0003\u04ae\u0003\u0004\u0003\u0004\u0005\u0004\u04b3\u000a\u0004\u0003\u0004\u0005\u0004\u04b6\u000a\u0004\u0003\u0004\u0005\u0004\u04b9\u000a\u0004\u0003\u0004\u0007\u0004\u04bc\u000a\u0004\u000c\u0004\u000e\u0004\u04bf\u000b\u0004\u0003\u0004\u0005\u0004\u04c2\u000a\u0004\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0003\u0006\u0007\u0006\u04ce\u000a\u0006\u000c\u0006\u000e\u0006\u04d1\u000b\u0006\u0003\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0003\u0007\u0005\u0007\u04d9\u000a\u0007\u0003\u0008\u0003\u0008\u0003\u0008\u0003\u0008\u0005\u0008\u04df\u000a\u0008\u0003\u0008\u0003\u0008\u0005\u0008\u04e3\u000a\u0008\u0005\u0008\u04e5\u000a\u0008\u0003\u0008\u0005\u0008\u04e8\u000a\u0008\u0003\u0008\u0005\u0008\u04eb\u000a\u0008\u0003\u0009\u0003\u0009\u0003\u0009\u0005\u0009\u04f0\u000a\u0009\u0003\u000a\u0003\u000a\u0003\u000a\u0005\u000a\u04f5\u000a\u000a\u0003\u000b\u0003\u000b\u0003\u000b\u0005\u000b\u04fa\u000a\u000b\u0003\u000c\u0003\u000c\u0003\u000c\u0005\u000c\u04ff\u000a\u000c\u0003\u000d\u0003\u000d\u0003\u000d\u0005\u000d\u0504\u000a\u000d\u0003\u000e\u0003\u000e\u0003\u000e\u0005\u000e\u0509\u000a\u000e\u0003\u000f\u0003\u000f\u0003\u000f\u0003\u000f\u0007\u000f\u050f\u000a\u000f\u000c\u000f\u000e\u000f\u0512\u000b\u000f\u0003\u0010\u0003\u0010\u0003\u0010\u0005\u0010\u0517\u000a\u0010\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0011\u0007\u0011\u051d\u000a\u0011\u000c\u0011\u000e\u0011\u0520\u000b\u0011\u0003\u0012\u0003\u0012\u0003\u0012\u0005\u0012\u0525\u000a\u0012\u0003\u0013\u0003\u0013\u0003\u0013\u0003\u0013\u0005\u0013\u052b\u000a\u0013\u0003\u0013\u0003\u0013\u0005\u0013\u052f\u000a\u0013\u0003\u0013\u0003\u0013\u0003\u0014\u0003\u0014\u0003\u0014\u0003\u0014\u0007\u0014\u0537\u000a\u0014\u000c\u0014\u000e\u0014\u053a\u000b\u0014\u0003\u0014\u0003\u0014\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0003\u0015\u0005\u0015\u0543\u000a\u0015\u0003\u0016\u0003\u0016\u0005\u0016\u0547\u000a\u0016\u0003\u0016\u0003\u0016\u0005\u0016\u054b\u000a\u0016\u0003\u0016\u0005\u0016\u054e\u000a\u0016\u0003\u0017\u0003\u0017\u0005\u0017\u0552\u000a\u0017\u0003\u0017\u0005\u0017\u0555\u000a\u0017\u0003\u0017\u0003\u0017\u0005\u0017\u0559\u000a\u0017\u0003\u0017\u0005\u0017\u055c\u000a\u0017\u0003\u0018\u0005\u0018\u055f\u000a\u0018\u0003\u0018\u0005\u0018\u0562\u000a\u0018\u0003\u0018\u0003\u0018\u0005\u0018\u0566\u000a\u0018\u0003\u0018\u0006\u0018\u0569\u000a\u0018\u000d\u0018\u000e\u0018\u056a\u0003\u0018\u0005\u0018\u056e\u000a\u0018\u0003\u0018\u0005\u0018\u0571\u000a\u0018\u0003\u0019\u0005\u0019\u0574\u000a\u0019\u0003\u0019\u0003\u0019\u0005\u0019\u0578\u000a\u0019\u0003\u0019\u0003\u0019\u0003\u001a\u0005\u001a\u057d\u000a\u001a\u0003\u001a\u0003\u001a\u0005\u001a\u0581\u000a\u001a\u0003\u001a\u0003\u001a\u0003\u001b\u0003\u001b\u0005\u001b\u0587\u000a\u001b\u0003\u001b\u0003\u001b\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001d\u0003\u001d\u0003\u001d\u0006\u001d\u0592\u000a\u001d\u000d\u001d\u000e\u001d\u0593\u0003\u001d\u0003\u001d\u0005\u001d\u0598\u000a\u001d\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0003\u001e\u0005\u001e\u05a5\u000a\u001e\u0003\u001f\u0003\u001f\u0005\u001f\u05a9\u000a\u001f\u0003\u0020\u0003\u0020\u0003\u0020\u0003\u0020\u0005\u0020\u05af\u000a\u0020\u0003\u0020\u0005\u0020\u05b2\u000a\u0020\u0003\u0020\u0003\u0020\u0003\u0020\u0003\u0020\u0003\u0020\u0003\u0020\u0003\u0020\u0006\u0020\u05bb\u000a\u0020\u000d\u0020\u000e\u0020\u05bc\u0005\u0020\u05bf\u000a\u0020\u0003\u0021\u0003\u0021\u0003\u0021\u0006\u0021\u05c4\u000a\u0021\u000d\u0021\u000e\u0021\u05c5\u0005\u0021\u05c8\u000a\u0021\u0003\u0022\u0003\u0022\u0003\u0022\u0003\u0023\u0003\u0023\u0006\u0023\u05cf\u000a\u0023\u000d\u0023\u000e\u0023\u05d0\u0003\u0024\u0003\u0024\u0003\u0024\u0005\u0024\u05d6\u000a\u0024\u0003\u0024\u0003\u0024\u0005\u0024\u05da\u000a\u0024\u0003\u0024\u0003\u0024\u0003\u0024\u0005\u0024\u05df\u000a\u0024\u0003\u0025\u0003\u0025\u0003\u0025\u0005\u0025\u05e4\u000a\u0025\u0003\u0025\u0003\u0025\u0003\u0026\u0003\u0026\u0003\u0026\u0005\u0026\u05eb\u000a\u0026\u0003\u0026\u0005\u0026\u05ee\u000a\u0026\u0003\u0026\u0005\u0026\u05f1\u000a\u0026\u0003\u0026\u0006\u0026\u05f4\u000a\u0026\u000d\u0026\u000e\u0026\u05f5\u0003\u0027\u0003\u0027\u0003\u0027\u0005\u0027\u05fb\u000a\u0027\u0003\u0028\u0003\u0028\u0005\u0028\u05ff\u000a\u0028\u0003\u0029\u0003\u0029\u0005\u0029\u0603\u000a\u0029\u0003\u002a\u0003\u002a\u0005\u002a\u0607\u000a\u002a\u0003\u002a\u0005\u002a\u060a\u000a\u002a\u0003\u002a\u0003\u002a\u0005\u002a\u060e\u000a\u002a\u0003\u002a\u0003\u002a\u0003\u002a\u0005\u002a\u0613\u000a\u002a\u0003\u002b\u0003\u002b\u0005\u002b\u0617\u000a\u002b\u0003\u002b\u0003\u002b\u0003\u002c\u0003\u002c\u0005\u002c\u061d\u000a\u002c\u0003\u002c\u0003\u002c\u0005\u002c\u0621\u000a\u002c\u0005\u002c\u0623\u000a\u002c\u0003\u002c\u0005\u002c\u0626\u000a\u002c\u0003\u002c\u0003\u002c\u0005\u002c\u062a\u000a\u002c\u0003\u002d\u0003\u002d\u0003\u002d\u0005\u002d\u062f\u000a\u002d\u0005\u002d\u0631\u000a\u002d\u0003\u002d\u0003\u002d\u0003\u002d\u0005\u002d\u0636\u000a\u002d\u0005\u002d\u0638\u000a\u002d\u0003\u002e\u0003\u002e\u0005\u002e\u063c\u000a\u002e\u0003\u002e\u0003\u002e\u0005\u002e\u0640\u000a\u002e\u0003\u002e\u0005\u002e\u0643\u000a\u002e\u0003\u002f\u0003\u002f\u0005\u002f\u0647\u000a\u002f\u0003\u002f\u0005\u002f\u064a\u000a\u002f\u0003\u002f\u0003\u002f\u0003\u002f\u0005\u002f\u064f\u000a\u002f\u0003\u002f\u0005\u002f\u0652\u000a\u002f\u0003\u002f\u0005\u002f\u0655\u000a\u002f\u0003\u002f\u0003\u002f\u0005\u002f\u0659\u000a\u002f\u0003\u002f\u0005\u002f\u065c\u000a\u002f\u0003\u002f\u0003\u002f\u0003\u002f\u0005\u002f\u0661\u000a\u002f\u0003\u002f\u0005\u002f\u0664\u000a\u002f\u0003\u002f\u0005\u002f\u0667\u000a\u002f\u0005\u002f\u0669\u000a\u002f\u0003\u0030\u0003\u0030\u0005\u0030\u066d\u000a\u0030\u0003\u0030\u0003\u0030\u0003\u0031\u0003\u0031\u0005\u0031\u0673\u000a\u0031\u0003\u0031\u0005\u0031\u0676\u000a\u0031\u0003\u0031\u0005\u0031\u0679\u000a\u0031\u0003\u0031\u0003\u0031\u0005\u0031\u067d\u000a\u0031\u0003\u0032\u0003\u0032\u0005\u0032\u0681\u000a\u0032\u0003\u0032\u0005\u0032\u0684\u000a\u0032\u0003\u0032\u0005\u0032\u0687\u000a\u0032\u0003\u0032\u0006\u0032\u068a\u000a\u0032\u000d\u0032\u000e\u0032\u068b\u0003\u0032\u0003\u0032\u0005\u0032\u0690\u000a\u0032\u0003\u0033\u0006\u0033\u0693\u000a\u0033\u000d\u0033\u000e\u0033\u0694\u0003\u0033\u0005\u0033\u0698\u000a\u0033\u0003\u0033\u0006\u0033\u069b\u000a\u0033\u000d\u0033\u000e\u0033\u069c\u0003\u0034\u0003\u0034\u0003\u0034\u0003\u0034\u0007\u0034\u06a3\u000a\u0034\u000c\u0034\u000e\u0034\u06a6\u000b\u0034\u0003\u0035\u0003\u0035\u0005\u0035\u06aa\u000a\u0035\u0003\u0036\u0003\u0036\u0005\u0036\u06ae\u000a\u0036\u0003\u0036\u0007\u0036\u06b1\u000a\u0036\u000c\u0036\u000e\u0036\u06b4\u000b\u0036\u0003\u0036\u0003\u0036\u0003\u0037\u0003\u0037\u0007\u0037\u06ba\u000a\u0037\u000c\u0037\u000e\u0037\u06bd\u000b\u0037\u0003\u0038\u0003\u0038\u0005\u0038\u06c1\u000a\u0038\u0003\u0038\u0003\u0038\u0003\u0039\u0003\u0039\u0003\u0039\u0003\u0039\u0003\u0039\u0003\u0039\u0003\u0039\u0003\u0039\u0003\u0039\u0003\u0039\u0003\u0039\u0005\u0039\u06d0\u000a\u0039\u0003\u003a\u0003\u003a\u0005\u003a\u06d4\u000a\u003a\u0003\u003a\u0003\u003a\u0003\u003a\u0003\u003a\u0003\u003a\u0003\u003a\u0003\u003a\u0003\u003a\u0003\u003a\u0003\u003a\u0003\u003a\u0005\u003a\u06e1\u000a\u003a\u0003\u003b\u0003\u003b\u0003\u003b\u0005\u003b\u06e6\u000a\u003b\u0003\u003b\u0005\u003b\u06e9\u000a\u003b\u0003\u003b\u0005\u003b\u06ec\u000a\u003b\u0003\u003c\u0003\u003c\u0005\u003c\u06f0\u000a\u003c\u0005\u003c\u06f2\u000a\u003c\u0003\u003c\u0003\u003c\u0003\u003c\u0003\u003c\u0003\u003c\u0005\u003c\u06f9\u000a\u003c\u0003\u003c\u0003\u003c\u0003\u003d\u0003\u003d\u0005\u003d\u06ff\u000a\u003d\u0003\u003d\u0005\u003d\u0702\u000a\u003d\u0003\u003d\u0003\u003d\u0005\u003d\u0706\u000a\u003d\u0003\u003e\u0003\u003e\u0003\u003e\u0005\u003e\u070b\u000a\u003e\u0003\u003e\u0003\u003e\u0003\u003e\u0005\u003e\u0710\u000a\u003e\u0003\u003f\u0003\u003f\u0005\u003f\u0714\u000a\u003f\u0003\u003f\u0005\u003f\u0717\u000a\u003f\u0003\u003f\u0003\u003f\u0003\u0040\u0003\u0040\u0005\u0040\u071d\u000a\u0040\u0003\u0040\u0005\u0040\u0720\u000a\u0040\u0003\u0040\u0003\u0040\u0005\u0040\u0724\u000a\u0040\u0003\u0040\u0005\u0040\u0727\u000a\u0040\u0003\u0040\u0005\u0040\u072a\u000a\u0040\u0003\u0041\u0003\u0041\u0003\u0041\u0005\u0041\u072f\u000a\u0041\u0003\u0041\u0005\u0041\u0732\u000a\u0041\u0003\u0041\u0003\u0041\u0005\u0041\u0736\u000a\u0041\u0003\u0041\u0005\u0041\u0739\u000a\u0041\u0003\u0041\u0005\u0041\u073c\u000a\u0041\u0003\u0042\u0003\u0042\u0005\u0042\u0740\u000a\u0042\u0003\u0042\u0003\u0042\u0003\u0043\u0005\u0043\u0745\u000a\u0043\u0003\u0043\u0003\u0043\u0005\u0043\u0749\u000a\u0043\u0003\u0043\u0003\u0043\u0005\u0043\u074d\u000a\u0043\u0003\u0044\u0003\u0044\u0005\u0044\u0751\u000a\u0044\u0003\u0044\u0005\u0044\u0754\u000a\u0044\u0003\u0044\u0003\u0044\u0003\u0045\u0003\u0045\u0003\u0045\u0003\u0045\u0003\u0045\u0005\u0045\u075d\u000a\u0045\u0003\u0045\u0007\u0045\u0760\u000a\u0045\u000c\u0045\u000e\u0045\u0763\u000b\u0045\u0003\u0045\u0005\u0045\u0766\u000a\u0045\u0003\u0046\u0003\u0046\u0003\u0046\u0003\u0046\u0005\u0046\u076c\u000a\u0046\u0003\u0047\u0003\u0047\u0003\u0047\u0003\u0047\u0005\u0047\u0772\u000a\u0047\u0005\u0047\u0774\u000a\u0047\u0003\u0047\u0003\u0047\u0003\u0047\u0003\u0047\u0005\u0047\u077a\u000a\u0047\u0003\u0048\u0003\u0048\u0003\u0048\u0003\u0049\u0005\u0049\u0780\u000a\u0049\u0003\u0049\u0005\u0049\u0783\u000a\u0049\u0003\u0049\u0003\u0049\u0003\u0049\u0003\u0049\u0003\u004a\u0003\u004a\u0005\u004a\u078b\u000a\u004a\u0003\u004b\u0003\u004b\u0005\u004b\u078f\u000a\u004b\u0003\u004b\u0005\u004b\u0792\u000a\u004b\u0003\u004b\u0005\u004b\u0795\u000a\u004b\u0003\u004b\u0006\u004b\u0798\u000a\u004b\u000d\u004b\u000e\u004b\u0799\u0003\u004c\u0003\u004c\u0003\u004c\u0005\u004c\u079f\u000a\u004c\u0003\u004c\u0005\u004c\u07a2\u000a\u004c\u0003\u004c\u0006\u004c\u07a5\u000a\u004c\u000d\u004c\u000e\u004c\u07a6\u0003\u004d\u0003\u004d\u0003\u004d\u0005\u004d\u07ac\u000a\u004d\u0003\u004e\u0003\u004e\u0003\u004e\u0005\u004e\u07b1\u000a\u004e\u0003\u004e\u0003\u004e\u0003\u004f\u0003\u004f\u0003\u004f\u0003\u004f\u0007\u004f\u07b9\u000a\u004f\u000c\u004f\u000e\u004f\u07bc\u000b\u004f\u0003\u0050\u0003\u0050\u0003\u0050\u0003\u0050\u0003\u0050\u0003\u0050\u0003\u0050\u0003\u0050\u0003\u0050\u0005\u0050\u07c7\u000a\u0050\u0003\u0051\u0003\u0051\u0003\u0051\u0003\u0051\u0007\u0051\u07cd\u000a\u0051\u000c\u0051\u000e\u0051\u07d0\u000b\u0051\u0003\u0052\u0003\u0052\u0003\u0052\u0005\u0052\u07d5\u000a\u0052\u0003\u0052\u0007\u0052\u07d8\u000a\u0052\u000c\u0052\u000e\u0052\u07db\u000b\u0052\u0003\u0052\u0003\u0052\u0007\u0052\u07df\u000a\u0052\u000c\u0052\u000e\u0052\u07e2\u000b\u0052\u0003\u0053\u0003\u0053\u0003\u0053\u0003\u0053\u0003\u0053\u0003\u0053\u0003\u0053\u0003\u0053\u0003\u0053\u0003\u0053\u0003\u0053\u0005\u0053\u07ef\u000a\u0053\u0003\u0054\u0005\u0054\u07f2\u000a\u0054\u0003\u0054\u0003\u0054\u0003\u0055\u0005\u0055\u07f7\u000a\u0055\u0003\u0055\u0003\u0055\u0003\u0056\u0003\u0056\u0005\u0056\u07fd\u000a\u0056\u0003\u0056\u0003\u0056\u0005\u0056\u0801\u000a\u0056\u0003\u0056\u0005\u0056\u0804\u000a\u0056\u0003\u0057\u0003\u0057\u0003\u0057\u0003\u0058\u0003\u0058\u0003\u0058\u0003\u0058\u0005\u0058\u080d\u000a\u0058\u0003\u0059\u0005\u0059\u0810\u000a\u0059\u0003\u0059\u0003\u0059\u0005\u0059\u0814\u000a\u0059\u0003\u005a\u0005\u005a\u0817\u000a\u005a\u0003\u005a\u0003\u005a\u0005\u005a\u081b\u000a\u005a\u0003\u005a\u0005\u005a\u081e\u000a\u005a\u0003\u005a\u0005\u005a\u0821\u000a\u005a\u0003\u005a\u0003\u005a\u0005\u005a\u0825\u000a\u005a\u0003\u005a\u0005\u005a\u0828\u000a\u005a\u0005\u005a\u082a\u000a\u005a\u0003\u005a\u0003\u005a\u0005\u005a\u082e\u000a\u005a\u0003\u005a\u0005\u005a\u0831\u000a\u005a\u0003\u005b\u0005\u005b\u0834\u000a\u005b\u0003\u005b\u0003\u005b\u0003\u005b\u0005\u005b\u0839\u000a\u005b\u0003\u005c\u0003\u005c\u0003\u005c\u0003\u005d\u0003\u005d\u0003\u005d\u0005\u005d\u0841\u000a\u005d\u0003\u005d\u0003\u005d\u0005\u005d\u0845\u000a\u005d\u0005\u005d\u0847\u000a\u005d\u0003\u005d\u0003\u005d\u0003\u005d\u0006\u005d\u084c\u000a\u005d\u000d\u005d\u000e\u005d\u084d\u0005\u005d\u0850\u000a\u005d\u0003\u005e\u0003\u005e\u0003\u005e\u0006\u005e\u0855\u000a\u005e\u000d\u005e\u000e\u005e\u0856\u0003\u005f\u0003\u005f\u0005\u005f\u085b\u000a\u005f\u0003\u005f\u0003\u005f\u0005\u005f\u085f\u000a\u005f\u0003\u0060\u0003\u0060\u0003\u0060\u0005\u0060\u0864\u000a\u0060\u0003\u0060\u0003\u0060\u0005\u0060\u0868\u000a\u0060\u0005\u0060\u086a\u000a\u0060\u0003\u0060\u0006\u0060\u086d\u000a\u0060\u000d\u0060\u000e\u0060\u086e\u0003\u0061\u0003\u0061\u0005\u0061\u0873\u000a\u0061\u0003\u0061\u0003\u0061\u0005\u0061\u0877\u000a\u0061\u0003\u0061\u0005\u0061\u087a\u000a\u0061\u0003\u0061\u0007\u0061\u087d\u000a\u0061\u000c\u0061\u000e\u0061\u0880\u000b\u0061\u0003\u0062\u0003\u0062\u0003\u0062\u0005\u0062\u0885\u000a\u0062\u0003\u0063\u0005\u0063\u0888\u000a\u0063\u0003\u0063\u0003\u0063\u0005\u0063\u088c\u000a\u0063\u0003\u0063\u0003\u0063\u0005\u0063\u0890\u000a\u0063\u0003\u0064\u0005\u0064\u0893\u000a\u0064\u0003\u0064\u0005\u0064\u0896\u000a\u0064\u0003\u0064\u0003\u0064\u0003\u0064\u0005\u0064\u089b\u000a\u0064\u0003\u0065\u0005\u0065\u089e\u000a\u0065\u0003\u0065\u0005\u0065\u08a1\u000a\u0065\u0003\u0065\u0003\u0065\u0003\u0065\u0005\u0065\u08a6\u000a\u0065\u0003\u0066\u0003\u0066\u0005\u0066\u08aa\u000a\u0066\u0003\u0066\u0005\u0066\u08ad\u000a\u0066\u0003\u0066\u0003\u0066\u0003\u0067\u0003\u0067\u0003\u0068\u0003\u0068\u0005\u0068\u08b5\u000a\u0068\u0003\u0068\u0003\u0068\u0003\u0069\u0003\u0069\u0005\u0069\u08bb\u000a\u0069\u0003\u0069\u0003\u0069\u0005\u0069\u08bf\u000a\u0069\u0005\u0069\u08c1\u000a\u0069\u0003\u0069\u0006\u0069\u08c4\u000a\u0069\u000d\u0069\u000e\u0069\u08c5\u0003\u006a\u0003\u006a\u0003\u006a\u0003\u006a\u0007\u006a\u08cc\u000a\u006a\u000c\u006a\u000e\u006a\u08cf\u000b\u006a\u0003\u006b\u0003\u006b\u0003\u006b\u0003\u006b\u0003\u006b\u0003\u006c\u0003\u006c\u0003\u006c\u0003\u006c\u0007\u006c\u08da\u000a\u006c\u000c\u006c\u000e\u006c\u08dd\u000b\u006c\u0003\u006d\u0003\u006d\u0003\u006d\u0003\u006d\u0007\u006d\u08e3\u000a\u006d\u000c\u006d\u000e\u006d\u08e6\u000b\u006d\u0003\u006e\u0003\u006e\u0003\u006e\u0003\u006e\u0003\u006e\u0007\u006e\u08ed\u000a\u006e\u000c\u006e\u000e\u006e\u08f0\u000b\u006e\u0003\u006f\u0003\u006f\u0003\u006f\u0005\u006f\u08f5\u000a\u006f\u0003\u0070\u0003\u0070\u0003\u0070\u0005\u0070\u08fa\u000a\u0070\u0003\u0070\u0005\u0070\u08fd\u000a\u0070\u0003\u0070\u0003\u0070\u0003\u0070\u0003\u0070\u0003\u0070\u0003\u0070\u0003\u0070\u0003\u0070\u0003\u0070\u0003\u0070\u0005\u0070\u0909\u000a\u0070\u0003\u0070\u0007\u0070\u090c\u000a\u0070\u000c\u0070\u000e\u0070\u090f\u000b\u0070\u0003\u0070\u0003\u0070\u0003\u0071\u0003\u0071\u0003\u0071\u0005\u0071\u0916\u000a\u0071\u0003\u0071\u0003\u0071\u0003\u0071\u0003\u0071\u0003\u0071\u0003\u0071\u0003\u0071\u0007\u0071\u091f\u000a\u0071\u000c\u0071\u000e\u0071\u0922\u000b\u0071\u0003\u0071\u0003\u0071\u0003\u0072\u0003\u0072\u0003\u0072\u0005\u0072\u0929\u000a\u0072\u0003\u0072\u0003\u0072\u0003\u0072\u0003\u0072\u0003\u0072\u0003\u0072\u0003\u0072\u0003\u0072\u0005\u0072\u0933\u000a\u0072\u0003\u0072\u0007\u0072\u0936\u000a\u0072\u000c\u0072\u000e\u0072\u0939\u000b\u0072\u0003\u0072\u0003\u0072\u0003\u0073\u0003\u0073\u0003\u0073\u0005\u0073\u0940\u000a\u0073\u0003\u0073\u0003\u0073\u0003\u0074\u0003\u0074\u0003\u0074\u0003\u0074\u0003\u0074\u0003\u0074\u0003\u0074\u0003\u0074\u0006\u0074\u094c\u000a\u0074\u000d\u0074\u000e\u0074\u094d\u0005\u0074\u0950\u000a\u0074\u0003\u0075\u0003\u0075\u0003\u0075\u0005\u0075\u0955\u000a\u0075\u0003\u0075\u0003\u0075\u0003\u0076\u0003\u0076\u0003\u0076\u0005\u0076\u095c\u000a\u0076\u0003\u0076\u0003\u0076\u0003\u0077\u0005\u0077\u0961\u000a\u0077\u0003\u0077\u0003\u0077\u0005\u0077\u0965\u000a\u0077\u0003\u0077\u0003\u0077\u0003\u0078\u0003\u0078\u0003\u0078\u0005\u0078\u096c\u000a\u0078\u0003\u0078\u0003\u0078\u0003\u0079\u0003\u0079\u0003\u0079\u0005\u0079\u0973\u000a\u0079\u0003\u0079\u0003\u0079\u0003\u007a\u0003\u007a\u0003\u007a\u0005\u007a\u097a\u000a\u007a\u0003\u007a\u0003\u007a\u0003\u007b\u0005\u007b\u097f\u000a\u007b\u0003\u007b\u0003\u007b\u0005\u007b\u0983\u000a\u007b\u0003\u007b\u0003\u007b\u0003\u007c\u0005\u007c\u0988\u000a\u007c\u0003\u007c\u0003\u007c\u0005\u007c\u098c\u000a\u007c\u0003\u007c\u0003\u007c\u0003\u007d\u0005\u007d\u0991\u000a\u007d\u0003\u007d\u0003\u007d\u0005\u007d\u0995\u000a\u007d\u0003\u007d\u0003\u007d\u0003\u007e\u0005\u007e\u099a\u000a\u007e\u0003\u007e\u0003\u007e\u0005\u007e\u099e\u000a\u007e\u0003\u007e\u0003\u007e\u0003\u007f\u0005\u007f\u09a3\u000a\u007f\u0003\u007f\u0003\u007f\u0005\u007f\u09a7\u000a\u007f\u0003\u007f\u0003\u007f\u0003\u0080\u0003\u0080\u0003\u0080\u0005\u0080\u09ae\u000a\u0080\u0003\u0080\u0003\u0080\u0003\u0081\u0003\u0081\u0003\u0081\u0003\u0081\u0003\u0081\u0003\u0081\u0003\u0081\u0005\u0081\u09b9\u000a\u0081\u0003\u0081\u0007\u0081\u09bc\u000a\u0081\u000c\u0081\u000e\u0081\u09bf\u000b\u0081\u0003\u0082\u0003\u0082\u0003\u0082\u0003\u0082\u0007\u0082\u09c5\u000a\u0082\u000c\u0082\u000e\u0082\u09c8\u000b\u0082\u0003\u0083\u0003\u0083\u0003\u0083\u0005\u0083\u09cd\u000a\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0005\u0083\u09e1\u000a\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0003\u0083\u0007\u0083\u09ed\u000a\u0083\u000c\u0083\u000e\u0083\u09f0\u000b\u0083\u0003\u0083\u0003\u0083\u0003\u0084\u0003\u0084\u0003\u0084\u0003\u0085\u0003\u0085\u0003\u0086\u0003\u0086\u0003\u0087\u0003\u0087\u0003\u0087\u0003\u0088\u0003\u0088\u0003\u0089\u0003\u0089\u0003\u008a\u0003\u008a\u0003\u008b\u0003\u008b\u0003\u008c\u0003\u008c\u0005\u008c\u0a08\u000a\u008c\u0003\u008c\u0003\u008c\u0005\u008c\u0a0c\u000a\u008c\u0003\u008d\u0003\u008d\u0005\u008d\u0a10\u000a\u008d\u0003\u008d\u0005\u008d\u0a13\u000a\u008d\u0003\u008d\u0005\u008d\u0a16\u000a\u008d\u0003\u008d\u0003\u008d\u0005\u008d\u0a1a\u000a\u008d\u0003\u008e\u0003\u008e\u0005\u008e\u0a1e\u000a\u008e\u0003\u008e\u0005\u008e\u0a21\u000a\u008e\u0003\u008e\u0005\u008e\u0a24\u000a\u008e\u0003\u008e\u0003\u008e\u0005\u008e\u0a28\u000a\u008e\u0003\u008f\u0003\u008f\u0005\u008f\u0a2c\u000a\u008f\u0003\u008f\u0003\u008f\u0005\u008f\u0a30\u000a\u008f\u0003\u0090\u0003\u0090\u0005\u0090\u0a34\u000a\u0090\u0003\u0090\u0003\u0090\u0005\u0090\u0a38\u000a\u0090\u0003\u0091\u0003\u0091\u0005\u0091\u0a3c\u000a\u0091\u0003\u0091\u0003\u0091\u0003\u0092\u0003\u0092\u0005\u0092\u0a42\u000a\u0092\u0003\u0092\u0003\u0092\u0003\u0093\u0003\u0093\u0005\u0093\u0a48\u000a\u0093\u0003\u0093\u0003\u0093\u0003\u0094\u0003\u0094\u0003\u0094\u0005\u0094\u0a4f\u000a\u0094\u0003\u0094\u0005\u0094\u0a52\u000a\u0094\u0003\u0095\u0003\u0095\u0003\u0095\u0003\u0096\u0003\u0096\u0003\u0096\u0003\u0097\u0003\u0097\u0005\u0097\u0a5c\u000a\u0097\u0003\u0097\u0003\u0097\u0003\u0098\u0003\u0098\u0005\u0098\u0a62\u000a\u0098\u0003\u0098\u0003\u0098\u0003\u0099\u0003\u0099\u0005\u0099\u0a68\u000a\u0099\u0003\u009a\u0003\u009a\u0005\u009a\u0a6c\u000a\u009a\u0005\u009a\u0a6e\u000a\u009a\u0003\u009a\u0003\u009a\u0003\u009a\u0005\u009a\u0a73\u000a\u009a\u0005\u009a\u0a75\u000a\u009a\u0003\u009b\u0003\u009b\u0003\u009c\u0003\u009c\u0003\u009d\u0003\u009d\u0003\u009e\u0003\u009e\u0005\u009e\u0a7f\u000a\u009e\u0003\u009e\u0005\u009e\u0a82\u000a\u009e\u0003\u009e\u0003\u009e\u0005\u009e\u0a86\u000a\u009e\u0003\u009e\u0005\u009e\u0a89\u000a\u009e\u0003\u009f\u0003\u009f\u0003\u009f\u0005\u009f\u0a8e\u000a\u009f\u0003\u00a0\u0003\u00a0\u0003\u00a1\u0003\u00a1\u0003\u00a2\u0003\u00a2\u0003\u00a2\u0003\u00a2\u0007\u00a2\u0a98\u000a\u00a2\u000c\u00a2\u000e\u00a2\u0a9b\u000b\u00a2\u0003\u00a3\u0003\u00a3\u0006\u00a3\u0a9f\u000a\u00a3\u000d\u00a3\u000e\u00a3\u0aa0\u0003\u00a4\u0003\u00a4\u0003\u00a4\u0005\u00a4\u0aa6\u000a\u00a4\u0003\u00a4\u0003\u00a4\u0005\u00a4\u0aaa\u000a\u00a4\u0003\u00a4\u0005\u00a4\u0aad\u000a\u00a4\u0003\u00a4\u0005\u00a4\u0ab0\u000a\u00a4\u0003\u00a4\u0005\u00a4\u0ab3\u000a\u00a4\u0005\u00a4\u0ab5\u000a\u00a4\u0003\u00a4\u0003\u00a4\u0003\u00a5\u0005\u00a5\u0aba\u000a\u00a5\u0003\u00a5\u0003\u00a5\u0003\u00a6\u0003\u00a6\u0003\u00a6\u0005\u00a6\u0ac1\u000a\u00a6\u0003\u00a6\u0003\u00a6\u0005\u00a6\u0ac5\u000a\u00a6\u0005\u00a6\u0ac7\u000a\u00a6\u0003\u00a6\u0003\u00a6\u0005\u00a6\u0acb\u000a\u00a6\u0003\u00a7\u0003\u00a7\u0003\u00a7\u0003\u00a8\u0003\u00a8\u0003\u00a8\u0003\u00a8\u0003\u00a9\u0003\u00a9\u0003\u00a9\u0003\u00a9\u0003\u00aa\u0003\u00aa\u0003\u00aa\u0003\u00ab\u0003\u00ab\u0003\u00ab\u0005\u00ab\u0ade\u000a\u00ab\u0003\u00ac\u0003\u00ac\u0003\u00ac\u0005\u00ac\u0ae3\u000a\u00ac\u0003\u00ac\u0005\u00ac\u0ae6\u000a\u00ac\u0003\u00ac\u0003\u00ac\u0005\u00ac\u0aea\u000a\u00ac\u0003\u00ac\u0003\u00ac\u0003\u00ad\u0003\u00ad\u0005\u00ad\u0af0\u000a\u00ad\u0003\u00ad\u0005\u00ad\u0af3\u000a\u00ad\u0003\u00ad\u0003\u00ad\u0003\u00ad\u0003\u00ae\u0003\u00ae\u0005\u00ae\u0afa\u000a\u00ae\u0003\u00ae\u0003\u00ae\u0003\u00ae\u0003\u00ae\u0003\u00ae\u0003\u00ae\u0003\u00ae\u0003\u00ae\u0003\u00ae\u0003\u00ae\u0003\u00ae\u0005\u00ae\u0b07\u000a\u00ae\u0003\u00ae\u0007\u00ae\u0b0a\u000a\u00ae\u000c\u00ae\u000e\u00ae\u0b0d\u000b\u00ae\u0003\u00ae\u0003\u00ae\u0003\u00af\u0003\u00af\u0005\u00af\u0b13\u000a\u00af\u0003\u00af\u0003\u00af\u0003\u00b0\u0003\u00b0\u0005\u00b0\u0b19\u000a\u00b0\u0003\u00b0\u0005\u00b0\u0b1c\u000a\u00b0\u0003\u00b0\u0003\u00b0\u0003\u00b1\u0003\u00b1\u0005\u00b1\u0b22\u000a\u00b1\u0003\u00b2\u0003\u00b2\u0005\u00b2\u0b26\u000a\u00b2\u0003\u00b3\u0005\u00b3\u0b29\u000a\u00b3\u0003\u00b3\u0005\u00b3\u0b2c\u000a\u00b3\u0003\u00b3\u0005\u00b3\u0b2f\u000a\u00b3\u0003\u00b3\u0003\u00b3\u0005\u00b3\u0b33\u000a\u00b3\u0003\u00b4\u0003\u00b4\u0005\u00b4\u0b37\u000a\u00b4\u0003\u00b4\u0003\u00b4\u0005\u00b4\u0b3b\u000a\u00b4\u0003\u00b5\u0003\u00b5\u0003\u00b5\u0003\u00b6\u0003\u00b6\u0003\u00b6\u0005\u00b6\u0b43\u000a\u00b6\u0003\u00b6\u0003\u00b6\u0003\u00b6\u0005\u00b6\u0b48\u000a\u00b6\u0003\u00b7\u0003\u00b7\u0003\u00b7\u0003\u00b8\u0003\u00b8\u0003\u00b8\u0003\u00b9\u0003\u00b9\u0005\u00b9\u0b52\u000a\u00b9\u0003\u00b9\u0003\u00b9\u0003\u00ba\u0003\u00ba\u0005\u00ba\u0b58\u000a\u00ba\u0003\u00ba\u0003\u00ba\u0005\u00ba\u0b5c\u000a\u00ba\u0003\u00bb\u0003\u00bb\u0005\u00bb\u0b60\u000a\u00bb\u0003\u00bb\u0003\u00bb\u0003\u00bb\u0005\u00bb\u0b65\u000a\u00bb\u0003\u00bc\u0003\u00bc\u0005\u00bc\u0b69\u000a\u00bc\u0003\u00bc\u0003\u00bc\u0003\u00bd\u0003\u00bd\u0003\u00bd\u0005\u00bd\u0b70\u000a\u00bd\u0003\u00bd\u0007\u00bd\u0b73\u000a\u00bd\u000c\u00bd\u000e\u00bd\u0b76\u000b\u00bd\u0003\u00bd\u0003\u00bd\u0003\u00bd\u0005\u00bd\u0b7b\u000a\u00bd\u0003\u00bd\u0007\u00bd\u0b7e\u000a\u00bd\u000c\u00bd\u000e\u00bd\u0b81\u000b\u00bd\u0005\u00bd\u0b83\u000a\u00bd\u0003\u00be\u0003\u00be\u0005\u00be\u0b87\u000a\u00be\u0003\u00be\u0003\u00be\u0003\u00be\u0003\u00be\u0003\u00be\u0003\u00be\u0003\u00be\u0005\u00be\u0b90\u000a\u00be\u0003\u00bf\u0003\u00bf\u0003\u00bf\u0005\u00bf\u0b95\u000a\u00bf\u0003\u00c0\u0003\u00c0\u0003\u00c0\u0005\u00c0\u0b9a\u000a\u00c0\u0003\u00c1\u0003\u00c1\u0003\u00c1\u0005\u00c1\u0b9f\u000a\u00c1\u0003\u00c1\u0003\u00c1\u0005\u00c1\u0ba3\u000a\u00c1\u0003\u00c2\u0003\u00c2\u0003\u00c3\u0003\u00c3\u0003\u00c3\u0005\u00c3\u0baa\u000a\u00c3\u0003\u00c3\u0003\u00c3\u0005\u00c3\u0bae\u000a\u00c3\u0003\u00c4\u0003\u00c4\u0005\u00c4\u0bb2\u000a\u00c4\u0005\u00c4\u0bb4\u000a\u00c4\u0003\u00c4\u0003\u00c4\u0003\u00c5\u0003\u00c5\u0003\u00c5\u0005\u00c5\u0bbb\u000a\u00c5\u0003\u00c6\u0003\u00c6\u0003\u00c6\u0005\u00c6\u0bc0\u000a\u00c6\u0003\u00c7\u0003\u00c7\u0005\u00c7\u0bc4\u000a\u00c7\u0003\u00c7\u0003\u00c7\u0003\u00c8\u0003\u00c8\u0003\u00c8\u0003\u00c8\u0007\u00c8\u0bcc\u000a\u00c8\u000c\u00c8\u000e\u00c8\u0bcf\u000b\u00c8\u0003\u00c9\u0003\u00c9\u0005\u00c9\u0bd3\u000a\u00c9\u0003\u00ca\u0003\u00ca\u0003\u00ca\u0003\u00ca\u0005\u00ca\u0bd9\u000a\u00ca\u0003\u00ca\u0005\u00ca\u0bdc\u000a\u00ca\u0003\u00cb\u0003\u00cb\u0003\u00cb\u0003\u00cb\u0005\u00cb\u0be2\u000a\u00cb\u0003\u00cb\u0005\u00cb\u0be5\u000a\u00cb\u0003\u00cb\u0003\u00cb\u0007\u00cb\u0be9\u000a\u00cb\u000c\u00cb\u000e\u00cb\u0bec\u000b\u00cb\u0003\u00cc\u0003\u00cc\u0003\u00cc\u0005\u00cc\u0bf1\u000a\u00cc\u0003\u00cc\u0005\u00cc\u0bf4\u000a\u00cc\u0003\u00cd\u0003\u00cd\u0005\u00cd\u0bf8\u000a\u00cd\u0003\u00cd\u0003\u00cd\u0005\u00cd\u0bfc\u000a\u00cd\u0003\u00cd\u0005\u00cd\u0bff\u000a\u00cd\u0003\u00cd\u0005\u00cd\u0c02\u000a\u00cd\u0003\u00cd\u0005\u00cd\u0c05\u000a\u00cd\u0003\u00ce\u0003\u00ce\u0003\u00ce\u0003\u00ce\u0003\u00cf\u0003\u00cf\u0005\u00cf\u0c0d\u000a\u00cf\u0003\u00cf\u0003\u00cf\u0003\u00d0\u0003\u00d0\u0005\u00d0\u0c13\u000a\u00d0\u0003\u00d0\u0003\u00d0\u0003\u00d1\u0003\u00d1\u0003\u00d1\u0005\u00d1\u0c1a\u000a\u00d1\u0003\u00d2\u0003\u00d2\u0003\u00d2\u0005\u00d2\u0c1f\u000a\u00d2\u0003\u00d2\u0005\u00d2\u0c22\u000a\u00d2\u0003\u00d2\u0005\u00d2\u0c25\u000a\u00d2\u0003\u00d2\u0005\u00d2\u0c28\u000a\u00d2\u0003\u00d3\u0003\u00d3\u0003\u00d3\u0003\u00d4\u0003\u00d4\u0003\u00d4\u0003\u00d5\u0003\u00d5\u0006\u00d5\u0c32\u000a\u00d5\u000d\u00d5\u000e\u00d5\u0c33\u0003\u00d6\u0003\u00d6\u0005\u00d6\u0c38\u000a\u00d6\u0003\u00d7\u0003\u00d7\u0006\u00d7\u0c3c\u000a\u00d7\u000d\u00d7\u000e\u00d7\u0c3d\u0003\u00d8\u0003\u00d8\u0005\u00d8\u0c42\u000a\u00d8\u0003\u00d9\u0005\u00d9\u0c45\u000a\u00d9\u0003\u00d9\u0003\u00d9\u0003\u00da\u0005\u00da\u0c4a\u000a\u00da\u0003\u00da\u0003\u00da\u0003\u00db\u0003\u00db\u0003\u00db\u0003\u00db\u0005\u00db\u0c52\u000a\u00db\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0005\u00dc\u0c57\u000a\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dc\u0007\u00dc\u0c6e\u000a\u00dc\u000c\u00dc\u000e\u00dc\u0c71\u000b\u00dc\u0003\u00dc\u0003\u00dc\u0003\u00dd\u0003\u00dd\u0003\u00dd\u0003\u00dd\u0003\u00dd\u0003\u00de\u0003\u00de\u0003\u00de\u0003\u00de\u0003\u00de\u0003\u00df\u0006\u00df\u0c80\u000a\u00df\u000d\u00df\u000e\u00df\u0c81\u0003\u00df\u0005\u00df\u0c85\u000a\u00df\u0003\u00e0\u0003\u00e0\u0003\u00e1\u0003\u00e1\u0005\u00e1\u0c8b\u000a\u00e1\u0003\u00e1\u0003\u00e1\u0003\u00e2\u0003\u00e2\u0003\u00e3\u0005\u00e3\u0c92\u000a\u00e3\u0003\u00e3\u0003\u00e3\u0003\u00e3\u0005\u00e3\u0c97\u000a\u00e3\u0003\u00e4\u0005\u00e4\u0c9a\u000a\u00e4\u0003\u00e4\u0003\u00e4\u0003\u00e5\u0003\u00e5\u0003\u00e6\u0003\u00e6\u0005\u00e6\u0ca2\u000a\u00e6\u0003\u00e7\u0003\u00e7\u0003\u00e7\u0005\u00e7\u0ca7\u000a\u00e7\u0003\u00e7\u0005\u00e7\u0caa\u000a\u00e7\u0003\u00e7\u0003\u00e7\u0005\u00e7\u0cae\u000a\u00e7\u0003\u00e7\u0005\u00e7\u0cb1\u000a\u00e7\u0003\u00e7\u0007\u00e7\u0cb4\u000a\u00e7\u000c\u00e7\u000e\u00e7\u0cb7\u000b\u00e7\u0003\u00e7\u0003\u00e7\u0005\u00e7\u0cbb\u000a\u00e7\u0003\u00e7\u0005\u00e7\u0cbe\u000a\u00e7\u0003\u00e7\u0006\u00e7\u0cc1\u000a\u00e7\u000d\u00e7\u000e\u00e7\u0cc2\u0005\u00e7\u0cc5\u000a\u00e7\u0003\u00e8\u0003\u00e8\u0003\u00e8\u0003\u00e9\u0003\u00e9\u0005\u00e9\u0ccc\u000a\u00e9\u0003\u00e9\u0005\u00e9\u0ccf\u000a\u00e9\u0003\u00e9\u0006\u00e9\u0cd2\u000a\u00e9\u000d\u00e9\u000e\u00e9\u0cd3\u0003\u00ea\u0003\u00ea\u0005\u00ea\u0cd8\u000a\u00ea\u0003\u00ea\u0003\u00ea\u0003\u00eb\u0006\u00eb\u0cdd\u000a\u00eb\u000d\u00eb\u000e\u00eb\u0cde\u0003\u00eb\u0005\u00eb\u0ce2\u000a\u00eb\u0006\u00eb\u0ce4\u000a\u00eb\u000d\u00eb\u000e\u00eb\u0ce5\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0003\u00ec\u0005\u00ec\u0cf8\u000a\u00ec\u0003\u00ed\u0003\u00ed\u0003\u00ed\u0003\u00ed\u0003\u00ee\u0005\u00ee\u0cff\u000a\u00ee\u0003\u00ee\u0005\u00ee\u0d02\u000a\u00ee\u0003\u00ee\u0003\u00ee\u0003\u00ef\u0003\u00ef\u0003\u00ef\u0003\u00f0\u0003\u00f0\u0003\u00f0\u0003\u00f1\u0003\u00f1\u0003\u00f1\u0003\u00f1\u0005\u00f1\u0d10\u000a\u00f1\u0003\u00f2\u0003\u00f2\u0005\u00f2\u0d14\u000a\u00f2\u0005\u00f2\u0d16\u000a\u00f2\u0003\u00f2\u0003\u00f2\u0003\u00f2\u0005\u00f2\u0d1b\u000a\u00f2\u0005\u00f2\u0d1d\u000a\u00f2\u0003\u00f3\u0003\u00f3\u0005\u00f3\u0d21\u000a\u00f3\u0003\u00f4\u0005\u00f4\u0d24\u000a\u00f4\u0003\u00f4\u0003\u00f4\u0003\u00f5\u0003\u00f5\u0005\u00f5\u0d2a\u000a\u00f5\u0003\u00f5\u0003\u00f5\u0003\u00f6\u0005\u00f6\u0d2f\u000a\u00f6\u0003\u00f6\u0003\u00f6\u0003\u00f7\u0003\u00f7\u0005\u00f7\u0d35\u000a\u00f7\u0005\u00f7\u0d37\u000a\u00f7\u0003\u00f7\u0003\u00f7\u0005\u00f7\u0d3b\u000a\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0003\u00f7\u0005\u00f7\u0d5a\u000a\u00f7\u0003\u00f8\u0003\u00f8\u0003\u00f8\u0005\u00f8\u0d5f\u000a\u00f8\u0003\u00f8\u0003\u00f8\u0005\u00f8\u0d63\u000a\u00f8\u0003\u00f9\u0003\u00f9\u0005\u00f9\u0d67\u000a\u00f9\u0003\u00f9\u0003\u00f9\u0005\u00f9\u0d6b\u000a\u00f9\u0005\u00f9\u0d6d\u000a\u00f9\u0003\u00f9\u0003\u00f9\u0005\u00f9\u0d71\u000a\u00f9\u0003\u00f9\u0007\u00f9\u0d74\u000a\u00f9\u000c\u00f9\u000e\u00f9\u0d77\u000b\u00f9\u0003\u00fa\u0003\u00fa\u0005\u00fa\u0d7b\u000a\u00fa\u0003\u00fb\u0003\u00fb\u0005\u00fb\u0d7f\u000a\u00fb\u0003\u00fc\u0003\u00fc\u0003\u00fc\u0003\u00fd\u0005\u00fd\u0d85\u000a\u00fd\u0003\u00fd\u0003\u00fd\u0003\u00fd\u0003\u00fe\u0003\u00fe\u0003\u00fe\u0005\u00fe\u0d8d\u000a\u00fe\u0003\u00fe\u0005\u00fe\u0d90\u000a\u00fe\u0003\u00fe\u0003\u00fe\u0005\u00fe\u0d94\u000a\u00fe\u0003\u00fe\u0003\u00fe\u0003\u00ff\u0003\u00ff\u0006\u00ff\u0d9a\u000a\u00ff\u000d\u00ff\u000e\u00ff\u0d9b\u0003\u0100\u0003\u0100\u0003\u0100\u0003\u0101\u0003\u0101\u0005\u0101\u0da3\u000a\u0101\u0003\u0102\u0005\u0102\u0da6\u000a\u0102\u0003\u0102\u0005\u0102\u0da9\u000a\u0102\u0003\u0102\u0006\u0102\u0dac\u000a\u0102\u000d\u0102\u000e\u0102\u0dad\u0003\u0103\u0005\u0103\u0db1\u000a\u0103\u0003\u0103\u0003\u0103\u0005\u0103\u0db5\u000a\u0103\u0003\u0103\u0005\u0103\u0db8\u000a\u0103\u0003\u0104\u0005\u0104\u0dbb\u000a\u0104\u0003\u0104\u0003\u0104\u0006\u0104\u0dbf\u000a\u0104\u000d\u0104\u000e\u0104\u0dc0\u0003\u0105\u0003\u0105\u0003\u0105\u0005\u0105\u0dc6\u000a\u0105\u0003\u0106\u0003\u0106\u0003\u0106\u0006\u0106\u0dcb\u000a\u0106\u000d\u0106\u000e\u0106\u0dcc\u0003\u0106\u0003\u0106\u0003\u0106\u0003\u0106\u0003\u0107\u0003\u0107\u0003\u0107\u0003\u0107\u0003\u0107\u0003\u0107\u0003\u0108\u0003\u0108\u0003\u0108\u0005\u0108\u0ddc\u000a\u0108\u0003\u0109\u0003\u0109\u0007\u0109\u0de0\u000a\u0109\u000c\u0109\u000e\u0109\u0de3\u000b\u0109\u0003\u010a\u0003\u010a\u0003\u010a\u0003\u010a\u0003\u010b\u0007\u010b\u0dea\u000a\u010b\u000c\u010b\u000e\u010b\u0ded\u000b\u010b\u0003\u010b\u0007\u010b\u0df0\u000a\u010b\u000c\u010b\u000e\u010b\u0df3\u000b\u010b\u0003\u010c\u0003\u010c\u0003\u010c\u0003\u010c\u0007\u010c\u0df9\u000a\u010c\u000c\u010c\u000e\u010c\u0dfc\u000b\u010c\u0005\u010c\u0dfe\u000a\u010c\u0003\u010d\u0007\u010d\u0e01\u000a\u010d\u000c\u010d\u000e\u010d\u0e04\u000b\u010d\u0003\u010d\u0003\u010d\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0003\u010e\u0005\u010e\u0e39\u000a\u010e\u0003\u010f\u0003\u010f\u0003\u010f\u0003\u010f\u0003\u010f\u0003\u010f\u0005\u010f\u0e41\u000a\u010f\u0003\u010f\u0005\u010f\u0e44\u000a\u010f\u0003\u010f\u0005\u010f\u0e47\u000a\u010f\u0003\u010f\u0005\u010f\u0e4a\u000a\u010f\u0003\u0110\u0003\u0110\u0003\u0110\u0005\u0110\u0e4f\u000a\u0110\u0003\u0110\u0003\u0110\u0005\u0110\u0e53\u000a\u0110\u0003\u0110\u0003\u0110\u0003\u0110\u0003\u0110\u0003\u0110\u0005\u0110\u0e5a\u000a\u0110\u0003\u0110\u0003\u0110\u0003\u0110\u0003\u0110\u0005\u0110\u0e60\u000a\u0110\u0003\u0111\u0003\u0111\u0003\u0111\u0003\u0112\u0003\u0112\u0003\u0112\u0003\u0112\u0003\u0113\u0005\u0113\u0e6a\u000a\u0113\u0003\u0113\u0003\u0113\u0003\u0114\u0003\u0114\u0003\u0114\u0003\u0114\u0005\u0114\u0e72\u000a\u0114\u0003\u0114\u0005\u0114\u0e75\u000a\u0114\u0003\u0114\u0005\u0114\u0e78\u000a\u0114\u0003\u0114\u0005\u0114\u0e7b\u000a\u0114\u0003\u0115\u0006\u0115\u0e7e\u000a\u0115\u000d\u0115\u000e\u0115\u0e7f\u0003\u0115\u0003\u0115\u0006\u0115\u0e84\u000a\u0115\u000d\u0115\u000e\u0115\u0e85\u0003\u0116\u0006\u0116\u0e89\u000a\u0116\u000d\u0116\u000e\u0116\u0e8a\u0003\u0116\u0003\u0116\u0006\u0116\u0e8f\u000a\u0116\u000d\u0116\u000e\u0116\u0e90\u0005\u0116\u0e93\u000a\u0116\u0003\u0116\u0003\u0116\u0006\u0116\u0e97\u000a\u0116\u000d\u0116\u000e\u0116\u0e98\u0003\u0117\u0003\u0117\u0003\u0117\u0003\u0117\u0003\u0117\u0003\u0118\u0003\u0118\u0005\u0118\u0ea2\u000a\u0118\u0003\u0119\u0003\u0119\u0005\u0119\u0ea6\u000a\u0119\u0003\u011a\u0003\u011a\u0005\u011a\u0eaa\u000a\u011a\u0003\u011b\u0003\u011b\u0005\u011b\u0eae\u000a\u011b\u0003\u011c\u0003\u011c\u0005\u011c\u0eb2\u000a\u011c\u0003\u011c\u0003\u011c\u0003\u011d\u0003\u011d\u0006\u011d\u0eb8\u000a\u011d\u000d\u011d\u000e\u011d\u0eb9\u0003\u011e\u0003\u011e\u0003\u011e\u0003\u011e\u0005\u011e\u0ec0\u000a\u011e\u0003\u011e\u0003\u011e\u0003\u011f\u0003\u011f\u0003\u011f\u0005\u011f\u0ec7\u000a\u011f\u0003\u011f\u0005\u011f\u0eca\u000a\u011f\u0003\u011f\u0005\u011f\u0ecd\u000a\u011f\u0003\u011f\u0005\u011f\u0ed0\u000a\u011f\u0003\u011f\u0005\u011f\u0ed3\u000a\u011f\u0003\u011f\u0005\u011f\u0ed6\u000a\u011f\u0003\u011f\u0005\u011f\u0ed9\u000a\u011f\u0003\u0120\u0003\u0120\u0006\u0120\u0edd\u000a\u0120\u000d\u0120\u000e\u0120\u0ede\u0003\u0121\u0003\u0121\u0003\u0121\u0005\u0121\u0ee4\u000a\u0121\u0003\u0122\u0005\u0122\u0ee7\u000a\u0122\u0003\u0122\u0005\u0122\u0eea\u000a\u0122\u0003\u0122\u0006\u0122\u0eed\u000a\u0122\u000d\u0122\u000e\u0122\u0eee\u0003\u0123\u0003\u0123\u0003\u0123\u0003\u0123\u0005\u0123\u0ef5\u000a\u0123\u0003\u0123\u0003\u0123\u0003\u0123\u0005\u0123\u0efa\u000a\u0123\u0003\u0123\u0005\u0123\u0efd\u000a\u0123\u0003\u0124\u0005\u0124\u0f00\u000a\u0124\u0003\u0124\u0003\u0124\u0006\u0124\u0f04\u000a\u0124\u000d\u0124\u000e\u0124\u0f05\u0003\u0125\u0003\u0125\u0003\u0125\u0003\u0125\u0005\u0125\u0f0c\u000a\u0125\u0005\u0125\u0f0e\u000a\u0125\u0003\u0125\u0003\u0125\u0005\u0125\u0f12\u000a\u0125\u0003\u0126\u0005\u0126\u0f15\u000a\u0126\u0003\u0126\u0003\u0126\u0006\u0126\u0f19\u000a\u0126\u000d\u0126\u000e\u0126\u0f1a\u0003\u0127\u0003\u0127\u0003\u0127\u0003\u0127\u0005\u0127\u0f21\u000a\u0127\u0005\u0127\u0f23\u000a\u0127\u0003\u0127\u0003\u0127\u0003\u0127\u0005\u0127\u0f28\u000a\u0127\u0003\u0128\u0003\u0128\u0003\u0128\u0003\u0129\u0003\u0129\u0006\u0129\u0f2f\u000a\u0129\u000d\u0129\u000e\u0129\u0f30\u0003\u012a\u0003\u012a\u0003\u012a\u0003\u012a\u0003\u012a\u0005\u012a\u0f38\u000a\u012a\u0003\u012b\u0003\u012b\u0006\u012b\u0f3c\u000a\u012b\u000d\u012b\u000e\u012b\u0f3d\u0003\u012c\u0003\u012c\u0003\u012c\u0003\u012c\u0005\u012c\u0f44\u000a\u012c\u0003\u012d\u0003\u012d\u0005\u012d\u0f48\u000a\u012d\u0003\u012d\u0005\u012d\u0f4b\u000a\u012d\u0003\u012d\u0005\u012d\u0f4e\u000a\u012d\u0003\u012d\u0003\u012d\u0003\u012d\u0005\u012d\u0f53\u000a\u012d\u0005\u012d\u0f55\u000a\u012d\u0003\u012e\u0005\u012e\u0f58\u000a\u012e\u0003\u012e\u0003\u012e\u0003\u012e\u0005\u012e\u0f5d\u000a\u012e\u0003\u012f\u0005\u012f\u0f60\u000a\u012f\u0003\u012f\u0003\u012f\u0003\u012f\u0003\u012f\u0005\u012f\u0f66\u000a\u012f\u0003\u012f\u0003\u012f\u0006\u012f\u0f6a\u000a\u012f\u000d\u012f\u000e\u012f\u0f6b\u0005\u012f\u0f6e\u000a\u012f\u0003\u0130\u0003\u0130\u0003\u0130\u0005\u0130\u0f73\u000a\u0130\u0003\u0131\u0003\u0131\u0005\u0131\u0f77\u000a\u0131\u0003\u0131\u0003\u0131\u0003\u0132\u0003\u0132\u0003\u0132\u0005\u0132\u0f7e\u000a\u0132\u0003\u0133\u0003\u0133\u0005\u0133\u0f82\u000a\u0133\u0003\u0133\u0003\u0133\u0005\u0133\u0f86\u000a\u0133\u0003\u0134\u0003\u0134\u0006\u0134\u0f8a\u000a\u0134\u000d\u0134\u000e\u0134\u0f8b\u0003\u0134\u0003\u0134\u0003\u0134\u0005\u0134\u0f91\u000a\u0134\u0003\u0134\u0005\u0134\u0f94\u000a\u0134\u0003\u0134\u0005\u0134\u0f97\u000a\u0134\u0003\u0135\u0003\u0135\u0005\u0135\u0f9b\u000a\u0135\u0003\u0136\u0003\u0136\u0003\u0137\u0003\u0137\u0003\u0137\u0005\u0137\u0fa2\u000a\u0137\u0003\u0137\u0005\u0137\u0fa5\u000a\u0137\u0003\u0137\u0005\u0137\u0fa8\u000a\u0137\u0003\u0137\u0005\u0137\u0fab\u000a\u0137\u0003\u0138\u0003\u0138\u0003\u0138\u0005\u0138\u0fb0\u000a\u0138\u0003\u0138\u0003\u0138\u0003\u0138\u0005\u0138\u0fb5\u000a\u0138\u0003\u0138\u0003\u0138\u0005\u0138\u0fb9\u000a\u0138\u0003\u0138\u0003\u0138\u0003\u0138\u0005\u0138\u0fbe\u000a\u0138\u0003\u0139\u0003\u0139\u0006\u0139\u0fc2\u000a\u0139\u000d\u0139\u000e\u0139\u0fc3\u0003\u0139\u0005\u0139\u0fc7\u000a\u0139\u0003\u0139\u0005\u0139\u0fca\u000a\u0139\u0003\u0139\u0005\u0139\u0fcd\u000a\u0139\u0003\u013a\u0003\u013a\u0005\u013a\u0fd1\u000a\u013a\u0003\u013b\u0003\u013b\u0003\u013b\u0005\u013b\u0fd6\u000a\u013b\u0003\u013c\u0003\u013c\u0003\u013c\u0005\u013c\u0fdb\u000a\u013c\u0003\u013d\u0005\u013d\u0fde\u000a\u013d\u0003\u013d\u0003\u013d\u0003\u013d\u0003\u013e\u0003\u013e\u0003\u013e\u0005\u013e\u0fe6\u000a\u013e\u0003\u013e\u0003\u013e\u0003\u013e\u0005\u013e\u0feb\u000a\u013e\u0003\u013e\u0005\u013e\u0fee\u000a\u013e\u0003\u013e\u0005\u013e\u0ff1\u000a\u013e\u0003\u013e\u0005\u013e\u0ff4\u000a\u013e\u0003\u013e\u0005\u013e\u0ff7\u000a\u013e\u0003\u013f\u0003\u013f\u0006\u013f\u0ffb\u000a\u013f\u000d\u013f\u000e\u013f\u0ffc\u0003\u0140\u0003\u0140\u0003\u0140\u0005\u0140\u1002\u000a\u0140\u0003\u0140\u0005\u0140\u1005\u000a\u0140\u0003\u0141\u0003\u0141\u0003\u0141\u0005\u0141\u100a\u000a\u0141\u0003\u0141\u0005\u0141\u100d\u000a\u0141\u0003\u0142\u0003\u0142\u0006\u0142\u1011\u000a\u0142\u000d\u0142\u000e\u0142\u1012\u0003\u0143\u0003\u0143\u0005\u0143\u1017\u000a\u0143\u0003\u0144\u0003\u0144\u0005\u0144\u101b\u000a\u0144\u0003\u0145\u0003\u0145\u0003\u0145\u0003\u0146\u0003\u0146\u0003\u0146\u0005\u0146\u1023\u000a\u0146\u0003\u0146\u0003\u0146\u0003\u0146\u0005\u0146\u1028\u000a\u0146\u0003\u0146\u0003\u0146\u0005\u0146\u102c\u000a\u0146\u0003\u0146\u0003\u0146\u0003\u0146\u0005\u0146\u1031\u000a\u0146\u0003\u0147\u0003\u0147\u0003\u0147\u0003\u0147\u0006\u0147\u1037\u000a\u0147\u000d\u0147\u000e\u0147\u1038\u0005\u0147\u103b\u000a\u0147\u0003\u0148\u0003\u0148\u0003\u0148\u0007\u0148\u1040\u000a\u0148\u000c\u0148\u000e\u0148\u1043\u000b\u0148\u0003\u0148\u0006\u0148\u1046\u000a\u0148\u000d\u0148\u000e\u0148\u1047\u0003\u0148\u0005\u0148\u104b\u000a\u0148\u0003\u0148\u0005\u0148\u104e\u000a\u0148\u0003\u0149\u0003\u0149\u0003\u0149\u0003\u0149\u0005\u0149\u1054\u000a\u0149\u0003\u014a\u0003\u014a\u0003\u014a\u0003\u014b\u0006\u014b\u105a\u000a\u014b\u000d\u014b\u000e\u014b\u105b\u0003\u014b\u0007\u014b\u105f\u000a\u014b\u000c\u014b\u000e\u014b\u1062\u000b\u014b\u0003\u014c\u0003\u014c\u0003\u014c\u0007\u014c\u1067\u000a\u014c\u000c\u014c\u000e\u014c\u106a\u000b\u014c\u0003\u014d\u0003\u014d\u0005\u014d\u106e\u000a\u014d\u0003\u014d\u0003\u014d\u0005\u014d\u1072\u000a\u014d\u0003\u014d\u0003\u014d\u0005\u014d\u1076\u000a\u014d\u0003\u014e\u0003\u014e\u0003\u014e\u0003\u014f\u0003\u014f\u0003\u014f\u0003\u0150\u0003\u0150\u0003\u0150\u0007\u0150\u1081\u000a\u0150\u000c\u0150\u000e\u0150\u1084\u000b\u0150\u0003\u0151\u0003\u0151\u0003\u0151\u0005\u0151\u1089\u000a\u0151\u0003\u0152\u0006\u0152\u108c\u000a\u0152\u000d\u0152\u000e\u0152\u108d\u0003\u0153\u0006\u0153\u1091\u000a\u0153\u000d\u0153\u000e\u0153\u1092\u0003\u0154\u0006\u0154\u1096\u000a\u0154\u000d\u0154\u000e\u0154\u1097\u0003\u0155\u0003\u0155\u0005\u0155\u109c\u000a\u0155\u0003\u0155\u0005\u0155\u109f\u000a\u0155\u0003\u0155\u0006\u0155\u10a2\u000a\u0155\u000d\u0155\u000e\u0155\u10a3\u0003\u0156\u0003\u0156\u0005\u0156\u10a8\u000a\u0156\u0003\u0157\u0003\u0157\u0005\u0157\u10ac\u000a\u0157\u0003\u0158\u0003\u0158\u0003\u0158\u0003\u0159\u0003\u0159\u0003\u015a\u0003\u015a\u0005\u015a\u10b5\u000a\u015a\u0003\u015a\u0003\u015a\u0005\u015a\u10b9\u000a\u015a\u0003\u015b\u0003\u015b\u0003\u015c\u0003\u015c\u0006\u015c\u10bf\u000a\u015c\u000d\u015c\u000e\u015c\u10c0\u0003\u015c\u0003\u015c\u0005\u015c\u10c5\u000a\u015c\u0003\u015c\u0005\u015c\u10c8\u000a\u015c\u0005\u015c\u10ca\u000a\u015c\u0003\u015d\u0003\u015d\u0003\u015d\u0003\u015d\u0005\u015d\u10d0\u000a\u015d\u0003\u015d\u0005\u015d\u10d3\u000a\u015d\u0003\u015e\u0005\u015e\u10d6\u000a\u015e\u0003\u015e\u0003\u015e\u0003\u015e\u0007\u015e\u10db\u000a\u015e\u000c\u015e\u000e\u015e\u10de\u000b\u015e\u0005\u015e\u10e0\u000a\u015e\u0003\u015f\u0003\u015f\u0003\u015f\u0003\u015f\u0007\u015f\u10e6\u000a\u015f\u000c\u015f\u000e\u015f\u10e9\u000b\u015f\u0005\u015f\u10eb\u000a\u015f\u0003\u0160\u0003\u0160\u0006\u0160\u10ef\u000a\u0160\u000d\u0160\u000e\u0160\u10f0\u0003\u0160\u0005\u0160\u10f4\u000a\u0160\u0003\u0161\u0003\u0161\u0006\u0161\u10f8\u000a\u0161\u000d\u0161\u000e\u0161\u10f9\u0003\u0162\u0003\u0162\u0005\u0162\u10fe\u000a\u0162\u0003\u0162\u0003\u0162\u0003\u0162\u0005\u0162\u1103\u000a\u0162\u0003\u0163\u0003\u0163\u0006\u0163\u1107\u000a\u0163\u000d\u0163\u000e\u0163\u1108\u0003\u0164\u0003\u0164\u0003\u0164\u0003\u0164\u0003\u0164\u0003\u0164\u0005\u0164\u1111\u000a\u0164\u0003\u0165\u0003\u0165\u0006\u0165\u1115\u000a\u0165\u000d\u0165\u000e\u0165\u1116\u0003\u0166\u0003\u0166\u0003\u0166\u0006\u0166\u111c\u000a\u0166\u000d\u0166\u000e\u0166\u111d\u0003\u0167\u0003\u0167\u0006\u0167\u1122\u000a\u0167\u000d\u0167\u000e\u0167\u1123\u0003\u0167\u0006\u0167\u1127\u000a\u0167\u000d\u0167\u000e\u0167\u1128\u0003\u0168\u0003\u0168\u0003\u0168\u0005\u0168\u112e\u000a\u0168\u0003\u0168\u0003\u0168\u0007\u0168\u1132\u000a\u0168\u000c\u0168\u000e\u0168\u1135\u000b\u0168\u0003\u0169\u0003\u0169\u0003\u0169\u0003\u0169\u0006\u0169\u113b\u000a\u0169\u000d\u0169\u000e\u0169\u113c\u0003\u016a\u0003\u016a\u0007\u016a\u1141\u000a\u016a\u000c\u016a\u000e\u016a\u1144\u000b\u016a\u0003\u016b\u0003\u016b\u0003\u016b\u0007\u016b\u1149\u000a\u016b\u000c\u016b\u000e\u016b\u114c\u000b\u016b\u0003\u016c\u0003\u016c\u0006\u016c\u1150\u000a\u016c\u000d\u016c\u000e\u016c\u1151\u0003\u016d\u0003\u016d\u0006\u016d\u1156\u000a\u016d\u000d\u016d\u000e\u016d\u1157\u0003\u016e\u0003\u016e\u0005\u016e\u115c\u000a\u016e\u0003\u016e\u0007\u016e\u115f\u000a\u016e\u000c\u016e\u000e\u016e\u1162\u000b\u016e\u0003\u016f\u0003\u016f\u0005\u016f\u1166\u000a\u016f\u0003\u016f\u0003\u016f\u0007\u016f\u116a\u000a\u016f\u000c\u016f\u000e\u016f\u116d\u000b\u016f\u0003\u0170\u0003\u0170\u0003\u0170\u0005\u0170\u1172\u000a\u0170\u0003\u0171\u0003\u0171\u0003\u0171\u0005\u0171\u1177\u000a\u0171\u0003\u0172\u0003\u0172\u0005\u0172\u117b\u000a\u0172\u0003\u0172\u0003\u0172\u0005\u0172\u117f\u000a\u0172\u0003\u0173\u0003\u0173\u0003\u0173\u0006\u0173\u1184\u000a\u0173\u000d\u0173\u000e\u0173\u1185\u0003\u0173\u0005\u0173\u1189\u000a\u0173\u0003\u0173\u0007\u0173\u118c\u000a\u0173\u000c\u0173\u000e\u0173\u118f\u000b\u0173\u0003\u0173\u0005\u0173\u1192\u000a\u0173\u0003\u0173\u0007\u0173\u1195\u000a\u0173\u000c\u0173\u000e\u0173\u1198\u000b\u0173\u0003\u0174\u0005\u0174\u119b\u000a\u0174\u0003\u0174\u0003\u0174\u0005\u0174\u119f\u000a\u0174\u0003\u0174\u0006\u0174\u11a2\u000a\u0174\u000d\u0174\u000e\u0174\u11a3\u0003\u0175\u0005\u0175\u11a7\u000a\u0175\u0003\u0175\u0003\u0175\u0005\u0175\u11ab\u000a\u0175\u0003\u0175\u0006\u0175\u11ae\u000a\u0175\u000d\u0175\u000e\u0175\u11af\u0003\u0175\u0005\u0175\u11b3\u000a\u0175\u0003\u0175\u0005\u0175\u11b6\u000a\u0175\u0003\u0176\u0005\u0176\u11b9\u000a\u0176\u0003\u0176\u0003\u0176\u0003\u0176\u0003\u0176\u0003\u0177\u0005\u0177\u11c0\u000a\u0177\u0003\u0177\u0003\u0177\u0005\u0177\u11c4\u000a\u0177\u0003\u0177\u0003\u0177\u0003\u0178\u0003\u0178\u0006\u0178\u11ca\u000a\u0178\u000d\u0178\u000e\u0178\u11cb\u0003\u0179\u0003\u0179\u0003\u0179\u0005\u0179\u11d1\u000a\u0179\u0003\u0179\u0003\u0179\u0005\u0179\u11d5\u000a\u0179\u0003\u017a\u0003\u017a\u0003\u017a\u0003\u017b\u0003\u017b\u0006\u017b\u11dc\u000a\u017b\u000d\u017b\u000e\u017b\u11dd\u0003\u017c\u0003\u017c\u0003\u017c\u0003\u017c\u0003\u017c\u0003\u017c\u0003\u017c\u0003\u017c\u0003\u017c\u0003\u017c\u0005\u017c\u11ea\u000a\u017c\u0003\u017d\u0003\u017d\u0005\u017d\u11ee\u000a\u017d\u0003\u017d\u0003\u017d\u0005\u017d\u11f2\u000a\u017d\u0003\u017e\u0003\u017e\u0003\u017e\u0006\u017e\u11f7\u000a\u017e\u000d\u017e\u000e\u017e\u11f8\u0003\u017f\u0003\u017f\u0005\u017f\u11fd\u000a\u017f\u0003\u0180\u0003\u0180\u0003\u0180\u0003\u0180\u0006\u0180\u1203\u000a\u0180\u000d\u0180\u000e\u0180\u1204\u0003\u0181\u0003\u0181\u0003\u0182\u0003\u0182\u0003\u0182\u0005\u0182\u120c\u000a\u0182\u0003\u0182\u0003\u0182\u0003\u0182\u0005\u0182\u1211\u000a\u0182\u0003\u0182\u0005\u0182\u1214\u000a\u0182\u0003\u0182\u0005\u0182\u1217\u000a\u0182\u0003\u0182\u0005\u0182\u121a\u000a\u0182\u0003\u0183\u0006\u0183\u121d\u000a\u0183\u000d\u0183\u000e\u0183\u121e\u0003\u0184\u0003\u0184\u0005\u0184\u1223\u000a\u0184\u0003\u0185\u0003\u0185\u0003\u0185\u0006\u0185\u1228\u000a\u0185\u000d\u0185\u000e\u0185\u1229\u0003\u0186\u0003\u0186\u0005\u0186\u122e\u000a\u0186\u0003\u0187\u0003\u0187\u0005\u0187\u1232\u000a\u0187\u0003\u0188\u0003\u0188\u0003\u0188\u0003\u0188\u0003\u0188\u0006\u0188\u1239\u000a\u0188\u000d\u0188\u000e\u0188\u123a\u0003\u0189\u0003\u0189\u0006\u0189\u123f\u000a\u0189\u000d\u0189\u000e\u0189\u1240\u0003\u018a\u0003\u018a\u0003\u018a\u0005\u018a\u1246\u000a\u018a\u0003\u018a\u0003\u018a\u0005\u018a\u124a\u000a\u018a\u0003\u018b\u0003\u018b\u0006\u018b\u124e\u000a\u018b\u000d\u018b\u000e\u018b\u124f\u0003\u018c\u0003\u018c\u0005\u018c\u1254\u000a\u018c\u0003\u018c\u0003\u018c\u0005\u018c\u1258\u000a\u018c\u0003\u018d\u0003\u018d\u0006\u018d\u125c\u000a\u018d\u000d\u018d\u000e\u018d\u125d\u0003\u018e\u0003\u018e\u0006\u018e\u1262\u000a\u018e\u000d\u018e\u000e\u018e\u1263\u0003\u018f\u0003\u018f\u0003\u018f\u0005\u018f\u1269\u000a\u018f\u0003\u0190\u0005\u0190\u126c\u000a\u0190\u0003\u0190\u0007\u0190\u126f\u000a\u0190\u000c\u0190\u000e\u0190\u1272\u000b\u0190\u0003\u0190\u0003\u0190\u0003\u0191\u0003\u0191\u0003\u0191\u0005\u0191\u1279\u000a\u0191\u0003\u0191\u0005\u0191\u127c\u000a\u0191\u0003\u0192\u0003\u0192\u0003\u0192\u0005\u0192\u1281\u000a\u0192\u0003\u0193\u0003\u0193\u0005\u0193\u1285\u000a\u0193\u0003\u0193\u0003\u0193\u0003\u0194\u0005\u0194\u128a\u000a\u0194\u0003\u0194\u0003\u0194\u0003\u0194\u0003\u0195\u0003\u0195\u0003\u0195\u0003\u0195\u0003\u0195\u0005\u0195\u1294\u000a\u0195\u0005\u0195\u1296\u000a\u0195\u0003\u0196\u0003\u0196\u0003\u0196\u0007\u0196\u129b\u000a\u0196\u000c\u0196\u000e\u0196\u129e\u000b\u0196\u0003\u0197\u0003\u0197\u0005\u0197\u12a2\u000a\u0197\u0003\u0197\u0003\u0197\u0003\u0197\u0003\u0197\u0003\u0198\u0003\u0198\u0003\u0198\u0003\u0199\u0003\u0199\u0003\u0199\u0003\u0199\u0005\u0199\u12af\u000a\u0199\u0003\u019a\u0003\u019a\u0003\u019a\u0003\u019a\u0005\u019a\u12b5\u000a\u019a\u0003\u019b\u0005\u019b\u12b8\u000a\u019b\u0003\u019b\u0003\u019b\u0003\u019b\u0003\u019c\u0003\u019c\u0006\u019c\u12bf\u000a\u019c\u000d\u019c\u000e\u019c\u12c0\u0003\u019d\u0003\u019d\u0003\u019d\u0005\u019d\u12c6\u000a\u019d\u0003\u019d\u0005\u019d\u12c9\u000a\u019d\u0003\u019d\u0005\u019d\u12cc\u000a\u019d\u0003\u019d\u0005\u019d\u12cf\u000a\u019d\u0003\u019d\u0005\u019d\u12d2\u000a\u019d\u0003\u019d\u0005\u019d\u12d5\u000a\u019d\u0003\u019d\u0005\u019d\u12d8\u000a\u019d\u0003\u019d\u0005\u019d\u12db\u000a\u019d\u0003\u019d\u0005\u019d\u12de\u000a\u019d\u0003\u019d\u0005\u019d\u12e1\u000a\u019d\u0003\u019e\u0003\u019e\u0003\u019e\u0003\u019f\u0005\u019f\u12e7\u000a\u019f\u0003\u019f\u0003\u019f\u0003\u019f\u0005\u019f\u12ec\u000a\u019f\u0003\u01a0\u0003\u01a0\u0005\u01a0\u12f0\u000a\u01a0\u0003\u01a0\u0003\u01a0\u0003\u01a1\u0003\u01a1\u0003\u01a1\u0005\u01a1\u12f7\u000a\u01a1\u0003\u01a1\u0005\u01a1\u12fa\u000a\u01a1\u0003\u01a1\u0005\u01a1\u12fd\u000a\u01a1\u0003\u01a1\u0005\u01a1\u1300\u000a\u01a1\u0003\u01a2\u0003\u01a2\u0003\u01a2\u0003\u01a2\u0003\u01a2\u0003\u01a2\u0003\u01a2\u0003\u01a2\u0007\u01a2\u130a\u000a\u01a2\u000c\u01a2\u000e\u01a2\u130d\u000b\u01a2\u0003\u01a3\u0003\u01a3\u0003\u01a3\u0003\u01a3\u0003\u01a3\u0003\u01a3\u0005\u01a3\u1315\u000a\u01a3\u0003\u01a4\u0003\u01a4\u0003\u01a4\u0005\u01a4\u131a\u000a\u01a4\u0003\u01a4\u0003\u01a4\u0005\u01a4\u131e\u000a\u01a4\u0003\u01a4\u0005\u01a4\u1321\u000a\u01a4\u0003\u01a5\u0003\u01a5\u0003\u01a5\u0007\u01a5\u1326\u000a\u01a5\u000c\u01a5\u000e\u01a5\u1329\u000b\u01a5\u0003\u01a6\u0003\u01a6\u0003\u01a6\u0007\u01a6\u132e\u000a\u01a6\u000c\u01a6\u000e\u01a6\u1331\u000b\u01a6\u0003\u01a7\u0003\u01a7\u0005\u01a7\u1335\u000a\u01a7\u0003\u01a7\u0003\u01a7\u0005\u01a7\u1339\u000a\u01a7\u0003\u01a8\u0005\u01a8\u133c\u000a\u01a8\u0003\u01a8\u0003\u01a8\u0003\u01a8\u0003\u01a9\u0003\u01a9\u0005\u01a9\u1343\u000a\u01a9\u0003\u01a9\u0003\u01a9\u0003\u01aa\u0003\u01aa\u0005\u01aa\u1349\u000a\u01aa\u0003\u01aa\u0003\u01aa\u0005\u01aa\u134d\u000a\u01aa\u0003\u01ab\u0003\u01ab\u0005\u01ab\u1351\u000a\u01ab\u0003\u01ab\u0003\u01ab\u0003\u01ac\u0003\u01ac\u0003\u01ac\u0003\u01ac\u0005\u01ac\u1359\u000a\u01ac\u0003\u01ad\u0003\u01ad\u0003\u01ad\u0005\u01ad\u135e\u000a\u01ad\u0003\u01ad\u0005\u01ad\u1361\u000a\u01ad\u0003\u01ad\u0003\u01ad\u0005\u01ad\u1365\u000a\u01ad\u0003\u01ad\u0005\u01ad\u1368\u000a\u01ad\u0003\u01ae\u0003\u01ae\u0003\u01ae\u0003\u01af\u0003\u01af\u0003\u01af\u0005\u01af\u1370\u000a\u01af\u0003\u01af\u0005\u01af\u1373\u000a\u01af\u0003\u01af\u0005\u01af\u1376\u000a\u01af\u0003\u01af\u0005\u01af\u1379\u000a\u01af\u0003\u01b0\u0003\u01b0\u0003\u01b0\u0003\u01b1\u0003\u01b1\u0005\u01b1\u1380\u000a\u01b1\u0003\u01b1\u0003\u01b1\u0005\u01b1\u1384\u000a\u01b1\u0003\u01b1\u0005\u01b1\u1387\u000a\u01b1\u0003\u01b1\u0006\u01b1\u138a\u000a\u01b1\u000d\u01b1\u000e\u01b1\u138b\u0003\u01b1\u0005\u01b1\u138f\u000a\u01b1\u0003\u01b2\u0003\u01b2\u0003\u01b2\u0003\u01b3\u0003\u01b3\u0003\u01b3\u0003\u01b3\u0003\u01b3\u0007\u01b3\u1399\u000a\u01b3\u000c\u01b3\u000e\u01b3\u139c\u000b\u01b3\u0005\u01b3\u139e\u000a\u01b3\u0003\u01b4\u0003\u01b4\u0003\u01b4\u0005\u01b4\u13a3\u000a\u01b4\u0003\u01b4\u0005\u01b4\u13a6\u000a\u01b4\u0003\u01b4\u0005\u01b4\u13a9\u000a\u01b4\u0003\u01b5\u0003\u01b5\u0005\u01b5\u13ad\u000a\u01b5\u0003\u01b5\u0005\u01b5\u13b0\u000a\u01b5\u0003\u01b5\u0005\u01b5\u13b3\u000a\u01b5\u0003\u01b5\u0005\u01b5\u13b6\u000a\u01b5\u0003\u01b5\u0005\u01b5\u13b9\u000a\u01b5\u0003\u01b6\u0003\u01b6\u0003\u01b6\u0003\u01b6\u0003\u01b7\u0003\u01b7\u0003\u01b7\u0003\u01b8\u0003\u01b8\u0003\u01b8\u0003\u01b8\u0003\u01b8\u0005\u01b8\u13c7\u000a\u01b8\u0003\u01b9\u0003\u01b9\u0005\u01b9\u13cb\u000a\u01b9\u0003\u01ba\u0003\u01ba\u0005\u01ba\u13cf\u000a\u01ba\u0003\u01ba\u0003\u01ba\u0003\u01ba\u0005\u01ba\u13d4\u000a\u01ba\u0003\u01bb\u0003\u01bb\u0003\u01bc\u0003\u01bc\u0005\u01bc\u13da\u000a\u01bc\u0003\u01bc\u0005\u01bc\u13dd\u000a\u01bc\u0003\u01bd\u0003\u01bd\u0003\u01be\u0003\u01be\u0006\u01be\u13e3\u000a\u01be\u000d\u01be\u000e\u01be\u13e4\u0003\u01be\u0005\u01be\u13e8\u000a\u01be\u0003\u01bf\u0006\u01bf\u13eb\u000a\u01bf\u000d\u01bf\u000e\u01bf\u13ec\u0003\u01bf\u0003\u01bf\u0006\u01bf\u13f1\u000a\u01bf\u000d\u01bf\u000e\u01bf\u13f2\u0003\u01c0\u0006\u01c0\u13f6\u000a\u01c0\u000d\u01c0\u000e\u01c0\u13f7\u0003\u01c0\u0003\u01c0\u0003\u01c0\u0003\u01c0\u0005\u01c0\u13fe\u000a\u01c0\u0003\u01c0\u0003\u01c0\u0003\u01c1\u0003\u01c1\u0003\u01c2\u0003\u01c2\u0003\u01c2\u0003\u01c2\u0003\u01c2\u0005\u01c2\u1409\u000a\u01c2\u0003\u01c2\u0003\u01c2\u0005\u01c2\u140d\u000a\u01c2\u0003\u01c3\u0003\u01c3\u0005\u01c3\u1411\u000a\u01c3\u0003\u01c4\u0003\u01c4\u0003\u01c4\u0006\u01c4\u1416\u000a\u01c4\u000d\u01c4\u000e\u01c4\u1417\u0003\u01c4\u0005\u01c4\u141b\u000a\u01c4\u0003\u01c4\u0005\u01c4\u141e\u000a\u01c4\u0003\u01c4\u0005\u01c4\u1421\u000a\u01c4\u0003\u01c4\u0007\u01c4\u1424\u000a\u01c4\u000c\u01c4\u000e\u01c4\u1427\u000b\u01c4\u0003\u01c4\u0005\u01c4\u142a\u000a\u01c4\u0003\u01c4\u0007\u01c4\u142d\u000a\u01c4\u000c\u01c4\u000e\u01c4\u1430\u000b\u01c4\u0003\u01c5\u0005\u01c5\u1433\u000a\u01c5\u0003\u01c5\u0003\u01c5\u0005\u01c5\u1437\u000a\u01c5\u0003\u01c5\u0006\u01c5\u143a\u000a\u01c5\u000d\u01c5\u000e\u01c5\u143b\u0003\u01c6\u0005\u01c6\u143f\u000a\u01c6\u0003\u01c6\u0003\u01c6\u0005\u01c6\u1443\u000a\u01c6\u0003\u01c6\u0005\u01c6\u1446\u000a\u01c6\u0003\u01c7\u0005\u01c7\u1449\u000a\u01c7\u0003\u01c7\u0003\u01c7\u0005\u01c7\u144d\u000a\u01c7\u0003\u01c7\u0006\u01c7\u1450\u000a\u01c7\u000d\u01c7\u000e\u01c7\u1451\u0003\u01c7\u0005\u01c7\u1455\u000a\u01c7\u0003\u01c7\u0005\u01c7\u1458\u000a\u01c7\u0003\u01c8\u0005\u01c8\u145b\u000a\u01c8\u0003\u01c8\u0003\u01c8\u0003\u01c8\u0003\u01c8\u0003\u01c9\u0005\u01c9\u1462\u000a\u01c9\u0003\u01c9\u0003\u01c9\u0005\u01c9\u1466\u000a\u01c9\u0003\u01c9\u0003\u01c9\u0003\u01ca\u0003\u01ca\u0003\u01ca\u0005\u01ca\u146d\u000a\u01ca\u0003\u01ca\u0003\u01ca\u0005\u01ca\u1471\u000a\u01ca\u0003\u01cb\u0003\u01cb\u0003\u01cb\u0003\u01cc\u0003\u01cc\u0006\u01cc\u1478\u000a\u01cc\u000d\u01cc\u000e\u01cc\u1479\u0003\u01cd\u0003\u01cd\u0003\u01cd\u0005\u01cd\u147f\u000a\u01cd\u0003\u01cd\u0003\u01cd\u0005\u01cd\u1483\u000a\u01cd\u0003\u01ce\u0003\u01ce\u0003\u01ce\u0003\u01cf\u0003\u01cf\u0006\u01cf\u148a\u000a\u01cf\u000d\u01cf\u000e\u01cf\u148b\u0003\u01d0\u0003\u01d0\u0003\u01d0\u0003\u01d0\u0003\u01d0\u0003\u01d0\u0003\u01d0\u0003\u01d0\u0003\u01d0\u0003\u01d0\u0005\u01d0\u1498\u000a\u01d0\u0003\u01d1\u0003\u01d1\u0003\u01d1\u0005\u01d1\u149d\u000a\u01d1\u0003\u01d1\u0005\u01d1\u14a0\u000a\u01d1\u0003\u01d1\u0005\u01d1\u14a3\u000a\u01d1\u0003\u01d1\u0005\u01d1\u14a6\u000a\u01d1\u0003\u01d2\u0003\u01d2\u0005\u01d2\u14aa\u000a\u01d2\u0003\u01d2\u0003\u01d2\u0005\u01d2\u14ae\u000a\u01d2\u0003\u01d2\u0003\u01d2\u0003\u01d2\u0005\u01d2\u14b3\u000a\u01d2\u0003\u01d2\u0003\u01d2\u0003\u01d2\u0003\u01d2\u0005\u01d2\u14b9\u000a\u01d2\u0003\u01d2\u0003\u01d2\u0003\u01d2\u0003\u01d2\u0005\u01d2\u14bf\u000a\u01d2\u0003\u01d2\u0003\u01d2\u0003\u01d2\u0005\u01d2\u14c4\u000a\u01d2\u0003\u01d2\u0005\u01d2\u14c7\u000a\u01d2\u0003\u01d2\u0003\u01d2\u0003\u01d3\u0003\u01d3\u0003\u01d3\u0005\u01d3\u14ce\u000a\u01d3\u0003\u01d4\u0003\u01d4\u0006\u01d4\u14d2\u000a\u01d4\u000d\u01d4\u000e\u01d4\u14d3\u0003\u01d4\u0003\u01d4\u0005\u01d4\u14d8\u000a\u01d4\u0003\u01d4\u0005\u01d4\u14db\u000a\u01d4\u0003\u01d4\u0005\u01d4\u14de\u000a\u01d4\u0003\u01d4\u0005\u01d4\u14e1\u000a\u01d4\u0003\u01d5\u0006\u01d5\u14e4\u000a\u01d5\u000d\u01d5\u000e\u01d5\u14e5\u0003\u01d5\u0003\u01d5\u0005\u01d5\u14ea\u000a\u01d5\u0003\u01d6\u0003\u01d6\u0005\u01d6\u14ee\u000a\u01d6\u0003\u01d7\u0003\u01d7\u0005\u01d7\u14f2\u000a\u01d7\u0003\u01d7\u0003\u01d7\u0003\u01d7\u0005\u01d7\u14f7\u000a\u01d7\u0003\u01d8\u0003\u01d8\u0003\u01d8\u0005\u01d8\u14fc\u000a\u01d8\u0003\u01d9\u0003\u01d9\u0003\u01d9\u0003\u01da\u0005\u01da\u1502\u000a\u01da\u0003\u01da\u0003\u01da\u0003\u01da\u0003\u01db\u0003\u01db\u0003\u01db\u0003\u01db\u0005\u01db\u150b\u000a\u01db\u0003\u01db\u0005\u01db\u150e\u000a\u01db\u0003\u01db\u0005\u01db\u1511\u000a\u01db\u0003\u01db\u0005\u01db\u1514\u000a\u01db\u0003\u01dc\u0006\u01dc\u1517\u000a\u01dc\u000d\u01dc\u000e\u01dc\u1518\u0003\u01dc\u0003\u01dc\u0006\u01dc\u151d\u000a\u01dc\u000d\u01dc\u000e\u01dc\u151e\u0003\u01dd\u0006\u01dd\u1522\u000a\u01dd\u000d\u01dd\u000e\u01dd\u1523\u0003\u01dd\u0003\u01dd\u0003\u01dd\u0003\u01dd\u0006\u01dd\u152a\u000a\u01dd\u000d\u01dd\u000e\u01dd\u152b\u0003\u01de\u0003\u01de\u0003\u01de\u0003\u01de\u0003\u01de\u0003\u01df\u0003\u01df\u0005\u01df\u1535\u000a\u01df\u0003\u01e0\u0003\u01e0\u0005\u01e0\u1539\u000a\u01e0\u0003\u01e1\u0003\u01e1\u0005\u01e1\u153d\u000a\u01e1\u0003\u01e2\u0003\u01e2\u0005\u01e2\u1541\u000a\u01e2\u0003\u01e3\u0003\u01e3\u0005\u01e3\u1545\u000a\u01e3\u0003\u01e4\u0003\u01e4\u0003\u01e4\u0003\u01e5\u0003\u01e5\u0003\u01e5\u0003\u01e5\u0005\u01e5\u154e\u000a\u01e5\u0003\u01e5\u0005\u01e5\u1551\u000a\u01e5\u0003\u01e5\u0005\u01e5\u1554\u000a\u01e5\u0003\u01e5\u0005\u01e5\u1557\u000a\u01e5\u0003\u01e5\u0005\u01e5\u155a\u000a\u01e5\u0003\u01e6\u0003\u01e6\u0003\u01e6\u0007\u01e6\u155f\u000a\u01e6\u000c\u01e6\u000e\u01e6\u1562\u000b\u01e6\u0005\u01e6\u1564\u000a\u01e6\u0003\u01e7\u0003\u01e7\u0005\u01e7\u1568\u000a\u01e7\u0003\u01e7\u0005\u01e7\u156b\u000a\u01e7\u0003\u01e7\u0003\u01e7\u0005\u01e7\u156f\u000a\u01e7\u0003\u01e8\u0003\u01e8\u0005\u01e8\u1573\u000a\u01e8\u0003\u01e8\u0003\u01e8\u0005\u01e8\u1577\u000a\u01e8\u0003\u01e9\u0003\u01e9\u0006\u01e9\u157b\u000a\u01e9\u000d\u01e9\u000e\u01e9\u157c\u0003\u01ea\u0003\u01ea\u0005\u01ea\u1581\u000a\u01ea\u0003\u01ea\u0005\u01ea\u1584\u000a\u01ea\u0003\u01eb\u0003\u01eb\u0005\u01eb\u1588\u000a\u01eb\u0003\u01eb\u0003\u01eb\u0003\u01ec\u0003\u01ec\u0005\u01ec\u158e\u000a\u01ec\u0003\u01ec\u0003\u01ec\u0003\u01ed\u0005\u01ed\u1593\u000a\u01ed\u0003\u01ed\u0003\u01ed\u0003\u01ed\u0003\u01ee\u0003\u01ee\u0005\u01ee\u159a\u000a\u01ee\u0003\u01ee\u0003\u01ee\u0003\u01ef\u0003\u01ef\u0003\u01ef\u0005\u01ef\u15a1\u000a\u01ef\u0003\u01f0\u0005\u01f0\u15a4\u000a\u01f0\u0003\u01f0\u0003\u01f0\u0005\u01f0\u15a8\u000a\u01f0\u0003\u01f0\u0003\u01f0\u0003\u01f0\u0005\u01f0\u15ad\u000a\u01f0\u0003\u01f0\u0003\u01f0\u0003\u01f1\u0003\u01f1\u0003\u01f1\u0003\u01f1\u0003\u01f1\u0006\u01f1\u15b6\u000a\u01f1\u000d\u01f1\u000e\u01f1\u15b7\u0005\u01f1\u15ba\u000a\u01f1\u0003\u01f2\u0005\u01f2\u15bd\u000a\u01f2\u0003\u01f2\u0003\u01f2\u0005\u01f2\u15c1\u000a\u01f2\u0003\u01f2\u0006\u01f2\u15c4\u000a\u01f2\u000d\u01f2\u000e\u01f2\u15c5\u0003\u01f3\u0003\u01f3\u0003\u01f3\u0003\u01f3\u0005\u01f3\u15cc\u000a\u01f3\u0003\u01f3\u0005\u01f3\u15cf\u000a\u01f3\u0003\u01f3\u0003\u01f3\u0003\u01f3\u0005\u01f3\u15d4\u000a\u01f3\u0003\u01f4\u0003\u01f4\u0003\u01f4\u0005\u01f4\u15d9\u000a\u01f4\u0003\u01f4\u0005\u01f4\u15dc\u000a\u01f4\u0003\u01f4\u0005\u01f4\u15df\u000a\u01f4\u0003\u01f4\u0005\u01f4\u15e2\u000a\u01f4\u0003\u01f4\u0005\u01f4\u15e5\u000a\u01f4\u0003\u01f4\u0005\u01f4\u15e8\u000a\u01f4\u0003\u01f4\u0005\u01f4\u15eb\u000a\u01f4\u0003\u01f5\u0003\u01f5\u0003\u01f5\u0005\u01f5\u15f0\u000a\u01f5\u0003\u01f6\u0003\u01f6\u0005\u01f6\u15f4\u000a\u01f6\u0003\u01f6\u0003\u01f6\u0003\u01f6\u0005\u01f6\u15f9\u000a\u01f6\u0003\u01f7\u0003\u01f7\u0003\u01f8\u0003\u01f8\u0005\u01f8\u15ff\u000a\u01f8\u0003\u01f8\u0005\u01f8\u1602\u000a\u01f8\u0003\u01f9\u0003\u01f9\u0003\u01fa\u0005\u01fa\u1607\u000a\u01fa\u0003\u01fa\u0003\u01fa\u0007\u01fa\u160b\u000a\u01fa\u000c\u01fa\u000e\u01fa\u160e\u000b\u01fa\u0003\u01fb\u0003\u01fb\u0005\u01fb\u1612\u000a\u01fb\u0003\u01fb\u0003\u01fb\u0007\u01fb\u1616\u000a\u01fb\u000c\u01fb\u000e\u01fb\u1619\u000b\u01fb\u0003\u01fc\u0005\u01fc\u161c\u000a\u01fc\u0003\u01fc\u0003\u01fc\u0007\u01fc\u1620\u000a\u01fc\u000c\u01fc\u000e\u01fc\u1623\u000b\u01fc\u0003\u01fd\u0003\u01fd\u0005\u01fd\u1627\u000a\u01fd\u0003\u01fd\u0003\u01fd\u0007\u01fd\u162b\u000a\u01fd\u000c\u01fd\u000e\u01fd\u162e\u000b\u01fd\u0003\u01fe\u0003\u01fe\u0005\u01fe\u1632\u000a\u01fe\u0003\u01fe\u0007\u01fe\u1635\u000a\u01fe\u000c\u01fe\u000e\u01fe\u1638\u000b\u01fe\u0003\u01ff\u0003\u01ff\u0003\u01ff\u0005\u01ff\u163d\u000a\u01ff\u0003\u01ff\u0007\u01ff\u1640\u000a\u01ff\u000c\u01ff\u000e\u01ff\u1643\u000b\u01ff\u0003\u0200\u0005\u0200\u1646\u000a\u0200\u0003\u0200\u0003\u0200\u0007\u0200\u164a\u000a\u0200\u000c\u0200\u000e\u0200\u164d\u000b\u0200\u0003\u0201\u0003\u0201\u0005\u0201\u1651\u000a\u0201\u0003\u0201\u0003\u0201\u0007\u0201\u1655\u000a\u0201\u000c\u0201\u000e\u0201\u1658\u000b\u0201\u0003\u0202\u0005\u0202\u165b\u000a\u0202\u0003\u0202\u0003\u0202\u0003\u0202\u0007\u0202\u1660\u000a\u0202\u000c\u0202\u000e\u0202\u1663\u000b\u0202\u0003\u0203\u0003\u0203\u0005\u0203\u1667\u000a\u0203\u0003\u0203\u0003\u0203\u0003\u0203\u0007\u0203\u166c\u000a\u0203\u000c\u0203\u000e\u0203\u166f\u000b\u0203\u0003\u0204\u0005\u0204\u1672\u000a\u0204\u0003\u0204\u0003\u0204\u0007\u0204\u1676\u000a\u0204\u000c\u0204\u000e\u0204\u1679\u000b\u0204\u0003\u0205\u0003\u0205\u0005\u0205\u167d\u000a\u0205\u0003\u0205\u0003\u0205\u0007\u0205\u1681\u000a\u0205\u000c\u0205\u000e\u0205\u1684\u000b\u0205\u0003\u0206\u0003\u0206\u0007\u0206\u1688\u000a\u0206\u000c\u0206\u000e\u0206\u168b\u000b\u0206\u0003\u0207\u0003\u0207\u0003\u0207\u0003\u0208\u0003\u0208\u0007\u0208\u1692\u000a\u0208\u000c\u0208\u000e\u0208\u1695\u000b\u0208\u0003\u0209\u0003\u0209\u0003\u0209\u0003\u020a\u0005\u020a\u169b\u000a\u020a\u0003\u020a\u0003\u020a\u0007\u020a\u169f\u000a\u020a\u000c\u020a\u000e\u020a\u16a2\u000b\u020a\u0003\u020b\u0003\u020b\u0003\u020b\u0003\u020c\u0003\u020c\u0003\u020c\u0003\u020c\u0003\u020c\u0003\u020c\u0005\u020c\u16ad\u000a\u020c\u0003\u020d\u0003\u020d\u0007\u020d\u16b1\u000a\u020d\u000c\u020d\u000e\u020d\u16b4\u000b\u020d\u0003\u020e\u0003\u020e\u0003\u020e\u0006\u020e\u16b9\u000a\u020e\u000d\u020e\u000e\u020e\u16ba\u0005\u020e\u16bd\u000a\u020e\u0003\u020f\u0005\u020f\u16c0\u000a\u020f\u0003\u020f\u0003\u020f\u0003\u0210\u0003\u0210\u0003\u0210\u0003\u0210\u0003\u0210\u0003\u0210\u0003\u0210\u0005\u0210\u16cb\u000a\u0210\u0003\u0211\u0003\u0211\u0005\u0211\u16cf\u000a\u0211\u0003\u0211\u0005\u0211\u16d2\u000a\u0211\u0003\u0211\u0003\u0211\u0003\u0211\u0003\u0211\u0003\u0211\u0003\u0211\u0003\u0211\u0005\u0211\u16db\u000a\u0211\u0003\u0212\u0003\u0212\u0007\u0212\u16df\u000a\u0212\u000c\u0212\u000e\u0212\u16e2\u000b\u0212\u0003\u0212\u0005\u0212\u16e5\u000a\u0212\u0003\u0212\u0007\u0212\u16e8\u000a\u0212\u000c\u0212\u000e\u0212\u16eb\u000b\u0212\u0003\u0212\u0007\u0212\u16ee\u000a\u0212\u000c\u0212\u000e\u0212\u16f1\u000b\u0212\u0005\u0212\u16f3\u000a\u0212\u0003\u0213\u0003\u0213\u0003\u0213\u0005\u0213\u16f8\u000a\u0213\u0003\u0213\u0007\u0213\u16fb\u000a\u0213\u000c\u0213\u000e\u0213\u16fe\u000b\u0213\u0003\u0213\u0003\u0213\u0003\u0214\u0003\u0214\u0003\u0214\u0005\u0214\u1705\u000a\u0214\u0003\u0215\u0003\u0215\u0005\u0215\u1709\u000a\u0215\u0003\u0215\u0005\u0215\u170c\u000a\u0215\u0003\u0215\u0003\u0215\u0003\u0216\u0003\u0216\u0003\u0216\u0003\u0216\u0003\u0217\u0003\u0217\u0003\u0217\u0003\u0217\u0003\u0217\u0003\u0217\u0003\u0218\u0003\u0218\u0003\u0218\u0006\u0218\u171d\u000a\u0218\u000d\u0218\u000e\u0218\u171e\u0003\u0219\u0005\u0219\u1722\u000a\u0219\u0003\u0219\u0005\u0219\u1725\u000a\u0219\u0003\u0219\u0003\u0219\u0005\u0219\u1729\u000a\u0219\u0003\u0219\u0003\u0219\u0003\u0219\u0005\u0219\u172e\u000a\u0219\u0003\u0219\u0003\u0219\u0003\u0219\u0005\u0219\u1733\u000a\u0219\u0003\u0219\u0005\u0219\u1736\u000a\u0219\u0003\u0219\u0003\u0219\u0003\u0219\u0005\u0219\u173b\u000a\u0219\u0003\u0219\u0003\u0219\u0003\u0219\u0005\u0219\u1740\u000a\u0219\u0003\u0219\u0003\u0219\u0003\u0219\u0005\u0219\u1745\u000a\u0219\u0003\u0219\u0003\u0219\u0003\u0219\u0005\u0219\u174a\u000a\u0219\u0003\u0219\u0005\u0219\u174d\u000a\u0219\u0003\u021a\u0005\u021a\u1750\u000a\u021a\u0003\u021a\u0005\u021a\u1753\u000a\u021a\u0003\u021a\u0003\u021a\u0003\u021a\u0003\u021a\u0003\u021a\u0003\u021a\u0005\u021a\u175b\u000a\u021a\u0003\u021b\u0003\u021b\u0003\u021b\u0003\u021b\u0005\u021b\u1761\u000a\u021b\u0003\u021c\u0003\u021c\u0003\u021c\u0003\u021c\u0005\u021c\u1767\u000a\u021c\u0003\u021c\u0007\u021c\u176a\u000a\u021c\u000c\u021c\u000e\u021c\u176d\u000b\u021c\u0003\u021c\u0003\u021c\u0007\u021c\u1771\u000a\u021c\u000c\u021c\u000e\u021c\u1774\u000b\u021c\u0003\u021c\u0005\u021c\u1777\u000a\u021c\u0003\u021d\u0003\u021d\u0003\u021d\u0003\u021d\u0003\u021d\u0005\u021d\u177e\u000a\u021d\u0003\u021d\u0007\u021d\u1781\u000a\u021d\u000c\u021d\u000e\u021d\u1784\u000b\u021d\u0003\u021d\u0003\u021d\u0007\u021d\u1788\u000a\u021d\u000c\u021d\u000e\u021d\u178b\u000b\u021d\u0003\u021d\u0005\u021d\u178e\u000a\u021d\u0003\u021e\u0003\u021e\u0003\u021e\u0003\u021e\u0005\u021e\u1794\u000a\u021e\u0003\u021e\u0003\u021e\u0003\u021f\u0003\u021f\u0003\u0220\u0003\u0220\u0003\u0221\u0003\u0221\u0003\u0221\u0003\u0221\u0005\u0221\u17a0\u000a\u0221\u0003\u0221\u0003\u0221\u0005\u0221\u17a4\u000a\u0221\u0003\u0221\u0005\u0221\u17a7\u000a\u0221\u0003\u0222\u0003\u0222\u0003\u0222\u0003\u0222\u0005\u0222\u17ad\u000a\u0222\u0003\u0222\u0003\u0222\u0005\u0222\u17b1\u000a\u0222\u0003\u0222\u0005\u0222\u17b4\u000a\u0222\u0003\u0223\u0003\u0223\u0003\u0223\u0003\u0223\u0005\u0223\u17ba\u000a\u0223\u0003\u0224\u0003\u0224\u0005\u0224\u17be\u000a\u0224\u0003\u0224\u0006\u0224\u17c1\u000a\u0224\u000d\u0224\u000e\u0224\u17c2\u0003\u0224\u0005\u0224\u17c6\u000a\u0224\u0003\u0224\u0005\u0224\u17c9\u000a\u0224\u0003\u0225\u0003\u0225\u0003\u0225\u0003\u0226\u0003\u0226\u0003\u0226\u0003\u0227\u0003\u0227\u0003\u0227\u0003\u0228\u0003\u0228\u0005\u0228\u17d6\u000a\u0228\u0003\u0229\u0003\u0229\u0003\u0229\u0003\u022a\u0003\u022a\u0003\u022a\u0003\u022b\u0003\u022b\u0003\u022b\u0003\u022c\u0003\u022c\u0003\u022c\u0003\u022d\u0003\u022d\u0003\u022d\u0003\u022e\u0003\u022e\u0003\u022e\u0003\u022f\u0003\u022f\u0003\u0230\u0003\u0230\u0003\u0231\u0003\u0231\u0003\u0232\u0003\u0232\u0003\u0233\u0003\u0233\u0003\u0234\u0003\u0234\u0003\u0235\u0003\u0235\u0003\u0236\u0003\u0236\u0003\u0237\u0003\u0237\u0003\u0237\u0005\u0237\u17fd\u000a\u0237\u0003\u0238\u0003\u0238\u0003\u0239\u0003\u0239\u0003\u023a\u0003\u023a\u0003\u023a\u0003\u023a\u0003\u023a\u0003\u023a\u0005\u023a\u1809\u000a\u023a\u0003\u023b\u0003\u023b\u0003\u023c\u0003\u023c\u0003\u023d\u0003\u023d\u0003\u023e\u0003\u023e\u0003\u023f\u0003\u023f\u0003\u0240\u0003\u0240\u0005\u0240\u1817\u000a\u0240\u0003\u0241\u0003\u0241\u0005\u0241\u181b\u000a\u0241\u0003\u0241\u0005\u0241\u181e\u000a\u0241\u0003\u0242\u0003\u0242\u0005\u0242\u1822\u000a\u0242\u0003\u0243\u0003\u0243\u0003\u0244\u0003\u0244\u0003\u0245\u0003\u0245\u0003\u0246\u0003\u0246\u0003\u0247\u0003\u0247\u0005\u0247\u182e\u000a\u0247\u0003\u0248\u0003\u0248\u0003\u0249\u0003\u0249\u0003\u024a\u0003\u024a\u0003\u024b\u0003\u024b\u0003\u024c\u0003\u024c\u0003\u024c\u0003\u024c\u0003\u024c\u0003\u024c\u0005\u024c\u183e\u000a\u024c\u0003\u024d\u0003\u024d\u0003\u024e\u0003\u024e\u0003\u024e\u0005\u024e\u1845\u000a\u024e\u0003\u024f\u0003\u024f\u0003\u0250\u0003\u0250\u0003\u0250\u0003\u0250\u0005\u0250\u184d\u000a\u0250\u0003\u0250\u0003\u0250\u0003\u0251\u0003\u0251\u0003\u0251\u0003\u0251\u0005\u0251\u1855\u000a\u0251\u0003\u0251\u0003\u0251\u0003\u0252\u0003\u0252\u0003\u0252\u0003\u0252\u0003\u0252\u0003\u0252\u0003\u0252\u0003\u0252\u0003\u0252\u0003\u0252\u0003\u0252\u0003\u0252\u0003\u0252\u0003\u0252\u0003\u0252\u0005\u0252\u1868\u000a\u0252\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0005\u0253\u1879\u000a\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0003\u0253\u0005\u0253\u188b\u000a\u0253\u0003\u0254\u0006\u0254\u188e\u000a\u0254\u000d\u0254\u000e\u0254\u188f\u0003\u0254\u0002\u0002\u0255\u0002\u0004\u0006\u0008\u000a\u000c\u000e\u0010\u0012\u0014\u0016\u0018\u001a\u001c\u001e\u0020\u0022\u0024\u0026\u0028\u002a\u002c\u002e\u0030\u0032\u0034\u0036\u0038\u003a\u003c\u003e\u0040\u0042\u0044\u0046\u0048\u004a\u004c\u004e\u0050\u0052\u0054\u0056\u0058\u005a\u005c\u005e\u0060\u0062\u0064\u0066\u0068\u006a\u006c\u006e\u0070\u0072\u0074\u0076\u0078\u007a\u007c\u007e\u0080\u0082\u0084\u0086\u0088\u008a\u008c\u008e\u0090\u0092\u0094\u0096\u0098\u009a\u009c\u009e\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa\u00ac\u00ae\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0\u00c2\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce\u00d0\u00d2\u00d4\u00d6\u00d8\u00da\u00dc\u00de\u00e0\u00e2\u00e4\u00e6\u00e8\u00ea\u00ec\u00ee\u00f0\u00f2\u00f4\u00f6\u00f8\u00fa\u00fc\u00fe\u0100\u0102\u0104\u0106\u0108\u010a\u010c\u010e\u0110\u0112\u0114\u0116\u0118\u011a\u011c\u011e\u0120\u0122\u0124\u0126\u0128\u012a\u012c\u012e\u0130\u0132\u0134\u0136\u0138\u013a\u013c\u013e\u0140\u0142\u0144\u0146\u0148\u014a\u014c\u014e\u0150\u0152\u0154\u0156\u0158\u015a\u015c\u015e\u0160\u0162\u0164\u0166\u0168\u016a\u016c\u016e\u0170\u0172\u0174\u0176\u0178\u017a\u017c\u017e\u0180\u0182\u0184\u0186\u0188\u018a\u018c\u018e\u0190\u0192\u0194\u0196\u0198\u019a\u019c\u019e\u01a0\u01a2\u01a4\u01a6\u01a8\u01aa\u01ac\u01ae\u01b0\u01b2\u01b4\u01b6\u01b8\u01ba\u01bc\u01be\u01c0\u01c2\u01c4\u01c6\u01c8\u01ca\u01cc\u01ce\u01d0\u01d2\u01d4\u01d6\u01d8\u01da\u01dc\u01de\u01e0\u01e2\u01e4\u01e6\u01e8\u01ea\u01ec\u01ee\u01f0\u01f2\u01f4\u01f6\u01f8\u01fa\u01fc\u01fe\u0200\u0202\u0204\u0206\u0208\u020a\u020c\u020e\u0210\u0212\u0214\u0216\u0218\u021a\u021c\u021e\u0220\u0222\u0224\u0226\u0228\u022a\u022c\u022e\u0230\u0232\u0234\u0236\u0238\u023a\u023c\u023e\u0240\u0242\u0244\u0246\u0248\u024a\u024c\u024e\u0250\u0252\u0254\u0256\u0258\u025a\u025c\u025e\u0260\u0262\u0264\u0266\u0268\u026a\u026c\u026e\u0270\u0272\u0274\u0276\u0278\u027a\u027c\u027e\u0280\u0282\u0284\u0286\u0288\u028a\u028c\u028e\u0290\u0292\u0294\u0296\u0298\u029a\u029c\u029e\u02a0\u02a2\u02a4\u02a6\u02a8\u02aa\u02ac\u02ae\u02b0\u02b2\u02b4\u02b6\u02b8\u02ba\u02bc\u02be\u02c0\u02c2\u02c4\u02c6\u02c8\u02ca\u02cc\u02ce\u02d0\u02d2\u02d4\u02d6\u02d8\u02da\u02dc\u02de\u02e0\u02e2\u02e4\u02e6\u02e8\u02ea\u02ec\u02ee\u02f0\u02f2\u02f4\u02f6\u02f8\u02fa\u02fc\u02fe\u0300\u0302\u0304\u0306\u0308\u030a\u030c\u030e\u0310\u0312\u0314\u0316\u0318\u031a\u031c\u031e\u0320\u0322\u0324\u0326\u0328\u032a\u032c\u032e\u0330\u0332\u0334\u0336\u0338\u033a\u033c\u033e\u0340\u0342\u0344\u0346\u0348\u034a\u034c\u034e\u0350\u0352\u0354\u0356\u0358\u035a\u035c\u035e\u0360\u0362\u0364\u0366\u0368\u036a\u036c\u036e\u0370\u0372\u0374\u0376\u0378\u037a\u037c\u037e\u0380\u0382\u0384\u0386\u0388\u038a\u038c\u038e\u0390\u0392\u0394\u0396\u0398\u039a\u039c\u039e\u03a0\u03a2\u03a4\u03a6\u03a8\u03aa\u03ac\u03ae\u03b0\u03b2\u03b4\u03b6\u03b8\u03ba\u03bc\u03be\u03c0\u03c2\u03c4\u03c6\u03c8\u03ca\u03cc\u03ce\u03d0\u03d2\u03d4\u03d6\u03d8\u03da\u03dc\u03de\u03e0\u03e2\u03e4\u03e6\u03e8\u03ea\u03ec\u03ee\u03f0\u03f2\u03f4\u03f6\u03f8\u03fa\u03fc\u03fe\u0400\u0402\u0404\u0406\u0408\u040a\u040c\u040e\u0410\u0412\u0414\u0416\u0418\u041a\u041c\u041e\u0420\u0422\u0424\u0426\u0428\u042a\u042c\u042e\u0430\u0432\u0434\u0436\u0438\u043a\u043c\u043e\u0440\u0442\u0444\u0446\u0448\u044a\u044c\u044e\u0450\u0452\u0454\u0456\u0458\u045a\u045c\u045e\u0460\u0462\u0464\u0466\u0468\u046a\u046c\u046e\u0470\u0472\u0474\u0476\u0478\u047a\u047c\u047e\u0480\u0482\u0484\u0486\u0488\u048a\u048c\u048e\u0490\u0492\u0494\u0496\u0498\u049a\u049c\u049e\u04a0\u04a2\u04a4\u04a6\u0002\u0048\u0003\u0002\u00ec\u00ed\u0007\u0002\u0050\u0050\u0084\u0084\u00f5\u00f5\u0114\u0114\u017e\u017e\u0005\u0002\u0041\u0041\u012c\u012c\u0205\u0205\u0004\u0002\u012c\u012c\u0205\u0205\u0003\u0002\u01e5\u01e6\u0004\u0002\u0010\u0010\u0132\u0132\u0004\u0002\u0052\u0052\u0058\u0058\u0004\u0002\u010c\u010c\u01ef\u01ef\u0004\u0002\u0017\u0017\u0100\u0100\u0003\u0002\u0018\u0019\u0005\u0002\u00f3\u00f3\u0184\u0184\u01af\u01af\u0006\u0002\u0098\u0098\u00c7\u00c7\u0173\u0173\u01af\u01af\u0004\u0002\u0180\u0180\u01f5\u01f5\u0005\u0002\u017b\u017b\u01ba\u01ba\u01be\u01be\u0004\u0002\u00cf\u00cf\u01a3\u01a3\u0004\u0002\u0041\u0041\u017d\u017d\u0003\u0002\u01ce\u01d0\u0004\u0002\u0119\u0119\u01a2\u01a2\u0004\u0002\u0028\u0028\u002b\u002b\u0003\u0002\u00bf\u00c0\u0004\u0002\u00e7\u00e7\u0124\u0124\u0005\u0002\u00e4\u00e4\u010e\u010e\u0152\u0152\u0005\u0002\u015e\u015e\u0221\u0221\u0225\u0225\u0003\u0002\u004b\u004c\u0003\u0002\u00d7\u00d8\u0003\u0002\u0025\u0026\u0003\u0002\u015c\u015d\u0003\u0002\u0090\u0091\u0003\u0002\u0101\u0102\u0003\u0002\u0023\u0024\u0004\u0002\u0139\u0139\u01a6\u01a6\u0004\u0002\u009e\u009e\u0190\u0190\u0004\u0002\u00da\u00da\u0110\u0110\u0003\u0002\u0119\u011a\u0004\u0002\u0077\u0077\u008b\u008b\u0005\u0002\u0094\u0094\u0165\u0165\u01b2\u01b3\u0003\u0002\u0034\u0035\u0004\u0002\u022b\u022b\u022d\u022d\u0004\u0002\u020b\u020b\u020d\u020e\u0005\u0002\u0050\u0050\u011e\u011e\u0153\u0153\u0004\u0002\u00fc\u00fc\u01cd\u01cd\u0004\u0002\u001b\u001b\u0089\u0089\u0004\u0002\u0061\u0061\u0181\u0182\u0003\u0002\u01d6\u01d7\u0004\u0002\u010d\u010d\u019d\u019d\u0006\u0002\u0121\u0122\u013f\u013f\u0141\u0141\u01b7\u01b7\u0004\u0002\u00cc\u00cc\u01f1\u01f1\u0004\u0002\u0066\u0066\u0108\u0108\u0004\u0002\u003d\u003d\u01fc\u01fc\u0004\u0002\u00e0\u00e0\u0197\u0197\u0003\u0002\u0069\u006a\u0004\u0002\u0003\u0003\u014d\u014d\u0004\u0002\u00bc\u00bc\u021a\u021a\u0009\u0002\u000d\u000d\u0010\u0011\u0076\u0076\u009a\u009a\u0132\u0133\u013e\u013e\u0140\u0140\u0004\u0002\u000b\u000b\u010c\u010c\u0005\u0002\u000b\u000b\u00d4\u00d4\u010c\u010c\u0004\u0002\u0009\u0009\u0029\u0029\u0004\u0002\u0104\u0104\u0138\u0138\u0004\u0002\u0129\u0129\u01a8\u01a8\u0004\u0002\u0032\u0032\u01ee\u01ee\u0004\u0002\u00be\u00be\u00c6\u00c6\u0004\u0002\u00aa\u00aa\u00bb\u00bb\u0004\u0002\u0221\u0221\u0225\u0225\u0004\u0002\u0210\u0210\u0228\u0228\u0004\u0002\u0015\u0015\u014b\u014b\u0005\u0002\u0135\u0135\u0161\u0161\u020b\u020b\u0004\u0002\u00f1\u00f1\u0145\u0145\u0057\u0002\u0003\u0003\u001a\u001a\u001c\u001c\u001e\u001f\u0021\u0021\u0023\u0026\u0028\u0028\u002b\u002d\u002f\u002f\u0031\u0031\u0038\u0039\u003e\u003f\u0046\u0047\u004f\u004f\u0064\u0064\u0066\u0066\u006c\u006c\u006e\u006e\u0082\u0084\u008c\u008d\u008f\u008f\u0094\u0095\u0099\u0099\u009e\u009e\u00b7\u00b7\u00b9\u00b9\u00bd\u00bd\u00bf\u00c1\u00c4\u00c4\u00c7\u00c7\u00ca\u00ca\u00cc\u00cc\u00d7\u00d8\u00da\u00da\u00dc\u00dd\u00e4\u00e4\u00e7\u00e7\u00ef\u00f0\u00fc\u00fc\u0104\u0104\u0106\u0106\u0108\u0108\u010a\u010b\u010e\u010e\u0110\u0110\u0112\u0114\u011d\u011e\u0121\u0124\u012a\u012a\u0131\u0133\u0136\u0136\u0139\u0139\u013f\u013f\u0141\u0141\u0144\u0144\u014d\u014d\u0152\u0153\u0158\u0158\u0162\u0163\u0165\u0165\u016a\u016b\u016e\u016e\u0174\u0175\u0177\u0177\u017a\u017a\u017e\u017e\u0181\u0181\u0189\u0189\u0190\u0190\u0193\u0193\u01a1\u01a1\u01a6\u01a6\u01b1\u01b4\u01b7\u01b7\u01d4\u01d4\u01db\u01db\u01e3\u01e4\u01e8\u01e8\u01ec\u01ed\u01f1\u01f1\u01f3\u01f4\u0200\u0201\u0208\u020a\u020c\u020c\u022f\u022f\u0004\u0002\u00ce\u00ce\u01f0\u01f0\u0003\u0002\u022a\u022d\u0002\u1b95\u0002\u04a8\u0003\u0002\u0002\u0002\u0004\u04ac\u0003\u0002\u0002\u0002\u0006\u04b0\u0003\u0002\u0002\u0002\u0008\u04c3\u0003\u0002\u0002\u0002\u000a\u04c8\u0003\u0002\u0002\u0002\u000c\u04d8\u0003\u0002\u0002\u0002\u000e\u04da\u0003\u0002\u0002\u0002\u0010\u04ec\u0003\u0002\u0002\u0002\u0012\u04f1\u0003\u0002\u0002\u0002\u0014\u04f6\u0003\u0002\u0002\u0002\u0016\u04fb\u0003\u0002\u0002\u0002\u0018\u0500\u0003\u0002\u0002\u0002\u001a\u0505\u0003\u0002\u0002\u0002\u001c\u050a\u0003\u0002\u0002\u0002\u001e\u0516\u0003\u0002\u0002\u0002\u0020\u0518\u0003\u0002\u0002\u0002\u0022\u0524\u0003\u0002\u0002\u0002\u0024\u0526\u0003\u0002\u0002\u0002\u0026\u0532\u0003\u0002\u0002\u0002\u0028\u0542\u0003\u0002\u0002\u0002\u002a\u0544\u0003\u0002\u0002\u0002\u002c\u054f\u0003\u0002\u0002\u0002\u002e\u055e\u0003\u0002\u0002\u0002\u0030\u0573\u0003\u0002\u0002\u0002\u0032\u057c\u0003\u0002\u0002\u0002\u0034\u0584\u0003\u0002\u0002\u0002\u0036\u058a\u0003\u0002\u0002\u0002\u0038\u058e\u0003\u0002\u0002\u0002\u003a\u05a4\u0003\u0002\u0002\u0002\u003c\u05a8\u0003\u0002\u0002\u0002\u003e\u05aa\u0003\u0002\u0002\u0002\u0040\u05c0\u0003\u0002\u0002\u0002\u0042\u05c9\u0003\u0002\u0002\u0002\u0044\u05cc\u0003\u0002\u0002\u0002\u0046\u05d2\u0003\u0002\u0002\u0002\u0048\u05e0\u0003\u0002\u0002\u0002\u004a\u05e7\u0003\u0002\u0002\u0002\u004c\u05f7\u0003\u0002\u0002\u0002\u004e\u05fe\u0003\u0002\u0002\u0002\u0050\u0602\u0003\u0002\u0002\u0002\u0052\u0604\u0003\u0002\u0002\u0002\u0054\u0614\u0003\u0002\u0002\u0002\u0056\u061a\u0003\u0002\u0002\u0002\u0058\u062b\u0003\u0002\u0002\u0002\u005a\u0642\u0003\u0002\u0002\u0002\u005c\u0668\u0003\u0002\u0002\u0002\u005e\u066a\u0003\u0002\u0002\u0002\u0060\u0670\u0003\u0002\u0002\u0002\u0062\u067e\u0003\u0002\u0002\u0002\u0064\u0692\u0003\u0002\u0002\u0002\u0066\u069e\u0003\u0002\u0002\u0002\u0068\u06a9\u0003\u0002\u0002\u0002\u006a\u06ab\u0003\u0002\u0002\u0002\u006c\u06b7\u0003\u0002\u0002\u0002\u006e\u06be\u0003\u0002\u0002\u0002\u0070\u06cf\u0003\u0002\u0002\u0002\u0072\u06d1\u0003\u0002\u0002\u0002\u0074\u06e2\u0003\u0002\u0002\u0002\u0076\u06f1\u0003\u0002\u0002\u0002\u0078\u06fc\u0003\u0002\u0002\u0002\u007a\u0707\u0003\u0002\u0002\u0002\u007c\u0711\u0003\u0002\u0002\u0002\u007e\u071a\u0003\u0002\u0002\u0002\u0080\u072b\u0003\u0002\u0002\u0002\u0082\u073d\u0003\u0002\u0002\u0002\u0084\u0744\u0003\u0002\u0002\u0002\u0086\u074e\u0003\u0002\u0002\u0002\u0088\u0757\u0003\u0002\u0002\u0002\u008a\u076b\u0003\u0002\u0002\u0002\u008c\u076d\u0003\u0002\u0002\u0002\u008e\u077b\u0003\u0002\u0002\u0002\u0090\u077f\u0003\u0002\u0002\u0002\u0092\u0788\u0003\u0002\u0002\u0002\u0094\u078c\u0003\u0002\u0002\u0002\u0096\u079b\u0003\u0002\u0002\u0002\u0098\u07a8\u0003\u0002\u0002\u0002\u009a\u07ad\u0003\u0002\u0002\u0002\u009c\u07b4\u0003\u0002\u0002\u0002\u009e\u07c6\u0003\u0002\u0002\u0002\u00a0\u07c8\u0003\u0002\u0002\u0002\u00a2\u07d1\u0003\u0002\u0002\u0002\u00a4\u07ee\u0003\u0002\u0002\u0002\u00a6\u07f1\u0003\u0002\u0002\u0002\u00a8\u07f6\u0003\u0002\u0002\u0002\u00aa\u07fa\u0003\u0002\u0002\u0002\u00ac\u0805\u0003\u0002\u0002\u0002\u00ae\u0808\u0003\u0002\u0002\u0002\u00b0\u080f\u0003\u0002\u0002\u0002\u00b2\u0816\u0003\u0002\u0002\u0002\u00b4\u0833\u0003\u0002\u0002\u0002\u00b6\u083a\u0003\u0002\u0002\u0002\u00b8\u083d\u0003\u0002\u0002\u0002\u00ba\u0851\u0003\u0002\u0002\u0002\u00bc\u0858\u0003\u0002\u0002\u0002\u00be\u0860\u0003\u0002\u0002\u0002\u00c0\u0870\u0003\u0002\u0002\u0002\u00c2\u0884\u0003\u0002\u0002\u0002\u00c4\u0887\u0003\u0002\u0002\u0002\u00c6\u0892\u0003\u0002\u0002\u0002\u00c8\u089d\u0003\u0002\u0002\u0002\u00ca\u08a7\u0003\u0002\u0002\u0002\u00cc\u08b0\u0003\u0002\u0002\u0002\u00ce\u08b2\u0003\u0002\u0002\u0002\u00d0\u08c0\u0003\u0002\u0002\u0002\u00d2\u08c7\u0003\u0002\u0002\u0002\u00d4\u08d0\u0003\u0002\u0002\u0002\u00d6\u08d5\u0003\u0002\u0002\u0002\u00d8\u08de\u0003\u0002\u0002\u0002\u00da\u08e7\u0003\u0002\u0002\u0002\u00dc\u08f4\u0003\u0002\u0002\u0002\u00de\u08f6\u0003\u0002\u0002\u0002\u00e0\u0912\u0003\u0002\u0002\u0002\u00e2\u0925\u0003\u0002\u0002\u0002\u00e4\u093c\u0003\u0002\u0002\u0002\u00e6\u0943\u0003\u0002\u0002\u0002\u00e8\u0951\u0003\u0002\u0002\u0002\u00ea\u0958\u0003\u0002\u0002\u0002\u00ec\u0960\u0003\u0002\u0002\u0002\u00ee\u0968\u0003\u0002\u0002\u0002\u00f0\u096f\u0003\u0002\u0002\u0002\u00f2\u0976\u0003\u0002\u0002\u0002\u00f4\u097e\u0003\u0002\u0002\u0002\u00f6\u0987\u0003\u0002\u0002\u0002\u00f8\u0990\u0003\u0002\u0002\u0002\u00fa\u0999\u0003\u0002\u0002\u0002\u00fc\u09a2\u0003\u0002\u0002\u0002\u00fe\u09aa\u0003\u0002\u0002\u0002\u0100\u09b1\u0003\u0002\u0002\u0002\u0102\u09c0\u0003\u0002\u0002\u0002\u0104\u09c9\u0003\u0002\u0002\u0002\u0106\u09f3\u0003\u0002\u0002\u0002\u0108\u09f6\u0003\u0002\u0002\u0002\u010a\u09f8\u0003\u0002\u0002\u0002\u010c\u09fa\u0003\u0002\u0002\u0002\u010e\u09fd\u0003\u0002\u0002\u0002\u0110\u09ff\u0003\u0002\u0002\u0002\u0112\u0a01\u0003\u0002\u0002\u0002\u0114\u0a03\u0003\u0002\u0002\u0002\u0116\u0a05\u0003\u0002\u0002\u0002\u0118\u0a0d\u0003\u0002\u0002\u0002\u011a\u0a1b\u0003\u0002\u0002\u0002\u011c\u0a29\u0003\u0002\u0002\u0002\u011e\u0a31\u0003\u0002\u0002\u0002\u0120\u0a39\u0003\u0002\u0002\u0002\u0122\u0a3f\u0003\u0002\u0002\u0002\u0124\u0a45\u0003\u0002\u0002\u0002\u0126\u0a4b\u0003\u0002\u0002\u0002\u0128\u0a53\u0003\u0002\u0002\u0002\u012a\u0a56\u0003\u0002\u0002\u0002\u012c\u0a59\u0003\u0002\u0002\u0002\u012e\u0a5f\u0003\u0002\u0002\u0002\u0130\u0a65\u0003\u0002\u0002\u0002\u0132\u0a6d\u0003\u0002\u0002\u0002\u0134\u0a76\u0003\u0002\u0002\u0002\u0136\u0a78\u0003\u0002\u0002\u0002\u0138\u0a7a\u0003\u0002\u0002\u0002\u013a\u0a7c\u0003\u0002\u0002\u0002\u013c\u0a8a\u0003\u0002\u0002\u0002\u013e\u0a8f\u0003\u0002\u0002\u0002\u0140\u0a91\u0003\u0002\u0002\u0002\u0142\u0a93\u0003\u0002\u0002\u0002\u0144\u0a9c\u0003\u0002\u0002\u0002\u0146\u0aa2\u0003\u0002\u0002\u0002\u0148\u0ab9\u0003\u0002\u0002\u0002\u014a\u0abd\u0003\u0002\u0002\u0002\u014c\u0acc\u0003\u0002\u0002\u0002\u014e\u0acf\u0003\u0002\u0002\u0002\u0150\u0ad3\u0003\u0002\u0002\u0002\u0152\u0ad7\u0003\u0002\u0002\u0002\u0154\u0add\u0003\u0002\u0002\u0002\u0156\u0adf\u0003\u0002\u0002\u0002\u0158\u0aed\u0003\u0002\u0002\u0002\u015a\u0af7\u0003\u0002\u0002\u0002\u015c\u0b10\u0003\u0002\u0002\u0002\u015e\u0b16\u0003\u0002\u0002\u0002\u0160\u0b1f\u0003\u0002\u0002\u0002\u0162\u0b23\u0003\u0002\u0002\u0002\u0164\u0b28\u0003\u0002\u0002\u0002\u0166\u0b34\u0003\u0002\u0002\u0002\u0168\u0b3c\u0003\u0002\u0002\u0002\u016a\u0b3f\u0003\u0002\u0002\u0002\u016c\u0b49\u0003\u0002\u0002\u0002\u016e\u0b4c\u0003\u0002\u0002\u0002\u0170\u0b4f\u0003\u0002\u0002\u0002\u0172\u0b55\u0003\u0002\u0002\u0002\u0174\u0b5d\u0003\u0002\u0002\u0002\u0176\u0b66\u0003\u0002\u0002\u0002\u0178\u0b6c\u0003\u0002\u0002\u0002\u017a\u0b84\u0003\u0002\u0002\u0002\u017c\u0b94\u0003\u0002\u0002\u0002\u017e\u0b99\u0003\u0002\u0002\u0002\u0180\u0b9e\u0003\u0002\u0002\u0002\u0182\u0ba4\u0003\u0002\u0002\u0002\u0184\u0ba9\u0003\u0002\u0002\u0002\u0186\u0bb3\u0003\u0002\u0002\u0002\u0188\u0bba\u0003\u0002\u0002\u0002\u018a\u0bbf\u0003\u0002\u0002\u0002\u018c\u0bc1\u0003\u0002\u0002\u0002\u018e\u0bc7\u0003\u0002\u0002\u0002\u0190\u0bd2\u0003\u0002\u0002\u0002\u0192\u0bd4\u0003\u0002\u0002\u0002\u0194\u0bdd\u0003\u0002\u0002\u0002\u0196\u0bed\u0003\u0002\u0002\u0002\u0198\u0bf5\u0003\u0002\u0002\u0002\u019a\u0c06\u0003\u0002\u0002\u0002\u019c\u0c0a\u0003\u0002\u0002\u0002\u019e\u0c10\u0003\u0002\u0002\u0002\u01a0\u0c16\u0003\u0002\u0002\u0002\u01a2\u0c1b\u0003\u0002\u0002\u0002\u01a4\u0c29\u0003\u0002\u0002\u0002\u01a6\u0c2c\u0003\u0002\u0002\u0002\u01a8\u0c2f\u0003\u0002\u0002\u0002\u01aa\u0c37\u0003\u0002\u0002\u0002\u01ac\u0c39\u0003\u0002\u0002\u0002\u01ae\u0c41\u0003\u0002\u0002\u0002\u01b0\u0c44\u0003\u0002\u0002\u0002\u01b2\u0c49\u0003\u0002\u0002\u0002\u01b4\u0c51\u0003\u0002\u0002\u0002\u01b6\u0c53\u0003\u0002\u0002\u0002\u01b8\u0c74\u0003\u0002\u0002\u0002\u01ba\u0c79\u0003\u0002\u0002\u0002\u01bc\u0c7f\u0003\u0002\u0002\u0002\u01be\u0c86\u0003\u0002\u0002\u0002\u01c0\u0c88\u0003\u0002\u0002\u0002\u01c2\u0c8e\u0003\u0002\u0002\u0002\u01c4\u0c91\u0003\u0002\u0002\u0002\u01c6\u0c99\u0003\u0002\u0002\u0002\u01c8\u0c9d\u0003\u0002\u0002\u0002\u01ca\u0c9f\u0003\u0002\u0002\u0002\u01cc\u0ca3\u0003\u0002\u0002\u0002\u01ce\u0cc6\u0003\u0002\u0002\u0002\u01d0\u0cc9\u0003\u0002\u0002\u0002\u01d2\u0cd5\u0003\u0002\u0002\u0002\u01d4\u0ce3\u0003\u0002\u0002\u0002\u01d6\u0cf7\u0003\u0002\u0002\u0002\u01d8\u0cf9\u0003\u0002\u0002\u0002\u01da\u0cfe\u0003\u0002\u0002\u0002\u01dc\u0d05\u0003\u0002\u0002\u0002\u01de\u0d08\u0003\u0002\u0002\u0002\u01e0\u0d0b\u0003\u0002\u0002\u0002\u01e2\u0d15\u0003\u0002\u0002\u0002\u01e4\u0d1e\u0003\u0002\u0002\u0002\u01e6\u0d23\u0003\u0002\u0002\u0002\u01e8\u0d27\u0003\u0002\u0002\u0002\u01ea\u0d2e\u0003\u0002\u0002\u0002\u01ec\u0d36\u0003\u0002\u0002\u0002\u01ee\u0d5b\u0003\u0002\u0002\u0002\u01f0\u0d6c\u0003\u0002\u0002\u0002\u01f2\u0d78\u0003\u0002\u0002\u0002\u01f4\u0d7e\u0003\u0002\u0002\u0002\u01f6\u0d80\u0003\u0002\u0002\u0002\u01f8\u0d84\u0003\u0002\u0002\u0002\u01fa\u0d89\u0003\u0002\u0002\u0002\u01fc\u0d97\u0003\u0002\u0002\u0002\u01fe\u0d9d\u0003\u0002\u0002\u0002\u0200\u0da2\u0003\u0002\u0002\u0002\u0202\u0da8\u0003\u0002\u0002\u0002\u0204\u0db7\u0003\u0002\u0002\u0002\u0206\u0dba\u0003\u0002\u0002\u0002\u0208\u0dc5\u0003\u0002\u0002\u0002\u020a\u0dc7\u0003\u0002\u0002\u0002\u020c\u0dd2\u0003\u0002\u0002\u0002\u020e\u0dd8\u0003\u0002\u0002\u0002\u0210\u0ddd\u0003\u0002\u0002\u0002\u0212\u0de4\u0003\u0002\u0002\u0002\u0214\u0deb\u0003\u0002\u0002\u0002\u0216\u0df4\u0003\u0002\u0002\u0002\u0218\u0e02\u0003\u0002\u0002\u0002\u021a\u0e38\u0003\u0002\u0002\u0002\u021c\u0e3a\u0003\u0002\u0002\u0002\u021e\u0e4b\u0003\u0002\u0002\u0002\u0220\u0e61\u0003\u0002\u0002\u0002\u0222\u0e64\u0003\u0002\u0002\u0002\u0224\u0e69\u0003\u0002\u0002\u0002\u0226\u0e6d\u0003\u0002\u0002\u0002\u0228\u0e7d\u0003\u0002\u0002\u0002\u022a\u0e88\u0003\u0002\u0002\u0002\u022c\u0e9a\u0003\u0002\u0002\u0002\u022e\u0ea1\u0003\u0002\u0002\u0002\u0230\u0ea3\u0003\u0002\u0002\u0002\u0232\u0ea9\u0003\u0002\u0002\u0002\u0234\u0eab\u0003\u0002\u0002\u0002\u0236\u0eaf\u0003\u0002\u0002\u0002\u0238\u0eb5\u0003\u0002\u0002\u0002\u023a\u0ebb\u0003\u0002\u0002\u0002\u023c\u0ec3\u0003\u0002\u0002\u0002\u023e\u0eda\u0003\u0002\u0002\u0002\u0240\u0ee3\u0003\u0002\u0002\u0002\u0242\u0ee9\u0003\u0002\u0002\u0002\u0244\u0efc\u0003\u0002\u0002\u0002\u0246\u0eff\u0003\u0002\u0002\u0002\u0248\u0f0d\u0003\u0002\u0002\u0002\u024a\u0f14\u0003\u0002\u0002\u0002\u024c\u0f27\u0003\u0002\u0002\u0002\u024e\u0f29\u0003\u0002\u0002\u0002\u0250\u0f2c\u0003\u0002\u0002\u0002\u0252\u0f37\u0003\u0002\u0002\u0002\u0254\u0f39\u0003\u0002\u0002\u0002\u0256\u0f3f\u0003\u0002\u0002\u0002\u0258\u0f45\u0003\u0002\u0002\u0002\u025a\u0f57\u0003\u0002\u0002\u0002\u025c\u0f65\u0003\u0002\u0002\u0002\u025e\u0f72\u0003\u0002\u0002\u0002\u0260\u0f74\u0003\u0002\u0002\u0002\u0262\u0f7a\u0003\u0002\u0002\u0002\u0264\u0f7f\u0003\u0002\u0002\u0002\u0266\u0f87\u0003\u0002\u0002\u0002\u0268\u0f98\u0003\u0002\u0002\u0002\u026a\u0f9c\u0003\u0002\u0002\u0002\u026c\u0f9e\u0003\u0002\u0002\u0002\u026e\u0fac\u0003\u0002\u0002\u0002\u0270\u0fbf\u0003\u0002\u0002\u0002\u0272\u0fd0\u0003\u0002\u0002\u0002\u0274\u0fd2\u0003\u0002\u0002\u0002\u0276\u0fd7\u0003\u0002\u0002\u0002\u0278\u0fdd\u0003\u0002\u0002\u0002\u027a\u0fe2\u0003\u0002\u0002\u0002\u027c\u0ff8\u0003\u0002\u0002\u0002\u027e\u0ffe\u0003\u0002\u0002\u0002\u0280\u1006\u0003\u0002\u0002\u0002\u0282\u100e\u0003\u0002\u0002\u0002\u0284\u1014\u0003\u0002\u0002\u0002\u0286\u1018\u0003\u0002\u0002\u0002\u0288\u101c\u0003\u0002\u0002\u0002\u028a\u101f\u0003\u0002\u0002\u0002\u028c\u1032\u0003\u0002\u0002\u0002\u028e\u103c\u0003\u0002\u0002\u0002\u0290\u1053\u0003\u0002\u0002\u0002\u0292\u1055\u0003\u0002\u0002\u0002\u0294\u1059\u0003\u0002\u0002\u0002\u0296\u1063\u0003\u0002\u0002\u0002\u0298\u1075\u0003\u0002\u0002\u0002\u029a\u1077\u0003\u0002\u0002\u0002\u029c\u107a\u0003\u0002\u0002\u0002\u029e\u107d\u0003\u0002\u0002\u0002\u02a0\u1088\u0003\u0002\u0002\u0002\u02a2\u108b\u0003\u0002\u0002\u0002\u02a4\u1090\u0003\u0002\u0002\u0002\u02a6\u1095\u0003\u0002\u0002\u0002\u02a8\u1099\u0003\u0002\u0002\u0002\u02aa\u10a7\u0003\u0002\u0002\u0002\u02ac\u10a9\u0003\u0002\u0002\u0002\u02ae\u10ad\u0003\u0002\u0002\u0002\u02b0\u10b0\u0003\u0002\u0002\u0002\u02b2\u10b2\u0003\u0002\u0002\u0002\u02b4\u10ba\u0003\u0002\u0002\u0002\u02b6\u10c9\u0003\u0002\u0002\u0002\u02b8\u10cb\u0003\u0002\u0002\u0002\u02ba\u10d5\u0003\u0002\u0002\u0002\u02bc\u10e1\u0003\u0002\u0002\u0002\u02be\u10ec\u0003\u0002\u0002\u0002\u02c0\u10f5\u0003\u0002\u0002\u0002\u02c2\u10fb\u0003\u0002\u0002\u0002\u02c4\u1104\u0003\u0002\u0002\u0002\u02c6\u110a\u0003\u0002\u0002\u0002\u02c8\u1112\u0003\u0002\u0002\u0002\u02ca\u1118\u0003\u0002\u0002\u0002\u02cc\u111f\u0003\u0002\u0002\u0002\u02ce\u112a\u0003\u0002\u0002\u0002\u02d0\u1136\u0003\u0002\u0002\u0002\u02d2\u113e\u0003\u0002\u0002\u0002\u02d4\u1145\u0003\u0002\u0002\u0002\u02d6\u114d\u0003\u0002\u0002\u0002\u02d8\u1153\u0003\u0002\u0002\u0002\u02da\u115b\u0003\u0002\u0002\u0002\u02dc\u1165\u0003\u0002\u0002\u0002\u02de\u116e\u0003\u0002\u0002\u0002\u02e0\u1173\u0003\u0002\u0002\u0002\u02e2\u1178\u0003\u0002\u0002\u0002\u02e4\u1180\u0003\u0002\u0002\u0002\u02e6\u119a\u0003\u0002\u0002\u0002\u02e8\u11a6\u0003\u0002\u0002\u0002\u02ea\u11b8\u0003\u0002\u0002\u0002\u02ec\u11bf\u0003\u0002\u0002\u0002\u02ee\u11c7\u0003\u0002\u0002\u0002\u02f0\u11cd\u0003\u0002\u0002\u0002\u02f2\u11d6\u0003\u0002\u0002\u0002\u02f4\u11d9\u0003\u0002\u0002\u0002\u02f6\u11df\u0003\u0002\u0002\u0002\u02f8\u11eb\u0003\u0002\u0002\u0002\u02fa\u11f3\u0003\u0002\u0002\u0002\u02fc\u11fc\u0003\u0002\u0002\u0002\u02fe\u11fe\u0003\u0002\u0002\u0002\u0300\u1206\u0003\u0002\u0002\u0002\u0302\u1208\u0003\u0002\u0002\u0002\u0304\u121c\u0003\u0002\u0002\u0002\u0306\u1220\u0003\u0002\u0002\u0002\u0308\u1224\u0003\u0002\u0002\u0002\u030a\u122d\u0003\u0002\u0002\u0002\u030c\u122f\u0003\u0002\u0002\u0002\u030e\u1233\u0003\u0002\u0002\u0002\u0310\u123c\u0003\u0002\u0002\u0002\u0312\u1242\u0003\u0002\u0002\u0002\u0314\u124b\u0003\u0002\u0002\u0002\u0316\u1251\u0003\u0002\u0002\u0002\u0318\u1259\u0003\u0002\u0002\u0002\u031a\u125f\u0003\u0002\u0002\u0002\u031c\u1265\u0003\u0002\u0002\u0002\u031e\u126b\u0003\u0002\u0002\u0002\u0320\u1275\u0003\u0002\u0002\u0002\u0322\u1280\u0003\u0002\u0002\u0002\u0324\u1284\u0003\u0002\u0002\u0002\u0326\u1289\u0003\u0002\u0002\u0002\u0328\u1295\u0003\u0002\u0002\u0002\u032a\u1297\u0003\u0002\u0002\u0002\u032c\u12a1\u0003\u0002\u0002\u0002\u032e\u12a7\u0003\u0002\u0002\u0002\u0330\u12aa\u0003\u0002\u0002\u0002\u0332\u12b0\u0003\u0002\u0002\u0002\u0334\u12b7\u0003\u0002\u0002\u0002\u0336\u12bc\u0003\u0002\u0002\u0002\u0338\u12c2\u0003\u0002\u0002\u0002\u033a\u12e2\u0003\u0002\u0002\u0002\u033c\u12e6\u0003\u0002\u0002\u0002\u033e\u12ed\u0003\u0002\u0002\u0002\u0340\u12f3\u0003\u0002\u0002\u0002\u0342\u1301\u0003\u0002\u0002\u0002\u0344\u1314\u0003\u0002\u0002\u0002\u0346\u1316\u0003\u0002\u0002\u0002\u0348\u1322\u0003\u0002\u0002\u0002\u034a\u132a\u0003\u0002\u0002\u0002\u034c\u1332\u0003\u0002\u0002\u0002\u034e\u133b\u0003\u0002\u0002\u0002\u0350\u1340\u0003\u0002\u0002\u0002\u0352\u1346\u0003\u0002\u0002\u0002\u0354\u134e\u0003\u0002\u0002\u0002\u0356\u1354\u0003\u0002\u0002\u0002\u0358\u135a\u0003\u0002\u0002\u0002\u035a\u1369\u0003\u0002\u0002\u0002\u035c\u136c\u0003\u0002\u0002\u0002\u035e\u137a\u0003\u0002\u0002\u0002\u0360\u137d\u0003\u0002\u0002\u0002\u0362\u1390\u0003\u0002\u0002\u0002\u0364\u1393\u0003\u0002\u0002\u0002\u0366\u139f\u0003\u0002\u0002\u0002\u0368\u13ac\u0003\u0002\u0002\u0002\u036a\u13ba\u0003\u0002\u0002\u0002\u036c\u13be\u0003\u0002\u0002\u0002\u036e\u13c1\u0003\u0002\u0002\u0002\u0370\u13c8\u0003\u0002\u0002\u0002\u0372\u13cc\u0003\u0002\u0002\u0002\u0374\u13d5\u0003\u0002\u0002\u0002\u0376\u13d9\u0003\u0002\u0002\u0002\u0378\u13de\u0003\u0002\u0002\u0002\u037a\u13e0\u0003\u0002\u0002\u0002\u037c\u13ea\u0003\u0002\u0002\u0002\u037e\u13f5\u0003\u0002\u0002\u0002\u0380\u1401\u0003\u0002\u0002\u0002\u0382\u140c\u0003\u0002\u0002\u0002\u0384\u1410\u0003\u0002\u0002\u0002\u0386\u1412\u0003\u0002\u0002\u0002\u0388\u1432\u0003\u0002\u0002\u0002\u038a\u143e\u0003\u0002\u0002\u0002\u038c\u1448\u0003\u0002\u0002\u0002\u038e\u145a\u0003\u0002\u0002\u0002\u0390\u1461\u0003\u0002\u0002\u0002\u0392\u1469\u0003\u0002\u0002\u0002\u0394\u1472\u0003\u0002\u0002\u0002\u0396\u1475\u0003\u0002\u0002\u0002\u0398\u147b\u0003\u0002\u0002\u0002\u039a\u1484\u0003\u0002\u0002\u0002\u039c\u1487\u0003\u0002\u0002\u0002\u039e\u148d\u0003\u0002\u0002\u0002\u03a0\u1499\u0003\u0002\u0002\u0002\u03a2\u14a7\u0003\u0002\u0002\u0002\u03a4\u14ca\u0003\u0002\u0002\u0002\u03a6\u14cf\u0003\u0002\u0002\u0002\u03a8\u14e3\u0003\u0002\u0002\u0002\u03aa\u14ed\u0003\u0002\u0002\u0002\u03ac\u14ef\u0003\u0002\u0002\u0002\u03ae\u14f8\u0003\u0002\u0002\u0002\u03b0\u14fd\u0003\u0002\u0002\u0002\u03b2\u1501\u0003\u0002\u0002\u0002\u03b4\u1506\u0003\u0002\u0002\u0002\u03b6\u1516\u0003\u0002\u0002\u0002\u03b8\u1521\u0003\u0002\u0002\u0002\u03ba\u152d\u0003\u0002\u0002\u0002\u03bc\u1534\u0003\u0002\u0002\u0002\u03be\u1536\u0003\u0002\u0002\u0002\u03c0\u153c\u0003\u0002\u0002\u0002\u03c2\u153e\u0003\u0002\u0002\u0002\u03c4\u1542\u0003\u0002\u0002\u0002\u03c6\u1546\u0003\u0002\u0002\u0002\u03c8\u1549\u0003\u0002\u0002\u0002\u03ca\u155b\u0003\u0002\u0002\u0002\u03cc\u1565\u0003\u0002\u0002\u0002\u03ce\u1570\u0003\u0002\u0002\u0002\u03d0\u1578\u0003\u0002\u0002\u0002\u03d2\u157e\u0003\u0002\u0002\u0002\u03d4\u1585\u0003\u0002\u0002\u0002\u03d6\u158b\u0003\u0002\u0002\u0002\u03d8\u1592\u0003\u0002\u0002\u0002\u03da\u1597\u0003\u0002\u0002\u0002\u03dc\u159d\u0003\u0002\u0002\u0002\u03de\u15a3\u0003\u0002\u0002\u0002\u03e0\u15b9\u0003\u0002\u0002\u0002\u03e2\u15bc\u0003\u0002\u0002\u0002\u03e4\u15d3\u0003\u0002\u0002\u0002\u03e6\u15d5\u0003\u0002\u0002\u0002\u03e8\u15ec\u0003\u0002\u0002\u0002\u03ea\u15f1\u0003\u0002\u0002\u0002\u03ec\u15fa\u0003\u0002\u0002\u0002\u03ee\u15fe\u0003\u0002\u0002\u0002\u03f0\u1603\u0003\u0002\u0002\u0002\u03f2\u1606\u0003\u0002\u0002\u0002\u03f4\u160f\u0003\u0002\u0002\u0002\u03f6\u161b\u0003\u0002\u0002\u0002\u03f8\u1624\u0003\u0002\u0002\u0002\u03fa\u162f\u0003\u0002\u0002\u0002\u03fc\u1639\u0003\u0002\u0002\u0002\u03fe\u1645\u0003\u0002\u0002\u0002\u0400\u164e\u0003\u0002\u0002\u0002\u0402\u165a\u0003\u0002\u0002\u0002\u0404\u1664\u0003\u0002\u0002\u0002\u0406\u1671\u0003\u0002\u0002\u0002\u0408\u167a\u0003\u0002\u0002\u0002\u040a\u1685\u0003\u0002\u0002\u0002\u040c\u168c\u0003\u0002\u0002\u0002\u040e\u168f\u0003\u0002\u0002\u0002\u0410\u1696\u0003\u0002\u0002\u0002\u0412\u169a\u0003\u0002\u0002\u0002\u0414\u16a3\u0003\u0002\u0002\u0002\u0416\u16ac\u0003\u0002\u0002\u0002\u0418\u16ae\u0003\u0002\u0002\u0002\u041a\u16b5\u0003\u0002\u0002\u0002\u041c\u16bf\u0003\u0002\u0002\u0002\u041e\u16ca\u0003\u0002\u0002\u0002\u0420\u16cc\u0003\u0002\u0002\u0002\u0422\u16dc\u0003\u0002\u0002\u0002\u0424\u16f4\u0003\u0002\u0002\u0002\u0426\u1704\u0003\u0002\u0002\u0002\u0428\u1706\u0003\u0002\u0002\u0002\u042a\u170f\u0003\u0002\u0002\u0002\u042c\u1713\u0003\u0002\u0002\u0002\u042e\u1719\u0003\u0002\u0002\u0002\u0430\u1721\u0003\u0002\u0002\u0002\u0432\u174f\u0003\u0002\u0002\u0002\u0434\u1760\u0003\u0002\u0002\u0002\u0436\u1762\u0003\u0002\u0002\u0002\u0438\u1778\u0003\u0002\u0002\u0002\u043a\u178f\u0003\u0002\u0002\u0002\u043c\u1797\u0003\u0002\u0002\u0002\u043e\u1799\u0003\u0002\u0002\u0002\u0440\u17a6\u0003\u0002\u0002\u0002\u0442\u17b3\u0003\u0002\u0002\u0002\u0444\u17b9\u0003\u0002\u0002\u0002\u0446\u17bd\u0003\u0002\u0002\u0002\u0448\u17ca\u0003\u0002\u0002\u0002\u044a\u17cd\u0003\u0002\u0002\u0002\u044c\u17d0\u0003\u0002\u0002\u0002\u044e\u17d5\u0003\u0002\u0002\u0002\u0450\u17d7\u0003\u0002\u0002\u0002\u0452\u17da\u0003\u0002\u0002\u0002\u0454\u17dd\u0003\u0002\u0002\u0002\u0456\u17e0\u0003\u0002\u0002\u0002\u0458\u17e3\u0003\u0002\u0002\u0002\u045a\u17e6\u0003\u0002\u0002\u0002\u045c\u17e9\u0003\u0002\u0002\u0002\u045e\u17eb\u0003\u0002\u0002\u0002\u0460\u17ed\u0003\u0002\u0002\u0002\u0462\u17ef\u0003\u0002\u0002\u0002\u0464\u17f1\u0003\u0002\u0002\u0002\u0466\u17f3\u0003\u0002\u0002\u0002\u0468\u17f5\u0003\u0002\u0002\u0002\u046a\u17f7\u0003\u0002\u0002\u0002\u046c\u17fc\u0003\u0002\u0002\u0002\u046e\u17fe\u0003\u0002\u0002\u0002\u0470\u1800\u0003\u0002\u0002\u0002\u0472\u1808\u0003\u0002\u0002\u0002\u0474\u180a\u0003\u0002\u0002\u0002\u0476\u180c\u0003\u0002\u0002\u0002\u0478\u180e\u0003\u0002\u0002\u0002\u047a\u1810\u0003\u0002\u0002\u0002\u047c\u1812\u0003\u0002\u0002\u0002\u047e\u1816\u0003\u0002\u0002\u0002\u0480\u181d\u0003\u0002\u0002\u0002\u0482\u1821\u0003\u0002\u0002\u0002\u0484\u1823\u0003\u0002\u0002\u0002\u0486\u1825\u0003\u0002\u0002\u0002\u0488\u1827\u0003\u0002\u0002\u0002\u048a\u1829\u0003\u0002\u0002\u0002\u048c\u182d\u0003\u0002\u0002\u0002\u048e\u182f\u0003\u0002\u0002\u0002\u0490\u1831\u0003\u0002\u0002\u0002\u0492\u1833\u0003\u0002\u0002\u0002\u0494\u1835\u0003\u0002\u0002\u0002\u0496\u183d\u0003\u0002\u0002\u0002\u0498\u183f\u0003\u0002\u0002\u0002\u049a\u1844\u0003\u0002\u0002\u0002\u049c\u1846\u0003\u0002\u0002\u0002\u049e\u1848\u0003\u0002\u0002\u0002\u04a0\u1850\u0003\u0002\u0002\u0002\u04a2\u1867\u0003\u0002\u0002\u0002\u04a4\u188a\u0003\u0002\u0002\u0002\u04a6\u188d\u0003\u0002\u0002\u0002\u04a8\u04a9\u0005\u0004\u0003\u0002\u04a9\u04aa\u0007\u0002\u0002\u0003\u04aa\u0003\u0003\u0002\u0002\u0002\u04ab\u04ad\u0005\u0006\u0004\u0002\u04ac\u04ab\u0003\u0002\u0002\u0002\u04ad\u04ae\u0003\u0002\u0002\u0002\u04ae\u04ac\u0003\u0002\u0002\u0002\u04ae\u04af\u0003\u0002\u0002\u0002\u04af\u0005\u0003\u0002\u0002\u0002\u04b0\u04b2\u0005\u000a\u0006\u0002\u04b1\u04b3\u0005\u001c\u000f\u0002\u04b2\u04b1\u0003\u0002\u0002\u0002\u04b2\u04b3\u0003\u0002\u0002\u0002\u04b3\u04b5\u0003\u0002\u0002\u0002\u04b4\u04b6\u0005\u009c\u004f\u0002\u04b5\u04b4\u0003\u0002\u0002\u0002\u04b5\u04b6\u0003\u0002\u0002\u0002\u04b6\u04b8\u0003\u0002\u0002\u0002\u04b7\u04b9\u0005\u01fa\u00fe\u0002\u04b8\u04b7\u0003\u0002\u0002\u0002\u04b8\u04b9\u0003\u0002\u0002\u0002\u04b9\u04bd\u0003\u0002\u0002\u0002\u04ba\u04bc\u0005\u0006\u0004\u0002\u04bb\u04ba\u0003\u0002\u0002\u0002\u04bc\u04bf\u0003\u0002\u0002\u0002\u04bd\u04bb\u0003\u0002\u0002\u0002\u04bd\u04be\u0003\u0002\u0002\u0002\u04be\u04c1\u0003\u0002\u0002\u0002\u04bf\u04bd\u0003\u0002\u0002\u0002\u04c0\u04c2\u0005\u0008\u0005\u0002\u04c1\u04c0\u0003\u0002\u0002\u0002\u04c1\u04c2\u0003\u0002\u0002\u0002\u04c2\u0007\u0003\u0002\u0002\u0002\u04c3\u04c4\u0007\u00a0\u0002\u0002\u04c4\u04c5\u0007\u016b\u0002\u0002\u04c5\u04c6\u0005\u0482\u0242\u0002\u04c6\u04c7\u0007\u0218\u0002\u0002\u04c7\u0009\u0003\u0002\u0002\u0002\u04c8\u04c9\u0009\u0002\u0002\u0002\u04c9\u04ca\u0007\u0093\u0002\u0002\u04ca\u04cb\u0007\u0218\u0002\u0002\u04cb\u04cf\u0005\u000e\u0008\u0002\u04cc\u04ce\u0005\u000c\u0007\u0002\u04cd\u04cc\u0003\u0002\u0002\u0002\u04ce\u04d1\u0003\u0002\u0002\u0002\u04cf\u04cd\u0003\u0002\u0002\u0002\u04cf\u04d0\u0003\u0002\u0002\u0002\u04d0\u000b\u0003\u0002\u0002\u0002\u04d1\u04cf\u0003\u0002\u0002\u0002\u04d2\u04d9\u0005\u0010\u0009\u0002\u04d3\u04d9\u0005\u0012\u000a\u0002\u04d4\u04d9\u0005\u0014\u000b\u0002\u04d5\u04d9\u0005\u0016\u000c\u0002\u04d6\u04d9\u0005\u0018\u000d\u0002\u04d7\u04d9\u0005\u001a\u000e\u0002\u04d8\u04d2\u0003\u0002\u0002\u0002\u04d8\u04d3\u0003\u0002\u0002\u0002\u04d8\u04d4\u0003\u0002\u0002\u0002\u04d8\u04d5\u0003\u0002\u0002\u0002\u04d8\u04d6\u0003\u0002\u0002\u0002\u04d8\u04d7\u0003\u0002\u0002\u0002\u04d9\u000d\u0003\u0002\u0002\u0002\u04da\u04db\u0007\u016c\u0002\u0002\u04db\u04dc\u0007\u0218\u0002\u0002\u04dc\u04e4\u0005\u0482\u0242\u0002\u04dd\u04df\u0007\u0100\u0002\u0002\u04de\u04dd\u0003\u0002\u0002\u0002\u04de\u04df\u0003\u0002\u0002\u0002\u04df\u04e0\u0003\u0002\u0002\u0002\u04e0\u04e2\u0009\u0003\u0002\u0002\u04e1\u04e3\u0007\u016b\u0002\u0002\u04e2\u04e1\u0003\u0002\u0002\u0002\u04e2\u04e3\u0003\u0002\u0002\u0002\u04e3\u04e5\u0003\u0002\u0002\u0002\u04e4\u04de\u0003\u0002\u0002\u0002\u04e4\u04e5\u0003\u0002\u0002\u0002\u04e5\u04e7\u0003\u0002\u0002\u0002\u04e6\u04e8\u0007\u0218\u0002\u0002\u04e7\u04e6\u0003\u0002\u0002\u0002\u04e7\u04e8\u0003\u0002\u0002\u0002\u04e8\u04ea\u0003\u0002\u0002\u0002\u04e9\u04eb\u0005\u04a6\u0254\u0002\u04ea\u04e9\u0003\u0002\u0002\u0002\u04ea\u04eb\u0003\u0002\u0002\u0002\u04eb\u000f\u0003\u0002\u0002\u0002\u04ec\u04ed\u0007\u0022\u0002\u0002\u04ed\u04ef\u0007\u0218\u0002\u0002\u04ee\u04f0\u0005\u04a6\u0254\u0002\u04ef\u04ee\u0003\u0002\u0002\u0002\u04ef\u04f0\u0003\u0002\u0002\u0002\u04f0\u0011\u0003\u0002\u0002\u0002\u04f1\u04f2\u0007\u00fb\u0002\u0002\u04f2\u04f4\u0007\u0218\u0002\u0002\u04f3\u04f5\u0005\u04a6\u0254\u0002\u04f4\u04f3\u0003\u0002\u0002\u0002\u04f4\u04f5\u0003\u0002\u0002\u0002\u04f5\u0013\u0003\u0002\u0002\u0002\u04f6\u04f7\u0007\u0073\u0002\u0002\u04f7\u04f9\u0007\u0218\u0002\u0002\u04f8\u04fa\u0005\u04a6\u0254\u0002\u04f9\u04f8\u0003\u0002\u0002\u0002\u04f9\u04fa\u0003\u0002\u0002\u0002\u04fa\u0015\u0003\u0002\u0002\u0002\u04fb\u04fc\u0007\u0072\u0002\u0002\u04fc\u04fe\u0007\u0218\u0002\u0002\u04fd\u04ff\u0005\u04a6\u0254\u0002\u04fe\u04fd\u0003\u0002\u0002\u0002\u04fe\u04ff\u0003\u0002\u0002\u0002\u04ff\u0017\u0003\u0002\u0002\u0002\u0500\u0501\u0007\u01a7\u0002\u0002\u0501\u0503\u0007\u0218\u0002\u0002\u0502\u0504\u0005\u04a6\u0254\u0002\u0503\u0502\u0003\u0002\u0002\u0002\u0503\u0504\u0003\u0002\u0002\u0002\u0504\u0019\u0003\u0002\u0002\u0002\u0505\u0506\u0007\u0187\u0002\u0002\u0506\u0508\u0007\u0218\u0002\u0002\u0507\u0509\u0005\u04a6\u0254\u0002\u0508\u0507\u0003\u0002\u0002\u0002\u0508\u0509\u0003\u0002\u0002\u0002\u0509\u001b\u0003\u0002\u0002\u0002\u050a\u050b\u0007\u00ba\u0002\u0002\u050b\u050c\u0007\u0093\u0002\u0002\u050c\u0510\u0007\u0218\u0002\u0002\u050d\u050f\u0005\u001e\u0010\u0002\u050e\u050d\u0003\u0002\u0002\u0002\u050f\u0512\u0003\u0002\u0002\u0002\u0510\u050e\u0003\u0002\u0002\u0002\u0510\u0511\u0003\u0002\u0002\u0002\u0511\u001d\u0003\u0002\u0002\u0002\u0512\u0510\u0003\u0002\u0002\u0002\u0513\u0517\u0005\u0020\u0011\u0002\u0514\u0517\u0005\u0038\u001d\u0002\u0515\u0517\u0005\u0066\u0034\u0002\u0516\u0513\u0003\u0002\u0002\u0002\u0516\u0514\u0003\u0002\u0002\u0002\u0516\u0515\u0003\u0002\u0002\u0002\u0517\u001f\u0003\u0002\u0002\u0002\u0518\u0519\u0007\u005f\u0002\u0002\u0519\u051a\u0007\u01a5\u0002\u0002\u051a\u051e\u0007\u0218\u0002\u0002\u051b\u051d\u0005\u0022\u0012\u0002\u051c\u051b\u0003\u0002\u0002\u0002\u051d\u0520\u0003\u0002\u0002\u0002\u051e\u051c\u0003\u0002\u0002\u0002\u051e\u051f\u0003\u0002\u0002\u0002\u051f\u0021\u0003\u0002\u0002\u0002\u0520\u051e\u0003\u0002\u0002\u0002\u0521\u0525\u0005\u0024\u0013\u0002\u0522\u0525\u0005\u0026\u0014\u0002\u0523\u0525\u0005\u0038\u001d\u0002\u0524\u0521\u0003\u0002\u0002\u0002\u0524\u0522\u0003\u0002\u0002\u0002\u0524\u0523\u0003\u0002\u0002\u0002\u0525\u0023\u0003\u0002\u0002\u0002\u0526\u0527\u0007\u01c3\u0002\u0002\u0527\u0528\u0007\u0218\u0002\u0002\u0528\u052e\u0005\u0466\u0234\u0002\u0529\u052b\u0007\u0204\u0002\u0002\u052a\u0529\u0003\u0002\u0002\u0002\u052a\u052b\u0003\u0002\u0002\u0002\u052b\u052c\u0003\u0002\u0002\u0002\u052c\u052d\u0007\u007f\u0002\u0002\u052d\u052f\u0007\u012b\u0002\u0002\u052e\u052a\u0003\u0002\u0002\u0002\u052e\u052f\u0003\u0002\u0002\u0002\u052f\u0530\u0003\u0002\u0002\u0002\u0530\u0531\u0007\u0218\u0002\u0002\u0531\u0025\u0003\u0002\u0002\u0002\u0532\u0533\u0007\u0142\u0002\u0002\u0533\u0534\u0007\u0218\u0002\u0002\u0534\u0538\u0005\u0466\u0234\u0002\u0535\u0537\u0005\u0028\u0015\u0002\u0536\u0535\u0003\u0002\u0002\u0002\u0537\u053a\u0003\u0002\u0002\u0002\u0538\u0536\u0003\u0002\u0002\u0002\u0538\u0539\u0003\u0002\u0002\u0002\u0539\u053b\u0003\u0002\u0002\u0002\u053a\u0538\u0003\u0002\u0002\u0002\u053b\u053c\u0007\u0218\u0002\u0002\u053c\u0027\u0003\u0002\u0002\u0002\u053d\u0543\u0005\u002a\u0016\u0002\u053e\u0543\u0005\u002c\u0017\u0002\u053f\u0543\u0005\u002e\u0018\u0002\u0540\u0543\u0005\u0034\u001b\u0002\u0541\u0543\u0005\u0036\u001c\u0002\u0542\u053d\u0003\u0002\u0002\u0002\u0542\u053e\u0003\u0002\u0002\u0002\u0542\u053f\u0003\u0002\u0002\u0002\u0542\u0540\u0003\u0002\u0002\u0002\u0542\u0541\u0003\u0002\u0002\u0002\u0543\u0029\u0003\u0002\u0002\u0002\u0544\u0546\u0007\u0127\u0002\u0002\u0545\u0547\u0007\u01b9\u0002\u0002\u0546\u0545\u0003\u0002\u0002\u0002\u0546\u0547\u0003\u0002\u0002\u0002\u0547\u054a\u0003\u0002\u0002\u0002\u0548\u054b\u0005\u049c\u024f\u0002\u0549\u054b\u0005\u0494\u024b\u0002\u054a\u0548\u0003\u0002\u0002\u0002\u054a\u0549\u0003\u0002\u0002\u0002\u054b\u054d\u0003\u0002\u0002\u0002\u054c\u054e\u0009\u0004\u0002\u0002\u054d\u054c\u0003\u0002\u0002\u0002\u054d\u054e\u0003\u0002\u0002\u0002\u054e\u002b\u0003\u0002\u0002\u0002\u054f\u0551\u0007\u008f\u0002\u0002\u0550\u0552\u0007\u01b9\u0002\u0002\u0551\u0550\u0003\u0002\u0002\u0002\u0551\u0552\u0003\u0002\u0002\u0002\u0552\u0554\u0003\u0002\u0002\u0002\u0553\u0555\u0007\u0100\u0002\u0002\u0554\u0553\u0003\u0002\u0002\u0002\u0554\u0555\u0003\u0002\u0002\u0002\u0555\u0558\u0003\u0002\u0002\u0002\u0556\u0559\u0005\u049c\u024f\u0002\u0557\u0559\u0005\u0494\u024b\u0002\u0558\u0556\u0003\u0002\u0002\u0002\u0558\u0557\u0003\u0002\u0002\u0002\u0559\u055b\u0003\u0002\u0002\u0002\u055a\u055c\u0009\u0005\u0002\u0002\u055b\u055a\u0003\u0002\u0002\u0002\u055b\u055c\u0003\u0002\u0002\u0002\u055c\u002d\u0003\u0002\u0002\u0002\u055d\u055f\u0007\u016b\u0002\u0002\u055e\u055d\u0003\u0002\u0002\u0002\u055e\u055f\u0003\u0002\u0002\u0002\u055f\u0561\u0003\u0002\u0002\u0002\u0560\u0562\u0007\u004a\u0002\u0002\u0561\u0560\u0003\u0002\u0002\u0002\u0561\u0562\u0003\u0002\u0002\u0002\u0562\u0563\u0003\u0002\u0002\u0002\u0563\u0565\u0007\u01ae\u0002\u0002\u0564\u0566\u0007\u0100\u0002\u0002\u0565\u0564\u0003\u0002\u0002\u0002\u0565\u0566\u0003\u0002\u0002\u0002\u0566\u0568\u0003\u0002\u0002\u0002\u0567\u0569\u0005\u045c\u022f\u0002\u0568\u0567\u0003\u0002\u0002\u0002\u0569\u056a\u0003\u0002\u0002\u0002\u056a\u0568\u0003\u0002\u0002\u0002\u056a\u056b\u0003\u0002\u0002\u0002\u056b\u056d\u0003\u0002\u0002\u0002\u056c\u056e\u0005\u0030\u0019\u0002\u056d\u056c\u0003\u0002\u0002\u0002\u056d\u056e\u0003\u0002\u0002\u0002\u056e\u0570\u0003\u0002\u0002\u0002\u056f\u0571\u0005\u0032\u001a\u0002\u0570\u056f\u0003\u0002\u0002\u0002\u0570\u0571\u0003\u0002\u0002\u0002\u0571\u002f\u0003\u0002\u0002\u0002\u0572\u0574\u0007\u00d6\u0002\u0002\u0573\u0572\u0003\u0002\u0002\u0002\u0573\u0574\u0003\u0002\u0002\u0002\u0574\u0575\u0003\u0002\u0002\u0002\u0575\u0577\u0007\u0010\u0002\u0002\u0576\u0578\u0007\u0100\u0002\u0002\u0577\u0576\u0003\u0002\u0002\u0002\u0577\u0578\u0003\u0002\u0002\u0002\u0578\u0579\u0003\u0002\u0002\u0002\u0579\u057a\u0005\u045c\u022f\u0002\u057a\u0031\u0003\u0002\u0002\u0002\u057b\u057d\u0007\u00d6\u0002\u0002\u057c\u057b\u0003\u0002\u0002\u0002\u057c\u057d\u0003\u0002\u0002\u0002\u057d\u057e\u0003\u0002\u0002\u0002\u057e\u0580\u0007\u0132\u0002\u0002\u057f\u0581\u0007\u0100\u0002\u0002\u0580\u057f\u0003\u0002\u0002\u0002\u0580\u0581\u0003\u0002\u0002\u0002\u0581\u0582\u0003\u0002\u0002\u0002\u0582\u0583\u0005\u045c\u022f\u0002\u0583\u0033\u0003\u0002\u0002\u0002\u0584\u0586\u0007\u01a9\u0002\u0002\u0585\u0587\u0007\u0100\u0002\u0002\u0586\u0585\u0003\u0002\u0002\u0002\u0586\u0587\u0003\u0002\u0002\u0002\u0587\u0588\u0003\u0002\u0002\u0002\u0588\u0589\u0005\u049c\u024f\u0002\u0589\u0035\u0003\u0002\u0002\u0002\u058a\u058b\u0007\u0040\u0002\u0002\u058b\u058c\u0007\u01b0\u0002\u0002\u058c\u058d\u0007\u0218\u0002\u0002\u058d\u0037\u0003\u0002\u0002\u0002\u058e\u058f\u0007\u01c6\u0002\u0002\u058f\u0597\u0007\u0218\u0002\u0002\u0590\u0592\u0005\u003a\u001e\u0002\u0591\u0590\u0003\u0002\u0002\u0002\u0592\u0593\u0003\u0002\u0002\u0002\u0593\u0591\u0003\u0002\u0002\u0002\u0593\u0594\u0003\u0002\u0002\u0002\u0594\u0595\u0003\u0002\u0002\u0002\u0595\u0596\u0007\u0218\u0002\u0002\u0596\u0598\u0003\u0002\u0002\u0002\u0597\u0591\u0003\u0002\u0002\u0002\u0597\u0598\u0003\u0002\u0002\u0002\u0598\u0039\u0003\u0002\u0002\u0002\u0599\u05a5\u0005\u0048\u0025\u0002\u059a\u05a5\u0005\u005e\u0030\u0002\u059b\u05a5\u0005\u003c\u001f\u0002\u059c\u05a5\u0005\u004a\u0026\u0002\u059d\u05a5\u0005\u0052\u002a\u0002\u059e\u05a5\u0005\u0054\u002b\u0002\u059f\u05a5\u0005\u0062\u0032\u0002\u05a0\u05a5\u0005\u005a\u002e\u0002\u05a1\u05a5\u0005\u0058\u002d\u0002\u05a2\u05a5\u0005\u0056\u002c\u0002\u05a3\u05a5\u0005\u0060\u0031\u0002\u05a4\u0599\u0003\u0002\u0002\u0002\u05a4\u059a\u0003\u0002\u0002\u0002\u05a4\u059b\u0003\u0002\u0002\u0002\u05a4\u059c\u0003\u0002\u0002\u0002\u05a4\u059d\u0003\u0002\u0002\u0002\u05a4\u059e\u0003\u0002\u0002\u0002\u05a4\u059f\u0003\u0002\u0002\u0002\u05a4\u05a0\u0003\u0002\u0002\u0002\u05a4\u05a1\u0003\u0002\u0002\u0002\u05a4\u05a2\u0003\u0002\u0002\u0002\u05a4\u05a3\u0003\u0002\u0002\u0002\u05a5\u003b\u0003\u0002\u0002\u0002\u05a6\u05a9\u0005\u003e\u0020\u0002\u05a7\u05a9\u0005\u0046\u0024\u0002\u05a8\u05a6\u0003\u0002\u0002\u0002\u05a8\u05a7\u0003\u0002\u0002\u0002\u05a9\u003d\u0003\u0002\u0002\u0002\u05aa\u05ab\u0007\u000c\u0002\u0002\u05ab\u05ae\u0005\u045c\u022f\u0002\u05ac\u05ad\u0007\u00d6\u0002\u0002\u05ad\u05af\u0007\u0010\u0002\u0002\u05ae\u05ac\u0003\u0002\u0002\u0002\u05ae\u05af\u0003\u0002\u0002\u0002\u05af\u05b1\u0003\u0002\u0002\u0002\u05b0\u05b2\u0007\u0100\u0002\u0002\u05b1\u05b0\u0003\u0002\u0002\u0002\u05b1\u05b2\u0003\u0002\u0002\u0002\u05b2\u05be\u0003\u0002\u0002\u0002\u05b3\u05bf\u0007\u0099\u0002\u0002\u05b4\u05bf\u0007\u001c\u0002\u0002\u05b5\u05bf\u0007\u01c8\u0002\u0002\u05b6\u05bf\u0007\u01c9\u0002\u0002\u05b7\u05bf\u0007\u0134\u0002\u0002\u05b8\u05bf\u0005\u0494\u024b\u0002\u05b9\u05bb\u0005\u0040\u0021\u0002\u05ba\u05b9\u0003\u0002\u0002\u0002\u05bb\u05bc\u0003\u0002\u0002\u0002\u05bc\u05ba\u0003\u0002\u0002\u0002\u05bc\u05bd\u0003\u0002\u0002\u0002\u05bd\u05bf\u0003\u0002\u0002\u0002\u05be\u05b3\u0003\u0002\u0002\u0002\u05be\u05b4\u0003\u0002\u0002\u0002\u05be\u05b5\u0003\u0002\u0002\u0002\u05be\u05b6\u0003\u0002\u0002\u0002\u05be\u05b7\u0003\u0002\u0002\u0002\u05be\u05b8\u0003\u0002\u0002\u0002\u05be\u05ba\u0003\u0002\u0002\u0002\u05bf\u003f\u0003\u0002\u0002\u0002\u05c0\u05c7\u0005\u0496\u024c\u0002\u05c1\u05c8\u0005\u0042\u0022\u0002\u05c2\u05c4\u0005\u0044\u0023\u0002\u05c3\u05c2\u0003\u0002\u0002\u0002\u05c4\u05c5\u0003\u0002\u0002\u0002\u05c5\u05c3\u0003\u0002\u0002\u0002\u05c5\u05c6\u0003\u0002\u0002\u0002\u05c6\u05c8\u0003\u0002\u0002\u0002\u05c7\u05c1\u0003\u0002\u0002\u0002\u05c7\u05c3\u0003\u0002\u0002\u0002\u05c7\u05c8\u0003\u0002\u0002\u0002\u05c8\u0041\u0003\u0002\u0002\u0002\u05c9\u05ca\u0009\u0006\u0002\u0002\u05ca\u05cb\u0005\u0496\u024c\u0002\u05cb\u0043\u0003\u0002\u0002\u0002\u05cc\u05ce\u0007\u0012\u0002\u0002\u05cd\u05cf\u0005\u0496\u024c\u0002\u05ce\u05cd\u0003\u0002\u0002\u0002\u05cf\u05d0\u0003\u0002\u0002\u0002\u05d0\u05ce\u0003\u0002\u0002\u0002\u05d0\u05d1\u0003\u0002\u0002\u0002\u05d1\u0045\u0003\u0002\u0002\u0002\u05d2\u05d3\u0007\u000c\u0002\u0002\u05d3\u05d5\u0005\u045c\u022f\u0002\u05d4\u05d6\u0007\u00d6\u0002\u0002\u05d5\u05d4\u0003\u0002\u0002\u0002\u05d5\u05d6\u0003\u0002\u0002\u0002\u05d6\u05d7\u0003\u0002\u0002\u0002\u05d7\u05d9\u0007\u0132\u0002\u0002\u05d8\u05da\u0007\u0100\u0002\u0002\u05d9\u05d8\u0003\u0002\u0002\u0002\u05d9\u05da\u0003\u0002\u0002\u0002\u05da\u05de\u0003\u0002\u0002\u0002\u05db\u05df\u0007\u0134\u0002\u0002\u05dc\u05dd\u0007\u0039\u0002\u0002\u05dd\u05df\u0005\u0496\u024c\u0002\u05de\u05db\u0003\u0002\u0002\u0002\u05de\u05dc\u0003\u0002\u0002\u0002\u05df\u0047\u0003\u0002\u0002\u0002\u05e0\u05e1\u0007\u003f\u0002\u0002\u05e1\u05e3\u0005\u049c\u024f\u0002\u05e2\u05e4\u0007\u0100\u0002\u0002\u05e3\u05e2\u0003\u0002\u0002\u0002\u05e3\u05e4\u0003\u0002\u0002\u0002\u05e4\u05e5\u0003\u0002\u0002\u0002\u05e5\u05e6\u0005\u047c\u023f\u0002\u05e6\u0049\u0003\u0002\u0002\u0002\u05e7\u05e8\u0007\u0042\u0002\u0002\u05e8\u05ed\u0005\u0464\u0233\u0002\u05e9\u05eb\u0007\u00d6\u0002\u0002\u05ea\u05e9\u0003\u0002\u0002\u0002\u05ea\u05eb\u0003\u0002\u0002\u0002\u05eb\u05ec\u0003\u0002\u0002\u0002\u05ec\u05ee\u0009\u0007\u0002\u0002\u05ed\u05ea\u0003\u0002\u0002\u0002\u05ed\u05ee\u0003\u0002\u0002\u0002\u05ee\u05f0\u0003\u0002\u0002\u0002\u05ef\u05f1\u0007\u0100\u0002\u0002\u05f0\u05ef\u0003\u0002\u0002\u0002\u05f0\u05f1\u0003\u0002\u0002\u0002\u05f1\u05f3\u0003\u0002\u0002\u0002\u05f2\u05f4\u0005\u004c\u0027\u0002\u05f3\u05f2\u0003\u0002\u0002\u0002\u05f4\u05f5\u0003\u0002\u0002\u0002\u05f5\u05f3\u0003\u0002\u0002\u0002\u05f5\u05f6\u0003\u0002\u0002\u0002\u05f6\u004b\u0003\u0002\u0002\u0002\u05f7\u05fa\u0005\u004e\u0028\u0002\u05f8\u05f9\u0009\u0006\u0002\u0002\u05f9\u05fb\u0005\u0050\u0029\u0002\u05fa\u05f8\u0003\u0002\u0002\u0002\u05fa\u05fb\u0003\u0002\u0002\u0002\u05fb\u004d\u0003\u0002\u0002\u0002\u05fc\u05ff\u0005\u0434\u021b\u0002\u05fd\u05ff\u0005\u0496\u024c\u0002\u05fe\u05fc\u0003\u0002\u0002\u0002\u05fe\u05fd\u0003\u0002\u0002\u0002\u05ff\u004f\u0003\u0002\u0002\u0002\u0600\u0603\u0005\u0434\u021b\u0002\u0601\u0603\u0005\u0496\u024c\u0002\u0602\u0600\u0003\u0002\u0002\u0002\u0602\u0601\u0003\u0002\u0002\u0002\u0603\u0051\u0003\u0002\u0002\u0002\u0604\u0606\u0007\u006d\u0002\u0002\u0605\u0607\u0007\u01b8\u0002\u0002\u0606\u0605\u0003\u0002\u0002\u0002\u0606\u0607\u0003\u0002\u0002\u0002\u0607\u0609\u0003\u0002\u0002\u0002\u0608\u060a\u0007\u0100\u0002\u0002\u0609\u0608\u0003\u0002\u0002\u0002\u0609\u060a\u0003\u0002\u0002\u0002\u060a\u060b\u0003\u0002\u0002\u0002\u060b\u0612\u0005\u0496\u024c\u0002\u060c\u060e\u0007\u0204\u0002\u0002\u060d\u060c\u0003\u0002\u0002\u0002\u060d\u060e\u0003\u0002\u0002\u0002\u060e\u060f\u0003\u0002\u0002\u0002\u060f\u0610\u0007\u015d\u0002\u0002\u0610\u0611\u0007\u01d4\u0002\u0002\u0611\u0613\u0005\u0496\u024c\u0002\u0612\u060d\u0003\u0002\u0002\u0002\u0612\u0613\u0003\u0002\u0002\u0002\u0613\u0053\u0003\u0002\u0002\u0002\u0614\u0616\u0007\u0080\u0002\u0002\u0615\u0617\u0007\u0100\u0002\u0002\u0616\u0615\u0003\u0002\u0002\u0002\u0616\u0617\u0003\u0002\u0002\u0002\u0617\u0618\u0003\u0002\u0002\u0002\u0618\u0619\u0007\u004e\u0002\u0002\u0619\u0055\u0003\u0002\u0002\u0002\u061a\u061c\u0007\u0082\u0002\u0002\u061b\u061d\u0009\u0008\u0002\u0002\u061c\u061b\u0003\u0002\u0002\u0002\u061c\u061d\u0003\u0002\u0002\u0002\u061d\u0622\u0003\u0002\u0002\u0002\u061e\u0620\u0007\u01b8\u0002\u0002\u061f\u0621\u0007\u0100\u0002\u0002\u0620\u061f\u0003\u0002\u0002\u0002\u0620\u0621\u0003\u0002\u0002\u0002\u0621\u0623\u0003\u0002\u0002\u0002\u0622\u061e\u0003\u0002\u0002\u0002\u0622\u0623\u0003\u0002\u0002\u0002\u0623\u0625\u0003\u0002\u0002\u0002\u0624\u0626\u0009\u0009\u0002\u0002\u0625\u0624\u0003\u0002\u0002\u0002\u0625\u0626\u0003\u0002\u0002\u0002\u0626\u0627\u0003\u0002\u0002\u0002\u0627\u0629\u0007\u01ad\u0002\u0002\u0628\u062a\u0007\u0040\u0002\u0002\u0629\u0628\u0003\u0002\u0002\u0002\u0629\u062a\u0003\u0002\u0002\u0002\u062a\u0057\u0003\u0002\u0002\u0002\u062b\u0630\u0007\u0083\u0002\u0002\u062c\u062e\u0007\u01b8\u0002\u0002\u062d\u062f\u0007\u0100\u0002\u0002\u062e\u062d\u0003\u0002\u0002\u0002\u062e\u062f\u0003\u0002\u0002\u0002\u062f\u0631\u0003\u0002\u0002\u0002\u0630\u062c\u0003\u0002\u0002\u0002\u0630\u0631\u0003\u0002\u0002\u0002\u0631\u0632\u0003\u0002\u0002\u0002\u0632\u0637\u0009\u0009\u0002\u0002\u0633\u0635\u0007\u01ad\u0002\u0002\u0634\u0636\u0007\u0040\u0002\u0002\u0635\u0634\u0003\u0002\u0002\u0002\u0635\u0636\u0003\u0002\u0002\u0002\u0636\u0638\u0003\u0002\u0002\u0002\u0637\u0633\u0003\u0002\u0002\u0002\u0637\u0638\u0003\u0002\u0002\u0002\u0638\u0059\u0003\u0002\u0002\u0002\u0639\u063b\u0005\u046e\u0238\u0002\u063a\u063c\u0007\u0100\u0002\u0002\u063b\u063a\u0003\u0002\u0002\u0002\u063b\u063c\u0003\u0002\u0002\u0002\u063c\u063d\u0003\u0002\u0002\u0002\u063d\u063f\u0005\u047c\u023f\u0002\u063e\u0640\u0005\u005c\u002f\u0002\u063f\u063e\u0003\u0002\u0002\u0002\u063f\u0640\u0003\u0002\u0002\u0002\u0640\u0643\u0003\u0002\u0002\u0002\u0641\u0643\u0005\u005c\u002f\u0002\u0642\u0639\u0003\u0002\u0002\u0002\u0642\u0641\u0003\u0002\u0002\u0002\u0643\u005b\u0003\u0002\u0002\u0002\u0644\u0646\u0007\u0148\u0002\u0002\u0645\u0647\u0007\u01cb\u0002\u0002\u0646\u0645\u0003\u0002\u0002\u0002\u0646\u0647\u0003\u0002\u0002\u0002\u0647\u0649\u0003\u0002\u0002\u0002\u0648\u064a\u0007\u0100\u0002\u0002\u0649\u0648\u0003\u0002\u0002\u0002\u0649\u064a\u0003\u0002\u0002\u0002\u064a\u064b\u0003\u0002\u0002\u0002\u064b\u0654\u0005\u0418\u020d\u0002\u064c\u064e\u0007\u0146\u0002\u0002\u064d\u064f\u0007\u01cb\u0002\u0002\u064e\u064d\u0003\u0002\u0002\u0002\u064e\u064f\u0003\u0002\u0002\u0002\u064f\u0651\u0003\u0002\u0002\u0002\u0650\u0652\u0007\u0100\u0002\u0002\u0651\u0650\u0003\u0002\u0002\u0002\u0651\u0652\u0003\u0002\u0002\u0002\u0652\u0653\u0003\u0002\u0002\u0002\u0653\u0655\u0005\u0418\u020d\u0002\u0654\u064c\u0003\u0002\u0002\u0002\u0654\u0655\u0003\u0002\u0002\u0002\u0655\u0669\u0003\u0002\u0002\u0002\u0656\u0658\u0007\u0146\u0002\u0002\u0657\u0659\u0007\u01cb\u0002\u0002\u0658\u0657\u0003\u0002\u0002\u0002\u0658\u0659\u0003\u0002\u0002\u0002\u0659\u065b\u0003\u0002\u0002\u0002\u065a\u065c\u0007\u0100\u0002\u0002\u065b\u065a\u0003\u0002\u0002\u0002\u065b\u065c\u0003\u0002\u0002\u0002\u065c\u065d\u0003\u0002\u0002\u0002\u065d\u0666\u0005\u0418\u020d\u0002\u065e\u0660\u0007\u0148\u0002\u0002\u065f\u0661\u0007\u01cb\u0002\u0002\u0660\u065f\u0003\u0002\u0002\u0002\u0660\u0661";
        private const val serializedATNSegment1 : String =
        	"\u0003\u0002\u0002\u0002\u0661\u0663\u0003\u0002\u0002\u0002\u0662\u0664\u0007\u0100\u0002\u0002\u0663\u0662\u0003\u0002\u0002\u0002\u0663\u0664\u0003\u0002\u0002\u0002\u0664\u0665\u0003\u0002\u0002\u0002\u0665\u0667\u0005\u0418\u020d\u0002\u0666\u065e\u0003\u0002\u0002\u0002\u0666\u0667\u0003\u0002\u0002\u0002\u0667\u0669\u0003\u0002\u0002\u0002\u0668\u0644\u0003\u0002\u0002\u0002\u0668\u0656\u0003\u0002\u0002\u0002\u0669\u005d\u0003\u0002\u0002\u0002\u066a\u066c\u0007\u0144\u0002\u0002\u066b\u066d\u0007\u0100\u0002\u0002\u066c\u066b\u0003\u0002\u0002\u0002\u066c\u066d\u0003\u0002\u0002\u0002\u066d\u066e\u0003\u0002\u0002\u0002\u066e\u066f\u0005\u047c\u023f\u0002\u066f\u005f\u0003\u0002\u0002\u0002\u0670\u0672\u0007\u0192\u0002\u0002\u0671\u0673\u0007\u0205\u0002\u0002\u0672\u0671\u0003\u0002\u0002\u0002\u0672\u0673\u0003\u0002\u0002\u0002\u0673\u0675\u0003\u0002\u0002\u0002\u0674\u0676\u0007\u011d\u0002\u0002\u0675\u0674\u0003\u0002\u0002\u0002\u0675\u0676\u0003\u0002\u0002\u0002\u0676\u0678\u0003\u0002\u0002\u0002\u0677\u0679\u0007\u0100\u0002\u0002\u0678\u0677\u0003\u0002\u0002\u0002\u0678\u0679\u0003\u0002\u0002\u0002\u0679\u067a\u0003\u0002\u0002\u0002\u067a\u067c\u0007\u0136\u0002\u0002\u067b\u067d\u0007\u0038\u0002\u0002\u067c\u067b\u0003\u0002\u0002\u0002\u067c\u067d\u0003\u0002\u0002\u0002\u067d\u0061\u0003\u0002\u0002\u0002\u067e\u0680\u0007\u01d5\u0002\u0002\u067f\u0681\u0007\u0041\u0002\u0002\u0680\u067f\u0003\u0002\u0002\u0002\u0680\u0681\u0003\u0002\u0002\u0002\u0681\u0686\u0003\u0002\u0002\u0002\u0682\u0684\u0007\u00d6\u0002\u0002\u0683\u0682\u0003\u0002\u0002\u0002\u0683\u0684\u0003\u0002\u0002\u0002\u0684\u0685\u0003\u0002\u0002\u0002\u0685\u0687\u0009\u0007\u0002\u0002\u0686\u0683\u0003\u0002\u0002\u0002\u0686\u0687\u0003\u0002\u0002\u0002\u0687\u0689\u0003\u0002\u0002\u0002\u0688\u068a\u0005\u0064\u0033\u0002\u0689\u0688\u0003\u0002\u0002\u0002\u068a\u068b\u0003\u0002\u0002\u0002\u068b\u0689\u0003\u0002\u0002\u0002\u068b\u068c\u0003\u0002\u0002\u0002\u068c\u068f\u0003\u0002\u0002\u0002\u068d\u068e\u0007\u00f1\u0002\u0002\u068e\u0690\u0005\u045c\u022f\u0002\u068f\u068d\u0003\u0002\u0002\u0002\u068f\u0690\u0003\u0002\u0002\u0002\u0690\u0063\u0003\u0002\u0002\u0002\u0691\u0693\u0005\u0490\u0249\u0002\u0692\u0691\u0003\u0002\u0002\u0002\u0693\u0694\u0003\u0002\u0002\u0002\u0694\u0692\u0003\u0002\u0002\u0002\u0694\u0695\u0003\u0002\u0002\u0002\u0695\u0697\u0003\u0002\u0002\u0002\u0696\u0698\u0009\u000a\u0002\u0002\u0697\u0696\u0003\u0002\u0002\u0002\u0697\u0698\u0003\u0002\u0002\u0002\u0698\u069a\u0003\u0002\u0002\u0002\u0699\u069b\u0005\u049c\u024f\u0002\u069a\u0699\u0003\u0002\u0002\u0002\u069b\u069c\u0003\u0002\u0002\u0002\u069c\u069a\u0003\u0002\u0002\u0002\u069c\u069d\u0003\u0002\u0002\u0002\u069d\u0065\u0003\u0002\u0002\u0002\u069e\u069f\u0007\u00f9\u0002\u0002\u069f\u06a0\u0007\u01a5\u0002\u0002\u06a0\u06a4\u0007\u0218\u0002\u0002\u06a1\u06a3\u0005\u0068\u0035\u0002\u06a2\u06a1\u0003\u0002\u0002\u0002\u06a3\u06a6\u0003\u0002\u0002\u0002\u06a4\u06a2\u0003\u0002\u0002\u0002\u06a4\u06a5\u0003\u0002\u0002\u0002\u06a5\u0067\u0003\u0002\u0002\u0002\u06a6\u06a4\u0003\u0002\u0002\u0002\u06a7\u06aa\u0005\u006a\u0036\u0002\u06a8\u06aa\u0005\u0088\u0045\u0002\u06a9\u06a7\u0003\u0002\u0002\u0002\u06a9\u06a8\u0003\u0002\u0002\u0002\u06aa\u0069\u0003\u0002\u0002\u0002\u06ab\u06b2\u0007\u00d1\u0002\u0002\u06ac\u06ae\u0007\u0218\u0002\u0002\u06ad\u06ac\u0003\u0002\u0002\u0002\u06ad\u06ae\u0003\u0002\u0002\u0002\u06ae\u06af\u0003\u0002\u0002\u0002\u06af\u06b1\u0005\u006c\u0037\u0002\u06b0\u06ad\u0003\u0002\u0002\u0002\u06b1\u06b4\u0003\u0002\u0002\u0002\u06b2\u06b0\u0003\u0002\u0002\u0002\u06b2\u06b3\u0003\u0002\u0002\u0002\u06b3\u06b5\u0003\u0002\u0002\u0002\u06b4\u06b2\u0003\u0002\u0002\u0002\u06b5\u06b6\u0007\u0218\u0002\u0002\u06b6\u006b\u0003\u0002\u0002\u0002\u06b7\u06bb\u0005\u006e\u0038\u0002\u06b8\u06ba\u0005\u0070\u0039\u0002\u06b9\u06b8\u0003\u0002\u0002\u0002\u06ba\u06bd\u0003\u0002\u0002\u0002\u06bb\u06b9\u0003\u0002\u0002\u0002\u06bb\u06bc\u0003\u0002\u0002\u0002\u06bc\u006d\u0003\u0002\u0002\u0002\u06bd\u06bb\u0003\u0002\u0002\u0002\u06be\u06c0\u0007\u01aa\u0002\u0002\u06bf\u06c1\u0007\u014a\u0002\u0002\u06c0\u06bf\u0003\u0002\u0002\u0002\u06c0\u06c1\u0003\u0002\u0002\u0002\u06c1\u06c2\u0003\u0002\u0002\u0002\u06c2\u06c3\u0005\u0470\u0239\u0002\u06c3\u006f\u0003\u0002\u0002\u0002\u06c4\u06d0\u0005\u0072\u003a\u0002\u06c5\u06d0\u0005\u0074\u003b\u0002\u06c6\u06d0\u0005\u0076\u003c\u0002\u06c7\u06d0\u0005\u0078\u003d\u0002\u06c8\u06d0\u0005\u007a\u003e\u0002\u06c9\u06d0\u0005\u007c\u003f\u0002\u06ca\u06d0\u0005\u007e\u0040\u0002\u06cb\u06d0\u0005\u0080\u0041\u0002\u06cc\u06d0\u0005\u0084\u0043\u0002\u06cd\u06d0\u0005\u0082\u0042\u0002\u06ce\u06d0\u0005\u0086\u0044\u0002\u06cf\u06c4\u0003\u0002\u0002\u0002\u06cf\u06c5\u0003\u0002\u0002\u0002\u06cf\u06c6\u0003\u0002\u0002\u0002\u06cf\u06c7\u0003\u0002\u0002\u0002\u06cf\u06c8\u0003\u0002\u0002\u0002\u06cf\u06c9\u0003\u0002\u0002\u0002\u06cf\u06ca\u0003\u0002\u0002\u0002\u06cf\u06cb\u0003\u0002\u0002\u0002\u06cf\u06cc\u0003\u0002\u0002\u0002\u06cf\u06cd\u0003\u0002\u0002\u0002\u06cf\u06ce\u0003\u0002\u0002\u0002\u06d0\u0071\u0003\u0002\u0002\u0002\u06d1\u06d3\u0007\u001d\u0002\u0002\u06d2\u06d4\u0007\u01eb\u0002\u0002\u06d3\u06d2\u0003\u0002\u0002\u0002\u06d3\u06d4\u0003\u0002\u0002\u0002\u06d4\u06e0\u0003\u0002\u0002\u0002\u06d5\u06e1\u0007\u008f\u0002\u0002\u06d6\u06e1\u0007\u0090\u0002\u0002\u06d7\u06e1\u0007\u0106\u0002\u0002\u06d8\u06e1\u0007\u0162\u0002\u0002\u06d9\u06e1\u0007\u0163\u0002\u0002\u06da\u06e1\u0007\u0174\u0002\u0002\u06db\u06e1\u0007\u0175\u0002\u0002\u06dc\u06e1\u0007\u01dc\u0002\u0002\u06dd\u06e1\u0007\u0200\u0002\u0002\u06de\u06e1\u0005\u045e\u0230\u0002\u06df\u06e1\u0005\u0496\u024c\u0002\u06e0\u06d5\u0003\u0002\u0002\u0002\u06e0\u06d6\u0003\u0002\u0002\u0002\u06e0\u06d7\u0003\u0002\u0002\u0002\u06e0\u06d8\u0003\u0002\u0002\u0002\u06e0\u06d9\u0003\u0002\u0002\u0002\u06e0\u06da\u0003\u0002\u0002\u0002\u06e0\u06db\u0003\u0002\u0002\u0002\u06e0\u06dc\u0003\u0002\u0002\u0002\u06e0\u06dd\u0003\u0002\u0002\u0002\u06e0\u06de\u0003\u0002\u0002\u0002\u06e0\u06df\u0003\u0002\u0002\u0002\u06e1\u0073\u0003\u0002\u0002\u0002\u06e2\u06e5\u0007\u0192\u0002\u0002\u06e3\u06e6\u0007\u0138\u0002\u0002\u06e4\u06e6\u0005\u049c\u024f\u0002\u06e5\u06e3\u0003\u0002\u0002\u0002\u06e5\u06e4\u0003\u0002\u0002\u0002\u06e6\u06e8\u0003\u0002\u0002\u0002\u06e7\u06e9\u0007\u0014\u0002\u0002\u06e8\u06e7\u0003\u0002\u0002\u0002\u06e8\u06e9\u0003\u0002\u0002\u0002\u06e9\u06eb\u0003\u0002\u0002\u0002\u06ea\u06ec\u0009\u000b\u0002\u0002\u06eb\u06ea\u0003\u0002\u0002\u0002\u06eb\u06ec\u0003\u0002\u0002\u0002\u06ec\u0075\u0003\u0002\u0002\u0002\u06ed\u06ef\u0007\u014e\u0002\u0002\u06ee\u06f0\u0007\u0100\u0002\u0002\u06ef\u06ee\u0003\u0002\u0002\u0002\u06ef\u06f0\u0003\u0002\u0002\u0002\u06f0\u06f2\u0003\u0002\u0002\u0002\u06f1\u06ed\u0003\u0002\u0002\u0002\u06f1\u06f2\u0003\u0002\u0002\u0002\u06f2\u06f8\u0003\u0002\u0002\u0002\u06f3\u06f9\u0007\u0119\u0002\u0002\u06f4\u06f5\u0007\u017b\u0002\u0002\u06f5\u06f9\u0007\u002c\u0002\u0002\u06f6\u06f9\u0007\u017b\u0002\u0002\u06f7\u06f9\u0007\u002c\u0002\u0002\u06f8\u06f3\u0003\u0002\u0002\u0002\u06f8\u06f4\u0003\u0002\u0002\u0002\u06f8\u06f6\u0003\u0002\u0002\u0002\u06f8\u06f7\u0003\u0002\u0002\u0002\u06f8\u06f9\u0003\u0002\u0002\u0002\u06f9\u06fa\u0003\u0002\u0002\u0002\u06fa\u06fb\u0009\u000c\u0002\u0002\u06fb\u0077\u0003\u0002\u0002\u0002\u06fc\u06fe\u0007\u0155\u0002\u0002\u06fd\u06ff\u0007\u0040\u0002\u0002\u06fe\u06fd\u0003\u0002\u0002\u0002\u06fe\u06ff\u0003\u0002\u0002\u0002\u06ff\u0701\u0003\u0002\u0002\u0002\u0700\u0702\u0007\u0100\u0002\u0002\u0701\u0700\u0003\u0002\u0002\u0002\u0701\u0702\u0003\u0002\u0002\u0002\u0702\u0705\u0003\u0002\u0002\u0002\u0703\u0706\u0005\u0444\u0223\u0002\u0704\u0706\u0005\u0496\u024c\u0002\u0705\u0703\u0003\u0002\u0002\u0002\u0705\u0704\u0003\u0002\u0002\u0002\u0706\u0079\u0003\u0002\u0002\u0002\u0707\u0708\u0007\u017b\u0002\u0002\u0708\u070a\u0007\u0087\u0002\u0002\u0709\u070b\u0007\u0100\u0002\u0002\u070a\u0709\u0003\u0002\u0002\u0002\u070a\u070b\u0003\u0002\u0002\u0002\u070b\u070f\u0003\u0002\u0002\u0002\u070c\u0710\u0007\u01c8\u0002\u0002\u070d\u0710\u0007\u00ef\u0002\u0002\u070e\u0710\u0005\u045e\u0230\u0002\u070f\u070c\u0003\u0002\u0002\u0002\u070f\u070d\u0003\u0002\u0002\u0002\u070f\u070e\u0003\u0002\u0002\u0002\u0710\u007b\u0003\u0002\u0002\u0002\u0711\u0713\u0007\u0005\u0002\u0002\u0712\u0714\u0007\u012b\u0002\u0002\u0713\u0712\u0003\u0002\u0002\u0002\u0713\u0714\u0003\u0002\u0002\u0002\u0714\u0716\u0003\u0002\u0002\u0002\u0715\u0717\u0007\u0100\u0002\u0002\u0716\u0715\u0003\u0002\u0002\u0002\u0716\u0717\u0003\u0002\u0002\u0002\u0717\u0718\u0003\u0002\u0002\u0002\u0718\u0719\u0009\u000d\u0002\u0002\u0719\u007d\u0003\u0002\u0002\u0002\u071a\u071c\u0007\u017b\u0002\u0002\u071b\u071d\u0007\u0105\u0002\u0002\u071c\u071b\u0003\u0002\u0002\u0002\u071c\u071d\u0003\u0002\u0002\u0002\u071d\u071f\u0003\u0002\u0002\u0002\u071e\u0720\u0007\u0100\u0002\u0002\u071f\u071e\u0003\u0002\u0002\u0002\u071f\u0720\u0003\u0002\u0002\u0002\u0720\u0721\u0003\u0002\u0002\u0002\u0721\u0723\u0005\u0444\u0223\u0002\u0722\u0724\u0005\u0082\u0042\u0002\u0723\u0722\u0003\u0002\u0002\u0002\u0723\u0724\u0003\u0002\u0002\u0002\u0724\u0729\u0003\u0002\u0002\u0002\u0725\u0727\u0007\u0204\u0002\u0002\u0726\u0725\u0003\u0002\u0002\u0002\u0726\u0727\u0003\u0002\u0002\u0002\u0727\u0728\u0003\u0002\u0002\u0002\u0728\u072a\u0007\u0097\u0002\u0002\u0729\u0726\u0003\u0002\u0002\u0002\u0729\u072a\u0003\u0002\u0002\u0002\u072a\u007f\u0003\u0002\u0002\u0002\u072b\u072c\u0007\u0014\u0002\u0002\u072c\u072e\u0007\u017b\u0002\u0002\u072d\u072f\u0007\u0105\u0002\u0002\u072e\u072d\u0003\u0002\u0002\u0002\u072e\u072f\u0003\u0002\u0002\u0002\u072f\u0731\u0003\u0002\u0002\u0002\u0730\u0732\u0007\u0100\u0002\u0002\u0731\u0730\u0003\u0002\u0002\u0002\u0731\u0732\u0003\u0002\u0002\u0002\u0732\u0733\u0003\u0002\u0002\u0002\u0733\u0735\u0005\u0444\u0223\u0002\u0734\u0736\u0005\u0082\u0042\u0002\u0735\u0734\u0003\u0002\u0002\u0002\u0735\u0736\u0003\u0002\u0002\u0002\u0736\u073b\u0003\u0002\u0002\u0002\u0737\u0739\u0007\u0204\u0002\u0002\u0738\u0737\u0003\u0002\u0002\u0002\u0738\u0739\u0003\u0002\u0002\u0002\u0739\u073a\u0003\u0002\u0002\u0002\u073a\u073c\u0007\u0097\u0002\u0002\u073b\u0738\u0003\u0002\u0002\u0002\u073b\u073c\u0003\u0002\u0002\u0002\u073c\u0081\u0003\u0002\u0002\u0002\u073d\u073f\u0007\u0158\u0002\u0002\u073e\u0740\u0007\u0100\u0002\u0002\u073f\u073e\u0003\u0002\u0002\u0002\u073f\u0740\u0003\u0002\u0002\u0002\u0740\u0741\u0003\u0002\u0002\u0002\u0741\u0742\u0005\u046a\u0236\u0002\u0742\u0083\u0003\u0002\u0002\u0002\u0743\u0745\u0007\u00d0\u0002\u0002\u0744\u0743\u0003\u0002\u0002\u0002\u0744\u0745\u0003\u0002\u0002\u0002\u0745\u0746\u0003\u0002\u0002\u0002\u0746\u0748\u0007\u01cb\u0002\u0002\u0747\u0749\u0007\u0100\u0002\u0002\u0748\u0747\u0003\u0002\u0002\u0002\u0748\u0749\u0003\u0002\u0002\u0002\u0749\u074a\u0003\u0002\u0002\u0002\u074a\u074c\u0005\u0444\u0223\u0002\u074b\u074d\u0005\u0444\u0223\u0002\u074c\u074b\u0003\u0002\u0002\u0002\u074c\u074d\u0003\u0002\u0002\u0002\u074d\u0085\u0003\u0002\u0002\u0002\u074e\u0750\u0007\u0184\u0002\u0002\u074f\u0751\u0007\u0105\u0002\u0002\u0750\u074f\u0003\u0002\u0002\u0002\u0750\u0751\u0003\u0002\u0002\u0002\u0751\u0753\u0003\u0002\u0002\u0002\u0752\u0754\u0007\u0100\u0002\u0002\u0753\u0752\u0003\u0002\u0002\u0002\u0753\u0754\u0003\u0002\u0002\u0002\u0754\u0755\u0003\u0002\u0002\u0002\u0755\u0756\u0005\u0444\u0223\u0002\u0756\u0087\u0003\u0002\u0002\u0002\u0757\u0758\u0007\u00eb\u0002\u0002\u0758\u075c\u0007\u0218\u0002\u0002\u0759\u075a\u0005\u0470\u0239\u0002\u075a\u075b\u0007\u0218\u0002\u0002\u075b\u075d\u0003\u0002\u0002\u0002\u075c\u0759\u0003\u0002\u0002\u0002\u075c\u075d\u0003\u0002\u0002\u0002\u075d\u0765\u0003\u0002\u0002\u0002\u075e\u0760\u0005\u008a\u0046\u0002\u075f\u075e\u0003\u0002\u0002\u0002\u0760\u0763\u0003\u0002\u0002\u0002\u0761\u075f\u0003\u0002\u0002\u0002\u0761\u0762\u0003\u0002\u0002\u0002\u0762\u0764\u0003\u0002\u0002\u0002\u0763\u0761\u0003\u0002\u0002\u0002\u0764\u0766\u0007\u0218\u0002\u0002\u0765\u0761\u0003\u0002\u0002\u0002\u0765\u0766\u0003\u0002\u0002\u0002\u0766\u0089\u0003\u0002\u0002\u0002\u0767\u076c\u0005\u008c\u0047\u0002\u0768\u076c\u0005\u0094\u004b\u0002\u0769\u076c\u0005\u0096\u004c\u0002\u076a\u076c\u0005\u009a\u004e\u0002\u076b\u0767\u0003\u0002\u0002\u0002\u076b\u0768\u0003\u0002\u0002\u0002\u076b\u0769\u0003\u0002\u0002\u0002\u076b\u076a\u0003\u0002\u0002\u0002\u076c\u008b\u0003\u0002\u0002\u0002\u076d\u0773\u0007\u0191\u0002\u0002\u076e\u0771\u0007\u0148\u0002\u0002\u076f\u0772\u0005\u045e\u0230\u0002\u0770\u0772\u0005\u0470\u0239\u0002\u0771\u076f\u0003\u0002\u0002\u0002\u0771\u0770\u0003\u0002\u0002\u0002\u0772\u0774\u0003\u0002\u0002\u0002\u0773\u076e\u0003\u0002\u0002\u0002\u0773\u0774\u0003\u0002\u0002\u0002\u0774\u0775\u0003\u0002\u0002\u0002\u0775\u0779\u0007\u00c5\u0002\u0002\u0776\u077a\u0005\u008e\u0048\u0002\u0777\u077a\u0005\u0090\u0049\u0002\u0778\u077a\u0005\u0092\u004a\u0002\u0779\u0776\u0003\u0002\u0002\u0002\u0779\u0777\u0003\u0002\u0002\u0002\u0779\u0778\u0003\u0002\u0002\u0002\u077a\u008d\u0003\u0002\u0002\u0002\u077b\u077c\u0005\u049c\u024f\u0002\u077c\u077d\u0007\u017d\u0002\u0002\u077d\u008f\u0003\u0002\u0002\u0002\u077e\u0780\u0007\u00a0\u0002\u0002\u077f\u077e\u0003\u0002\u0002\u0002\u077f\u0780\u0003\u0002\u0002\u0002\u0780\u0782\u0003\u0002\u0002\u0002\u0781\u0783\u0007\u0145\u0002\u0002\u0782\u0781\u0003\u0002\u0002\u0002\u0782\u0783\u0003\u0002\u0002\u0002\u0783\u0784\u0003\u0002\u0002\u0002\u0784\u0785\u0009\u000e\u0002\u0002\u0785\u0786\u0007\u0145\u0002\u0002\u0786\u0787\u0005\u0470\u0239\u0002\u0787\u0091\u0003\u0002\u0002\u0002\u0788\u078a\u0005\u049c\u024f\u0002\u0789\u078b\u0007\u0044\u0002\u0002\u078a\u0789\u0003\u0002\u0002\u0002\u078a\u078b\u0003\u0002\u0002\u0002\u078b\u0093\u0003\u0002\u0002\u0002\u078c\u078e\u0007\u01a0\u0002\u0002\u078d\u078f\u0009\u000f\u0002\u0002\u078e\u078d\u0003\u0002\u0002\u0002\u078e\u078f\u0003\u0002\u0002\u0002\u078f\u0791\u0003\u0002\u0002\u0002\u0790\u0792\u0007\u0018\u0002\u0002\u0791\u0790\u0003\u0002\u0002\u0002\u0791\u0792\u0003\u0002\u0002\u0002\u0792\u0794\u0003\u0002\u0002\u0002\u0793\u0795\u0007\u00d6\u0002\u0002\u0794\u0793\u0003\u0002\u0002\u0002\u0794\u0795\u0003\u0002\u0002\u0002\u0795\u0797\u0003\u0002\u0002\u0002\u0796\u0798\u0005\u0470\u0239\u0002\u0797\u0796\u0003\u0002\u0002\u0002\u0798\u0799\u0003\u0002\u0002\u0002\u0799\u0797\u0003\u0002\u0002\u0002\u0799\u079a\u0003\u0002\u0002\u0002\u079a\u0095\u0003\u0002\u0002\u0002\u079b\u079c\u0007\u012f\u0002\u0002\u079c\u079e\u0007\u00d0\u0002\u0002\u079d\u079f\u0007\u01dc\u0002\u0002\u079e\u079d\u0003\u0002\u0002\u0002\u079e\u079f\u0003\u0002\u0002\u0002\u079f\u07a1\u0003\u0002\u0002\u0002\u07a0\u07a2\u0007\u0060\u0002\u0002\u07a1\u07a0\u0003\u0002\u0002\u0002\u07a1\u07a2\u0003\u0002\u0002\u0002\u07a2\u07a4\u0003\u0002\u0002\u0002\u07a3\u07a5\u0005\u0098\u004d\u0002\u07a4\u07a3\u0003\u0002\u0002\u0002\u07a5\u07a6\u0003\u0002\u0002\u0002\u07a6\u07a4\u0003\u0002\u0002\u0002\u07a6\u07a7\u0003\u0002\u0002\u0002\u07a7\u0097\u0003\u0002\u0002\u0002\u07a8\u07ab\u0005\u0470\u0239\u0002\u07a9\u07aa\u0007\u0160\u0002\u0002\u07aa\u07ac\u0005\u049c\u024f\u0002\u07ab\u07a9\u0003\u0002\u0002\u0002\u07ab\u07ac\u0003\u0002\u0002\u0002\u07ac\u0099\u0003\u0002\u0002\u0002\u07ad\u07ae\u0007\u004f\u0002\u0002\u07ae\u07b0\u0007\u0063\u0002\u0002\u07af\u07b1\u0007\u00d6\u0002\u0002\u07b0\u07af\u0003\u0002\u0002\u0002\u07b0\u07b1\u0003\u0002\u0002\u0002\u07b1\u07b2\u0003\u0002\u0002\u0002\u07b2\u07b3\u0005\u0470\u0239\u0002\u07b3\u009b\u0003\u0002\u0002\u0002\u07b4\u07b5\u0007\u006f\u0002\u0002\u07b5\u07b6\u0007\u0093\u0002\u0002\u07b6\u07ba\u0007\u0218\u0002\u0002\u07b7\u07b9\u0005\u009e\u0050\u0002\u07b8\u07b7\u0003\u0002\u0002\u0002\u07b9\u07bc\u0003\u0002\u0002\u0002\u07ba\u07b8\u0003\u0002\u0002\u0002\u07ba\u07bb\u0003\u0002\u0002\u0002\u07bb\u009d\u0003\u0002\u0002\u0002\u07bc\u07ba\u0003\u0002\u0002\u0002\u07bd\u07c7\u0005\u00a0\u0051\u0002\u07be\u07c7\u0005\u00d2\u006a\u0002\u07bf\u07c7\u0005\u00d6\u006c\u0002\u07c0\u07c7\u0005\u00d8\u006d\u0002\u07c1\u07c7\u0005\u00da\u006e\u0002\u07c2\u07c7\u0005\u0100\u0081\u0002\u07c3\u07c7\u0005\u0102\u0082\u0002\u07c4\u07c7\u0005\u0142\u00a2\u0002\u07c5\u07c7\u0005\u018e\u00c8\u0002\u07c6\u07bd\u0003\u0002\u0002\u0002\u07c6\u07be\u0003\u0002\u0002\u0002\u07c6\u07bf\u0003\u0002\u0002\u0002\u07c6\u07c0\u0003\u0002\u0002\u0002\u07c6\u07c1\u0003\u0002\u0002\u0002\u07c6\u07c2\u0003\u0002\u0002\u0002\u07c6\u07c3\u0003\u0002\u0002\u0002\u07c6\u07c4\u0003\u0002\u0002\u0002\u07c6\u07c5\u0003\u0002\u0002\u0002\u07c7\u009f\u0003\u0002\u0002\u0002\u07c8\u07c9\u0007\u00d0\u0002\u0002\u07c9\u07ca\u0007\u01a5\u0002\u0002\u07ca\u07ce\u0007\u0218\u0002\u0002\u07cb\u07cd\u0005\u00a2\u0052\u0002\u07cc\u07cb\u0003\u0002\u0002\u0002\u07cd\u07d0\u0003\u0002\u0002\u0002\u07ce\u07cc\u0003\u0002\u0002\u0002\u07ce\u07cf\u0003\u0002\u0002\u0002\u07cf\u00a1\u0003\u0002\u0002\u0002\u07d0\u07ce\u0003\u0002\u0002\u0002\u07d1\u07d2\u0009\u0010\u0002\u0002\u07d2\u07d9\u0005\u0470\u0239\u0002\u07d3\u07d5\u0007\u0218\u0002\u0002\u07d4\u07d3\u0003\u0002\u0002\u0002\u07d4\u07d5\u0003\u0002\u0002\u0002\u07d5\u07d6\u0003\u0002\u0002\u0002\u07d6\u07d8\u0005\u00a4\u0053\u0002\u07d7\u07d4\u0003\u0002\u0002\u0002\u07d8\u07db\u0003\u0002\u0002\u0002\u07d9\u07d7\u0003\u0002\u0002\u0002\u07d9\u07da\u0003\u0002\u0002\u0002\u07da\u07dc\u0003\u0002\u0002\u0002\u07db\u07d9\u0003\u0002\u0002\u0002\u07dc\u07e0\u0007\u0218\u0002\u0002\u07dd\u07df\u0005\u01b4\u00db\u0002\u07de\u07dd\u0003\u0002\u0002\u0002\u07df\u07e2\u0003\u0002\u0002\u0002\u07e0\u07de\u0003\u0002\u0002\u0002\u07e0\u07e1\u0003\u0002\u0002\u0002\u07e1\u00a3\u0003\u0002\u0002\u0002\u07e2\u07e0\u0003\u0002\u0002\u0002\u07e3\u07ef\u0005\u00a6\u0054\u0002\u07e4\u07ef\u0005\u00a8\u0055\u0002\u07e5\u07ef\u0005\u00aa\u0056\u0002\u07e6\u07ef\u0005\u00ae\u0058\u0002\u07e7\u07ef\u0005\u00b8\u005d\u0002\u07e8\u07ef\u0005\u00ba\u005e\u0002\u07e9\u07ef\u0005\u00be\u0060\u0002\u07ea\u07ef\u0005\u00c0\u0061\u0002\u07eb\u07ef\u0005\u00ce\u0068\u0002\u07ec\u07ef\u0005\u00d0\u0069\u0002\u07ed\u07ef\u0005\u00ca\u0066\u0002\u07ee\u07e3\u0003\u0002\u0002\u0002\u07ee\u07e4\u0003\u0002\u0002\u0002\u07ee\u07e5\u0003\u0002\u0002\u0002\u07ee\u07e6\u0003\u0002\u0002\u0002\u07ee\u07e7\u0003\u0002\u0002\u0002\u07ee\u07e8\u0003\u0002\u0002\u0002\u07ee\u07e9\u0003\u0002\u0002\u0002\u07ee\u07ea\u0003\u0002\u0002\u0002\u07ee\u07eb\u0003\u0002\u0002\u0002\u07ee\u07ec\u0003\u0002\u0002\u0002\u07ee\u07ed\u0003\u0002\u0002\u0002\u07ef\u00a5\u0003\u0002\u0002\u0002\u07f0\u07f2\u0007\u0100\u0002\u0002\u07f1\u07f0\u0003\u0002\u0002\u0002\u07f1\u07f2\u0003\u0002\u0002\u0002\u07f2\u07f3\u0003\u0002\u0002\u0002\u07f3\u07f4\u0007\u00cd\u0002\u0002\u07f4\u00a7\u0003\u0002\u0002\u0002\u07f5\u07f7\u0007\u0100\u0002\u0002\u07f6\u07f5\u0003\u0002\u0002\u0002\u07f6\u07f7\u0003\u0002\u0002\u0002\u07f7\u07f8\u0003\u0002\u0002\u0002\u07f8\u07f9\u0007\u00e1\u0002\u0002\u07f9\u00a9\u0003\u0002\u0002\u0002\u07fa\u07fc\u0007\u0030\u0002\u0002\u07fb\u07fd\u0007\u0060\u0002\u0002\u07fc\u07fb\u0003\u0002\u0002\u0002\u07fc\u07fd\u0003\u0002\u0002\u0002\u07fd\u07fe\u0003\u0002\u0002\u0002\u07fe\u0800\u0005\u049c\u024f\u0002\u07ff\u0801\u0005\u00ac\u0057\u0002\u0800\u07ff\u0003\u0002\u0002\u0002\u0800\u0801\u0003\u0002\u0002\u0002\u0801\u0803\u0003\u0002\u0002\u0002\u0802\u0804\u0009\u0011\u0002\u0002\u0803\u0802\u0003\u0002\u0002\u0002\u0803\u0804\u0003\u0002\u0002\u0002\u0804\u00ab\u0003\u0002\u0002\u0002\u0805\u0806\u0007\u01eb\u0002\u0002\u0806\u0807\u0005\u049c\u024f\u0002\u0807\u00ad\u0003\u0002\u0002\u0002\u0808\u080c\u0007\u017b\u0002\u0002\u0809\u080d\u0005\u00b0\u0059\u0002\u080a\u080d\u0005\u00b2\u005a\u0002\u080b\u080d\u0005\u00b4\u005b\u0002\u080c\u0809\u0003\u0002\u0002\u0002\u080c\u080a\u0003\u0002\u0002\u0002\u080c\u080b\u0003\u0002\u0002\u0002\u080d\u00af\u0003\u0002\u0002\u0002\u080e\u0810\u0007\u0060\u0002\u0002\u080f\u080e\u0003\u0002\u0002\u0002\u080f\u0810\u0003\u0002\u0002\u0002\u0810\u0811\u0003\u0002\u0002\u0002\u0811\u0813\u0005\u049c\u024f\u0002\u0812\u0814\u0007\u0041\u0002\u0002\u0813\u0812\u0003\u0002\u0002\u0002\u0813\u0814\u0003\u0002\u0002\u0002\u0814\u00b1\u0003\u0002\u0002\u0002\u0815\u0817\u0007\u0100\u0002\u0002\u0816\u0815\u0003\u0002\u0002\u0002\u0816\u0817\u0003\u0002\u0002\u0002\u0817\u0818\u0003\u0002\u0002\u0002\u0818\u081a\u0007\u01ff\u0002\u0002\u0819\u081b\u0007\u00f1\u0002\u0002\u081a\u0819\u0003\u0002\u0002\u0002\u081a\u081b\u0003\u0002\u0002\u0002\u081b\u081d\u0003\u0002\u0002\u0002\u081c\u081e\u0007\u01b9\u0002\u0002\u081d\u081c\u0003\u0002\u0002\u0002\u081d\u081e\u0003\u0002\u0002\u0002\u081e\u0829\u0003\u0002\u0002\u0002\u081f\u0821\u0007\u00d9\u0002\u0002\u0820\u081f\u0003\u0002\u0002\u0002\u0820\u0821\u0003\u0002\u0002\u0002\u0821\u0822\u0003\u0002\u0002\u0002\u0822\u0824\u0005\u049c\u024f\u0002\u0823\u0825\u0005\u00b6\u005c\u0002\u0824\u0823\u0003\u0002\u0002\u0002\u0824\u0825\u0003\u0002\u0002\u0002\u0825\u0827\u0003\u0002\u0002\u0002\u0826\u0828\u0007\u0041\u0002\u0002\u0827\u0826\u0003\u0002\u0002\u0002\u0827\u0828\u0003\u0002\u0002\u0002\u0828\u082a\u0003\u0002\u0002\u0002\u0829\u0820\u0003\u0002\u0002\u0002\u0829\u082a\u0003\u0002\u0002\u0002\u082a\u0830\u0003\u0002\u0002\u0002\u082b\u082d\u0007\u0088\u0002\u0002\u082c\u082e\u0007\u0148\u0002\u0002\u082d\u082c\u0003\u0002\u0002\u0002\u082d\u082e\u0003\u0002\u0002\u0002\u082e\u082f\u0003\u0002\u0002\u0002\u082f\u0831\u0005\u0444\u0223\u0002\u0830\u082b\u0003\u0002\u0002\u0002\u0830\u0831\u0003\u0002\u0002\u0002\u0831\u00b3\u0003\u0002\u0002\u0002\u0832\u0834\u0007\u0060\u0002\u0002\u0833\u0832\u0003\u0002\u0002\u0002\u0833\u0834\u0003\u0002\u0002\u0002\u0834\u0835\u0003\u0002\u0002\u0002\u0835\u0836\u0005\u049c\u024f\u0002\u0836\u0838\u0005\u00b6\u005c\u0002\u0837\u0839\u0007\u0041\u0002\u0002\u0838\u0837\u0003\u0002\u0002\u0002\u0838\u0839\u0003\u0002\u0002\u0002\u0839\u00b5\u0003\u0002\u0002\u0002\u083a\u083b\u0007\u01eb\u0002\u0002\u083b\u083c\u0005\u049c\u024f\u0002\u083c\u00b7\u0003\u0002\u0002\u0002\u083d\u0846\u0007\u0107\u0002\u0002\u083e\u0840\u0007\u017b\u0002\u0002\u083f\u0841\u0007\u0100\u0002\u0002\u0840\u083f\u0003\u0002\u0002\u0002\u0840\u0841\u0003\u0002\u0002\u0002\u0841\u0847\u0003\u0002\u0002\u0002\u0842\u0844\u0007\u017d\u0002\u0002\u0843\u0845\u0007\u0017\u0002\u0002\u0844\u0843\u0003\u0002\u0002\u0002\u0844\u0845\u0003\u0002\u0002\u0002\u0845\u0847\u0003\u0002\u0002\u0002\u0846\u083e\u0003\u0002\u0002\u0002\u0846\u0842\u0003\u0002\u0002\u0002\u0847\u084f\u0003\u0002\u0002\u0002\u0848\u0850\u0007\u0147\u0002\u0002\u0849\u0850\u0007\u01c7\u0002\u0002\u084a\u084c\u0005\u046a\u0236\u0002\u084b\u084a\u0003\u0002\u0002\u0002\u084c\u084d\u0003\u0002\u0002\u0002\u084d\u084b\u0003\u0002\u0002\u0002\u084d\u084e\u0003\u0002\u0002\u0002\u084e\u0850\u0003\u0002\u0002\u0002\u084f\u0848\u0003\u0002\u0002\u0002\u084f\u0849\u0003\u0002\u0002\u0002\u084f\u084b\u0003\u0002\u0002\u0002\u0850\u00b9\u0003\u0002\u0002\u0002\u0851\u0852\u0007\u01fd\u0002\u0002\u0852\u0854\u0007\u0145\u0002\u0002\u0853\u0855\u0005\u00bc\u005f\u0002\u0854\u0853\u0003\u0002\u0002\u0002\u0855\u0856\u0003\u0002\u0002\u0002\u0856\u0854\u0003\u0002\u0002\u0002\u0856\u0857\u0003\u0002\u0002\u0002\u0857\u00bb\u0003\u0002\u0002\u0002\u0858\u085a\u0005\u048e\u0248\u0002\u0859\u085b\u0007\u0100\u0002\u0002\u085a\u0859\u0003\u0002\u0002\u0002\u085a\u085b\u0003\u0002\u0002\u0002\u085b\u085e\u0003\u0002\u0002\u0002\u085c\u085f\u0005\u0444\u0223\u0002\u085d\u085f\u0005\u0496\u024c\u0002\u085e\u085c\u0003\u0002\u0002\u0002\u085e\u085d\u0003\u0002\u0002\u0002\u085f\u00bd\u0003\u0002\u0002\u0002\u0860\u0869\u0007\u006f\u0002\u0002\u0861\u0863\u0007\u017b\u0002\u0002\u0862\u0864\u0007\u0100\u0002\u0002\u0863\u0862\u0003\u0002\u0002\u0002\u0863\u0864\u0003\u0002\u0002\u0002\u0864\u086a\u0003\u0002\u0002\u0002\u0865\u0867\u0007\u017d\u0002\u0002\u0866\u0868\u0007\u0017\u0002\u0002\u0867\u0866\u0003\u0002\u0002\u0002\u0867\u0868\u0003\u0002\u0002\u0002\u0868\u086a\u0003\u0002\u0002\u0002\u0869\u0861\u0003\u0002\u0002\u0002\u0869\u0865\u0003\u0002\u0002\u0002\u086a\u086c\u0003\u0002\u0002\u0002\u086b\u086d\u0005\u046a\u0236\u0002\u086c\u086b\u0003\u0002\u0002\u0002\u086d\u086e\u0003\u0002\u0002\u0002\u086e\u086c\u0003\u0002\u0002\u0002\u086e\u086f\u0003\u0002\u0002\u0002\u086f\u00bf\u0003\u0002\u0002\u0002\u0870\u0872\u0007\u0117\u0002\u0002\u0871\u0873\u0007\u0100\u0002\u0002\u0872\u0871\u0003\u0002\u0002\u0002\u0872\u0873\u0003\u0002\u0002\u0002\u0873\u0876\u0003\u0002\u0002\u0002\u0874\u0877\u0005\u046a\u0236\u0002\u0875\u0877\u0005\u049c\u024f\u0002\u0876\u0874\u0003\u0002\u0002\u0002\u0876\u0875\u0003\u0002\u0002\u0002\u0877\u0879\u0003\u0002\u0002\u0002\u0878\u087a\u0007\u011a\u0002\u0002\u0879\u0878\u0003\u0002\u0002\u0002\u0879\u087a\u0003\u0002\u0002\u0002\u087a\u087e\u0003\u0002\u0002\u0002\u087b\u087d\u0005\u00c2\u0062\u0002\u087c\u087b\u0003\u0002\u0002\u0002\u087d\u0880\u0003\u0002\u0002\u0002\u087e\u087c\u0003\u0002\u0002\u0002\u087e\u087f\u0003\u0002\u0002\u0002\u087f\u00c1\u0003\u0002\u0002\u0002\u0880\u087e\u0003\u0002\u0002\u0002\u0881\u0885\u0005\u00c4\u0063\u0002\u0882\u0885\u0005\u00c6\u0064\u0002\u0883\u0885\u0005\u00c8\u0065\u0002\u0884\u0881\u0003\u0002\u0002\u0002\u0884\u0882\u0003\u0002\u0002\u0002\u0884\u0883\u0003\u0002\u0002\u0002\u0885\u00c3\u0003\u0002\u0002\u0002\u0886\u0888\u0007\u0204\u0002\u0002\u0887\u0886\u0003\u0002\u0002\u0002\u0887\u0888\u0003\u0002\u0002\u0002\u0888\u0889\u0003\u0002\u0002\u0002\u0889\u088b\u0007\u00d5\u0002\u0002\u088a\u088c\u0007\u0020\u0002\u0002\u088b\u088a\u0003\u0002\u0002\u0002\u088b\u088c\u0003\u0002\u0002\u0002\u088c\u088f\u0003\u0002\u0002\u0002\u088d\u0890\u0005\u046a\u0236\u0002\u088e\u0890\u0005\u049c\u024f\u0002\u088f\u088d\u0003\u0002\u0002\u0002\u088f\u088e\u0003\u0002\u0002\u0002\u0890\u00c5\u0003\u0002\u0002\u0002\u0891\u0893\u0007\u011a\u0002\u0002\u0892\u0891\u0003\u0002\u0002\u0002\u0892\u0893\u0003\u0002\u0002\u0002\u0893\u0895\u0003\u0002\u0002\u0002\u0894\u0896\u0007\u0020\u0002\u0002\u0895\u0894\u0003\u0002\u0002\u0002\u0895\u0896\u0003\u0002\u0002\u0002\u0896\u0897\u0003\u0002\u0002\u0002\u0897\u089a\u0007\u01ee\u0002\u0002\u0898\u089b\u0005\u046a\u0236\u0002\u0899\u089b\u0005\u049c\u024f\u0002\u089a\u0898\u0003\u0002\u0002\u0002\u089a\u0899\u0003\u0002\u0002\u0002\u089b\u00c7\u0003\u0002\u0002\u0002\u089c\u089e\u0007\u011a\u0002\u0002\u089d\u089c\u0003\u0002\u0002\u0002\u089d\u089e\u0003\u0002\u0002\u0002\u089e\u08a0\u0003\u0002\u0002\u0002\u089f\u08a1\u0007\u0020\u0002\u0002\u08a0\u089f\u0003\u0002\u0002\u0002\u08a0\u08a1\u0003\u0002\u0002\u0002\u08a1\u08a2\u0003\u0002\u0002\u0002\u08a2\u08a5\u0007\u0032\u0002\u0002\u08a3\u08a6\u0005\u046a\u0236\u0002\u08a4\u08a6\u0005\u049c\u024f\u0002\u08a5\u08a3\u0003\u0002\u0002\u0002\u08a5\u08a4\u0003\u0002\u0002\u0002\u08a6\u00c9\u0003\u0002\u0002\u0002\u08a7\u08a9\u0007\u017c\u0002\u0002\u08a8\u08aa\u0007\u012b\u0002\u0002\u08a9\u08a8\u0003\u0002\u0002\u0002\u08a9\u08aa\u0003\u0002\u0002\u0002\u08aa\u08ac\u0003\u0002\u0002\u0002\u08ab\u08ad\u0007\u0100\u0002\u0002\u08ac\u08ab\u0003\u0002\u0002\u0002\u08ac\u08ad\u0003\u0002\u0002\u0002\u08ad\u08ae\u0003\u0002\u0002\u0002\u08ae\u08af\u0005\u00cc\u0067\u0002\u08af\u00cb\u0003\u0002\u0002\u0002\u08b0\u08b1\u0005\u0494\u024b\u0002\u08b1\u00cd\u0003\u0002\u0002\u0002\u08b2\u08b4\u0007\u0049\u0002\u0002\u08b3\u08b5\u0007\u0100\u0002\u0002\u08b4\u08b3\u0003\u0002\u0002\u0002\u08b4\u08b5\u0003\u0002\u0002\u0002\u08b5\u08b6\u0003\u0002\u0002\u0002\u08b6\u08b7\u0005\u045c\u022f\u0002\u08b7\u00cf\u0003\u0002\u0002\u0002\u08b8\u08ba\u0007\u018d\u0002\u0002\u08b9\u08bb\u0007\u0100\u0002\u0002\u08ba\u08b9\u0003\u0002\u0002\u0002\u08ba\u08bb\u0003\u0002\u0002\u0002\u08bb\u08c1\u0003\u0002\u0002\u0002\u08bc\u08be\u0007\u018f\u0002\u0002\u08bd\u08bf\u0007\u0017\u0002\u0002\u08be\u08bd\u0003\u0002\u0002\u0002\u08be\u08bf\u0003\u0002\u0002\u0002\u08bf\u08c1\u0003\u0002\u0002\u0002\u08c0\u08b8\u0003\u0002\u0002\u0002\u08c0\u08bc\u0003\u0002\u0002\u0002\u08c1\u08c3\u0003\u0002\u0002\u0002\u08c2\u08c4\u0005\u0486\u0244\u0002\u08c3\u08c2\u0003\u0002\u0002\u0002\u08c4\u08c5\u0003\u0002\u0002\u0002\u08c5\u08c3\u0003\u0002\u0002\u0002\u08c5\u08c6\u0003\u0002\u0002\u0002\u08c6\u00d1\u0003\u0002\u0002\u0002\u08c7\u08c8\u0007\u0070\u0002\u0002\u08c8\u08c9\u0007\u01a5\u0002\u0002\u08c9\u08cd\u0007\u0218\u0002\u0002\u08ca\u08cc\u0005\u00d4\u006b\u0002\u08cb\u08ca\u0003\u0002\u0002\u0002\u08cc\u08cf\u0003\u0002\u0002\u0002\u08cd\u08cb\u0003\u0002\u0002\u0002\u08cd\u08ce\u0003\u0002\u0002\u0002\u08ce\u00d3\u0003\u0002\u0002\u0002\u08cf\u08cd\u0003\u0002\u0002\u0002\u08d0\u08d1\u0005\u049c\u024f\u0002\u08d1\u08d2\u0005\u0496\u024c\u0002\u08d2\u08d3\u0007\u00ff\u0002\u0002\u08d3\u08d4\u0005\u0496\u024c\u0002\u08d4\u00d5\u0003\u0002\u0002\u0002\u08d5\u08d6\u0007\u0206\u0002\u0002\u08d6\u08d7\u0007\u01a5\u0002\u0002\u08d7\u08db\u0007\u0218\u0002\u0002\u08d8\u08da\u0005\u01b4\u00db\u0002\u08d9\u08d8\u0003\u0002\u0002\u0002\u08da\u08dd\u0003\u0002\u0002\u0002\u08db\u08d9\u0003\u0002\u0002\u0002\u08db\u08dc\u0003\u0002\u0002\u0002\u08dc\u00d7\u0003\u0002\u0002\u0002\u08dd\u08db\u0003\u0002\u0002\u0002\u08de\u08df\u0007\u011c\u0002\u0002\u08df\u08e0\u0007\u01a5\u0002\u0002\u08e0\u08e4\u0007\u0218\u0002\u0002\u08e1\u08e3\u0005\u01b4\u00db\u0002\u08e2\u08e1\u0003\u0002\u0002\u0002\u08e3\u08e6\u0003\u0002\u0002\u0002\u08e4\u08e2\u0003\u0002\u0002\u0002\u08e4\u08e5\u0003\u0002\u0002\u0002\u08e5\u00d9\u0003\u0002\u0002\u0002\u08e6\u08e4\u0003\u0002\u0002\u0002\u08e7\u08e8\u0007\u0051\u0002\u0002\u08e8\u08e9\u0007\u01a5\u0002\u0002\u08e9\u08ee\u0007\u0218\u0002\u0002\u08ea\u08ed\u0005\u00dc\u006f\u0002\u08eb\u08ed\u0005\u01b4\u00db\u0002\u08ec\u08ea\u0003\u0002\u0002\u0002\u08ec\u08eb\u0003\u0002\u0002\u0002\u08ed\u08f0\u0003\u0002\u0002\u0002\u08ee\u08ec\u0003\u0002\u0002\u0002\u08ee\u08ef\u0003\u0002\u0002\u0002\u08ef\u00db\u0003\u0002\u0002\u0002\u08f0\u08ee\u0003\u0002\u0002\u0002\u08f1\u08f5\u0005\u00de\u0070\u0002\u08f2\u08f5\u0005\u00e0\u0071\u0002\u08f3\u08f5\u0005\u00e2\u0072\u0002\u08f4\u08f1\u0003\u0002\u0002\u0002\u08f4\u08f2\u0003\u0002\u0002\u0002\u08f4\u08f3\u0003\u0002\u0002\u0002\u08f5\u00dd\u0003\u0002\u0002\u0002\u08f6\u08f7\u0007\u003a\u0002\u0002\u08f7\u08f9\u0005\u0462\u0232\u0002\u08f8\u08fa\u0007\u00d6\u0002\u0002\u08f9\u08f8\u0003\u0002\u0002\u0002\u08f9\u08fa\u0003\u0002\u0002\u0002\u08fa\u08fc\u0003\u0002\u0002\u0002\u08fb\u08fd\u0007\u00f5\u0002\u0002\u08fc\u08fb\u0003\u0002\u0002\u0002\u08fc\u08fd\u0003\u0002\u0002\u0002\u08fd\u08fe\u0003\u0002\u0002\u0002\u08fe\u090d\u0007\u00f8\u0002\u0002\u08ff\u0909\u0005\u00f6\u007c\u0002\u0900\u0909\u0005\u00fc\u007f\u0002\u0901\u0909\u0005\u00ee\u0078\u0002\u0902\u0909\u0005\u00f0\u0079\u0002\u0903\u0909\u0005\u00f8\u007d\u0002\u0904\u0909\u0005\u00fe\u0080\u0002\u0905\u0909\u0005\u00e8\u0075\u0002\u0906\u0909\u0005\u00f2\u007a\u0002\u0907\u0909\u0005\u00ec\u0077\u0002\u0908\u08ff\u0003\u0002\u0002\u0002\u0908\u0900\u0003\u0002\u0002\u0002\u0908\u0901\u0003\u0002\u0002\u0002\u0908\u0902\u0003\u0002\u0002\u0002\u0908\u0903\u0003\u0002\u0002\u0002\u0908\u0904\u0003\u0002\u0002\u0002\u0908\u0905\u0003\u0002\u0002\u0002\u0908\u0906\u0003\u0002\u0002\u0002\u0908\u0907\u0003\u0002\u0002\u0002\u0909\u090c\u0003\u0002\u0002\u0002\u090a\u090c\u0005\u046c\u0237\u0002\u090b\u0908\u0003\u0002\u0002\u0002\u090b\u090a\u0003\u0002\u0002\u0002\u090c\u090f\u0003\u0002\u0002\u0002\u090d\u090b\u0003\u0002\u0002\u0002\u090d\u090e\u0003\u0002\u0002\u0002\u090e\u0910\u0003\u0002\u0002\u0002\u090f\u090d\u0003\u0002\u0002\u0002\u0910\u0911\u0007\u0218\u0002\u0002\u0911\u00df\u0003\u0002\u0002\u0002\u0912\u0913\u0007\u003a\u0002\u0002\u0913\u0915\u0005\u0462\u0232\u0002\u0914\u0916\u0007\u00d6\u0002\u0002\u0915\u0914\u0003\u0002\u0002\u0002\u0915\u0916\u0003\u0002\u0002\u0002\u0916\u0917\u0003\u0002\u0002\u0002\u0917\u0920\u0007\u0150\u0002\u0002\u0918\u091f\u0005\u00e4\u0073\u0002\u0919\u091f\u0005\u00fe\u0080\u0002\u091a\u091f\u0005\u00f2\u007a\u0002\u091b\u091f\u0005\u00e6\u0074\u0002\u091c\u091f\u0005\u00ea\u0076\u0002\u091d\u091f\u0005\u00f4\u007b\u0002\u091e\u0918\u0003\u0002\u0002\u0002\u091e\u0919\u0003\u0002\u0002\u0002\u091e\u091a\u0003\u0002\u0002\u0002\u091e\u091b\u0003\u0002\u0002\u0002\u091e\u091c\u0003\u0002\u0002\u0002\u091e\u091d\u0003\u0002\u0002\u0002\u091f\u0922\u0003\u0002\u0002\u0002\u0920\u091e\u0003\u0002\u0002\u0002\u0920\u0921\u0003\u0002\u0002\u0002\u0921\u0923\u0003\u0002\u0002\u0002\u0922\u0920\u0003\u0002\u0002\u0002\u0923\u0924\u0007\u0218\u0002\u0002\u0924\u00e1\u0003\u0002\u0002\u0002\u0925\u0926\u0007\u003a\u0002\u0002\u0926\u0928\u0005\u0462\u0232\u0002\u0927\u0929\u0007\u00d6\u0002\u0002\u0928\u0927\u0003\u0002\u0002\u0002\u0928\u0929\u0003\u0002\u0002\u0002\u0929\u092a\u0003\u0002\u0002\u0002\u092a\u092b\u0007\u00f5\u0002\u0002\u092b\u0937\u0007\u00ea\u0002\u0002\u092c\u0933\u0005\u00ee\u0078\u0002\u092d\u0933\u0005\u00f0\u0079\u0002\u092e\u0933\u0005\u00fa\u007e\u0002\u092f\u0933\u0005\u00fe\u0080\u0002\u0930\u0933\u0005\u00e8\u0075\u0002\u0931\u0933\u0005\u00f2\u007a\u0002\u0932\u092c\u0003\u0002\u0002\u0002\u0932\u092d\u0003\u0002\u0002\u0002\u0932\u092e\u0003\u0002\u0002\u0002\u0932\u092f\u0003\u0002\u0002\u0002\u0932\u0930\u0003\u0002\u0002\u0002\u0932\u0931\u0003\u0002\u0002\u0002\u0933\u0936\u0003\u0002\u0002\u0002\u0934\u0936\u0005\u046c\u0237\u0002\u0935\u0932\u0003\u0002\u0002\u0002\u0935\u0934\u0003\u0002\u0002\u0002\u0936\u0939\u0003\u0002\u0002\u0002\u0937\u0935\u0003\u0002\u0002\u0002\u0937\u0938\u0003\u0002\u0002\u0002\u0938\u093a\u0003\u0002\u0002\u0002\u0939\u0937\u0003\u0002\u0002\u0002\u093a\u093b\u0007\u0218\u0002\u0002\u093b\u00e3\u0003\u0002\u0002\u0002\u093c\u093d\u0007\u008a\u0002\u0002\u093d\u093f\u0007\u006b\u0002\u0002\u093e\u0940\u0007\u0100\u0002\u0002\u093f\u093e\u0003\u0002\u0002\u0002\u093f\u0940\u0003\u0002\u0002\u0002\u0940\u0941\u0003\u0002\u0002\u0002\u0941\u0942\u0005\u046c\u0237\u0002\u0942\u00e5\u0003\u0002\u0002\u0002\u0943\u0944\u0007\u008a\u0002\u0002\u0944\u0945\u0007\u01d8\u0002\u0002\u0945\u0946\u0007\u0143\u0002\u0002\u0946\u0947\u0005\u049c\u024f\u0002\u0947\u094f\u0007\u01e9\u0002\u0002\u0948\u0949\u0007\u00f3\u0002\u0002\u0949\u094b\u0007\u0033\u0002\u0002\u094a\u094c\u0005\u0474\u023b\u0002\u094b\u094a\u0003\u0002\u0002\u0002\u094c\u094d\u0003\u0002\u0002\u0002\u094d\u094b\u0003\u0002\u0002\u0002\u094d\u094e\u0003\u0002\u0002\u0002\u094e\u0950\u0003\u0002\u0002\u0002\u094f\u0948\u0003\u0002\u0002\u0002\u094f\u0950\u0003\u0002\u0002\u0002\u0950\u00e7\u0003\u0002\u0002\u0002\u0951\u0952\u0007\u00a0\u0002\u0002\u0952\u0954\u0007\u0105\u0002\u0002\u0953\u0955\u0007\u0100\u0002\u0002\u0954\u0953\u0003\u0002\u0002\u0002\u0954\u0955\u0003\u0002\u0002\u0002\u0955\u0956\u0003\u0002\u0002\u0002\u0956\u0957\u0005\u046c\u0237\u0002\u0957\u00e9\u0003\u0002\u0002\u0002\u0958\u0959\u0007\u00be\u0002\u0002\u0959\u095b\u0007\u0105\u0002\u0002\u095a\u095c\u0007\u0100\u0002\u0002\u095b\u095a\u0003\u0002\u0002\u0002\u095b\u095c\u0003\u0002\u0002\u0002\u095c\u095d\u0003\u0002\u0002\u0002\u095d\u095e\u0005\u046c\u0237\u0002\u095e\u00eb\u0003\u0002\u0002\u0002\u095f\u0961\u0007\u0129\u0002\u0002\u0960\u095f\u0003\u0002\u0002\u0002\u0960\u0961\u0003\u0002\u0002\u0002\u0961\u0962\u0003\u0002\u0002\u0002\u0962\u0964\u0007\u006b\u0002\u0002\u0963\u0965\u0007\u0100\u0002\u0002\u0964\u0963\u0003\u0002\u0002\u0002\u0964\u0965\u0003\u0002\u0002\u0002\u0965\u0966\u0003\u0002\u0002\u0002\u0966\u0967\u0005\u046c\u0237\u0002\u0967\u00ed\u0003\u0002\u0002\u0002\u0968\u0969\u0007\u0129\u0002\u0002\u0969\u096b\u0007\u0071\u0002\u0002\u096a\u096c\u0007\u0100\u0002\u0002\u096b\u096a\u0003\u0002\u0002\u0002\u096b\u096c\u0003\u0002\u0002\u0002\u096c\u096d\u0003\u0002\u0002\u0002\u096d\u096e\u0005\u046c\u0237\u0002\u096e\u00ef\u0003\u0002\u0002\u0002\u096f\u0970\u0007\u0129\u0002\u0002\u0970\u0972\u0007\u01e7\u0002\u0002\u0971\u0973\u0007\u0100\u0002\u0002\u0972\u0971\u0003\u0002\u0002\u0002\u0972\u0973\u0003\u0002\u0002\u0002\u0973\u0974\u0003\u0002\u0002\u0002\u0974\u0975\u0005\u046c\u0237\u0002\u0975\u00f1\u0003\u0002\u0002\u0002\u0976\u0977\u0007\u01cb\u0002\u0002\u0977\u0979\u0007\u0105\u0002\u0002\u0978\u097a\u0007\u0100\u0002\u0002\u0979\u0978\u0003\u0002\u0002\u0002\u0979\u097a\u0003\u0002\u0002\u0002\u097a\u097b\u0003\u0002\u0002\u0002\u097b\u097c\u0005\u046c\u0237\u0002\u097c\u00f3\u0003\u0002\u0002\u0002\u097d\u097f\u0007\u01d5\u0002\u0002\u097e\u097d\u0003\u0002\u0002\u0002\u097e\u097f\u0003\u0002\u0002\u0002\u097f\u0980\u0003\u0002\u0002\u0002\u0980\u0982\u0007\u008a\u0002\u0002\u0981\u0983\u0007\u0100\u0002\u0002\u0982\u0981\u0003\u0002\u0002\u0002\u0982\u0983\u0003\u0002\u0002\u0002\u0983\u0984\u0003\u0002\u0002\u0002\u0984\u0985\u0005\u046c\u0237\u0002\u0985\u00f5\u0003\u0002\u0002\u0002\u0986\u0988\u0007\u01d5\u0002\u0002\u0987\u0986\u0003\u0002\u0002\u0002\u0987\u0988\u0003\u0002\u0002\u0002\u0988\u0989\u0003\u0002\u0002\u0002\u0989\u098b\u0007\u0170\u0002\u0002\u098a\u098c\u0007\u0100\u0002\u0002\u098b\u098a\u0003\u0002\u0002\u0002\u098b\u098c\u0003\u0002\u0002\u0002\u098c\u098d\u0003\u0002\u0002\u0002\u098d\u098e\u0005\u046c\u0237\u0002\u098e\u00f7\u0003\u0002\u0002\u0002\u098f\u0991\u0007\u01d5\u0002\u0002\u0990\u098f\u0003\u0002\u0002\u0002\u0990\u0991\u0003\u0002\u0002\u0002\u0991\u0992\u0003\u0002\u0002\u0002\u0992\u0994\u0007\u01c2\u0002\u0002\u0993\u0995\u0007\u0100\u0002\u0002\u0994\u0993\u0003\u0002\u0002\u0002\u0994\u0995\u0003\u0002\u0002\u0002\u0995\u0996\u0003\u0002\u0002\u0002\u0996\u0997\u0005\u046c\u0237\u0002\u0997\u00f9\u0003\u0002\u0002\u0002\u0998\u099a\u0007\u01d5\u0002\u0002\u0999\u0998\u0003\u0002\u0002\u0002\u0999\u099a\u0003\u0002\u0002\u0002\u099a\u099b\u0003\u0002\u0002\u0002\u099b\u099d\u0007\u01dd\u0002\u0002\u099c\u099e\u0007\u0100\u0002\u0002\u099d\u099c\u0003\u0002\u0002\u0002\u099d\u099e\u0003\u0002\u0002\u0002\u099e\u099f\u0003\u0002\u0002\u0002\u099f\u09a0\u0005\u046c\u0237\u0002\u09a0\u00fb\u0003\u0002\u0002\u0002\u09a1\u09a3\u0007\u01d5\u0002\u0002\u09a2\u09a1\u0003\u0002\u0002\u0002\u09a2\u09a3\u0003\u0002\u0002\u0002\u09a3\u09a4\u0003\u0002\u0002\u0002\u09a4\u09a6\u0009\u0012\u0002\u0002\u09a5\u09a7\u0007\u0100\u0002\u0002\u09a6\u09a5\u0003\u0002\u0002\u0002\u09a6\u09a7\u0003\u0002\u0002\u0002\u09a7\u09a8\u0003\u0002\u0002\u0002\u09a8\u09a9\u0005\u046c\u0237\u0002\u09a9\u00fd\u0003\u0002\u0002\u0002\u09aa\u09ab\u0007\u01e0\u0002\u0002\u09ab\u09ad\u0007\u010f\u0002\u0002\u09ac\u09ae\u0007\u0100\u0002\u0002\u09ad\u09ac\u0003\u0002\u0002\u0002\u09ad\u09ae\u0003\u0002\u0002\u0002\u09ae\u09af\u0003\u0002\u0002\u0002\u09af\u09b0\u0005\u046c\u0237\u0002\u09b0\u00ff\u0003\u0002\u0002\u0002\u09b1\u09b2\u0007\u011f\u0002\u0002\u09b2\u09b3\u0007\u01a5\u0002\u0002\u09b3\u09b8\u0007\u0218\u0002\u0002\u09b4\u09b5\u0007\u010b\u0002\u0002\u09b5\u09b6\u0005\u047a\u023e\u0002\u09b6\u09b7\u0007\u0218\u0002\u0002\u09b7\u09b9\u0003\u0002\u0002\u0002\u09b8\u09b4\u0003\u0002\u0002\u0002\u09b8\u09b9\u0003\u0002\u0002\u0002\u09b9\u09bd\u0003\u0002\u0002\u0002\u09ba\u09bc\u0005\u01b4\u00db\u0002\u09bb\u09ba\u0003\u0002\u0002\u0002\u09bc\u09bf\u0003\u0002\u0002\u0002\u09bd\u09bb\u0003\u0002\u0002\u0002\u09bd\u09be\u0003\u0002\u0002\u0002\u09be\u0101\u0003\u0002\u0002\u0002\u09bf\u09bd\u0003\u0002\u0002\u0002\u09c0\u09c1\u0007\u01a2\u0002\u0002\u09c1\u09c2\u0007\u01a5\u0002\u0002\u09c2\u09c6\u0007\u0218\u0002\u0002\u09c3\u09c5\u0005\u0104\u0083\u0002\u09c4\u09c3\u0003\u0002\u0002\u0002\u09c5\u09c8\u0003\u0002\u0002\u0002\u09c6\u09c4\u0003\u0002\u0002\u0002\u09c6\u09c7\u0003\u0002\u0002\u0002\u09c7\u0103\u0003\u0002\u0002\u0002\u09c8\u09c6\u0003\u0002\u0002\u0002\u09c9\u09cc\u0007\u022d\u0002\u0002\u09ca\u09cd\u0007\u00d2\u0002\u0002\u09cb\u09cd\u0005\u048a\u0246\u0002\u09cc\u09ca\u0003\u0002\u0002\u0002\u09cc\u09cb\u0003\u0002\u0002\u0002\u09cc\u09cd\u0003\u0002\u0002\u0002\u09cd\u09ee\u0003\u0002\u0002\u0002\u09ce\u09ed\u0005\u0106\u0084\u0002\u09cf\u09ed\u0005\u0108\u0085\u0002\u09d0\u09ed\u0005\u010a\u0086\u0002\u09d1\u09ed\u0005\u010c\u0087\u0002\u09d2\u09ed\u0005\u010e\u0088\u0002\u09d3\u09ed\u0005\u0110\u0089\u0002\u09d4\u09ed\u0005\u0112\u008a\u0002\u09d5\u09ed\u0005\u0114\u008b\u0002\u09d6\u09ed\u0005\u0116\u008c\u0002\u09d7\u09ed\u0005\u0118\u008d\u0002\u09d8\u09ed\u0005\u011a\u008e\u0002\u09d9\u09ed\u0005\u011c\u008f\u0002\u09da\u09ed\u0005\u011e\u0090\u0002\u09db\u09ed\u0005\u0120\u0091\u0002\u09dc\u09ed\u0005\u0122\u0092\u0002\u09dd\u09ed\u0005\u0124\u0093\u0002\u09de\u09e1\u0005\u0126\u0094\u0002\u09df\u09e1\u0005\u012a\u0096\u0002\u09e0\u09de\u0003\u0002\u0002\u0002\u09e0\u09df\u0003\u0002\u0002\u0002\u09e1\u09ed\u0003\u0002\u0002\u0002\u09e2\u09ed\u0005\u012c\u0097\u0002\u09e3\u09ed\u0005\u012e\u0098\u0002\u09e4\u09ed\u0005\u0130\u0099\u0002\u09e5\u09ed\u0005\u0132\u009a\u0002\u09e6\u09ed\u0005\u0134\u009b\u0002\u09e7\u09ed\u0005\u0136\u009c\u0002\u09e8\u09ed\u0005\u0138\u009d\u0002\u09e9\u09ed\u0005\u013a\u009e\u0002\u09ea\u09ed\u0005\u013e\u00a0\u0002\u09eb\u09ed\u0005\u0140\u00a1\u0002\u09ec\u09ce\u0003\u0002\u0002\u0002\u09ec\u09cf\u0003\u0002\u0002\u0002\u09ec\u09d0\u0003\u0002\u0002\u0002\u09ec\u09d1\u0003\u0002\u0002\u0002\u09ec\u09d2\u0003\u0002\u0002\u0002\u09ec\u09d3\u0003\u0002\u0002\u0002\u09ec\u09d4\u0003\u0002\u0002\u0002\u09ec\u09d5\u0003\u0002\u0002\u0002\u09ec\u09d6\u0003\u0002\u0002\u0002\u09ec\u09d7\u0003\u0002\u0002\u0002\u09ec\u09d8\u0003\u0002\u0002\u0002\u09ec\u09d9\u0003\u0002\u0002\u0002\u09ec\u09da\u0003\u0002\u0002\u0002\u09ec\u09db\u0003\u0002\u0002\u0002\u09ec\u09dc\u0003\u0002\u0002\u0002\u09ec\u09dd\u0003\u0002\u0002\u0002\u09ec\u09e0\u0003\u0002\u0002\u0002\u09ec\u09e2\u0003\u0002\u0002\u0002\u09ec\u09e3\u0003\u0002\u0002\u0002\u09ec\u09e4\u0003\u0002\u0002\u0002\u09ec\u09e5\u0003\u0002\u0002\u0002\u09ec\u09e6\u0003\u0002\u0002\u0002\u09ec\u09e7\u0003\u0002\u0002\u0002\u09ec\u09e8\u0003\u0002\u0002\u0002\u09ec\u09e9\u0003\u0002\u0002\u0002\u09ec\u09ea\u0003\u0002\u0002\u0002\u09ec\u09eb\u0003\u0002\u0002\u0002\u09ed\u09f0\u0003\u0002\u0002\u0002\u09ee\u09ec\u0003\u0002\u0002\u0002\u09ee\u09ef\u0003\u0002\u0002\u0002\u09ef\u09f1\u0003\u0002\u0002\u0002\u09f0\u09ee\u0003\u0002\u0002\u0002\u09f1\u09f2\u0007\u0218\u0002\u0002\u09f2\u0105\u0003\u0002\u0002\u0002\u09f3\u09f4\u0007\u002e\u0002\u0002\u09f4\u09f5\u0009\u0013\u0002\u0002\u09f5\u0107\u0003\u0002\u0002\u0002\u09f6\u09f7\u0009\u0014\u0002\u0002\u09f7\u0109\u0003\u0002\u0002\u0002\u09f8\u09f9\u0007\u002f\u0002\u0002\u09f9\u010b\u0003\u0002\u0002\u0002\u09fa\u09fb\u0007\u00bd\u0002\u0002\u09fb\u09fc\u0009\u0015\u0002\u0002\u09fc\u010d\u0003\u0002\u0002\u0002\u09fd\u09fe\u0009\u0016\u0002\u0002\u09fe\u010f\u0003\u0002\u0002\u0002\u09ff\u0a00\u0009\u0017\u0002\u0002\u0a00\u0111\u0003\u0002\u0002\u0002\u0a01\u0a02\u0007\u0193\u0002\u0002\u0a02\u0113\u0003\u0002\u0002\u0002\u0a03\u0a04\u0007\u01f4\u0002\u0002\u0a04\u0115\u0003\u0002\u0002\u0002\u0a05\u0a07\u0007\u01b9\u0002\u0002\u0a06\u0a08\u0007\u0100\u0002\u0002\u0a07\u0a06\u0003\u0002\u0002\u0002\u0a07\u0a08\u0003\u0002\u0002\u0002\u0a08\u0a0b\u0003\u0002\u0002\u0002\u0a09\u0a0c\u0005\u0434\u021b\u0002\u0a0a\u0a0c\u0005\u049c\u024f\u0002\u0a0b\u0a09\u0003\u0002\u0002\u0002\u0a0b\u0a0a\u0003\u0002\u0002\u0002\u0a0c\u0117\u0003\u0002\u0002\u0002\u0a0d\u0a15\u0007\u0119\u0002\u0002\u0a0e\u0a10\u0007\u013d\u0002\u0002\u0a0f\u0a0e\u0003\u0002\u0002\u0002\u0a0f\u0a10\u0003\u0002\u0002\u0002\u0a10\u0a12\u0003\u0002\u0002\u0002\u0a11\u0a13\u0007\u0100\u0002\u0002\u0a12\u0a11\u0003\u0002\u0002\u0002\u0a12\u0a13\u0003\u0002\u0002\u0002\u0a13\u0a14\u0003\u0002\u0002\u0002\u0a14\u0a16\u0009\u0018\u0002\u0002\u0a15\u0a0f\u0003\u0002\u0002\u0002\u0a15\u0a16\u0003\u0002\u0002\u0002\u0a16\u0a19\u0003\u0002\u0002\u0002\u0a17\u0a1a\u0005\u0434\u021b\u0002\u0a18\u0a1a\u0005\u049c\u024f\u0002\u0a19\u0a17\u0003\u0002\u0002\u0002\u0a19\u0a18\u0003\u0002\u0002\u0002\u0a1a\u0119\u0003\u0002\u0002\u0002\u0a1b\u0a23\u0009\u0019\u0002\u0002\u0a1c\u0a1e\u0007\u013d\u0002\u0002\u0a1d\u0a1c\u0003\u0002\u0002\u0002\u0a1d\u0a1e\u0003\u0002\u0002\u0002\u0a1e\u0a20\u0003\u0002\u0002\u0002\u0a1f\u0a21\u0007\u0100\u0002\u0002\u0a20\u0a1f\u0003\u0002\u0002\u0002\u0a20\u0a21\u0003\u0002\u0002\u0002\u0a21\u0a22\u0003\u0002\u0002\u0002\u0a22\u0a24\u0009\u0018\u0002\u0002\u0a23\u0a1d\u0003\u0002\u0002\u0002\u0a23\u0a24\u0003\u0002\u0002\u0002\u0a24\u0a27\u0003\u0002\u0002\u0002\u0a25\u0a28\u0005\u0434\u021b\u0002\u0a26\u0a28\u0005\u049c\u024f\u0002\u0a27\u0a25\u0003\u0002\u0002\u0002\u0a27\u0a26\u0003\u0002\u0002\u0002\u0a28\u011b\u0003\u0002\u0002\u0002\u0a29\u0a2b\u0009\u001a\u0002\u0002\u0a2a\u0a2c\u0007\u0100\u0002\u0002\u0a2b\u0a2a\u0003\u0002\u0002\u0002\u0a2b\u0a2c\u0003\u0002\u0002\u0002\u0a2c\u0a2f\u0003\u0002\u0002\u0002\u0a2d\u0a30\u0005\u0434\u021b\u0002\u0a2e\u0a30\u0005\u049c\u024f\u0002\u0a2f\u0a2d\u0003\u0002\u0002\u0002\u0a2f\u0a2e\u0003\u0002\u0002\u0002\u0a30\u011d\u0003\u0002\u0002\u0002\u0a31\u0a33\u0009\u001b\u0002\u0002\u0a32\u0a34\u0007\u0100\u0002\u0002\u0a33\u0a32\u0003\u0002\u0002\u0002\u0a33\u0a34\u0003\u0002\u0002\u0002\u0a34\u0a37\u0003\u0002\u0002\u0002\u0a35\u0a38\u0005\u0434\u021b\u0002\u0a36\u0a38\u0005\u049c\u024f\u0002\u0a37\u0a35\u0003\u0002\u0002\u0002\u0a37\u0a36\u0003\u0002\u0002\u0002\u0a38\u011f\u0003\u0002\u0002\u0002\u0a39\u0a3b\u0007\u0063\u0002\u0002\u0a3a\u0a3c\u0007\u0100\u0002\u0002\u0a3b\u0a3a\u0003\u0002\u0002\u0002\u0a3b\u0a3c\u0003\u0002\u0002\u0002\u0a3c\u0a3d\u0003\u0002\u0002\u0002\u0a3d\u0a3e\u0005\u0434\u021b\u0002\u0a3e\u0121\u0003\u0002\u0002\u0002\u0a3f\u0a41\u0007\u01fd\u0002\u0002\u0a40\u0a42\u0007\u0100\u0002\u0002\u0a41\u0a40\u0003\u0002\u0002\u0002\u0a41\u0a42\u0003\u0002\u0002\u0002\u0a42\u0a43\u0003\u0002\u0002\u0002\u0a43\u0a44\u0005\u0496\u024c\u0002\u0a44\u0123\u0003\u0002\u0002\u0002\u0a45\u0a47\u0009\u001c\u0002\u0002\u0a46\u0a48\u0007\u0100\u0002\u0002\u0a47\u0a46\u0003\u0002\u0002\u0002\u0a47\u0a48\u0003\u0002\u0002\u0002\u0a48\u0a49\u0003\u0002\u0002\u0002\u0a49\u0a4a\u0005\u01d4\u00eb\u0002\u0a4a\u0125\u0003\u0002\u0002\u0002\u0a4b\u0a4e\u0007\u00d9\u0002\u0002\u0a4c\u0a4f\u0005\u0434\u021b\u0002\u0a4d\u0a4f\u0005\u0496\u024c\u0002\u0a4e\u0a4c\u0003\u0002\u0002\u0002\u0a4e\u0a4d\u0003\u0002\u0002\u0002\u0a4f\u0a51\u0003\u0002\u0002\u0002\u0a50\u0a52\u0005\u0128\u0095\u0002\u0a51\u0a50\u0003\u0002\u0002\u0002\u0a51\u0a52\u0003\u0002\u0002\u0002\u0a52\u0127\u0003\u0002\u0002\u0002\u0a53\u0a54\u0007\u01eb\u0002\u0002\u0a54\u0a55\u0005\u0434\u021b\u0002\u0a55\u0129\u0003\u0002\u0002\u0002\u0a56\u0a57\u0007\u01fc\u0002\u0002\u0a57\u0a58\u0005\u0434\u021b\u0002\u0a58\u012b\u0003\u0002\u0002\u0002\u0a59\u0a5b\u0007\u01fa\u0002\u0002\u0a5a\u0a5c\u0007\u0100\u0002\u0002\u0a5b\u0a5a\u0003\u0002\u0002\u0002\u0a5b\u0a5c\u0003\u0002\u0002\u0002\u0a5c\u0a5d\u0003\u0002\u0002\u0002\u0a5d\u0a5e\u0009\u001d\u0002\u0002\u0a5e\u012d\u0003\u0002\u0002\u0002\u0a5f\u0a61\u0007\u002e\u0002\u0002\u0a60\u0a62\u0007\u0202\u0002\u0002\u0a61\u0a60\u0003\u0002\u0002\u0002\u0a61\u0a62\u0003\u0002\u0002\u0002\u0a62\u0a63\u0003\u0002\u0002\u0002\u0a63\u0a64\u0007\u020b\u0002\u0002\u0a64\u012f\u0003\u0002\u0002\u0002\u0a65\u0a67\u0009\u001e\u0002\u0002\u0a66\u0a68\u0007\u019d\u0002\u0002\u0a67\u0a66\u0003\u0002\u0002\u0002\u0a67\u0a68\u0003\u0002\u0002\u0002\u0a68\u0131\u0003\u0002\u0002\u0002\u0a69\u0a6b\u0007\u01b8\u0002\u0002\u0a6a\u0a6c\u0007\u0100\u0002\u0002\u0a6b\u0a6a\u0003\u0002\u0002\u0002\u0a6b\u0a6c\u0003\u0002\u0002\u0002\u0a6c\u0a6e\u0003\u0002\u0002\u0002\u0a6d\u0a69\u0003\u0002\u0002\u0002\u0a6d\u0a6e\u0003\u0002\u0002\u0002\u0a6e\u0a6f\u0003\u0002\u0002\u0002\u0a6f\u0a74\u0009\u0009\u0002\u0002\u0a70\u0a72\u0007\u01ad\u0002\u0002\u0a71\u0a73\u0007\u0040\u0002\u0002\u0a72\u0a71\u0003\u0002\u0002\u0002\u0a72\u0a73\u0003\u0002\u0002\u0002\u0a73\u0a75\u0003\u0002\u0002\u0002\u0a74\u0a70\u0003\u0002\u0002\u0002\u0a74\u0a75\u0003\u0002\u0002\u0002\u0a75\u0133\u0003\u0002\u0002\u0002\u0a76\u0a77\u0009\u001f\u0002\u0002\u0a77\u0135\u0003\u0002\u0002\u0002\u0a78\u0a79\u0009\u0020\u0002\u0002\u0a79\u0137\u0003\u0002\u0002\u0002\u0a7a\u0a7b\u0009\u0021\u0002\u0002\u0a7b\u0139\u0003\u0002\u0002\u0002\u0a7c\u0a7e\u0007\u016e\u0002\u0002\u0a7d\u0a7f\u0007\u0040\u0002\u0002\u0a7e\u0a7d\u0003\u0002\u0002\u0002\u0a7e\u0a7f\u0003\u0002\u0002\u0002\u0a7f\u0a81\u0003\u0002\u0002\u0002\u0a80\u0a82\u0007\u0100\u0002\u0002\u0a81\u0a80\u0003\u0002\u0002\u0002\u0a81\u0a82\u0003\u0002\u0002\u0002\u0a82\u0a85\u0003\u0002\u0002\u0002\u0a83\u0a86\u0005\u0434\u021b\u0002\u0a84\u0a86\u0005\u0496\u024c\u0002\u0a85\u0a83\u0003\u0002\u0002\u0002\u0a85\u0a84\u0003\u0002\u0002\u0002\u0a86\u0a88\u0003\u0002\u0002\u0002\u0a87\u0a89\u0005\u013c\u009f\u0002\u0a88\u0a87\u0003\u0002\u0002\u0002\u0a88\u0a89\u0003\u0002\u0002\u0002\u0a89\u013b\u0003\u0002\u0002\u0002\u0a8a\u0a8b\u0007\u0143\u0002\u0002\u0a8b\u0a8d\u0005\u049c\u024f\u0002\u0a8c\u0a8e\u0007\u01e9\u0002\u0002\u0a8d\u0a8c\u0003\u0002\u0002\u0002\u0a8d\u0a8e\u0003\u0002\u0002\u0002\u0a8e\u013d\u0003\u0002\u0002\u0002\u0a8f\u0a90\u0009\u0022\u0002\u0002\u0a90\u013f\u0003\u0002\u0002\u0002\u0a91\u0a92\u0007\u020c\u0002\u0002\u0a92\u0141\u0003\u0002\u0002\u0002\u0a93\u0a94\u0007\u018d\u0002\u0002\u0a94\u0a95\u0007\u01a5\u0002\u0002\u0a95\u0a99\u0007\u0218\u0002\u0002\u0a96\u0a98\u0005\u0144\u00a3\u0002\u0a97\u0a96\u0003\u0002\u0002\u0002\u0a98\u0a9b\u0003\u0002\u0002\u0002\u0a99\u0a97\u0003\u0002\u0002\u0002\u0a99\u0a9a\u0003\u0002\u0002\u0002\u0a9a\u0143\u0003\u0002\u0002\u0002\u0a9b\u0a99\u0003\u0002\u0002\u0002\u0a9c\u0a9e\u0005\u0146\u00a4\u0002\u0a9d\u0a9f\u0005\u0154\u00ab\u0002\u0a9e\u0a9d\u0003\u0002\u0002\u0002\u0a9f\u0aa0\u0003\u0002\u0002\u0002\u0aa0\u0a9e\u0003\u0002\u0002\u0002\u0aa0\u0aa1\u0003\u0002\u0002\u0002\u0aa1\u0145\u0003\u0002\u0002\u0002\u0aa2\u0aa3\u0007\u0176\u0002\u0002\u0aa3\u0aa5\u0005\u0486\u0244\u0002\u0aa4\u0aa6\u0005\u0148\u00a5\u0002\u0aa5\u0aa4\u0003\u0002\u0002\u0002\u0aa5\u0aa6\u0003\u0002\u0002\u0002\u0aa6\u0ab4\u0003\u0002\u0002\u0002\u0aa7\u0aa9\u0005\u014a\u00a6\u0002\u0aa8\u0aaa\u0005\u014c\u00a7\u0002\u0aa9\u0aa8\u0003\u0002\u0002\u0002\u0aa9\u0aaa\u0003\u0002\u0002\u0002\u0aaa\u0aac\u0003\u0002\u0002\u0002\u0aab\u0aad\u0005\u014e\u00a8\u0002\u0aac\u0aab\u0003\u0002\u0002\u0002\u0aac\u0aad\u0003\u0002\u0002\u0002\u0aad\u0aaf\u0003\u0002\u0002\u0002\u0aae\u0ab0\u0005\u0150\u00a9\u0002\u0aaf\u0aae\u0003\u0002\u0002\u0002\u0aaf\u0ab0\u0003\u0002\u0002\u0002\u0ab0\u0ab2\u0003\u0002\u0002\u0002\u0ab1\u0ab3\u0005\u0152\u00aa\u0002\u0ab2\u0ab1\u0003\u0002\u0002\u0002\u0ab2\u0ab3\u0003\u0002\u0002\u0002\u0ab3\u0ab5\u0003\u0002\u0002\u0002\u0ab4\u0aa7\u0003\u0002\u0002\u0002\u0ab4\u0ab5\u0003\u0002\u0002\u0002\u0ab5\u0ab6\u0003\u0002\u0002\u0002\u0ab6\u0ab7\u0007\u0218\u0002\u0002\u0ab7\u0147\u0003\u0002\u0002\u0002\u0ab8\u0aba\u0007\u0100\u0002\u0002\u0ab9\u0ab8\u0003\u0002\u0002\u0002\u0ab9\u0aba\u0003\u0002\u0002\u0002\u0aba\u0abb\u0003\u0002\u0002\u0002\u0abb\u0abc\u0007\u00e1\u0002\u0002\u0abc\u0149\u0003\u0002\u0002\u0002\u0abd\u0ac6\u0007\u0156\u0002\u0002\u0abe\u0ac0\u0007\u0115\u0002\u0002\u0abf\u0ac1\u0007\u0100\u0002\u0002\u0ac0\u0abf\u0003\u0002\u0002\u0002\u0ac0\u0ac1\u0003\u0002\u0002\u0002\u0ac1\u0ac7\u0003\u0002\u0002\u0002\u0ac2\u0ac4\u0007\u0116\u0002\u0002\u0ac3\u0ac5\u0007\u0017\u0002\u0002\u0ac4\u0ac3\u0003\u0002\u0002\u0002\u0ac4\u0ac5\u0003\u0002\u0002\u0002\u0ac5\u0ac7\u0003\u0002\u0002\u0002\u0ac6\u0abe\u0003\u0002\u0002\u0002\u0ac6\u0ac2\u0003\u0002\u0002\u0002\u0ac6\u0ac7\u0003\u0002\u0002\u0002\u0ac7\u0ac8\u0003\u0002\u0002\u0002\u0ac8\u0aca\u0005\u049c\u024f\u0002\u0ac9\u0acb\u0009\u0023\u0002\u0002\u0aca\u0ac9\u0003\u0002\u0002\u0002\u0aca\u0acb\u0003\u0002\u0002\u0002\u0acb\u014b\u0003\u0002\u0002\u0002\u0acc\u0acd\u0007\u00e6\u0002\u0002\u0acd\u0ace\u0005\u049c\u024f\u0002\u0ace\u014d\u0003\u0002\u0002\u0002\u0acf\u0ad0\u0007\u00d4\u0002\u0002\u0ad0\u0ad1\u0007\u008b\u0002\u0002\u0ad1\u0ad2\u0005\u049c\u024f\u0002\u0ad2\u014f\u0003\u0002\u0002\u0002\u0ad3\u0ad4\u0007\u0109\u0002\u0002\u0ad4\u0ad5\u0007\u008b\u0002\u0002\u0ad5\u0ad6\u0005\u049c\u024f\u0002\u0ad6\u0151\u0003\u0002\u0002\u0002\u0ad7\u0ad8\u0007\u00d5\u0002\u0002\u0ad8\u0ad9\u0005\u049c\u024f\u0002\u0ad9\u0153\u0003\u0002\u0002\u0002\u0ada\u0ade\u0005\u0156\u00ac\u0002\u0adb\u0ade\u0005\u0158\u00ad\u0002\u0adc\u0ade\u0005\u015a\u00ae\u0002\u0add\u0ada\u0003\u0002\u0002\u0002\u0add\u0adb\u0003\u0002\u0002\u0002\u0add\u0adc\u0003\u0002\u0002\u0002\u0ade\u0155\u0003\u0002\u0002\u0002\u0adf\u0ae0\u0005\u049c\u024f\u0002\u0ae0\u0ae2\u0005\u046a\u0236\u0002\u0ae1\u0ae3\u0005\u0164\u00b3\u0002\u0ae2\u0ae1\u0003\u0002\u0002\u0002\u0ae2\u0ae3\u0003\u0002\u0002\u0002\u0ae3\u0ae5\u0003\u0002\u0002\u0002\u0ae4\u0ae6\u0005\u016a\u00b6\u0002\u0ae5\u0ae4\u0003\u0002\u0002\u0002\u0ae5\u0ae6\u0003\u0002\u0002\u0002\u0ae6\u0ae7\u0003\u0002\u0002\u0002\u0ae7\u0ae9\u0005\u017a\u00be\u0002\u0ae8\u0aea\u0005\u0186\u00c4\u0002\u0ae9\u0ae8\u0003\u0002\u0002\u0002\u0ae9\u0aea\u0003\u0002\u0002\u0002\u0aea\u0aeb\u0003\u0002\u0002\u0002\u0aeb\u0aec\u0007\u0218\u0002\u0002\u0aec\u0157\u0003\u0002\u0002\u0002\u0aed\u0aef\u0005\u049c\u024f\u0002\u0aee\u0af0\u0005\u046a\u0236\u0002\u0aef\u0aee\u0003\u0002\u0002\u0002\u0aef\u0af0\u0003\u0002\u0002\u0002\u0af0\u0af2\u0003\u0002\u0002\u0002\u0af1\u0af3\u0005\u0164\u00b3\u0002\u0af2\u0af1\u0003\u0002\u0002\u0002\u0af2\u0af3\u0003\u0002\u0002\u0002\u0af3\u0af4\u0003\u0002\u0002\u0002\u0af4\u0af5\u0005\u0186\u00c4\u0002\u0af5\u0af6\u0007\u0218\u0002\u0002\u0af6\u0159\u0003\u0002\u0002\u0002\u0af7\u0af9\u0005\u049c\u024f\u0002\u0af8\u0afa\u0005\u046a\u0236\u0002\u0af9\u0af8\u0003\u0002\u0002\u0002\u0af9\u0afa\u0003\u0002\u0002\u0002\u0afa\u0b0b\u0003\u0002\u0002\u0002\u0afb\u0b0a\u0005\u0170\u00b9\u0002\u0afc\u0b0a\u0005\u0186\u00c4\u0002\u0afd\u0b0a\u0005\u0174\u00bb\u0002\u0afe\u0b0a\u0005\u0162\u00b2\u0002\u0aff\u0b0a\u0005\u015c\u00af\u0002\u0b00\u0b0a\u0005\u0164\u00b3\u0002\u0b01\u0b0a\u0005\u015e\u00b0\u0002\u0b02\u0b07\u0005\u0176\u00bc\u0002\u0b03\u0b07\u0005\u018c\u00c7\u0002\u0b04\u0b07\u0005\u0178\u00bd\u0002\u0b05\u0b07\u0005\u0172\u00ba\u0002\u0b06\u0b02\u0003\u0002\u0002\u0002\u0b06\u0b03\u0003\u0002\u0002\u0002\u0b06\u0b04\u0003\u0002\u0002\u0002\u0b06\u0b05\u0003\u0002\u0002\u0002\u0b07\u0b0a\u0003\u0002\u0002\u0002\u0b08\u0b0a\u0005\u0160\u00b1\u0002\u0b09\u0afb\u0003\u0002\u0002\u0002\u0b09\u0afc\u0003\u0002\u0002\u0002\u0b09\u0afd\u0003\u0002\u0002\u0002\u0b09\u0afe\u0003\u0002\u0002\u0002\u0b09\u0aff\u0003\u0002\u0002\u0002\u0b09\u0b00\u0003\u0002\u0002\u0002\u0b09\u0b01\u0003\u0002\u0002\u0002\u0b09\u0b06\u0003\u0002\u0002\u0002\u0b09\u0b08\u0003\u0002\u0002\u0002\u0b0a\u0b0d\u0003\u0002\u0002\u0002\u0b0b\u0b09\u0003\u0002\u0002\u0002\u0b0b\u0b0c\u0003\u0002\u0002\u0002\u0b0c\u0b0e\u0003\u0002\u0002\u0002\u0b0d\u0b0b\u0003\u0002\u0002\u0002\u0b0e\u0b0f\u0007\u0218\u0002\u0002\u0b0f\u015b\u0003\u0002\u0002\u0002\u0b10\u0b12\u0007\u002e\u0002\u0002\u0b11\u0b13\u0007\u0202\u0002\u0002\u0b12\u0b11\u0003\u0002\u0002\u0002\u0b12\u0b13\u0003\u0002\u0002\u0002\u0b13\u0b14\u0003\u0002\u0002\u0002\u0b14\u0b15\u0007\u020b\u0002\u0002\u0b15\u015d\u0003\u0002\u0002\u0002\u0b16\u0b18\u0007\u004c\u0002\u0002\u0b17\u0b19\u0007\u013d\u0002\u0002\u0b18\u0b17\u0003\u0002\u0002\u0002\u0b18\u0b19\u0003\u0002\u0002\u0002\u0b19\u0b1b\u0003\u0002\u0002\u0002\u0b1a\u0b1c\u0007\u0100\u0002\u0002\u0b1b\u0b1a\u0003\u0002\u0002\u0002\u0b1b\u0b1c\u0003\u0002\u0002\u0002\u0b1c\u0b1d\u0003\u0002\u0002\u0002\u0b1d\u0b1e\u0005\u049c\u024f\u0002\u0b1e\u015f\u0003\u0002\u0002\u0002\u0b1f\u0b21\u0007\u00e5\u0002\u0002\u0b20\u0b22\u0007\u00f4\u0002\u0002\u0b21\u0b20\u0003\u0002\u0002\u0002\u0b21\u0b22\u0003\u0002\u0002\u0002\u0b22\u0161\u0003\u0002\u0002\u0002\u0b23\u0b25\u0009\u001e\u0002\u0002\u0b24\u0b26\u0007\u019d\u0002\u0002\u0b25\u0b24\u0003\u0002\u0002\u0002\u0b25\u0b26\u0003\u0002\u0002\u0002\u0b26\u0163\u0003\u0002\u0002\u0002\u0b27\u0b29\u0007\u0119\u0002\u0002\u0b28\u0b27\u0003\u0002\u0002\u0002\u0b28\u0b29\u0003\u0002\u0002\u0002\u0b29\u0b2b\u0003\u0002\u0002\u0002\u0b2a\u0b2c\u0007\u013d\u0002\u0002\u0b2b\u0b2a\u0003\u0002\u0002\u0002\u0b2b\u0b2c\u0003\u0002\u0002\u0002\u0b2c\u0b2e\u0003\u0002\u0002\u0002\u0b2d\u0b2f\u0007\u0100\u0002\u0002\u0b2e\u0b2d\u0003\u0002\u0002\u0002\u0b2e\u0b2f\u0003\u0002\u0002\u0002\u0b2f\u0b32\u0003\u0002\u0002\u0002\u0b30\u0b33\u0005\u0166\u00b4\u0002\u0b31\u0b33\u0005\u0168\u00b5\u0002\u0b32\u0b30\u0003\u0002\u0002\u0002\u0b32\u0b31\u0003\u0002\u0002\u0002\u0b33\u0165\u0003\u0002\u0002\u0002\u0b34\u0b3a\u0005\u049c\u024f\u0002\u0b35\u0b37\u0007\u0148\u0002\u0002\u0b36\u0b35\u0003\u0002\u0002\u0002\u0b36\u0b37\u0003\u0002\u0002\u0002\u0b37\u0b38\u0003\u0002\u0002\u0002\u0b38\u0b39\u0007\u0137\u0002\u0002\u0b39\u0b3b\u0007\u0156\u0002\u0002\u0b3a\u0b36\u0003\u0002\u0002\u0002\u0b3a\u0b3b\u0003\u0002\u0002\u0002\u0b3b\u0167\u0003\u0002\u0002\u0002\u0b3c\u0b3d\u0007\u015e\u0002\u0002\u0b3d\u0b3e\u0005\u049c\u024f\u0002\u0b3e\u0169\u0003\u0002\u0002\u0002\u0b3f\u0b40\u0007\u0137\u0002\u0002\u0b40\u0b42\u0007\u00e5\u0002\u0002\u0b41\u0b43\u0007\u0100\u0002\u0002\u0b42\u0b41\u0003\u0002\u0002\u0002\u0b42\u0b43\u0003\u0002\u0002\u0002\u0b43\u0b47\u0003\u0002\u0002\u0002\u0b44\u0b48\u0005\u049c\u024f\u0002\u0b45\u0b48\u0005\u016e\u00b8\u0002\u0b46\u0b48\u0005\u016c\u00b7\u0002\u0b47\u0b44\u0003\u0002\u0002\u0002\u0b47\u0b45\u0003\u0002\u0002\u0002\u0b47\u0b46\u0003\u0002\u0002\u0002\u0b48\u016b\u0003\u0002\u0002\u0002\u0b49\u0b4a\u0007\u015e\u0002\u0002\u0b4a\u0b4b\u0005\u049c\u024f\u0002\u0b4b\u016d\u0003\u0002\u0002\u0002\u0b4c\u0b4d\u0007\u0137\u0002\u0002\u0b4d\u0b4e\u0007\u0156\u0002\u0002\u0b4e\u016f\u0003\u0002\u0002\u0002\u0b4f\u0b51\u0009\u001c\u0002\u0002\u0b50\u0b52\u0007\u0100\u0002\u0002\u0b51\u0b50\u0003\u0002\u0002\u0002\u0b51\u0b52\u0003\u0002\u0002\u0002\u0b52\u0b53\u0003\u0002\u0002\u0002\u0b53\u0b54\u0005\u01d4\u00eb\u0002\u0b54\u0171\u0003\u0002\u0002\u0002\u0b55\u0b57\u0007\u0194\u0002\u0002\u0b56\u0b58\u0007\u0148\u0002\u0002\u0b57\u0b56\u0003\u0002\u0002\u0002\u0b57\u0b58\u0003\u0002\u0002\u0002\u0b58\u0b5b\u0003\u0002\u0002\u0002\u0b59\u0b5c\u0007\u00d3\u0002\u0002\u0b5a\u0b5c\u0005\u046a\u0236\u0002\u0b5b\u0b59\u0003\u0002\u0002\u0002\u0b5b\u0b5a\u0003\u0002\u0002\u0002\u0b5c\u0173\u0003\u0002\u0002\u0002\u0b5d\u0b5f\u0007\u01b8\u0002\u0002\u0b5e\u0b60\u0007\u0100\u0002\u0002\u0b5f\u0b5e\u0003\u0002\u0002\u0002\u0b5f\u0b60\u0003\u0002\u0002\u0002\u0b60\u0b61\u0003\u0002\u0002\u0002\u0b61\u0b62\u0009\u0009\u0002\u0002\u0b62\u0b64\u0007\u01ad\u0002\u0002\u0b63\u0b65\u0007\u0040\u0002\u0002\u0b64\u0b63\u0003\u0002\u0002\u0002\u0b64\u0b65\u0003\u0002\u0002\u0002\u0b65\u0175\u0003\u0002\u0002\u0002\u0b66\u0b68\u0007\u01c2\u0002\u0002\u0b67\u0b69\u0007\u0100\u0002\u0002\u0b68\u0b67\u0003\u0002\u0002\u0002\u0b68\u0b69\u0003\u0002\u0002\u0002\u0b69\u0b6a\u0003\u0002\u0002\u0002\u0b6a\u0b6b\u0005\u0434\u021b\u0002\u0b6b\u0177\u0003\u0002\u0002\u0002\u0b6c\u0b6d\u0007\u01d2\u0002\u0002\u0b6d\u0b74\u0005\u0434\u021b\u0002\u0b6e\u0b70\u0007\u0213\u0002\u0002\u0b6f\u0b6e\u0003\u0002\u0002\u0002\u0b6f\u0b70\u0003\u0002\u0002\u0002\u0b70\u0b71\u0003\u0002\u0002\u0002\u0b71\u0b73\u0005\u0434\u021b\u0002\u0b72\u0b6f\u0003\u0002\u0002\u0002\u0b73\u0b76\u0003\u0002\u0002\u0002\u0b74\u0b72\u0003\u0002\u0002\u0002\u0b74\u0b75\u0003\u0002\u0002\u0002\u0b75\u0b82\u0003\u0002\u0002\u0002\u0b76\u0b74\u0003\u0002\u0002\u0002\u0b77\u0b78\u0007\u01f9\u0002\u0002\u0b78\u0b7f\u0005\u046a\u0236\u0002\u0b79\u0b7b\u0007\u0213\u0002\u0002\u0b7a\u0b79\u0003\u0002\u0002\u0002\u0b7a\u0b7b\u0003\u0002\u0002\u0002\u0b7b\u0b7c\u0003\u0002\u0002\u0002\u0b7c\u0b7e\u0005\u046a\u0236\u0002\u0b7d\u0b7a\u0003\u0002\u0002\u0002\u0b7e\u0b81\u0003\u0002\u0002\u0002\u0b7f\u0b7d\u0003\u0002\u0002\u0002\u0b7f\u0b80\u0003\u0002\u0002\u0002\u0b80\u0b83\u0003\u0002\u0002\u0002\u0b81\u0b7f\u0003\u0002\u0002\u0002\u0b82\u0b77\u0003\u0002\u0002\u0002\u0b82\u0b83\u0003\u0002\u0002\u0002\u0b83\u0179\u0003\u0002\u0002\u0002\u0b84\u0b86\u0007\u01f2\u0002\u0002\u0b85\u0b87\u0007\u0100\u0002\u0002\u0b86\u0b85\u0003\u0002\u0002\u0002\u0b86\u0b87\u0003\u0002\u0002\u0002\u0b87\u0b8f\u0003\u0002\u0002\u0002\u0b88\u0b90\u0005\u017c\u00bf\u0002\u0b89\u0b90\u0005\u017e\u00c0\u0002\u0b8a\u0b90\u0005\u0180\u00c1\u0002\u0b8b\u0b90\u0005\u0182\u00c2\u0002\u0b8c\u0b90\u0005\u0184\u00c3\u0002\u0b8d\u0b90\u0005\u0188\u00c5\u0002\u0b8e\u0b90\u0005\u018a\u00c6\u0002\u0b8f\u0b88\u0003\u0002\u0002\u0002\u0b8f\u0b89\u0003\u0002\u0002\u0002\u0b8f\u0b8a\u0003\u0002\u0002\u0002\u0b8f\u0b8b\u0003\u0002\u0002\u0002\u0b8f\u0b8c\u0003\u0002\u0002\u0002\u0b8f\u0b8d\u0003\u0002\u0002\u0002\u0b8f\u0b8e\u0003\u0002\u0002\u0002\u0b90\u017b\u0003\u0002\u0002\u0002\u0b91\u0b92\u0007\u018d\u0002\u0002\u0b92\u0b95\u0007\u00e6\u0002\u0002\u0b93\u0b95\u0007\u019c\u0002\u0002\u0b94\u0b91\u0003\u0002\u0002\u0002\u0b94\u0b93\u0003\u0002\u0002\u0002\u0b95\u017d\u0003\u0002\u0002\u0002\u0b96\u0b97\u0007\u0156\u0002\u0002\u0b97\u0b9a\u0007\u00e6\u0002\u0002\u0b98\u0b9a\u0007\u015b\u0002\u0002\u0b99\u0b96\u0003\u0002\u0002\u0002\u0b99\u0b98\u0003\u0002\u0002\u0002\u0b9a\u017f\u0003\u0002\u0002\u0002\u0b9b\u0b9c\u0007\u0063\u0002\u0002\u0b9c\u0b9f\u0007\u00e6\u0002\u0002\u0b9d\u0b9f\u0007\u003c\u0002\u0002\u0b9e\u0b9b\u0003\u0002\u0002\u0002\u0b9e\u0b9d\u0003\u0002\u0002\u0002\u0b9f\u0ba2\u0003\u0002\u0002\u0002\u0ba0\u0ba3\u0007\u00d3\u0002\u0002\u0ba1\u0ba3\u0005\u046a\u0236\u0002\u0ba2\u0ba0\u0003\u0002\u0002\u0002\u0ba2\u0ba1\u0003\u0002\u0002\u0002\u0ba3\u0181\u0003\u0002\u0002\u0002\u0ba4\u0ba5\u0009\u0024\u0002\u0002\u0ba5\u0183\u0003\u0002\u0002\u0002\u0ba6\u0ba7\u0007\u0063\u0002\u0002\u0ba7\u0baa\u0007\u00d5\u0002\u0002\u0ba8\u0baa\u0007\u003b\u0002\u0002\u0ba9\u0ba6\u0003\u0002\u0002\u0002\u0ba9\u0ba8\u0003\u0002\u0002\u0002\u0baa\u0bad\u0003\u0002\u0002\u0002\u0bab\u0bae\u0007\u00d3\u0002\u0002\u0bac\u0bae\u0005\u046a\u0236\u0002\u0bad\u0bab\u0003\u0002\u0002\u0002\u0bad\u0bac\u0003\u0002\u0002\u0002\u0bae\u0185\u0003\u0002\u0002\u0002\u0baf\u0bb1\u0007\u01fa\u0002\u0002\u0bb0\u0bb2\u0007\u0100\u0002\u0002\u0bb1\u0bb0\u0003\u0002\u0002\u0002\u0bb1\u0bb2\u0003\u0002\u0002\u0002\u0bb2\u0bb4\u0003\u0002\u0002\u0002\u0bb3\u0baf\u0003\u0002\u0002\u0002\u0bb3\u0bb4\u0003\u0002\u0002\u0002\u0bb4\u0bb5\u0003\u0002\u0002\u0002\u0bb5\u0bb6\u0009\u001d\u0002\u0002\u0bb6\u0187\u0003\u0002\u0002\u0002\u0bb7\u0bb8\u0007\u0156\u0002\u0002\u0bb8\u0bbb\u0007\u00d5\u0002\u0002\u0bb9\u0bbb\u0007\u015a\u0002\u0002\u0bba\u0bb7\u0003\u0002\u0002\u0002\u0bba\u0bb9\u0003\u0002\u0002\u0002\u0bbb\u0189\u0003\u0002\u0002\u0002\u0bbc\u0bbd\u0007\u018d\u0002\u0002\u0bbd\u0bc0\u0007\u00d5\u0002\u0002\u0bbe\u0bc0\u0007\u019b\u0002\u0002\u0bbf\u0bbc\u0003\u0002\u0002\u0002\u0bbf\u0bbe\u0003\u0002\u0002\u0002\u0bc0\u018b\u0003\u0002\u0002\u0002\u0bc1\u0bc3\u0007\u01fd\u0002\u0002\u0bc2\u0bc4\u0007\u0100\u0002\u0002\u0bc3\u0bc2\u0003\u0002\u0002\u0002\u0bc3\u0bc4\u0003\u0002\u0002\u0002\u0bc4\u0bc5\u0003\u0002\u0002\u0002\u0bc5\u0bc6\u0005\u0496\u024c\u0002\u0bc6\u018d\u0003\u0002\u0002\u0002\u0bc7\u0bc8\u0007\u016d\u0002\u0002\u0bc8\u0bc9\u0007\u01a5\u0002\u0002\u0bc9\u0bcd\u0007\u0218\u0002\u0002\u0bca\u0bcc\u0005\u0190\u00c9\u0002\u0bcb\u0bca\u0003\u0002\u0002\u0002\u0bcc\u0bcf\u0003\u0002\u0002\u0002\u0bcd\u0bcb\u0003\u0002\u0002\u0002\u0bcd\u0bce\u0003\u0002\u0002\u0002\u0bce\u018f\u0003\u0002\u0002\u0002\u0bcf\u0bcd\u0003\u0002\u0002\u0002\u0bd0\u0bd3\u0005\u0192\u00ca\u0002\u0bd1\u0bd3\u0005\u0194\u00cb\u0002\u0bd2\u0bd0\u0003\u0002\u0002\u0002\u0bd2\u0bd1\u0003\u0002\u0002\u0002\u0bd3\u0191\u0003\u0002\u0002\u0002\u0bd4\u0bd5\u0007\u010b\u0002\u0002\u0bd5\u0bd6\u0005\u0478\u023d\u0002\u0bd6\u0bd8\u0007\u00ca\u0002\u0002\u0bd7\u0bd9\u0005\u0196\u00cc\u0002\u0bd8\u0bd7\u0003\u0002\u0002\u0002\u0bd8\u0bd9\u0003\u0002\u0002\u0002\u0bd9\u0bdb\u0003\u0002\u0002\u0002\u0bda\u0bdc\u0005\u01a0\u00d1\u0002\u0bdb\u0bda\u0003\u0002\u0002\u0002\u0bdb\u0bdc\u0003\u0002\u0002\u0002\u0bdc\u0193\u0003\u0002\u0002\u0002\u0bdd\u0bde\u0007\u010a\u0002\u0002\u0bde\u0bdf\u0005\u0478\u023d\u0002\u0bdf\u0be1\u0007\u00f0\u0002\u0002\u0be0\u0be2\u0005\u01b2\u00da\u0002\u0be1\u0be0\u0003\u0002\u0002\u0002\u0be1\u0be2\u0003\u0002\u0002\u0002\u0be2\u0be4\u0003\u0002\u0002\u0002\u0be3\u0be5\u0005\u01b0\u00d9\u0002\u0be4\u0be3\u0003\u0002\u0002\u0002\u0be4\u0be5\u0003\u0002\u0002\u0002\u0be5\u0bea\u0003\u0002\u0002\u0002\u0be6\u0be9\u0005\u0198\u00cd\u0002\u0be7\u0be9\u0005\u01a2\u00d2\u0002\u0be8\u0be6\u0003\u0002\u0002\u0002\u0be8\u0be7\u0003\u0002\u0002\u0002\u0be9\u0bec\u0003\u0002\u0002\u0002\u0bea\u0be8\u0003\u0002\u0002\u0002\u0bea\u0beb\u0003\u0002\u0002\u0002\u0beb\u0195\u0003\u0002\u0002\u0002\u0bec\u0bea\u0003\u0002\u0002\u0002\u0bed\u0bf3\u0007\u0021\u0002\u0002\u0bee\u0bf0\u0007\u01b4\u0002\u0002\u0bef\u0bf1\u0007\u0100\u0002\u0002\u0bf0\u0bef\u0003\u0002\u0002\u0002\u0bf0\u0bf1\u0003\u0002\u0002\u0002\u0bf1\u0bf2\u0003\u0002\u0002\u0002\u0bf2\u0bf4\u0009\u0025\u0002\u0002\u0bf3\u0bee\u0003\u0002\u0002\u0002\u0bf3\u0bf4\u0003\u0002\u0002\u0002\u0bf4\u0197\u0003\u0002\u0002\u0002\u0bf5\u0bf7\u0007\u0021\u0002\u0002\u0bf6\u0bf8\u0005\u019a\u00ce\u0002\u0bf7\u0bf6\u0003\u0002\u0002\u0002\u0bf7\u0bf8\u0003\u0002\u0002\u0002\u0bf8\u0bfe\u0003\u0002\u0002\u0002\u0bf9\u0bfb\u0007\u0112\u0002\u0002\u0bfa\u0bfc\u0007\u0100\u0002\u0002\u0bfb\u0bfa\u0003\u0002\u0002\u0002\u0bfb\u0bfc\u0003\u0002\u0002\u0002\u0bfc\u0bfd\u0003\u0002\u0002\u0002\u0bfd\u0bff\u0009\u0026\u0002\u0002\u0bfe\u0bf9\u0003\u0002\u0002\u0002\u0bfe\u0bff\u0003\u0002\u0002\u0002\u0bff\u0c01\u0003\u0002\u0002\u0002\u0c00\u0c02\u0005\u019c\u00cf\u0002\u0c01\u0c00\u0003\u0002\u0002\u0002\u0c01\u0c02\u0003\u0002\u0002\u0002\u0c02\u0c04\u0003\u0002\u0002\u0002\u0c03\u0c05\u0005\u019e\u00d0\u0002\u0c04\u0c03\u0003\u0002\u0002\u0002\u0c04\u0c05\u0003\u0002\u0002\u0002\u0c05\u0199\u0003\u0002\u0002\u0002\u0c06\u0c07\u0007\u00dc\u0002\u0002\u0c07\u0c08\u0007\u0100\u0002\u0002\u0c08\u0c09\u0005\u0496\u024c\u0002\u0c09\u019b\u0003\u0002\u0002\u0002\u0c0a\u0c0c\u0007\u0113\u0002\u0002\u0c0b\u0c0d\u0007\u0100\u0002\u0002\u0c0c\u0c0b\u0003\u0002\u0002\u0002\u0c0c\u0c0d\u0003\u0002\u0002\u0002\u0c0d\u0c0e\u0003\u0002\u0002\u0002\u0c0e\u0c0f\u0005\u0496\u024c\u0002\u0c0f\u019d\u0003\u0002\u0002\u0002\u0c10\u0c12\u0007\u01ea\u0002\u0002\u0c11\u0c13\u0007\u0100\u0002\u0002\u0c12\u0c11\u0003\u0002\u0002\u0002\u0c12\u0c13\u0003\u0002\u0002\u0002\u0c13\u0c14\u0003\u0002\u0002\u0002\u0c14\u0c15\u0005\u0496\u024c\u0002\u0c15\u019f\u0003\u0002\u0002\u0002\u0c16\u0c17\u0007\u00b9\u0002\u0002\u0c17\u0c19\u0005\u0482\u0242\u0002\u0c18\u0c1a\u0005\u01a4\u00d3\u0002\u0c19\u0c18\u0003\u0002\u0002\u0002\u0c19\u0c1a\u0003\u0002\u0002\u0002\u0c1a\u01a1\u0003\u0002\u0002\u0002\u0c1b\u0c1c\u0007\u00b9\u0002\u0002\u0c1c\u0c1e\u0005\u0482\u0242\u0002\u0c1d\u0c1f\u0005\u01a4\u00d3\u0002\u0c1e\u0c1d\u0003\u0002\u0002\u0002\u0c1e\u0c1f\u0003\u0002\u0002\u0002\u0c1f\u0c21\u0003\u0002\u0002\u0002\u0c20\u0c22\u0005\u01ac\u00d7\u0002\u0c21\u0c20\u0003\u0002\u0002\u0002\u0c21\u0c22\u0003\u0002\u0002\u0002\u0c22\u0c24\u0003\u0002\u0002\u0002\u0c23\u0c25\u0005\u01a8\u00d5\u0002\u0c24\u0c23\u0003\u0002\u0002\u0002\u0c24\u0c25\u0003\u0002\u0002\u0002\u0c25\u0c27\u0003\u0002\u0002\u0002\u0c26\u0c28\u0005\u01a6\u00d4\u0002\u0c27\u0c26\u0003\u0002\u0002\u0002\u0c27\u0c28\u0003\u0002\u0002\u0002\u0c28\u01a3\u0003\u0002\u0002\u0002\u0c29\u0c2a\u0007\u00d6\u0002\u0002\u0c2a\u0c2b\u0005\u0496\u024c\u0002\u0c2b\u01a5\u0003\u0002\u0002\u0002\u0c2c\u0c2d\u0007\u00e0\u0002\u0002\u0c2d\u0c2e\u0005\u046a\u0236\u0002\u0c2e\u01a7\u0003\u0002\u0002\u0002\u0c2f\u0c31\u0007\u01fc\u0002\u0002\u0c30\u0c32\u0005\u01aa\u00d6\u0002\u0c31\u0c30\u0003\u0002\u0002\u0002\u0c32\u0c33\u0003\u0002\u0002\u0002\u0c33\u0c31\u0003\u0002\u0002\u0002\u0c33\u0c34\u0003\u0002\u0002\u0002\u0c34\u01a9\u0003\u0002\u0002\u0002\u0c35\u0c38\u0005\u046a\u0236\u0002\u0c36\u0c38\u0005\u0470\u0239\u0002\u0c37\u0c35\u0003\u0002\u0002\u0002\u0c37\u0c36\u0003\u0002\u0002\u0002\u0c38\u01ab\u0003\u0002\u0002\u0002\u0c39\u0c3b\u0007\u0204\u0002\u0002\u0c3a\u0c3c\u0005\u01ae\u00d8\u0002\u0c3b\u0c3a\u0003\u0002\u0002\u0002\u0c3c\u0c3d\u0003\u0002\u0002\u0002\u0c3d\u0c3b\u0003\u0002\u0002\u0002\u0c3d\u0c3e\u0003\u0002\u0002\u0002\u0c3e\u01ad\u0003\u0002\u0002\u0002\u0c3f\u0c42\u0005\u047a\u023e\u0002\u0c40\u0c42\u0005\u0470\u0239\u0002\u0c41\u0c3f\u0003\u0002\u0002\u0002\u0c41\u0c40\u0003\u0002\u0002\u0002\u0c42\u01af\u0003\u0002\u0002\u0002\u0c43\u0c45\u0007\u0100\u0002\u0002\u0c44\u0c43\u0003\u0002\u0002\u0002\u0c44\u0c45\u0003\u0002\u0002\u0002\u0c45\u0c46\u0003\u0002\u0002\u0002\u0c46\u0c47\u0007\u0050\u0002\u0002\u0c47\u01b1\u0003\u0002\u0002\u0002\u0c48\u0c4a\u0007\u0100\u0002\u0002\u0c49\u0c48\u0003\u0002\u0002\u0002\u0c49\u0c4a\u0003\u0002\u0002\u0002\u0c4a\u0c4b\u0003\u0002\u0002\u0002\u0c4b\u0c4c\u0007\u00e1\u0002\u0002\u0c4c\u01b3\u0003\u0002\u0002\u0002\u0c4d\u0c52\u0005\u01b6\u00dc\u0002\u0c4e\u0c52\u0005\u01b8\u00dd\u0002\u0c4f\u0c52\u0005\u01ba\u00de\u0002\u0c50\u0c52\u0005\u01bc\u00df\u0002\u0c51\u0c4d\u0003\u0002\u0002\u0002\u0c51\u0c4e\u0003\u0002\u0002\u0002\u0c51\u0c4f\u0003\u0002\u0002\u0002\u0c51\u0c50\u0003\u0002\u0002\u0002\u0c52\u01b5\u0003\u0002\u0002\u0002\u0c53\u0c56\u0009\u0027\u0002\u0002\u0c54\u0c57\u0007\u00d2\u0002\u0002\u0c55\u0c57\u0005\u046a\u0236\u0002\u0c56\u0c54\u0003\u0002\u0002\u0002\u0c56\u0c55\u0003\u0002\u0002\u0002\u0c56\u0c57\u0003\u0002\u0002\u0002\u0c57\u0c6f\u0003\u0002\u0002\u0002\u0c58\u0c6e\u0005\u01de\u00f0\u0002\u0c59\u0c6e\u0005\u01c8\u00e5\u0002\u0c5a\u0c6e\u0005\u01c4\u00e3\u0002\u0c5b\u0c6e\u0005\u01c6\u00e4\u0002\u0c5c\u0c6e\u0005\u01ea\u00f6\u0002\u0c5d\u0c6e\u0005\u01e6\u00f4\u0002\u0c5e\u0c6e\u0005\u01d2\u00ea\u0002\u0c5f\u0c6e\u0005\u01c2\u00e2\u0002\u0c60\u0c6e\u0005\u01e8\u00f5\u0002\u0c61\u0c6e\u0005\u01ee\u00f8\u0002\u0c62\u0c6e\u0005\u01ec\u00f7\u0002\u0c63\u0c6e\u0005\u01f0\u00f9\u0002\u0c64\u0c6e\u0005\u01da\u00ee\u0002\u0c65\u0c6e\u0005\u01cc\u00e7\u0002\u0c66\u0c6e\u0005\u01e2\u00f2\u0002\u0c67\u0c6e\u0005\u01e4\u00f3\u0002\u0c68\u0c6e\u0005\u01ca\u00e6\u0002\u0c69\u0c6e\u0005\u01c0\u00e1\u0002\u0c6a\u0c6e\u0005\u01f8\u00fd\u0002\u0c6b\u0c6e\u0005\u01be\u00e0\u0002\u0c6c\u0c6e\u0005\u01dc\u00ef\u0002\u0c6d\u0c58\u0003\u0002\u0002\u0002\u0c6d\u0c59\u0003\u0002\u0002\u0002\u0c6d\u0c5a\u0003\u0002\u0002\u0002\u0c6d\u0c5b\u0003\u0002\u0002\u0002\u0c6d\u0c5c\u0003\u0002\u0002\u0002\u0c6d\u0c5d\u0003\u0002\u0002\u0002\u0c6d\u0c5e\u0003\u0002\u0002\u0002\u0c6d\u0c5f\u0003\u0002\u0002\u0002\u0c6d\u0c60\u0003\u0002\u0002\u0002\u0c6d\u0c61\u0003\u0002\u0002\u0002\u0c6d\u0c62\u0003\u0002\u0002\u0002\u0c6d\u0c63\u0003\u0002\u0002\u0002\u0c6d\u0c64\u0003\u0002\u0002\u0002\u0c6d\u0c65\u0003\u0002\u0002\u0002\u0c6d\u0c66\u0003\u0002\u0002\u0002\u0c6d\u0c67\u0003\u0002\u0002\u0002\u0c6d\u0c68\u0003\u0002\u0002\u0002\u0c6d\u0c69\u0003\u0002\u0002\u0002\u0c6d\u0c6a\u0003\u0002\u0002\u0002\u0c6d\u0c6b\u0003\u0002\u0002\u0002\u0c6d\u0c6c\u0003\u0002\u0002\u0002\u0c6e\u0c71\u0003\u0002\u0002\u0002\u0c6f\u0c6d\u0003\u0002\u0002\u0002\u0c6f\u0c70\u0003\u0002\u0002\u0002\u0c70\u0c72\u0003\u0002\u0002\u0002\u0c71\u0c6f\u0003\u0002\u0002\u0002\u0c72\u0c73\u0007\u0218\u0002\u0002\u0c73\u01b7\u0003\u0002\u0002\u0002\u0c74\u0c75\u0007\u022a\u0002\u0002\u0c75\u0c76\u0005\u046a\u0236\u0002\u0c76\u0c77\u0005\u01e0\u00f1\u0002\u0c77\u0c78\u0007\u0218\u0002\u0002\u0c78\u01b9\u0003\u0002\u0002\u0002\u0c79\u0c7a\u0007\u022c\u0002\u0002\u0c7a\u0c7b\u0005\u0468\u0235\u0002\u0c7b\u0c7c\u0005\u01f0\u00f9\u0002\u0c7c\u0c7d\u0007\u0218\u0002\u0002\u0c7d\u01bb\u0003\u0002\u0002\u0002\u0c7e\u0c80\u0007\u0233\u0002\u0002\u0c7f\u0c7e\u0003\u0002\u0002\u0002\u0c80\u0c81\u0003\u0002\u0002\u0002\u0c81\u0c7f\u0003\u0002\u0002\u0002\u0c81\u0c82\u0003\u0002\u0002\u0002\u0c82\u0c84\u0003\u0002\u0002\u0002\u0c83\u0c85\u0007\u0218\u0002\u0002\u0c84\u0c83\u0003\u0002\u0002\u0002\u0c84\u0c85\u0003\u0002\u0002\u0002\u0c85\u01bd\u0003\u0002\u0002\u0002\u0c86\u0c87\u0007\u000a\u0002\u0002\u0c87\u01bf\u0003\u0002\u0002\u0002\u0c88\u0c8a\u0007\u002e\u0002\u0002\u0c89\u0c8b\u0007\u0202\u0002\u0002\u0c8a\u0c89\u0003\u0002\u0002\u0002\u0c8a\u0c8b\u0003\u0002\u0002\u0002\u0c8b\u0c8c\u0003\u0002\u0002\u0002\u0c8c\u0c8d\u0009\u0028\u0002\u0002\u0c8d\u01c1\u0003\u0002\u0002\u0002\u0c8e\u0c8f\u0009\u0029\u0002\u0002\u0c8f\u01c3\u0003\u0002\u0002\u0002\u0c90\u0c92\u0007\u0100\u0002\u0002\u0c91\u0c90\u0003\u0002\u0002\u0002\u0c91\u0c92\u0003\u0002\u0002\u0002\u0c92\u0c93\u0003\u0002\u0002\u0002\u0c93\u0c96\u0007\u00cd\u0002\u0002\u0c94\u0c95\u0007\u0033\u0002\u0002\u0c95\u0c97\u0005\u0496\u024c\u0002\u0c96\u0c94\u0003\u0002\u0002\u0002\u0c96\u0c97\u0003\u0002\u0002\u0002\u0c97\u01c5\u0003\u0002\u0002\u0002\u0c98\u0c9a\u0007\u0100\u0002\u0002\u0c99\u0c98\u0003\u0002\u0002\u0002\u0c99\u0c9a\u0003\u0002\u0002\u0002\u0c9a\u0c9b\u0003\u0002\u0002\u0002\u0c9b\u0c9c\u0007\u00e1\u0002\u0002\u0c9c\u01c7\u0003\u0002\u0002\u0002\u0c9d\u0c9e\u0009\u002a\u0002\u0002\u0c9e\u01c9\u0003\u0002\u0002\u0002\u0c9f\u0ca1\u0009\u001e\u0002\u0002\u0ca0\u0ca2\u0007\u019d\u0002\u0002\u0ca1\u0ca0\u0003\u0002\u0002\u0002\u0ca1\u0ca2\u0003\u0002\u0002\u0002\u0ca2\u01cb\u0003\u0002\u0002\u0002\u0ca3\u0ca4\u0007\u0143\u0002\u0002\u0ca4\u0ca6\u0005\u049c\u024f\u0002\u0ca5\u0ca7\u0005\u01ce\u00e8\u0002\u0ca6\u0ca5\u0003\u0002\u0002\u0002\u0ca6\u0ca7\u0003\u0002\u0002\u0002\u0ca7\u0ca9\u0003\u0002\u0002\u0002\u0ca8\u0caa\u0007\u01e9\u0002\u0002\u0ca9\u0ca8\u0003\u0002\u0002\u0002\u0ca9\u0caa\u0003\u0002\u0002\u0002\u0caa\u0cb0\u0003\u0002\u0002\u0002\u0cab\u0cad\u0007\u0088\u0002\u0002\u0cac\u0cae\u0007\u0148\u0002\u0002\u0cad\u0cac\u0003\u0002\u0002\u0002\u0cad\u0cae\u0003\u0002\u0002\u0002\u0cae\u0caf\u0003\u0002\u0002\u0002\u0caf\u0cb1\u0005\u0444\u0223\u0002\u0cb0\u0cab\u0003\u0002\u0002\u0002\u0cb0\u0cb1\u0003\u0002\u0002\u0002\u0cb1\u0cb5\u0003\u0002\u0002\u0002\u0cb2\u0cb4\u0005\u01d0\u00e9\u0002\u0cb3\u0cb2\u0003\u0002\u0002\u0002\u0cb4\u0cb7\u0003\u0002\u0002\u0002\u0cb5\u0cb3\u0003\u0002\u0002\u0002\u0cb5\u0cb6\u0003\u0002\u0002\u0002\u0cb6\u0cc4\u0003\u0002\u0002\u0002\u0cb7\u0cb5\u0003\u0002\u0002\u0002\u0cb8\u0cba\u0007\u00f3\u0002\u0002\u0cb9\u0cbb\u0007\u0033\u0002\u0002\u0cba\u0cb9\u0003\u0002\u0002\u0002\u0cba\u0cbb\u0003\u0002\u0002\u0002\u0cbb\u0cbd\u0003\u0002\u0002\u0002\u0cbc\u0cbe\u0007\u011e\u0002\u0002\u0cbd\u0cbc\u0003\u0002\u0002\u0002\u0cbd\u0cbe\u0003\u0002\u0002\u0002\u0cbe\u0cc0\u0003\u0002\u0002\u0002\u0cbf\u0cc1\u0005\u0474\u023b\u0002\u0cc0\u0cbf\u0003\u0002\u0002\u0002\u0cc1\u0cc2\u0003\u0002\u0002\u0002\u0cc2\u0cc0\u0003\u0002\u0002\u0002\u0cc2\u0cc3\u0003\u0002\u0002\u0002\u0cc3\u0cc5\u0003\u0002\u0002\u0002\u0cc4\u0cb8\u0003\u0002\u0002\u0002\u0cc4\u0cc5\u0003\u0002\u0002\u0002\u0cc5\u01cd\u0003\u0002\u0002\u0002\u0cc6\u0cc7\u0007\u01eb\u0002\u0002\u0cc7\u0cc8\u0005\u049c\u024f\u0002\u0cc8\u01cf\u0003\u0002\u0002\u0002\u0cc9\u0ccb\u0009\u002b\u0002\u0002\u0cca\u0ccc\u0007\u0105\u0002\u0002\u0ccb\u0cca\u0003\u0002\u0002\u0002\u0ccb\u0ccc\u0003\u0002\u0002\u0002\u0ccc\u0cce\u0003\u0002\u0002\u0002\u0ccd\u0ccf\u0007\u0100\u0002\u0002\u0cce\u0ccd\u0003\u0002\u0002\u0002\u0cce\u0ccf\u0003\u0002\u0002\u0002\u0ccf\u0cd1\u0003\u0002\u0002\u0002\u0cd0\u0cd2\u0005\u0444\u0223\u0002\u0cd1\u0cd0\u0003\u0002\u0002\u0002\u0cd2\u0cd3\u0003\u0002\u0002\u0002\u0cd3\u0cd1\u0003\u0002\u0002\u0002\u0cd3\u0cd4\u0003\u0002\u0002\u0002\u0cd4\u01d1\u0003\u0002\u0002\u0002\u0cd5\u0cd7\u0009\u001c\u0002\u0002\u0cd6\u0cd8\u0007\u0100\u0002\u0002\u0cd7\u0cd6\u0003\u0002\u0002\u0002\u0cd7\u0cd8\u0003\u0002\u0002\u0002\u0cd8\u0cd9\u0003\u0002\u0002\u0002\u0cd9\u0cda\u0005\u01d4\u00eb\u0002\u0cda\u01d3\u0003\u0002\u0002\u0002\u0cdb\u0cdd\u0005\u01d6\u00ec\u0002\u0cdc\u0cdb\u0003\u0002\u0002\u0002\u0cdd\u0cde\u0003\u0002\u0002\u0002\u0cde\u0cdc\u0003\u0002\u0002\u0002\u0cde\u0cdf\u0003\u0002\u0002\u0002\u0cdf\u0ce1\u0003\u0002\u0002\u0002\u0ce0\u0ce2\u0005\u01d8\u00ed\u0002\u0ce1\u0ce0\u0003\u0002\u0002\u0002\u0ce1\u0ce2\u0003\u0002\u0002\u0002\u0ce2\u0ce4\u0003\u0002\u0002\u0002\u0ce3\u0cdc\u0003\u0002\u0002\u0002\u0ce4\u0ce5\u0003\u0002\u0002\u0002\u0ce5\u0ce3\u0003\u0002\u0002\u0002\u0ce5\u0ce6\u0003\u0002\u0002\u0002\u0ce6\u01d5\u0003\u0002\u0002\u0002\u0ce7\u0cf8\u0007\u0216\u0002\u0002\u0ce8\u0cf8\u0007\u022f\u0002\u0002\u0ce9\u0cf8\u0007\u022e\u0002\u0002\u0cea\u0cf8\u0007\u0228\u0002\u0002\u0ceb\u0cf8\u0007\u0213\u0002\u0002\u0cec\u0cf8\u0007\u0219\u0002\u0002\u0ced\u0cf8\u0007\u0212\u0002\u0002\u0cee\u0cf8\u0007\u0210\u0002\u0002\u0cef\u0cf8\u0007\u0211\u0002\u0002\u0cf0\u0cf8\u0007\u0220\u0002\u0002\u0cf1\u0cf8\u0007\u0227\u0002\u0002\u0cf2\u0cf8\u0007\u0225\u0002\u0002\u0cf3\u0cf8\u0007\u0221\u0002\u0002\u0cf4\u0cf8\u0007\u021e\u0002\u0002\u0cf5\u0cf8\u0007\u0222\u0002\u0002\u0cf6\u0cf8\u0005\u049c\u024f\u0002\u0cf7\u0ce7\u0003\u0002\u0002\u0002\u0cf7\u0ce8\u0003\u0002\u0002\u0002\u0cf7\u0ce9\u0003\u0002\u0002\u0002\u0cf7\u0cea\u0003\u0002\u0002\u0002\u0cf7\u0ceb\u0003\u0002\u0002\u0002\u0cf7\u0cec\u0003\u0002\u0002\u0002\u0cf7\u0ced\u0003\u0002\u0002\u0002\u0cf7\u0cee\u0003\u0002\u0002\u0002\u0cf7\u0cef\u0003\u0002\u0002\u0002\u0cf7\u0cf0\u0003\u0002\u0002\u0002\u0cf7\u0cf1\u0003\u0002\u0002\u0002\u0cf7\u0cf2\u0003\u0002\u0002\u0002\u0cf7\u0cf3\u0003\u0002\u0002\u0002\u0cf7\u0cf4\u0003\u0002\u0002\u0002\u0cf7\u0cf5\u0003\u0002\u0002\u0002\u0cf7\u0cf6\u0003\u0002\u0002\u0002\u0cf8\u01d7\u0003\u0002\u0002\u0002\u0cf9\u0cfa\u0007\u0220\u0002\u0002\u0cfa\u0cfb\u0005\u049c\u024f\u0002\u0cfb\u0cfc\u0007\u0227\u0002\u0002\u0cfc\u01d9\u0003\u0002\u0002\u0002\u0cfd\u0cff\u0007\u017a\u0002\u0002\u0cfe\u0cfd\u0003\u0002\u0002\u0002\u0cfe\u0cff\u0003\u0002\u0002\u0002\u0cff\u0d01\u0003\u0002\u0002\u0002\u0d00\u0d02\u0007\u0033\u0002\u0002\u0d01\u0d00\u0003\u0002\u0002\u0002\u0d01\u0d02\u0003\u0002\u0002\u0002\u0d02\u0d03\u0003\u0002\u0002\u0002\u0d03\u0d04\u0009\u002c\u0002\u0002\u0d04\u01db\u0003\u0002\u0002\u0002\u0d05\u0d06\u0007\u017b\u0002\u0002\u0d06\u0d07\u0007\u0018\u0002\u0002\u0d07\u01dd\u0003\u0002\u0002\u0002\u0d08\u0d09\u0007\u017f\u0002\u0002\u0d09\u0d0a\u0005\u046a\u0236\u0002\u0d0a\u01df\u0003\u0002\u0002\u0002\u0d0b\u0d0c\u0007\u018a\u0002\u0002\u0d0c\u0d0f\u0005\u0444\u0223\u0002\u0d0d\u0d0e\u0009\u0006\u0002\u0002\u0d0e\u0d10\u0005\u0444\u0223\u0002\u0d0f\u0d0d\u0003\u0002\u0002\u0002\u0d0f\u0d10\u0003\u0002\u0002\u0002\u0d10\u01e1\u0003\u0002\u0002\u0002\u0d11\u0d13\u0007\u01b8\u0002\u0002\u0d12\u0d14\u0007\u0100\u0002\u0002\u0d13\u0d12\u0003\u0002\u0002\u0002\u0d13\u0d14\u0003\u0002\u0002\u0002\u0d14\u0d16\u0003\u0002\u0002\u0002\u0d15\u0d11\u0003\u0002\u0002\u0002\u0d15\u0d16\u0003\u0002\u0002\u0002\u0d16\u0d17\u0003\u0002\u0002\u0002\u0d17\u0d1c\u0009\u0009\u0002\u0002\u0d18\u0d1a\u0007\u01ad\u0002\u0002\u0d19\u0d1b\u0007\u0040\u0002\u0002\u0d1a\u0d19\u0003\u0002\u0002\u0002\u0d1a\u0d1b\u0003\u0002\u0002\u0002\u0d1b\u0d1d\u0003\u0002\u0002\u0002\u0d1c\u0d18\u0003\u0002\u0002\u0002\u0d1c\u0d1d\u0003\u0002\u0002\u0002\u0d1d\u01e3\u0003\u0002\u0002\u0002\u0d1e\u0d20\u0009\u002d\u0002\u0002\u0d1f\u0d21\u0009\u002e\u0002\u0002\u0d20\u0d1f\u0003\u0002\u0002\u0002\u0d20\u0d21\u0003\u0002\u0002\u0002\u0d21\u01e5\u0003\u0002\u0002\u0002\u0d22\u0d24\u0007\u0100\u0002\u0002\u0d23\u0d22\u0003\u0002\u0002\u0002\u0d23\u0d24\u0003\u0002\u0002\u0002\u0d24\u0d25\u0003\u0002\u0002\u0002\u0d25\u0d26\u0007\u01e4\u0002\u0002\u0d26\u01e7\u0003\u0002\u0002\u0002\u0d27\u0d29\u0007\u01f2\u0002\u0002\u0d28\u0d2a\u0007\u0100\u0002\u0002\u0d29\u0d28\u0003\u0002\u0002\u0002\u0d29\u0d2a\u0003\u0002\u0002\u0002\u0d2a\u0d2b\u0003\u0002\u0002\u0002\u0d2b\u0d2c\u0009\u002f\u0002\u0002\u0d2c\u01e9\u0003\u0002\u0002\u0002\u0d2d\u0d2f\u0007\u0100\u0002\u0002\u0d2e\u0d2d\u0003\u0002\u0002\u0002\u0d2e\u0d2f\u0003\u0002\u0002\u0002\u0d2f\u0d30\u0003\u0002\u0002\u0002\u0d30\u0d31\u0007\u01f3\u0002\u0002\u0d31\u01eb\u0003\u0002\u0002\u0002\u0d32\u0d34\u0007\u01fa\u0002\u0002\u0d33\u0d35\u0007\u0100\u0002\u0002\u0d34\u0d33\u0003\u0002\u0002\u0002\u0d34\u0d35\u0003\u0002\u0002\u0002\u0d35\u0d37\u0003\u0002\u0002\u0002\u0d36\u0d32\u0003\u0002\u0002\u0002\u0d36\u0d37\u0003\u0002\u0002\u0002\u0d37\u0d59\u0003\u0002\u0002\u0002\u0d38\u0d3a\u0007\u002c\u0002\u0002\u0d39\u0d3b\u0009\u0030\u0002\u0002\u0d3a\u0d39\u0003\u0002\u0002\u0002\u0d3a\u0d3b\u0003\u0002\u0002\u0002\u0d3b\u0d5a\u0003\u0002\u0002\u0002\u0d3c\u0d5a\u0007\u002d\u0002\u0002\u0d3d\u0d5a\u0007\u0052\u0002\u0002\u0d3e\u0d5a\u0007\u0053\u0002\u0002\u0d3f\u0d5a\u0007\u0054\u0002\u0002\u0d40\u0d5a\u0007\u0055\u0002\u0002\u0d41\u0d5a\u0007\u0056\u0002\u0002\u0d42\u0d5a\u0007\u0057\u0002\u0002\u0d43\u0d5a\u0007\u0058\u0002\u0002\u0d44\u0d5a\u0007\u0059\u0002\u0002\u0d45\u0d5a\u0007\u005a\u0002\u0002\u0d46\u0d5a\u0007\u005b\u0002\u0002\u0d47\u0d5a\u0007\u005c\u0002\u0002\u0d48\u0d5a\u0007\u005d\u0002\u0002\u0d49\u0d5a\u0007\u0064\u0002\u0002\u0d4a\u0d5a\u0007\u0071\u0002\u0002\u0d4b\u0d5a\u0007\u0090\u0002\u0002\u0d4c\u0d5a\u0007\u0091\u0002\u0002\u0d4d\u0d5a\u0007\u0095\u0002\u0002\u0d4e\u0d5a\u0007\u00c4\u0002\u0002\u0d4f\u0d5a\u0007\u00dd\u0002\u0002\u0d50\u0d5a\u0007\u00f2\u0002\u0002\u0d51\u0d5a\u0007\u0103\u0002\u0002\u0d52\u0d5a\u0007\u0120\u0002\u0002\u0d53\u0d5a\u0007\u0132\u0002\u0002\u0d54\u0d5a\u0007\u0154\u0002\u0002\u0d55\u0d5a\u0007\u015f\u0002\u0002\u0d56\u0d5a\u0007\u0167\u0002\u0002\u0d57\u0d5a\u0007\u0177\u0002\u0002\u0d58\u0d5a\u0007\u01db\u0002\u0002\u0d59\u0d38\u0003\u0002\u0002\u0002\u0d59\u0d3c\u0003\u0002\u0002\u0002\u0d59\u0d3d\u0003\u0002\u0002\u0002\u0d59\u0d3e\u0003\u0002\u0002\u0002\u0d59\u0d3f\u0003\u0002\u0002\u0002\u0d59\u0d40\u0003\u0002\u0002\u0002\u0d59\u0d41\u0003\u0002\u0002\u0002\u0d59\u0d42\u0003\u0002\u0002\u0002\u0d59\u0d43\u0003\u0002\u0002\u0002\u0d59\u0d44\u0003\u0002\u0002\u0002\u0d59\u0d45\u0003\u0002\u0002\u0002\u0d59\u0d46\u0003\u0002\u0002\u0002\u0d59\u0d47\u0003\u0002\u0002\u0002\u0d59\u0d48\u0003\u0002\u0002\u0002\u0d59\u0d49\u0003\u0002\u0002\u0002\u0d59\u0d4a\u0003\u0002\u0002\u0002\u0d59\u0d4b\u0003\u0002\u0002\u0002\u0d59\u0d4c\u0003\u0002\u0002\u0002\u0d59\u0d4d\u0003\u0002\u0002\u0002\u0d59\u0d4e\u0003\u0002\u0002\u0002\u0d59\u0d4f\u0003\u0002\u0002\u0002\u0d59\u0d50\u0003\u0002\u0002\u0002\u0d59\u0d51\u0003\u0002\u0002\u0002\u0d59\u0d52\u0003\u0002\u0002\u0002\u0d59\u0d53\u0003\u0002\u0002\u0002\u0d59\u0d54\u0003\u0002\u0002\u0002\u0d59\u0d55\u0003\u0002\u0002\u0002\u0d59\u0d56\u0003\u0002\u0002\u0002\u0d59\u0d57\u0003\u0002\u0002\u0002\u0d59\u0d58\u0003\u0002\u0002\u0002\u0d5a\u01ed\u0003\u0002\u0002\u0002\u0d5b\u0d5c\u0007\u01fc\u0002\u0002\u0d5c\u0d5e\u0009\u0031\u0002\u0002\u0d5d\u0d5f\u0007\u0145\u0002\u0002\u0d5e\u0d5d\u0003\u0002\u0002\u0002\u0d5e\u0d5f\u0003\u0002\u0002\u0002\u0d5f\u0d62\u0003\u0002\u0002\u0002\u0d60\u0d63\u0005\u0494\u024b\u0002\u0d61\u0d63\u0005\u046a\u0236\u0002\u0d62\u0d60\u0003\u0002\u0002\u0002\u0d62\u0d61\u0003\u0002\u0002\u0002\u0d63\u01ef\u0003\u0002\u0002\u0002\u0d64\u0d66\u0007\u01fd\u0002\u0002\u0d65\u0d67\u0007\u0100\u0002\u0002\u0d66\u0d65\u0003\u0002\u0002\u0002\u0d66\u0d67\u0003\u0002\u0002\u0002\u0d67\u0d6d\u0003\u0002\u0002\u0002\u0d68\u0d6a\u0007\u01fe\u0002\u0002\u0d69\u0d6b\u0007\u0017\u0002\u0002\u0d6a\u0d69\u0003\u0002\u0002\u0002\u0d6a\u0d6b\u0003\u0002\u0002\u0002\u0d6b\u0d6d\u0003\u0002\u0002\u0002\u0d6c\u0d64\u0003\u0002\u0002\u0002\u0d6c\u0d68\u0003\u0002\u0002\u0002\u0d6c\u0d6d\u0003\u0002\u0002\u0002\u0d6d\u0d6e\u0003\u0002\u0002\u0002\u0d6e\u0d75\u0005\u01f2\u00fa\u0002\u0d6f\u0d71\u0007\u0213\u0002\u0002\u0d70\u0d6f\u0003\u0002\u0002\u0002\u0d70\u0d71\u0003\u0002\u0002\u0002\u0d71\u0d72\u0003\u0002\u0002\u0002\u0d72\u0d74\u0005\u01f2\u00fa\u0002\u0d73\u0d70\u0003\u0002\u0002\u0002\u0d74\u0d77\u0003\u0002\u0002\u0002\u0d75\u0d73\u0003\u0002\u0002\u0002\u0d75\u0d76\u0003\u0002\u0002\u0002\u0d76\u01f1\u0003\u0002\u0002\u0002\u0d77\u0d75\u0003\u0002\u0002\u0002\u0d78\u0d7a\u0005\u01f4\u00fb\u0002\u0d79\u0d7b\u0005\u01f6\u00fc\u0002\u0d7a\u0d79\u0003\u0002\u0002\u0002\u0d7a\u0d7b\u0003\u0002\u0002\u0002\u0d7b\u01f3\u0003\u0002\u0002\u0002\u0d7c\u0d7f\u0005\u0496\u024c\u0002\u0d7d\u0d7f\u0005\u0494\u024b\u0002\u0d7e\u0d7c\u0003\u0002\u0002\u0002\u0d7e\u0d7d\u0003\u0002\u0002\u0002\u0d7f\u01f5\u0003\u0002\u0002\u0002\u0d80\u0d81\u0009\u0006\u0002\u0002\u0d81\u0d82\u0005\u0496\u024c\u0002\u0d82\u01f7\u0003\u0002\u0002\u0002\u0d83\u0d85\u0007\u0204\u0002\u0002\u0d84\u0d83\u0003\u0002\u0002\u0002\u0d84\u0d85\u0003\u0002\u0002\u0002\u0d85\u0d86\u0003\u0002\u0002\u0002\u0d86\u0d87\u0007\u0123\u0002\u0002\u0d87\u0d88\u0007\u0031\u0002\u0002\u0d88\u01f9\u0003\u0002\u0002\u0002\u0d89\u0d8a\u0007\u0166\u0002\u0002\u0d8a\u0d8c\u0007\u0093\u0002\u0002\u0d8b\u0d8d\u0005\u01fc\u00ff\u0002\u0d8c\u0d8b\u0003\u0002\u0002\u0002\u0d8c\u0d8d\u0003\u0002\u0002\u0002\u0d8d\u0d8f\u0003\u0002\u0002\u0002\u0d8e\u0d90\u0005\u01fe\u0100\u0002\u0d8f\u0d8e\u0003\u0002\u0002\u0002\u0d8f\u0d90\u0003\u0002\u0002\u0002\u0d90\u0d91\u0003\u0002\u0002\u0002\u0d91\u0d93\u0007\u0218\u0002\u0002\u0d92\u0d94\u0005\u020a\u0106\u0002\u0d93\u0d92\u0003\u0002\u0002\u0002\u0d93\u0d94\u0003\u0002\u0002\u0002\u0d94\u0d95\u0003\u0002\u0002\u0002\u0d95\u0d96\u0005\u0210\u0109\u0002\u0d96\u01fb\u0003\u0002\u0002\u0002\u0d97\u0d99\u0009\u0032\u0002\u0002\u0d98\u0d9a\u0005\u0200\u0101\u0002\u0d99\u0d98\u0003\u0002\u0002\u0002\u0d9a\u0d9b\u0003\u0002\u0002\u0002\u0d9b\u0d99\u0003\u0002\u0002\u0002\u0d9b\u0d9c\u0003\u0002\u0002\u0002\u0d9c\u01fd\u0003\u0002\u0002\u0002\u0d9d\u0d9e\u0009\u0033\u0002\u0002\u0d9e\u0d9f\u0005\u046a\u0236\u0002\u0d9f\u01ff\u0003\u0002\u0002\u0002\u0da0\u0da3\u0005\u0202\u0102\u0002\u0da1\u0da3\u0005\u0206\u0104\u0002\u0da2\u0da0\u0003\u0002\u0002\u0002\u0da2\u0da1\u0003\u0002\u0002\u0002\u0da3\u0201\u0003\u0002\u0002\u0002\u0da4\u0da6\u0007\u0033\u0002\u0002\u0da5\u0da4\u0003\u0002\u0002\u0002\u0da5\u0da6\u0003\u0002\u0002\u0002\u0da6\u0da7\u0003\u0002\u0002\u0002\u0da7\u0da9\u0007\u0182\u0002\u0002\u0da8\u0da5\u0003\u0002\u0002\u0002\u0da8\u0da9\u0003\u0002\u0002\u0002\u0da9\u0dab\u0003\u0002\u0002\u0002\u0daa\u0dac\u0005\u0204\u0103\u0002\u0dab\u0daa\u0003\u0002\u0002\u0002\u0dac\u0dad\u0003\u0002\u0002\u0002\u0dad\u0dab\u0003\u0002\u0002\u0002\u0dad\u0dae\u0003\u0002\u0002\u0002\u0dae\u0203\u0003\u0002\u0002\u0002\u0daf\u0db1\u0007\u014a\u0002\u0002\u0db0\u0daf\u0003\u0002\u0002\u0002\u0db0\u0db1\u0003\u0002\u0002\u0002\u0db1\u0db4\u0003\u0002\u0002\u0002\u0db2\u0db5\u0005\u0434\u021b\u0002\u0db3\u0db5\u0005\u0470\u0239\u0002\u0db4\u0db2\u0003\u0002\u0002\u0002\u0db4\u0db3\u0003\u0002\u0002\u0002\u0db5\u0db8\u0003\u0002\u0002\u0002\u0db6\u0db8\u0007\u0016\u0002\u0002\u0db7\u0db0\u0003\u0002\u0002\u0002\u0db7\u0db6\u0003\u0002\u0002\u0002\u0db8\u0205\u0003\u0002\u0002\u0002\u0db9\u0dbb\u0007\u0033\u0002\u0002\u0dba\u0db9\u0003\u0002\u0002\u0002\u0dba\u0dbb\u0003\u0002\u0002\u0002\u0dbb\u0dbc\u0003\u0002\u0002\u0002\u0dbc\u0dbe\u0007\u01fd\u0002\u0002\u0dbd\u0dbf\u0005\u0208\u0105\u0002\u0dbe\u0dbd\u0003\u0002\u0002\u0002\u0dbf\u0dc0\u0003\u0002\u0002\u0002\u0dc0\u0dbe\u0003\u0002\u0002\u0002\u0dc0\u0dc1\u0003\u0002\u0002\u0002\u0dc1\u0207\u0003\u0002\u0002\u0002\u0dc2\u0dc6\u0005\u0434\u021b\u0002\u0dc3\u0dc6\u0005\u0496\u024c\u0002\u0dc4\u0dc6\u0007\u0016\u0002\u0002\u0dc5\u0dc2\u0003\u0002\u0002\u0002\u0dc5\u0dc3\u0003\u0002\u0002\u0002\u0dc5\u0dc4\u0003\u0002\u0002\u0002\u0dc6\u0209\u0003\u0002\u0002\u0002\u0dc7\u0dc8\u0007\u0081\u0002\u0002\u0dc8\u0dca\u0007\u0218\u0002\u0002\u0dc9\u0dcb\u0005\u020c\u0107\u0002\u0dca\u0dc9\u0003\u0002\u0002\u0002\u0dcb\u0dcc\u0003\u0002\u0002\u0002\u0dcc\u0dca\u0003\u0002\u0002\u0002\u0dcc\u0dcd\u0003\u0002\u0002\u0002\u0dcd\u0dce\u0003\u0002\u0002\u0002\u0dce\u0dcf\u0007\u00a0\u0002\u0002\u0dcf\u0dd0\u0007\u0081\u0002\u0002\u0dd0\u0dd1\u0007\u0218\u0002\u0002\u0dd1\u020b\u0003\u0002\u0002\u0002\u0dd2\u0dd3\u0005\u020e\u0108\u0002\u0dd3\u0dd4\u0007\u0218\u0002\u0002\u0dd4\u0dd5\u0005\u03dc\u01ef\u0002\u0dd5\u0dd6\u0007\u0218\u0002\u0002\u0dd6\u0dd7\u0005\u0214\u010b\u0002\u0dd7\u020d\u0003\u0002\u0002\u0002\u0dd8\u0dd9\u0005\u048c\u0247\u0002\u0dd9\u0ddb\u0007\u01a5\u0002\u0002\u0dda\u0ddc\u0005\u049c\u024f\u0002\u0ddb\u0dda\u0003\u0002\u0002\u0002\u0ddb\u0ddc\u0003\u0002\u0002\u0002\u0ddc\u020f\u0003\u0002\u0002\u0002\u0ddd\u0de1\u0005\u0214\u010b\u0002\u0dde\u0de0\u0005\u0212\u010a\u0002\u0ddf\u0dde\u0003\u0002\u0002\u0002\u0de0\u0de3\u0003\u0002\u0002\u0002\u0de1\u0ddf\u0003\u0002\u0002\u0002\u0de1\u0de2\u0003\u0002\u0002\u0002\u0de2\u0211\u0003\u0002\u0002\u0002\u0de3\u0de1\u0003\u0002\u0002\u0002\u0de4\u0de5\u0005\u020e\u0108\u0002\u0de5\u0de6\u0007\u0218\u0002\u0002\u0de6\u0de7\u0005\u0214\u010b\u0002\u0de7\u0213\u0003\u0002\u0002\u0002\u0de8\u0dea\u0005\u0218\u010d\u0002\u0de9\u0de8\u0003\u0002\u0002\u0002\u0dea\u0ded\u0003\u0002\u0002\u0002\u0deb\u0de9\u0003\u0002\u0002\u0002\u0deb\u0dec\u0003\u0002\u0002\u0002\u0dec\u0df1\u0003\u0002\u0002\u0002\u0ded\u0deb\u0003\u0002\u0002\u0002\u0dee\u0df0\u0005\u0216\u010c\u0002\u0def\u0dee\u0003\u0002\u0002\u0002\u0df0\u0df3\u0003\u0002\u0002\u0002\u0df1\u0def\u0003\u0002\u0002\u0002\u0df1\u0df2\u0003\u0002\u0002\u0002\u0df2\u0215\u0003\u0002\u0002\u0002\u0df3\u0df1\u0003\u0002\u0002\u0002\u0df4\u0df5\u0005\u047e\u0240\u0002\u0df5\u0dfd\u0007\u0218\u0002\u0002\u0df6\u0dfe\u0005\u0236\u011c\u0002\u0df7\u0df9\u0005\u0218\u010d\u0002\u0df8\u0df7\u0003\u0002\u0002\u0002\u0df9\u0dfc\u0003\u0002\u0002\u0002\u0dfa\u0df8\u0003\u0002\u0002\u0002\u0dfa\u0dfb\u0003\u0002\u0002\u0002\u0dfb\u0dfe\u0003\u0002\u0002\u0002\u0dfc\u0dfa\u0003\u0002\u0002\u0002\u0dfd\u0df6\u0003\u0002\u0002\u0002\u0dfd\u0dfa\u0003\u0002\u0002\u0002\u0dfe\u0217\u0003\u0002\u0002\u0002\u0dff\u0e01\u0005\u021a\u010e\u0002\u0e00\u0dff\u0003\u0002\u0002\u0002\u0e01\u0e04\u0003\u0002\u0002\u0002\u0e02\u0e00\u0003\u0002\u0002\u0002\u0e02\u0e03\u0003\u0002\u0002\u0002\u0e03\u0e05\u0003\u0002\u0002\u0002\u0e04\u0e02\u0003\u0002\u0002\u0002\u0e05\u0e06\u0007\u0218\u0002\u0002\u0e06\u0219\u0003\u0002\u0002\u0002\u0e07\u0e39\u0005\u021c\u010f\u0002\u0e08\u0e39\u0005\u0226\u0114\u0002\u0e09\u0e39\u0005\u0238\u011d\u0002\u0e0a\u0e39\u0005\u023c\u011f\u0002\u0e0b\u0e39\u0005\u0250\u0129\u0002\u0e0c\u0e39\u0005\u0254\u012b\u0002\u0e0d\u0e39\u0005\u0266\u0134\u0002\u0e0e\u0e39\u0005\u026a\u0136\u0002\u0e0f\u0e39\u0005\u026c\u0137\u0002\u0e10\u0e39\u0005\u026e\u0138\u0002\u0e11\u0e39\u0005\u0270\u0139\u0002\u0e12\u0e39\u0005\u027a\u013e\u0002\u0e13\u0e39\u0005\u028a\u0146\u0002\u0e14\u0e39\u0005\u028c\u0147\u0002\u0e15\u0e39\u0005\u028e\u0148\u0002\u0e16\u0e39\u0005\u02a8\u0155\u0002\u0e17\u0e39\u0005\u02a2\u0152\u0002\u0e18\u0e39\u0005\u02a4\u0153\u0002\u0e19\u0e39\u0005\u02a6\u0154\u0002\u0e1a\u0e39\u0005\u02ac\u0157\u0002\u0e1b\u0e39\u0005\u02ae\u0158\u0002\u0e1c\u0e39\u0005\u02b0\u0159\u0002\u0e1d\u0e39\u0005\u02b2\u015a\u0002\u0e1e\u0e39\u0005\u02b8\u015d\u0002\u0e1f\u0e39\u0005\u02be\u0160\u0002\u0e20\u0e39\u0005\u02c4\u0163\u0002\u0e21\u0e39\u0005\u02c6\u0164\u0002\u0e22\u0e39\u0005\u02e4\u0173\u0002\u0e23\u0e39\u0005\u02f8\u017d\u0002\u0e24\u0e39\u0005\u0302\u0182\u0002\u0e25\u0e39\u0005\u030e\u0188\u0002\u0e26\u0e39\u0005\u031c\u018f\u0002\u0e27\u0e39\u0005\u0336\u019c\u0002\u0e28\u0e39\u0005\u0338\u019d\u0002\u0e29\u0e39\u0005\u0340\u01a1\u0002\u0e2a\u0e39\u0005\u0356\u01ac\u0002\u0e2b\u0e39\u0005\u0358\u01ad\u0002\u0e2c\u0e39\u0005\u035c\u01af\u0002\u0e2d\u0e39\u0005\u0360\u01b1\u0002\u0e2e\u0e39\u0005\u0366\u01b4\u0002\u0e2f\u0e39\u0005\u037a\u01be\u0002\u0e30\u0e39\u0005\u0386\u01c4\u0002\u0e31\u0e39\u0005\u03a0\u01d1\u0002\u0e32\u0e39\u0005\u03a4\u01d3\u0002\u0e33\u0e39\u0005\u03a6\u01d4\u0002\u0e34\u0e39\u0005\u03b4\u01db\u0002\u0e35\u0e39\u0005\u03c6\u01e4\u0002\u0e36\u0e39\u0005\u03c8\u01e5\u0002\u0e37\u0e39\u0005\u03e6\u01f4\u0002\u0e38\u0e07\u0003\u0002\u0002\u0002\u0e38\u0e08\u0003\u0002\u0002\u0002\u0e38\u0e09\u0003\u0002\u0002\u0002\u0e38\u0e0a\u0003\u0002\u0002\u0002\u0e38\u0e0b\u0003\u0002\u0002\u0002\u0e38\u0e0c\u0003\u0002\u0002\u0002\u0e38\u0e0d\u0003\u0002\u0002\u0002\u0e38\u0e0e\u0003\u0002\u0002\u0002\u0e38\u0e0f\u0003\u0002\u0002\u0002\u0e38\u0e10\u0003\u0002\u0002\u0002\u0e38\u0e11\u0003\u0002\u0002\u0002\u0e38\u0e12\u0003\u0002\u0002\u0002\u0e38\u0e13\u0003\u0002\u0002\u0002\u0e38\u0e14\u0003\u0002\u0002\u0002\u0e38\u0e15\u0003\u0002\u0002\u0002\u0e38\u0e16\u0003\u0002\u0002\u0002\u0e38\u0e17\u0003\u0002\u0002\u0002\u0e38\u0e18\u0003\u0002\u0002\u0002\u0e38\u0e19\u0003\u0002\u0002\u0002\u0e38\u0e1a\u0003\u0002\u0002\u0002\u0e38\u0e1b\u0003\u0002\u0002\u0002\u0e38\u0e1c\u0003\u0002\u0002\u0002\u0e38\u0e1d\u0003\u0002\u0002\u0002\u0e38\u0e1e\u0003\u0002\u0002\u0002\u0e38\u0e1f\u0003\u0002\u0002\u0002\u0e38\u0e20\u0003\u0002\u0002\u0002\u0e38\u0e21\u0003\u0002\u0002\u0002\u0e38\u0e22\u0003\u0002\u0002\u0002\u0e38\u0e23\u0003\u0002\u0002\u0002\u0e38\u0e24\u0003\u0002\u0002\u0002\u0e38\u0e25\u0003\u0002\u0002\u0002\u0e38\u0e26\u0003\u0002\u0002\u0002\u0e38\u0e27\u0003\u0002\u0002\u0002\u0e38\u0e28\u0003\u0002\u0002\u0002\u0e38\u0e29\u0003\u0002\u0002\u0002\u0e38\u0e2a\u0003\u0002\u0002\u0002\u0e38\u0e2b\u0003\u0002\u0002\u0002\u0e38\u0e2c\u0003\u0002\u0002\u0002\u0e38\u0e2d\u0003\u0002\u0002\u0002\u0e38\u0e2e\u0003\u0002\u0002\u0002\u0e38\u0e2f\u0003\u0002\u0002\u0002\u0e38\u0e30\u0003\u0002\u0002\u0002\u0e38\u0e31\u0003\u0002\u0002\u0002\u0e38\u0e32\u0003\u0002\u0002\u0002\u0e38\u0e33\u0003\u0002\u0002\u0002\u0e38\u0e34\u0003\u0002\u0002\u0002\u0e38\u0e35\u0003\u0002\u0002\u0002\u0e38\u0e36\u0003\u0002\u0002\u0002\u0e38\u0e37\u0003\u0002\u0002\u0002\u0e39\u021b\u0003\u0002\u0002\u0002\u0e3a\u0e3b\u0007\u0004\u0002\u0002\u0e3b\u0e40\u0005\u0434\u021b\u0002\u0e3c\u0e41\u0005\u021e\u0110\u0002\u0e3d\u0e41\u0005\u0222\u0112\u0002\u0e3e\u0e41\u0005\u0220\u0111\u0002\u0e3f\u0e41\u0005\u0224\u0113\u0002\u0e40\u0e3c\u0003\u0002\u0002\u0002\u0e40\u0e3d\u0003\u0002\u0002\u0002\u0e40\u0e3e\u0003\u0002\u0002\u0002\u0e40\u0e3f\u0003\u0002\u0002\u0002\u0e40\u0e41\u0003\u0002\u0002\u0002\u0e41\u0e43\u0003\u0002\u0002\u0002\u0e42\u0e44\u0005\u0406\u0204\u0002\u0e43\u0e42\u0003\u0002\u0002\u0002\u0e43\u0e44\u0003\u0002\u0002\u0002\u0e44\u0e46\u0003\u0002\u0002\u0002\u0e45\u0e47\u0005\u0408\u0205\u0002\u0e46\u0e45\u0003\u0002\u0002\u0002\u0e46\u0e47\u0003\u0002\u0002\u0002\u0e47\u0e49\u0003\u0002\u0002\u0002\u0e48\u0e4a\u0007\u00a1\u0002\u0002\u0e49\u0e48\u0003\u0002\u0002\u0002\u0e49\u0e4a\u0003\u0002\u0002\u0002\u0e4a\u021d\u0003\u0002\u0002\u0002\u0e4b\u0e5f\u0007\u00d9\u0002\u0002\u0e4c\u0e4e\u0007\u0071\u0002\u0002\u0e4d\u0e4f\u0007\u0209\u0002\u0002\u0e4e\u0e4d\u0003\u0002\u0002\u0002\u0e4e\u0e4f\u0003\u0002\u0002\u0002\u0e4f\u0e60\u0003\u0002\u0002\u0002\u0e50\u0e52\u0007\u0074\u0002\u0002\u0e51\u0e53\u0007\u020a\u0002\u0002\u0e52\u0e51\u0003\u0002\u0002\u0002\u0e52\u0e53\u0003\u0002\u0002\u0002\u0e53\u0e60\u0003\u0002\u0002\u0002\u0e54\u0e60\u0007\u0075\u0002\u0002\u0e55\u0e60\u0007\u01e7\u0002\u0002\u0e56\u0e60\u0007\u01e8\u0002\u0002\u0e57\u0e59\u0007\u01ec\u0002\u0002\u0e58\u0e5a\u0007\u012a\u0002\u0002\u0e59\u0e58\u0003\u0002\u0002\u0002\u0e59\u0e5a\u0003\u0002\u0002\u0002\u0e5a\u0e60\u0003\u0002\u0002\u0002\u0e5b\u0e60\u0007\u01ed\u0002\u0002\u0e5c\u0e60\u0007\u0208\u0002\u0002\u0e5d\u0e60\u0007\u0209\u0002\u0002\u0e5e\u0e60\u0007\u020a\u0002\u0002\u0e5f\u0e4c\u0003\u0002\u0002\u0002\u0e5f\u0e50\u0003\u0002\u0002\u0002\u0e5f\u0e54\u0003\u0002\u0002\u0002\u0e5f\u0e55\u0003\u0002\u0002\u0002\u0e5f\u0e56\u0003\u0002\u0002\u0002\u0e5f\u0e57\u0003\u0002\u0002\u0002\u0e5f\u0e5b\u0003\u0002\u0002\u0002\u0e5f\u0e5c\u0003\u0002\u0002\u0002\u0e5f\u0e5d\u0003\u0002\u0002\u0002\u0e5f\u0e5e\u0003\u0002\u0002\u0002\u0e60\u021f\u0003\u0002\u0002\u0002\u0e61\u0e62\u0007\u00d9\u0002\u0002\u0e62\u0e63\u0005\u047c\u023f\u0002\u0e63\u0221\u0003\u0002\u0002\u0002\u0e64\u0e65\u0007\u00d9\u0002\u0002\u0e65\u0e66\u0007\u00c1\u0002\u0002\u0e66\u0e67\u0007\u0105\u0002\u0002\u0e67\u0223\u0003\u0002\u0002\u0002\u0e68\u0e6a\u0007\u0129\u0002\u0002\u0e69\u0e68\u0003\u0002\u0002\u0002\u0e69\u0e6a\u0003\u0002\u0002\u0002\u0e6a\u0e6b\u0003\u0002\u0002\u0002\u0e6b\u0e6c\u0007\u006b\u0002\u0002\u0e6c\u0225\u0003\u0002\u0002\u0002\u0e6d\u0e71\u0007\u0006\u0002\u0002\u0e6e\u0e72\u0005\u0228\u0115\u0002\u0e6f\u0e72\u0005\u022a\u0116\u0002\u0e70\u0e72\u0005\u022c\u0117\u0002\u0e71\u0e6e\u0003\u0002\u0002\u0002\u0e71\u0e6f\u0003\u0002\u0002\u0002\u0e71\u0e70\u0003\u0002\u0002\u0002\u0e72\u0e74\u0003\u0002\u0002\u0002\u0e73\u0e75\u0005\u0402\u0202\u0002\u0e74\u0e73\u0003\u0002\u0002\u0002\u0e74\u0e75\u0003\u0002\u0002\u0002\u0e75\u0e77\u0003\u0002\u0002\u0002\u0e76\u0e78\u0005\u0404\u0203\u0002\u0e77\u0e76\u0003\u0002\u0002\u0002\u0e77\u0e78\u0003\u0002\u0002\u0002\u0e78\u0e7a\u0003\u0002\u0002\u0002\u0e79\u0e7b\u0007\u00a2\u0002\u0002\u0e7a\u0e79\u0003\u0002\u0002\u0002\u0e7a\u0e7b\u0003\u0002\u0002\u0002\u0e7b\u0227\u0003\u0002\u0002\u0002\u0e7c\u0e7e\u0005\u022e\u0118\u0002\u0e7d\u0e7c\u0003\u0002\u0002\u0002\u0e7e\u0e7f\u0003\u0002\u0002\u0002\u0e7f\u0e7d\u0003\u0002\u0002\u0002\u0e7f\u0e80\u0003\u0002\u0002\u0002\u0e80\u0e81\u0003\u0002\u0002\u0002\u0e81\u0e83\u0007\u01eb\u0002\u0002\u0e82\u0e84\u0005\u0230\u0119\u0002\u0e83\u0e82\u0003\u0002\u0002\u0002\u0e84\u0e85\u0003\u0002\u0002\u0002\u0e85\u0e83\u0003\u0002\u0002\u0002\u0e85\u0e86\u0003\u0002\u0002\u0002\u0e86\u0229\u0003\u0002\u0002\u0002\u0e87\u0e89\u0005\u022e\u0118\u0002\u0e88\u0e87\u0003\u0002\u0002\u0002\u0e89\u0e8a\u0003\u0002\u0002\u0002\u0e8a\u0e88\u0003\u0002\u0002\u0002\u0e8a\u0e8b\u0003\u0002\u0002\u0002\u0e8b\u0e92\u0003\u0002\u0002\u0002\u0e8c\u0e8e\u0007\u01eb\u0002\u0002\u0e8d\u0e8f\u0005\u0232\u011a\u0002\u0e8e\u0e8d\u0003\u0002\u0002\u0002\u0e8f\u0e90\u0003\u0002\u0002\u0002\u0e90\u0e8e\u0003\u0002\u0002\u0002\u0e90\u0e91\u0003\u0002\u0002\u0002\u0e91\u0e93\u0003\u0002\u0002\u0002\u0e92\u0e8c\u0003\u0002\u0002\u0002\u0e92\u0e93\u0003\u0002\u0002\u0002\u0e93\u0e94\u0003\u0002\u0002\u0002\u0e94\u0e96\u0007\u00e0\u0002\u0002\u0e95\u0e97\u0005\u0234\u011b\u0002\u0e96\u0e95\u0003\u0002\u0002\u0002\u0e97\u0e98\u0003\u0002\u0002\u0002\u0e98\u0e96\u0003\u0002\u0002\u0002\u0e98\u0e99\u0003\u0002\u0002\u0002\u0e99\u022b\u0003\u0002\u0002\u0002\u0e9a\u0e9b\u0009\u0034\u0002\u0002\u0e9b\u0e9c\u0005\u0434\u021b\u0002\u0e9c\u0e9d\u0007\u01eb\u0002\u0002\u0e9d\u0e9e\u0005\u0230\u0119\u0002\u0e9e\u022d\u0003\u0002\u0002\u0002\u0e9f\u0ea2\u0005\u0434\u021b\u0002\u0ea0\u0ea2\u0005\u0496\u024c\u0002\u0ea1\u0e9f\u0003\u0002\u0002\u0002\u0ea1\u0ea0\u0003\u0002\u0002\u0002\u0ea2\u022f\u0003\u0002\u0002\u0002\u0ea3\u0ea5\u0005\u0434\u021b\u0002\u0ea4\u0ea6\u0007\u019e\u0002\u0002\u0ea5\u0ea4\u0003\u0002\u0002\u0002\u0ea5\u0ea6\u0003\u0002\u0002\u0002\u0ea6\u0231\u0003\u0002\u0002\u0002\u0ea7\u0eaa\u0005\u0434\u021b\u0002\u0ea8\u0eaa\u0005\u0496\u024c\u0002\u0ea9\u0ea7\u0003\u0002\u0002\u0002\u0ea9\u0ea8\u0003\u0002\u0002\u0002\u0eaa\u0233\u0003\u0002\u0002\u0002\u0eab\u0ead\u0005\u0434\u021b\u0002\u0eac\u0eae\u0007\u019e\u0002\u0002\u0ead\u0eac\u0003\u0002\u0002\u0002\u0ead\u0eae\u0003\u0002\u0002\u0002\u0eae\u0235\u0003\u0002\u0002\u0002\u0eaf\u0eb1\u0007\u00e2\u0002\u0002\u0eb0\u0eb2\u0007\u01eb\u0002\u0002\u0eb1\u0eb0\u0003\u0002\u0002\u0002\u0eb1\u0eb2\u0003\u0002\u0002\u0002\u0eb2\u0eb3\u0003\u0002\u0002\u0002\u0eb3\u0eb4\u0007\u0218\u0002\u0002\u0eb4\u0237\u0003\u0002\u0002\u0002\u0eb5\u0eb7\u0007\u0013\u0002\u0002\u0eb6\u0eb8\u0005\u023a\u011e\u0002\u0eb7\u0eb6\u0003\u0002\u0002\u0002\u0eb8\u0eb9\u0003\u0002\u0002\u0002\u0eb9\u0eb7\u0003\u0002\u0002\u0002\u0eb9\u0eba\u0003\u0002\u0002\u0002\u0eba\u0239\u0003\u0002\u0002\u0002\u0ebb\u0ebc\u0005\u0480\u0241\u0002\u0ebc\u0ebf\u0007\u01eb\u0002\u0002\u0ebd\u0ebe\u0007\u0169\u0002\u0002\u0ebe\u0ec0\u0007\u01eb\u0002\u0002\u0ebf\u0ebd\u0003\u0002\u0002\u0002\u0ebf\u0ec0\u0003\u0002\u0002\u0002\u0ec0\u0ec1\u0003\u0002\u0002\u0002\u0ec1\u0ec2\u0005\u0480\u0241\u0002\u0ec2\u023b\u0003\u0002\u0002\u0002\u0ec3\u0ec6\u0007\u0036\u0002\u0002\u0ec4\u0ec7\u0005\u0434\u021b\u0002\u0ec5\u0ec7\u0005\u0496\u024c\u0002\u0ec6\u0ec4\u0003\u0002\u0002\u0002\u0ec6\u0ec5\u0003\u0002\u0002\u0002\u0ec7\u0ec9\u0003\u0002\u0002\u0002\u0ec8\u0eca\u0005\u023e\u0120\u0002\u0ec9\u0ec8\u0003\u0002\u0002\u0002\u0ec9\u0eca\u0003\u0002\u0002\u0002\u0eca\u0ecc\u0003\u0002\u0002\u0002\u0ecb\u0ecd\u0005\u024e\u0128\u0002\u0ecc\u0ecb\u0003\u0002\u0002\u0002\u0ecc\u0ecd\u0003\u0002\u0002\u0002\u0ecd\u0ecf\u0003\u0002\u0002\u0002\u0ece\u0ed0\u0005\u03fe\u0200\u0002\u0ecf\u0ece\u0003\u0002\u0002\u0002\u0ecf\u0ed0\u0003\u0002\u0002\u0002\u0ed0\u0ed2\u0003\u0002\u0002\u0002\u0ed1\u0ed3\u0005\u0406\u0204\u0002\u0ed2\u0ed1\u0003\u0002\u0002\u0002\u0ed2\u0ed3\u0003\u0002\u0002\u0002\u0ed3\u0ed5\u0003\u0002\u0002\u0002\u0ed4\u0ed6\u0005\u0408\u0205\u0002\u0ed5\u0ed4\u0003\u0002\u0002\u0002\u0ed5\u0ed6\u0003\u0002\u0002\u0002\u0ed6\u0ed8\u0003\u0002\u0002\u0002\u0ed7\u0ed9\u0007\u00a3\u0002\u0002\u0ed8\u0ed7\u0003\u0002\u0002\u0002\u0ed8\u0ed9\u0003\u0002\u0002\u0002\u0ed9\u023d\u0003\u0002\u0002\u0002\u0eda\u0edc\u0007\u01fc\u0002\u0002\u0edb\u0edd\u0005\u0240\u0121\u0002\u0edc\u0edb\u0003\u0002\u0002\u0002\u0edd\u0ede\u0003\u0002\u0002\u0002\u0ede\u0edc\u0003\u0002\u0002\u0002\u0ede\u0edf\u0003\u0002\u0002\u0002\u0edf\u023f\u0003\u0002\u0002\u0002\u0ee0\u0ee4\u0005\u0242\u0122\u0002\u0ee1\u0ee4\u0005\u0246\u0124\u0002\u0ee2\u0ee4\u0005\u024a\u0126\u0002\u0ee3\u0ee0\u0003\u0002\u0002\u0002\u0ee3\u0ee1\u0003\u0002\u0002\u0002\u0ee3\u0ee2\u0003\u0002\u0002\u0002\u0ee4\u0241\u0003\u0002\u0002\u0002\u0ee5\u0ee7\u0007\u0033\u0002\u0002\u0ee6\u0ee5\u0003\u0002\u0002\u0002\u0ee6\u0ee7\u0003\u0002\u0002\u0002\u0ee7\u0ee8\u0003\u0002\u0002\u0002\u0ee8\u0eea\u0007\u0182\u0002\u0002\u0ee9\u0ee6\u0003\u0002\u0002\u0002\u0ee9\u0eea\u0003\u0002\u0002\u0002\u0eea\u0eec\u0003\u0002\u0002\u0002\u0eeb\u0eed\u0005\u0244\u0123\u0002\u0eec\u0eeb\u0003\u0002\u0002\u0002\u0eed\u0eee\u0003\u0002\u0002\u0002\u0eee\u0eec\u0003\u0002\u0002\u0002\u0eee\u0eef\u0003\u0002\u0002\u0002\u0eef\u0243\u0003\u0002\u0002\u0002\u0ef0\u0ef1\u0007\u0007\u0002\u0002\u0ef1\u0ef5\u0007\u0145\u0002\u0002\u0ef2\u0ef5\u0007\u00fc\u0002\u0002\u0ef3\u0ef5\u0007\u01cd\u0002\u0002\u0ef4\u0ef0\u0003\u0002\u0002\u0002\u0ef4\u0ef2\u0003\u0002\u0002\u0002\u0ef4\u0ef3\u0003\u0002\u0002\u0002\u0ef4\u0ef5\u0003\u0002\u0002\u0002\u0ef5\u0ef6\u0003\u0002\u0002\u0002\u0ef6\u0efa\u0005\u0434\u021b\u0002\u0ef7\u0efa\u0005\u0496\u024c\u0002\u0ef8\u0efa\u0005\u0470\u0239\u0002\u0ef9\u0ef4\u0003\u0002\u0002\u0002\u0ef9\u0ef7\u0003\u0002\u0002\u0002\u0ef9\u0ef8\u0003\u0002\u0002\u0002\u0efa\u0efd\u0003\u0002\u0002\u0002\u0efb\u0efd\u0007\u0147\u0002\u0002\u0efc\u0ef9\u0003\u0002\u0002\u0002\u0efc\u0efb\u0003\u0002\u0002\u0002\u0efd\u0245\u0003\u0002\u0002\u0002\u0efe\u0f00\u0007\u0033\u0002\u0002\u0eff\u0efe\u0003\u0002\u0002\u0002\u0eff\u0f00\u0003\u0002\u0002\u0002\u0f00\u0f01\u0003\u0002\u0002\u0002\u0f01\u0f03\u0007\u01fd\u0002\u0002\u0f02\u0f04\u0005\u0248\u0125\u0002\u0f03\u0f02\u0003\u0002\u0002\u0002\u0f04\u0f05\u0003\u0002\u0002\u0002\u0f05\u0f03\u0003\u0002\u0002\u0002\u0f05\u0f06\u0003\u0002\u0002\u0002\u0f06\u0247\u0003\u0002\u0002\u0002\u0f07\u0f08\u0007\u0007\u0002\u0002\u0f08\u0f0e\u0007\u0145\u0002\u0002\u0f09\u0f0b\u0007\u010f\u0002\u0002\u0f0a\u0f0c\u0007\u0145\u0002\u0002\u0f0b\u0f0a\u0003\u0002\u0002\u0002\u0f0b\u0f0c\u0003\u0002\u0002\u0002\u0f0c\u0f0e\u0003\u0002\u0002\u0002\u0f0d\u0f07\u0003\u0002\u0002\u0002\u0f0d\u0f09\u0003\u0002\u0002\u0002\u0f0d\u0f0e\u0003\u0002\u0002\u0002\u0f0e\u0f11\u0003\u0002\u0002\u0002\u0f0f\u0f12\u0005\u0434\u021b\u0002\u0f10\u0f12\u0005\u0496\u024c\u0002\u0f11\u0f0f\u0003\u0002\u0002\u0002\u0f11\u0f10\u0003\u0002\u0002\u0002\u0f12\u0249\u0003\u0002\u0002\u0002\u0f13\u0f15\u0007\u0033\u0002\u0002\u0f14\u0f13\u0003\u0002\u0002\u0002\u0f14\u0f15\u0003\u0002\u0002\u0002\u0f15\u0f16\u0003\u0002\u0002\u0002\u0f16\u0f18\u0007\u0061\u0002\u0002\u0f17\u0f19\u0005\u024c\u0127\u0002\u0f18\u0f17\u0003\u0002\u0002\u0002\u0f19\u0f1a\u0003\u0002\u0002\u0002\u0f1a\u0f18\u0003\u0002\u0002\u0002\u0f1a\u0f1b\u0003\u0002\u0002\u0002\u0f1b\u024b\u0003\u0002\u0002\u0002\u0f1c\u0f1d\u0007\u0007\u0002\u0002\u0f1d\u0f23\u0007\u0145\u0002\u0002\u0f1e\u0f20\u0007\u010f\u0002\u0002\u0f1f\u0f21\u0007\u0145\u0002\u0002\u0f20\u0f1f\u0003\u0002\u0002\u0002\u0f20\u0f21\u0003\u0002\u0002\u0002\u0f21\u0f23\u0003\u0002\u0002\u0002\u0f22\u0f1c\u0003\u0002\u0002\u0002\u0f22\u0f1e\u0003\u0002\u0002\u0002\u0f22\u0f23\u0003\u0002\u0002\u0002\u0f23\u0f24\u0003\u0002\u0002\u0002\u0f24\u0f28\u0005\u0434\u021b\u0002\u0f25\u0f28\u0005\u0496\u024c\u0002\u0f26\u0f28\u0007\u0147\u0002\u0002\u0f27\u0f22\u0003\u0002\u0002\u0002\u0f27\u0f25\u0003\u0002\u0002\u0002\u0f27\u0f26\u0003\u0002\u0002\u0002\u0f28\u024d\u0003\u0002\u0002\u0002\u0f29\u0f2a\u0009\u0033\u0002\u0002\u0f2a\u0f2b\u0005\u0434\u021b\u0002\u0f2b\u024f\u0003\u0002\u0002\u0002\u0f2c\u0f2e\u0007\u0037\u0002\u0002\u0f2d\u0f2f\u0005\u0252\u012a\u0002\u0f2e\u0f2d\u0003\u0002\u0002\u0002\u0f2f\u0f30\u0003\u0002\u0002\u0002\u0f30\u0f2e\u0003\u0002\u0002\u0002\u0f30\u0f31\u0003\u0002\u0002\u0002\u0f31\u0251\u0003\u0002\u0002\u0002\u0f32\u0f33\u0005\u0478\u023d\u0002\u0f33\u0f34\u0009\u0026\u0002\u0002\u0f34\u0f38\u0003\u0002\u0002\u0002\u0f35\u0f38\u0005\u0434\u021b\u0002\u0f36\u0f38\u0005\u0496\u024c\u0002\u0f37\u0f32\u0003\u0002\u0002\u0002\u0f37\u0f35\u0003\u0002\u0002\u0002\u0f37\u0f36\u0003\u0002\u0002\u0002\u0f38\u0253\u0003\u0002\u0002\u0002\u0f39\u0f3b\u0007\u0045\u0002\u0002\u0f3a\u0f3c\u0005\u0256\u012c\u0002\u0f3b\u0f3a\u0003\u0002\u0002\u0002\u0f3c\u0f3d\u0003\u0002\u0002\u0002\u0f3d\u0f3b\u0003\u0002\u0002\u0002\u0f3d\u0f3e\u0003\u0002\u0002\u0002\u0f3e\u0255\u0003\u0002\u0002\u0002\u0f3f\u0f43\u0005\u0470\u0239\u0002\u0f40\u0f44\u0005\u0258\u012d\u0002\u0f41\u0f44\u0005\u025a\u012e\u0002\u0f42\u0f44\u0005\u025c\u012f\u0002\u0f43\u0f40\u0003\u0002\u0002\u0002\u0f43\u0f41\u0003\u0002\u0002\u0002\u0f43\u0f42\u0003\u0002\u0002\u0002\u0f43\u0f44\u0003\u0002\u0002\u0002\u0f44\u0257\u0003\u0002\u0002\u0002\u0f45\u0f4a\u0009\u000e\u0002\u0002\u0f46\u0f48\u0007\u00d6\u0002\u0002\u0f47\u0f46\u0003\u0002\u0002\u0002\u0f47\u0f48\u0003\u0002\u0002\u0002\u0f48\u0f49\u0003\u0002\u0002\u0002\u0f49\u0f4b\u0007\u0188\u0002\u0002\u0f4a\u0f47\u0003\u0002\u0002\u0002\u0f4a\u0f4b\u0003\u0002\u0002\u0002\u0f4b\u0f54\u0003\u0002\u0002\u0002\u0f4c\u0f4e\u0007\u0204\u0002\u0002\u0f4d\u0f4c\u0003\u0002\u0002\u0002\u0f4d\u0f4e\u0003\u0002\u0002\u0002\u0f4e\u0f52\u0003\u0002\u0002\u0002\u0f4f\u0f50\u0007\u0138\u0002\u0002\u0f50\u0f53\u0007\u0199\u0002\u0002\u0f51\u0f53\u0007\u0120\u0002\u0002\u0f52\u0f4f\u0003\u0002\u0002\u0002\u0f52\u0f51\u0003\u0002\u0002\u0002\u0f53\u0f55\u0003\u0002\u0002\u0002\u0f54\u0f4d\u0003\u0002\u0002\u0002\u0f54\u0f55\u0003\u0002\u0002\u0002\u0f55\u0259\u0003\u0002\u0002\u0002\u0f56\u0f58\u0007\u0204\u0002\u0002\u0f57\u0f56\u0003\u0002\u0002\u0002\u0f57\u0f58\u0003\u0002\u0002\u0002\u0f58\u0f5c\u0003\u0002\u0002\u0002\u0f59\u0f5a\u0007\u0138\u0002\u0002\u0f5a\u0f5d\u0007\u0199\u0002\u0002\u0f5b\u0f5d\u0007\u0120\u0002\u0002\u0f5c\u0f59\u0003\u0002\u0002\u0002\u0f5c\u0f5b\u0003\u0002\u0002\u0002\u0f5d\u025b\u0003\u0002\u0002\u0002\u0f5e\u0f60\u0007\u0204\u0002\u0002\u0f5f\u0f5e\u0003\u0002\u0002\u0002\u0f5f\u0f60\u0003\u0002\u0002\u0002\u0f60\u0f61\u0003\u0002\u0002\u0002\u0f61\u0f62\u0007\u0138\u0002\u0002\u0f62\u0f66\u0007\u0201\u0002\u0002\u0f63\u0f64\u0007\u0204\u0002\u0002\u0f64\u0f66\u0007\u0201\u0002\u0002\u0f65\u0f5f\u0003\u0002\u0002\u0002\u0f65\u0f63\u0003\u0002\u0002\u0002\u0f66\u0f6d\u0003\u0002\u0002\u0002\u0f67\u0f69\u0007\u01fc\u0002\u0002\u0f68\u0f6a\u0005\u025e\u0130\u0002\u0f69\u0f68\u0003\u0002\u0002\u0002\u0f6a\u0f6b\u0003\u0002\u0002\u0002\u0f6b\u0f69\u0003\u0002\u0002\u0002\u0f6b\u0f6c\u0003\u0002\u0002\u0002\u0f6c\u0f6e\u0003\u0002\u0002\u0002\u0f6d\u0f67\u0003\u0002\u0002\u0002\u0f6d\u0f6e\u0003\u0002\u0002\u0002\u0f6e\u025d\u0003\u0002\u0002\u0002\u0f6f\u0f73\u0005\u0260\u0131\u0002\u0f70\u0f73\u0005\u0262\u0132\u0002\u0f71\u0f73\u0005\u0264\u0133\u0002\u0f72\u0f6f\u0003\u0002\u0002\u0002\u0f72\u0f70\u0003\u0002\u0002\u0002\u0f72\u0f71\u0003\u0002\u0002\u0002\u0f73\u025f\u0003\u0002\u0002\u0002\u0f74\u0f76\u0007\u0046\u0002\u0002\u0f75\u0f77\u0007\u0145\u0002\u0002\u0f76\u0f75\u0003\u0002\u0002\u0002\u0f76\u0f77\u0003\u0002\u0002\u0002\u0f77\u0f78\u0003\u0002\u0002\u0002\u0f78\u0f79\u0009\u0035\u0002\u0002\u0f79\u0261\u0003\u0002\u0002\u0002\u0f7a\u0f7d\u0007\u001e\u0002\u0002\u0f7b\u0f7e\u0005\u0434\u021b\u0002\u0f7c\u0f7e\u0005\u049c\u024f\u0002\u0f7d\u0f7b\u0003\u0002\u0002\u0002\u0f7d\u0f7c\u0003\u0002\u0002\u0002\u0f7e\u0263\u0003\u0002\u0002\u0002\u0f7f\u0f81\u0007\u001f\u0002\u0002\u0f80\u0f82\u0007\u0145\u0002\u0002\u0f81\u0f80\u0003\u0002\u0002\u0002\u0f81\u0f82\u0003\u0002\u0002\u0002\u0f82\u0f85\u0003\u0002\u0002\u0002\u0f83\u0f86\u0005\u0434\u021b\u0002\u0f84\u0f86\u0005\u049c\u024f\u0002\u0f85\u0f83\u0003\u0002\u0002\u0002\u0f85\u0f84\u0003\u0002\u0002\u0002\u0f86\u0265\u0003\u0002\u0002\u0002\u0f87\u0f89\u0007\u005e\u0002\u0002\u0f88\u0f8a\u0005\u0268\u0135\u0002\u0f89\u0f88\u0003\u0002\u0002\u0002\u0f8a\u0f8b\u0003\u0002\u0002\u0002\u0f8b\u0f89\u0003\u0002\u0002\u0002\u0f8b\u0f8c\u0003\u0002\u0002\u0002\u0f8c\u0f8d\u0003\u0002\u0002\u0002\u0f8d\u0f8e\u0009\u0036\u0002\u0002\u0f8e\u0f90\u0005\u040a\u0206\u0002\u0f8f\u0f91\u0005\u0402\u0202\u0002\u0f90\u0f8f\u0003\u0002\u0002\u0002\u0f90\u0f91\u0003\u0002\u0002\u0002\u0f91\u0f93\u0003\u0002\u0002\u0002\u0f92\u0f94\u0005\u0404\u0203\u0002\u0f93\u0f92\u0003\u0002\u0002\u0002\u0f93\u0f94\u0003\u0002\u0002\u0002\u0f94\u0f96\u0003\u0002\u0002\u0002\u0f95\u0f97\u0007\u00a4\u0002\u0002\u0f96\u0f95\u0003\u0002\u0002\u0002\u0f96\u0f97\u0003\u0002\u0002\u0002\u0f97\u0267\u0003\u0002\u0002\u0002\u0f98\u0f9a\u0005\u0434\u021b\u0002\u0f99\u0f9b\u0007\u019e\u0002\u0002\u0f9a\u0f99\u0003\u0002\u0002\u0002\u0f9a\u0f9b\u0003\u0002\u0002\u0002\u0f9b\u0269\u0003\u0002\u0002\u0002\u0f9c\u0f9d\u0007\u0062\u0002\u0002\u0f9d\u026b\u0003\u0002\u0002\u0002\u0f9e\u0f9f\u0007\u0085\u0002\u0002\u0f9f\u0fa1\u0005\u0470\u0239\u0002\u0fa0\u0fa2\u0007\u017b\u0002\u0002\u0fa1\u0fa0\u0003\u0002\u0002\u0002\u0fa1\u0fa2\u0003\u0002\u0002\u0002\u0fa2\u0fa4\u0003\u0002\u0002\u0002\u0fa3\u0fa5\u0005\u03fa\u01fe\u0002\u0fa4\u0fa3\u0003\u0002\u0002\u0002\u0fa4\u0fa5\u0003\u0002\u0002\u0002\u0fa5\u0fa7\u0003\u0002\u0002\u0002\u0fa6\u0fa8\u0005\u03fc\u01ff\u0002\u0fa7\u0fa6\u0003\u0002\u0002\u0002\u0fa7\u0fa8\u0003\u0002\u0002\u0002\u0fa8\u0faa\u0003\u0002\u0002\u0002\u0fa9\u0fab\u0007\u00a5\u0002\u0002\u0faa\u0fa9\u0003\u0002\u0002\u0002\u0faa\u0fab\u0003\u0002\u0002\u0002\u0fab\u026d\u0003\u0002\u0002\u0002\u0fac\u0fb4\u0007\u008e\u0002\u0002\u0fad\u0faf\u0007\u00f8\u0002\u0002\u0fae\u0fb0\u0007\u01dd\u0002\u0002\u0faf\u0fae\u0003\u0002\u0002\u0002\u0faf\u0fb0\u0003\u0002\u0002\u0002\u0fb0\u0fb5\u0003\u0002\u0002\u0002\u0fb1\u0fb2\u0007\u00ea\u0002\u0002\u0fb2\u0fb5\u0007\u01dd\u0002\u0002\u0fb3\u0fb5\u0007\u0150\u0002\u0002\u0fb4\u0fad\u0003\u0002\u0002\u0002\u0fb4\u0fb1\u0003\u0002\u0002\u0002\u0fb4\u0fb3\u0003\u0002\u0002\u0002\u0fb5\u0fb6\u0003\u0002\u0002\u0002\u0fb6\u0fb8\u0005\u0462\u0232\u0002\u0fb7\u0fb9\u0007\u0204\u0002\u0002\u0fb8\u0fb7\u0003\u0002\u0002\u0002\u0fb8\u0fb9\u0003\u0002\u0002\u0002\u0fb9\u0fba\u0003\u0002\u0002\u0002\u0fba\u0fbd\u0007\u0105\u0002\u0002\u0fbb\u0fbe\u0005\u0434\u021b\u0002\u0fbc\u0fbe\u0005\u0496\u024c\u0002\u0fbd\u0fbb\u0003\u0002\u0002\u0002\u0fbd\u0fbc\u0003\u0002\u0002\u0002\u0fbe\u026f\u0003\u0002\u0002\u0002\u0fbf\u0fc1\u0007\u0090\u0002\u0002\u0fc0\u0fc2\u0005\u0272\u013a\u0002\u0fc1\u0fc0\u0003\u0002\u0002\u0002\u0fc2\u0fc3\u0003\u0002\u0002\u0002\u0fc3\u0fc1\u0003\u0002\u0002\u0002\u0fc3\u0fc4\u0003\u0002\u0002\u0002\u0fc4\u0fc6\u0003\u0002\u0002\u0002\u0fc5\u0fc7\u0005\u0274\u013b\u0002\u0fc6\u0fc5\u0003\u0002\u0002\u0002\u0fc6\u0fc7\u0003\u0002\u0002\u0002\u0fc7\u0fc9\u0003\u0002\u0002\u0002\u0fc8\u0fca\u0005\u0276\u013c\u0002\u0fc9\u0fc8\u0003\u0002\u0002\u0002\u0fc9\u0fca\u0003\u0002\u0002\u0002\u0fca\u0fcc\u0003\u0002\u0002\u0002\u0fcb\u0fcd\u0005\u0278\u013d\u0002\u0fcc\u0fcb\u0003\u0002\u0002\u0002\u0fcc\u0fcd\u0003\u0002\u0002\u0002\u0fcd\u0271\u0003\u0002\u0002\u0002\u0fce\u0fd1\u0005\u0434\u021b\u0002\u0fcf\u0fd1\u0005\u0496\u024c\u0002\u0fd0\u0fce\u0003\u0002\u0002\u0002\u0fd0\u0fcf\u0003\u0002\u0002\u0002\u0fd1\u0273\u0003\u0002\u0002\u0002\u0fd2\u0fd5\u0007\u0020\u0002\u0002\u0fd3\u0fd6\u0005\u0434\u021b\u0002\u0fd4\u0fd6\u0005\u0496\u024c\u0002\u0fd5\u0fd3\u0003\u0002\u0002\u0002\u0fd5\u0fd4\u0003\u0002\u0002\u0002\u0fd6\u0275\u0003\u0002\u0002\u0002\u0fd7\u0fda\u0007\u01f9\u0002\u0002\u0fd8\u0fdb\u0005\u047c\u023f\u0002\u0fd9\u0fdb\u0005\u046e\u0238\u0002\u0fda\u0fd8\u0003\u0002\u0002\u0002\u0fda\u0fd9\u0003\u0002\u0002\u0002\u0fdb\u0277\u0003\u0002\u0002\u0002\u0fdc\u0fde\u0007\u0204\u0002\u0002\u0fdd\u0fdc\u0003\u0002\u0002\u0002\u0fdd\u0fde\u0003\u0002\u0002\u0002\u0fde\u0fdf\u0003\u0002\u0002\u0002\u0fdf\u0fe0\u0007\u0138\u0002\u0002\u0fe0\u0fe1\u0007\u0008\u0002\u0002\u0fe1\u0279\u0003\u0002\u0002\u0002\u0fe2\u0fe5\u0007\u0092\u0002\u0002\u0fe3\u0fe6\u0005\u0434\u021b\u0002\u0fe4\u0fe6\u0005\u0496\u024c\u0002\u0fe5\u0fe3\u0003\u0002\u0002\u0002\u0fe5\u0fe4\u0003\u0002\u0002\u0002\u0fe6\u0fea\u0003\u0002\u0002\u0002\u0fe7\u0feb\u0005\u027c\u013f\u0002\u0fe8\u0feb\u0005\u027e\u0140\u0002\u0fe9\u0feb\u0005\u0280\u0141\u0002\u0fea\u0fe7\u0003\u0002\u0002\u0002\u0fea\u0fe8\u0003\u0002\u0002\u0002\u0fea\u0fe9\u0003\u0002\u0002\u0002\u0feb\u0fed\u0003\u0002\u0002\u0002\u0fec\u0fee\u0005\u0288\u0145\u0002\u0fed\u0fec\u0003\u0002\u0002\u0002\u0fed\u0fee\u0003\u0002\u0002\u0002\u0fee\u0ff0\u0003\u0002\u0002\u0002\u0fef\u0ff1\u0005\u0402\u0202\u0002\u0ff0\u0fef\u0003\u0002\u0002\u0002\u0ff0\u0ff1\u0003\u0002\u0002\u0002\u0ff1\u0ff3\u0003\u0002\u0002\u0002\u0ff2\u0ff4\u0005\u0404\u0203\u0002\u0ff3\u0ff2\u0003\u0002\u0002\u0002\u0ff3\u0ff4\u0003\u0002\u0002\u0002\u0ff4\u0ff6\u0003\u0002\u0002\u0002\u0ff5\u0ff7\u0007\u00a6\u0002\u0002\u0ff6\u0ff5\u0003\u0002\u0002\u0002\u0ff6\u0ff7\u0003\u0002\u0002\u0002\u0ff7\u027b\u0003\u0002\u0002\u0002\u0ff8\u0ffa\u0007\u00fd\u0002\u0002\u0ff9\u0ffb\u0005\u0284\u0143\u0002\u0ffa\u0ff9\u0003\u0002\u0002\u0002\u0ffb\u0ffc\u0003\u0002\u0002\u0002\u0ffc\u0ffa\u0003\u0002\u0002\u0002\u0ffc\u0ffd\u0003\u0002\u0002\u0002\u0ffd\u027d\u0003\u0002\u0002\u0002\u0ffe\u1001\u0007\u00fd\u0002\u0002\u0fff\u1002\u0005\u0434\u021b\u0002\u1000\u1002\u0005\u0496\u024c\u0002\u1001\u0fff\u0003\u0002\u0002\u0002\u1001\u1000\u0003\u0002\u0002\u0002\u1002\u1004\u0003\u0002\u0002\u0002\u1003\u1005\u0005\u0282\u0142\u0002\u1004\u1003\u0003\u0002\u0002\u0002\u1004\u1005\u0003\u0002\u0002\u0002\u1005\u027f\u0003\u0002\u0002\u0002\u1006\u1009\u0007\u0033\u0002\u0002\u1007\u100a\u0005\u0434\u021b\u0002\u1008\u100a\u0005\u0496\u024c\u0002\u1009\u1007\u0003\u0002\u0002\u0002\u1009\u1008\u0003\u0002\u0002\u0002\u100a\u100c\u0003\u0002\u0002\u0002\u100b\u100d\u0005\u0282\u0142\u0002\u100c\u100b\u0003\u0002\u0002\u0002\u100c\u100d\u0003\u0002\u0002\u0002\u100d\u0281\u0003\u0002\u0002\u0002\u100e\u1010\u0007\u00e0\u0002\u0002\u100f\u1011\u0005\u0286\u0144\u0002\u1010\u100f\u0003\u0002\u0002\u0002\u1011\u1012\u0003\u0002\u0002\u0002\u1012\u1010\u0003\u0002\u0002\u0002\u1012\u1013\u0003\u0002\u0002\u0002\u1013\u0283\u0003\u0002\u0002\u0002\u1014\u1016\u0005\u0434\u021b\u0002\u1015\u1017\u0007\u019e\u0002\u0002\u1016\u1015\u0003\u0002\u0002\u0002\u1016\u1017\u0003\u0002\u0002\u0002\u1017\u0285\u0003\u0002\u0002\u0002\u1018\u101a\u0005\u0434\u021b\u0002\u1019\u101b\u0007\u019e\u0002\u0002\u101a\u1019\u0003\u0002\u0002\u0002\u101a\u101b\u0003\u0002\u0002\u0002\u101b\u0287\u0003\u0002\u0002\u0002\u101c\u101d\u0007\u0186\u0002\u0002\u101d\u101e\u0005\u0434\u021b\u0002\u101e\u0289\u0003\u0002\u0002\u0002\u101f\u1027\u0007\u009f\u0002\u0002\u1020\u1022\u0007\u00f8\u0002\u0002\u1021\u1023\u0007\u01dd\u0002\u0002\u1022\u1021\u0003\u0002\u0002\u0002\u1022\u1023\u0003\u0002\u0002\u0002\u1023\u1028\u0003\u0002\u0002\u0002\u1024\u1025\u0007\u00ea\u0002\u0002\u1025\u1028\u0007\u01dd\u0002\u0002\u1026\u1028\u0007\u0150\u0002\u0002\u1027\u1020\u0003\u0002\u0002\u0002\u1027\u1024\u0003\u0002\u0002\u0002\u1027\u1026\u0003\u0002\u0002\u0002\u1028\u1029\u0003\u0002\u0002\u0002\u1029\u102b\u0005\u0462\u0232\u0002\u102a\u102c\u0007\u0204\u0002\u0002\u102b\u102a\u0003\u0002\u0002\u0002\u102b\u102c\u0003\u0002\u0002\u0002\u102c\u102d\u0003\u0002\u0002\u0002\u102d\u1030\u0007\u0105\u0002\u0002\u102e\u1031\u0005\u0496\u024c\u0002\u102f\u1031\u0005\u0434\u021b\u0002\u1030\u102e\u0003\u0002\u0002\u0002\u1030\u102f\u0003\u0002\u0002\u0002\u1031\u028b\u0003\u0002\u0002\u0002\u1032\u1033\u0007\u00b8\u0002\u0002\u1033\u103a\u0005\u0496\u024c\u0002\u1034\u1036\u0007\u01fc\u0002\u0002\u1035\u1037\u0005\u0434\u021b\u0002\u1036\u1035\u0003\u0002\u0002\u0002\u1037\u1038\u0003\u0002\u0002\u0002\u1038\u1036\u0003\u0002\u0002\u0002\u1038\u1039\u0003\u0002\u0002\u0002\u1039\u103b\u0003\u0002\u0002\u0002\u103a\u1034\u0003\u0002\u0002\u0002\u103a\u103b\u0003\u0002\u0002\u0002\u103b\u028d\u0003\u0002\u0002\u0002\u103c\u103d\u0007\u00c3\u0002\u0002\u103d\u1041\u0005\u0290\u0149\u0002\u103e\u1040\u0005\u0292\u014a\u0002\u103f\u103e\u0003\u0002\u0002\u0002\u1040\u1043\u0003\u0002\u0002\u0002\u1041\u103f\u0003\u0002\u0002\u0002\u1041\u1042\u0003\u0002\u0002\u0002\u1042\u1045\u0003\u0002\u0002\u0002\u1043\u1041\u0003\u0002\u0002\u0002\u1044\u1046\u0005\u0294\u014b\u0002\u1045\u1044\u0003\u0002\u0002\u0002\u1046\u1047\u0003\u0002\u0002\u0002\u1047\u1045\u0003\u0002\u0002\u0002\u1047\u1048\u0003\u0002\u0002\u0002\u1048\u104a\u0003\u0002\u0002\u0002\u1049\u104b\u0005\u029e\u0150\u0002\u104a\u1049\u0003\u0002\u0002\u0002\u104a\u104b\u0003\u0002\u0002\u0002\u104b\u104d\u0003\u0002\u0002\u0002\u104c\u104e\u0007\u00a7\u0002\u0002\u104d\u104c\u0003\u0002\u0002\u0002\u104d\u104e\u0003\u0002\u0002\u0002\u104e\u028f\u0003\u0002\u0002\u0002\u104f\u1054\u0005\u0434\u021b\u0002\u1050\u1054\u0005\u0496\u024c\u0002\u1051\u1054\u0005\u040a\u0206\u0002\u1052\u1054\u0005\u0418\u020d\u0002\u1053\u104f\u0003\u0002\u0002\u0002\u1053\u1050\u0003\u0002\u0002\u0002\u1053\u1051\u0003\u0002\u0002\u0002\u1053\u1052\u0003\u0002\u0002\u0002\u1054\u0291\u0003\u0002\u0002\u0002\u1055\u1056\u0007\u0012\u0002\u0002\u1056\u1057\u0005\u0290\u0149\u0002\u1057\u0293\u0003\u0002\u0002\u0002\u1058\u105a\u0005\u0296\u014c\u0002\u1059\u1058\u0003\u0002\u0002\u0002\u105a\u105b\u0003\u0002\u0002\u0002\u105b\u1059\u0003\u0002\u0002\u0002\u105b\u105c\u0003\u0002\u0002\u0002\u105c\u1060\u0003\u0002\u0002\u0002\u105d\u105f\u0005\u021a\u010e\u0002\u105e\u105d\u0003\u0002\u0002\u0002\u105f\u1062\u0003\u0002\u0002\u0002\u1060\u105e\u0003\u0002\u0002\u0002\u1060\u1061\u0003\u0002\u0002\u0002\u1061\u0295\u0003\u0002\u0002\u0002\u1062\u1060\u0003\u0002\u0002\u0002\u1063\u1064\u0007\u0202\u0002\u0002\u1064\u1068\u0005\u0298\u014d\u0002\u1065\u1067\u0005\u029c\u014f\u0002\u1066\u1065\u0003\u0002\u0002\u0002\u1067\u106a\u0003\u0002\u0002\u0002\u1068\u1066\u0003\u0002\u0002\u0002\u1068\u1069\u0003\u0002\u0002\u0002\u1069\u0297\u0003\u0002\u0002\u0002\u106a\u1068\u0003\u0002\u0002\u0002\u106b\u1076\u0007\u0016\u0002\u0002\u106c\u106e\u0007\u013a\u0002\u0002\u106d\u106c\u0003\u0002\u0002\u0002\u106d\u106e\u0003\u0002\u0002\u0002\u106e\u106f\u0003\u0002\u0002\u0002\u106f\u1071\u0005\u02a0\u0151\u0002\u1070\u1072\u0005\u029a\u014e\u0002\u1071\u1070\u0003\u0002\u0002\u0002\u1071\u1072\u0003\u0002\u0002\u0002\u1072\u1076\u0003\u0002\u0002\u0002\u1073\u1076\u0005\u0418\u020d\u0002\u1074\u1076\u0005\u0498\u024d\u0002\u1075\u106b\u0003\u0002\u0002\u0002\u1075\u106d\u0003\u0002\u0002\u0002\u1075\u1073\u0003\u0002\u0002\u0002\u1075\u1074\u0003\u0002\u0002\u0002\u1076\u0299\u0003\u0002\u0002\u0002\u1077\u1078\u0009\u0006\u0002\u0002\u1078\u1079\u0005\u02a0\u0151\u0002\u1079\u029b\u0003\u0002\u0002\u0002\u107a\u107b\u0007\u0012\u0002\u0002\u107b\u107c\u0005\u0298\u014d\u0002\u107c\u029d\u0003\u0002\u0002\u0002\u107d\u107e\u0007\u0202\u0002\u0002\u107e\u1082\u0007\u014f\u0002\u0002\u107f\u1081\u0005\u021a\u010e\u0002\u1080\u107f\u0003\u0002\u0002\u0002\u1081\u1084\u0003\u0002\u0002\u0002\u1082\u1080\u0003\u0002\u0002\u0002\u1082\u1083\u0003\u0002\u0002\u0002\u1083\u029f\u0003\u0002\u0002\u0002\u1084\u1082\u0003\u0002\u0002\u0002\u1085\u1089\u0005\u0434\u021b\u0002\u1086\u1089\u0005\u0496\u024c\u0002\u1087\u1089\u0005\u040a\u0206\u0002\u1088\u1085\u0003\u0002\u0002\u0002\u1088\u1086\u0003\u0002\u0002\u0002\u1088\u1087\u0003\u0002\u0002\u0002\u1089\u02a1\u0003\u0002\u0002\u0002\u108a\u108c\u0007\u0231\u0002\u0002\u108b\u108a\u0003\u0002\u0002\u0002\u108c\u108d\u0003\u0002\u0002\u0002\u108d\u108b\u0003\u0002\u0002\u0002\u108d\u108e\u0003\u0002\u0002\u0002\u108e\u02a3\u0003\u0002\u0002\u0002\u108f\u1091\u0007\u0233\u0002\u0002\u1090\u108f\u0003\u0002\u0002\u0002\u1091\u1092\u0003\u0002\u0002\u0002\u1092\u1090\u0003\u0002\u0002\u0002\u1092\u1093\u0003\u0002\u0002\u0002\u1093\u02a5\u0003\u0002\u0002\u0002\u1094\u1096\u0007\u0232\u0002\u0002\u1095\u1094\u0003\u0002\u0002\u0002\u1096\u1097\u0003\u0002\u0002\u0002\u1097\u1095\u0003\u0002\u0002\u0002\u1097\u1098\u0003\u0002\u0002\u0002\u1098\u02a7\u0003\u0002\u0002\u0002\u1099\u109b\u0007\u00c8\u0002\u0002\u109a\u109c\u0007\u0131\u0002\u0002\u109b\u109a\u0003\u0002\u0002\u0002\u109b\u109c\u0003\u0002\u0002\u0002\u109c\u109e\u0003\u0002\u0002\u0002\u109d\u109f\u0007\u003e\u0002\u0002\u109e\u109d\u0003\u0002\u0002\u0002\u109e\u109f\u0003\u0002\u0002\u0002\u109f\u10a1\u0003\u0002\u0002\u0002\u10a0\u10a2\u0005\u02aa\u0156\u0002\u10a1\u10a0\u0003\u0002\u0002\u0002\u10a2\u10a3\u0003\u0002\u0002\u0002\u10a3\u10a1\u0003\u0002\u0002\u0002\u10a3\u10a4\u0003\u0002\u0002\u0002\u10a4\u02a9\u0003\u0002\u0002\u0002\u10a5\u10a8\u0005\u0434\u021b\u0002\u10a6\u10a8\u0005\u0496\u024c\u0002\u10a7\u10a5\u0003\u0002\u0002\u0002\u10a7\u10a6\u0003\u0002\u0002\u0002\u10a8\u02ab\u0003\u0002\u0002\u0002\u10a9\u10ab\u0007\u00c9\u0002\u0002\u10aa\u10ac\u0007\u016b\u0002\u0002\u10ab\u10aa\u0003\u0002\u0002\u0002\u10ab\u10ac\u0003\u0002\u0002\u0002\u10ac\u02ad\u0003\u0002\u0002\u0002\u10ad\u10ae\u0007\u00de\u0002\u0002\u10ae\u10af\u0005\u0486\u0244\u0002\u10af\u02af\u0003\u0002\u0002\u0002\u10b0\u10b1\u0007\u00df\u0002\u0002\u10b1\u02b1\u0003\u0002\u0002\u0002\u10b2\u10b4\u0007\u00e2\u0002\u0002\u10b3\u10b5\u0007\u01eb\u0002\u0002\u10b4\u10b3\u0003\u0002\u0002\u0002\u10b4\u10b5\u0003\u0002\u0002\u0002\u10b5\u10b8\u0003\u0002\u0002\u0002\u10b6\u10b9\u0005\u02b4\u015b\u0002\u10b7\u10b9\u0005\u02b6\u015c\u0002\u10b8\u10b6\u0003\u0002\u0002\u0002\u10b8\u10b7\u0003\u0002\u0002\u0002\u10b9\u02b3\u0003\u0002\u0002\u0002\u10ba\u10bb\u0005\u0480\u0241\u0002\u10bb\u02b5\u0003\u0002\u0002\u0002\u10bc\u10ca\u0007\u012d\u0002\u0002\u10bd\u10bf\u0005\u0480\u0241\u0002\u10be\u10bd\u0003\u0002\u0002\u0002\u10bf\u10c0\u0003\u0002\u0002\u0002\u10c0\u10be\u0003\u0002\u0002\u0002\u10c0\u10c1\u0003\u0002\u0002\u0002\u10c1\u10c7\u0003\u0002\u0002\u0002\u10c2\u10c4\u0007\u0088\u0002\u0002\u10c3\u10c5\u0007\u0148\u0002\u0002\u10c4\u10c3\u0003\u0002\u0002\u0002\u10c4\u10c5\u0003\u0002\u0002\u0002\u10c5\u10c6\u0003\u0002\u0002\u0002\u10c6\u10c8\u0005\u0434\u021b\u0002\u10c7\u10c2\u0003\u0002\u0002\u0002\u10c7\u10c8\u0003\u0002\u0002\u0002\u10c8\u10ca\u0003\u0002\u0002\u0002\u10c9\u10bc\u0003\u0002\u0002\u0002\u10c9\u10be\u0003\u0002\u0002\u0002\u10ca\u02b7\u0003\u0002\u0002\u0002\u10cb\u10cc\u0007\u00ee\u0002\u0002\u10cc\u10cd\u0005\u0418\u020d\u0002\u10cd\u10cf\u0005\u02ba\u015e\u0002\u10ce\u10d0\u0005\u02bc\u015f\u0002\u10cf\u10ce\u0003\u0002\u0002\u0002\u10cf\u10d0\u0003\u0002\u0002\u0002\u10d0\u10d2\u0003\u0002\u0002\u0002\u10d1\u10d3\u0007\u00a8\u0002\u0002\u10d2\u10d1\u0003\u0002\u0002\u0002\u10d2\u10d3\u0003\u0002\u0002\u0002\u10d3\u02b9\u0003\u0002\u0002\u0002\u10d4\u10d6\u0007\u01e2\u0002\u0002\u10d5\u10d4\u0003\u0002\u0002\u0002\u10d5\u10d6\u0003\u0002\u0002\u0002\u10d6\u10df\u0003\u0002\u0002\u0002\u10d7\u10d8\u0007\u0137\u0002\u0002\u10d8\u10e0\u0007\u01ac\u0002\u0002\u10d9\u10db\u0005\u021a\u010e\u0002\u10da\u10d9\u0003\u0002\u0002\u0002\u10db\u10de\u0003\u0002\u0002\u0002\u10dc\u10da\u0003\u0002\u0002\u0002\u10dc\u10dd\u0003\u0002\u0002\u0002\u10dd\u10e0\u0003\u0002\u0002\u0002\u10de\u10dc\u0003\u0002\u0002\u0002\u10df\u10d7\u0003\u0002\u0002\u0002\u10df\u10dc\u0003\u0002\u0002\u0002\u10e0\u02bb\u0003\u0002\u0002\u0002\u10e1\u10ea\u0007\u009c\u0002\u0002\u10e2\u10e3\u0007\u0137\u0002\u0002\u10e3\u10eb\u0007\u01ac\u0002\u0002\u10e4\u10e6\u0005\u021a\u010e\u0002\u10e5\u10e4\u0003\u0002\u0002\u0002\u10e6\u10e9\u0003\u0002\u0002\u0002\u10e7\u10e5\u0003\u0002\u0002\u0002\u10e7\u10e8\u0003\u0002\u0002\u0002\u10e8\u10eb\u0003\u0002\u0002\u0002\u10e9\u10e7\u0003\u0002\u0002\u0002\u10ea\u10e2\u0003\u0002\u0002\u0002\u10ea\u10e7\u0003\u0002\u0002\u0002\u10eb\u02bd\u0003\u0002\u0002\u0002\u10ec\u10ee\u0007\u00f6\u0002\u0002\u10ed\u10ef\u0005\u0434\u021b\u0002\u10ee\u10ed\u0003\u0002\u0002\u0002\u10ef\u10f0\u0003\u0002\u0002\u0002\u10f0\u10ee\u0003\u0002\u0002\u0002\u10f0\u10f1\u0003\u0002\u0002\u0002\u10f1\u10f3\u0003\u0002\u0002\u0002\u10f2\u10f4\u0005\u02c0\u0161\u0002\u10f3\u10f2\u0003\u0002\u0002\u0002\u10f3\u10f4\u0003\u0002\u0002\u0002\u10f4\u02bf\u0003\u0002\u0002\u0002\u10f5\u10f7\u0007\u018c\u0002\u0002\u10f6\u10f8\u0005\u02c2\u0162\u0002\u10f7\u10f6\u0003\u0002\u0002\u0002\u10f8\u10f9\u0003\u0002\u0002\u0002\u10f9\u10f7\u0003\u0002\u0002\u0002\u10f9\u10fa\u0003\u0002\u0002\u0002\u10fa\u02c1\u0003\u0002\u0002\u0002\u10fb\u10fd\u0009\u0037\u0002\u0002\u10fc\u10fe\u0007\u006f\u0002\u0002\u10fd\u10fc\u0003\u0002\u0002\u0002\u10fd\u10fe\u0003\u0002\u0002\u0002\u10fe\u10ff\u0003\u0002\u0002\u0002\u10ff\u1102\u0007\u0033\u0002\u0002\u1100\u1103\u0005\u0434\u021b\u0002\u1101\u1103\u0005\u0496\u024c\u0002\u1102\u1100\u0003\u0002\u0002\u0002\u1102\u1101\u0003\u0002\u0002\u0002\u1103\u02c3\u0003\u0002\u0002\u0002\u1104\u1106\u0007\u00f7\u0002\u0002\u1105\u1107\u0005\u0486\u0244\u0002\u1106\u1105\u0003\u0002\u0002\u0002\u1107\u1108\u0003\u0002\u0002\u0002\u1108\u1106\u0003\u0002\u0002\u0002\u1108\u1109\u0003\u0002\u0002\u0002\u1109\u02c5\u0003\u0002\u0002\u0002\u110a\u110b\u0007\u00fa\u0002\u0002\u110b\u1110\u0005\u0434\u021b\u0002\u110c\u1111\u0005\u02c8\u0165\u0002\u110d\u1111\u0005\u02ca\u0166\u0002\u110e\u1111\u0005\u02cc\u0167\u0002\u110f\u1111\u0005\u02ce\u0168\u0002\u1110\u110c\u0003\u0002\u0002\u0002\u1110\u110d\u0003\u0002\u0002\u0002\u1110\u110e\u0003\u0002\u0002\u0002\u1110\u110f\u0003\u0002\u0002\u0002\u1111\u02c7\u0003\u0002\u0002\u0002\u1112\u1114\u0007\u01da\u0002\u0002\u1113\u1115\u0005\u02d0\u0169\u0002\u1114\u1113\u0003\u0002\u0002\u0002\u1115\u1116\u0003\u0002\u0002\u0002\u1116\u1114\u0003\u0002\u0002\u0002\u1116\u1117\u0003\u0002\u0002\u0002\u1117\u02c9\u0003\u0002\u0002\u0002\u1118\u111b\u0007\u018c\u0002\u0002\u1119\u111c\u0005\u02d4\u016b\u0002\u111a\u111c\u0005\u02d8\u016d\u0002\u111b\u1119\u0003\u0002\u0002\u0002\u111b\u111a\u0003\u0002\u0002\u0002\u111c\u111d\u0003\u0002\u0002\u0002\u111d\u111b\u0003\u0002\u0002\u0002\u111d\u111e\u0003\u0002\u0002\u0002\u111e\u02cb\u0003\u0002\u0002\u0002\u111f\u1121\u0007\u01da\u0002\u0002\u1120\u1122\u0005\u02d0\u0169\u0002\u1121\u1120\u0003\u0002\u0002\u0002\u1122\u1123\u0003\u0002\u0002\u0002\u1123\u1121\u0003\u0002\u0002\u0002\u1123\u1124\u0003\u0002\u0002\u0002\u1124\u1126\u0003\u0002\u0002\u0002\u1125\u1127\u0005\u02ca\u0166\u0002\u1126\u1125\u0003\u0002\u0002\u0002\u1127\u1128\u0003\u0002\u0002\u0002\u1128\u1126\u0003\u0002\u0002\u0002\u1128\u1129\u0003\u0002\u0002\u0002\u1129\u02cd\u0003\u0002\u0002\u0002\u112a\u112d\u0007\u0067\u0002\u0002\u112b\u112e\u0005\u0434\u021b\u0002\u112c\u112e\u0005\u0496\u024c\u0002\u112d\u112b\u0003\u0002\u0002\u0002\u112d\u112c\u0003\u0002\u0002\u0002\u112e\u112f\u0003\u0002\u0002\u0002\u112f\u1133\u0005\u02e0\u0171\u0002\u1130\u1132\u0005\u02e2\u0172\u0002\u1131\u1130\u0003\u0002\u0002\u0002\u1132\u1135\u0003\u0002\u0002\u0002\u1133\u1131\u0003\u0002\u0002\u0002\u1133\u1134\u0003\u0002\u0002\u0002\u1134\u02cf\u0003\u0002\u0002\u0002\u1135\u1133\u0003\u0002\u0002\u0002\u1136\u1137\u0005\u0434\u021b\u0002\u1137\u113a\u0007\u00d6\u0002\u0002\u1138\u113b\u0005\u02d2\u016a\u0002\u1139\u113b\u0005\u02d6\u016c\u0002\u113a\u1138\u0003\u0002\u0002\u0002\u113a\u1139\u0003\u0002\u0002\u0002\u113b\u113c\u0003\u0002\u0002\u0002\u113c\u113a\u0003\u0002\u0002\u0002\u113c\u113d\u0003\u0002\u0002\u0002\u113d\u02d1\u0003\u0002\u0002\u0002\u113e\u1142\u0007\u0041\u0002\u0002\u113f\u1141\u0005\u02e2\u0172\u0002\u1140\u113f\u0003\u0002\u0002\u0002\u1141\u1144\u0003\u0002\u0002\u0002\u1142\u1140\u0003\u0002\u0002\u0002\u1142\u1143\u0003\u0002\u0002\u0002\u1143\u02d3\u0003\u0002\u0002\u0002\u1144\u1142\u0003\u0002\u0002\u0002\u1145\u1146\u0007\u0041\u0002\u0002\u1146\u114a\u0005\u02de\u0170\u0002\u1147\u1149\u0005\u02e2\u0172\u0002\u1148\u1147\u0003\u0002\u0002\u0002\u1149\u114c\u0003\u0002\u0002\u0002\u114a\u1148\u0003\u0002\u0002\u0002\u114a\u114b\u0003\u0002\u0002\u0002\u114b\u02d5\u0003\u0002\u0002\u0002\u114c\u114a\u0003\u0002\u0002\u0002\u114d\u114f\u0009\u0038\u0002\u0002\u114e\u1150\u0005\u02da\u016e\u0002\u114f\u114e\u0003\u0002\u0002\u0002\u1150\u1151\u0003\u0002\u0002\u0002\u1151\u114f\u0003\u0002\u0002\u0002\u1151\u1152\u0003\u0002\u0002\u0002\u1152\u02d7\u0003\u0002\u0002\u0002\u1153\u1155\u0009\u0039\u0002\u0002\u1154\u1156\u0005\u02dc\u016f\u0002\u1155\u1154\u0003\u0002\u0002\u0002\u1156\u1157\u0003\u0002\u0002\u0002\u1157\u1155\u0003\u0002\u0002\u0002\u1157\u1158\u0003\u0002\u0002\u0002\u1158\u02d9\u0003\u0002\u0002\u0002\u1159\u115c\u0005\u0434\u021b\u0002\u115a\u115c\u0005\u0496\u024c\u0002\u115b\u1159\u0003\u0002\u0002\u0002\u115b\u115a\u0003\u0002\u0002\u0002\u115c\u1160\u0003\u0002\u0002\u0002\u115d\u115f\u0005\u02e2\u0172\u0002\u115e\u115d\u0003\u0002\u0002\u0002\u115f\u1162\u0003\u0002\u0002\u0002\u1160\u115e\u0003\u0002\u0002\u0002\u1160\u1161\u0003\u0002\u0002\u0002\u1161\u02db\u0003\u0002\u0002\u0002\u1162\u1160\u0003\u0002\u0002\u0002\u1163\u1166\u0005\u0434\u021b\u0002\u1164\u1166\u0005\u0496\u024c\u0002\u1165\u1163\u0003\u0002\u0002\u0002\u1165\u1164\u0003\u0002\u0002\u0002\u1166\u1167\u0003\u0002\u0002\u0002\u1167\u116b\u0005\u02de\u0170\u0002\u1168\u116a\u0005\u02e2\u0172\u0002\u1169\u1168\u0003\u0002\u0002\u0002\u116a\u116d\u0003\u0002\u0002\u0002\u116b\u1169\u0003\u0002\u0002\u0002\u116b\u116c\u0003\u0002\u0002\u0002\u116c\u02dd\u0003\u0002\u0002\u0002\u116d\u116b\u0003\u0002\u0002\u0002\u116e\u1171\u0007\u0033\u0002\u0002\u116f\u1172\u0005\u0434\u021b\u0002\u1170\u1172\u0005\u0496\u024c\u0002\u1171\u116f\u0003\u0002\u0002\u0002\u1171\u1170\u0003\u0002\u0002\u0002\u1172\u02df\u0003\u0002\u0002\u0002\u1173\u1176\u0007\u01eb\u0002\u0002\u1174\u1177\u0005\u0434\u021b\u0002\u1175\u1177\u0005\u0496\u024c\u0002\u1176\u1174\u0003\u0002\u0002\u0002\u1176\u1175\u0003\u0002\u0002\u0002\u1177\u02e1\u0003\u0002\u0002\u0002\u1178\u117a\u0009\u003a\u0002\u0002\u1179\u117b\u0007\u00f5\u0002\u0002\u117a\u1179\u0003\u0002\u0002\u0002\u117a\u117b\u0003\u0002\u0002\u0002\u117b\u117e\u0003\u0002\u0002\u0002\u117c\u117f\u0005\u0434\u021b\u0002\u117d\u117f\u0005\u0496\u024c\u0002\u117e";
        private const val serializedATNSegment2 : String =
        	"\u117c\u0003\u0002\u0002\u0002\u117e\u117d\u0003\u0002\u0002\u0002\u117f\u02e3\u0003\u0002\u0002\u0002\u1180\u1181\u0007\u0128\u0002\u0002\u1181\u1183\u0005\u0470\u0239\u0002\u1182\u1184\u0005\u02e6\u0174\u0002\u1183\u1182\u0003\u0002\u0002\u0002\u1184\u1185\u0003\u0002\u0002\u0002\u1185\u1183\u0003\u0002\u0002\u0002\u1185\u1186\u0003\u0002\u0002\u0002\u1186\u1188\u0003\u0002\u0002\u0002\u1187\u1189\u0005\u02e8\u0175\u0002\u1188\u1187\u0003\u0002\u0002\u0002\u1188\u1189\u0003\u0002\u0002\u0002\u1189\u118d\u0003\u0002\u0002\u0002\u118a\u118c\u0005\u02ee\u0178\u0002\u118b\u118a\u0003\u0002\u0002\u0002\u118c\u118f\u0003\u0002\u0002\u0002\u118d\u118b\u0003\u0002\u0002\u0002\u118d\u118e\u0003\u0002\u0002\u0002\u118e\u1191\u0003\u0002\u0002\u0002\u118f\u118d\u0003\u0002\u0002\u0002\u1190\u1192\u0005\u02f0\u0179\u0002\u1191\u1190\u0003\u0002\u0002\u0002\u1191\u1192\u0003\u0002\u0002\u0002\u1192\u1196\u0003\u0002\u0002\u0002\u1193\u1195\u0005\u02f4\u017b\u0002\u1194\u1193\u0003\u0002\u0002\u0002\u1195\u1198\u0003\u0002\u0002\u0002\u1196\u1194\u0003\u0002\u0002\u0002\u1196\u1197\u0003\u0002\u0002\u0002\u1197\u02e5\u0003\u0002\u0002\u0002\u1198\u1196\u0003\u0002\u0002\u0002\u1199\u119b\u0007\u0148\u0002\u0002\u119a\u1199\u0003\u0002\u0002\u0002\u119a\u119b\u0003\u0002\u0002\u0002\u119b\u119c\u0003\u0002\u0002\u0002\u119c\u119e\u0009\u002b\u0002\u0002\u119d\u119f\u0007\u0105\u0002\u0002\u119e\u119d\u0003\u0002\u0002\u0002\u119e\u119f\u0003\u0002\u0002\u0002\u119f\u11a1\u0003\u0002\u0002\u0002\u11a0\u11a2\u0005\u0444\u0223\u0002\u11a1\u11a0\u0003\u0002\u0002\u0002\u11a2\u11a3\u0003\u0002\u0002\u0002\u11a3\u11a1\u0003\u0002\u0002\u0002\u11a3\u11a4\u0003\u0002\u0002\u0002\u11a4\u02e7\u0003\u0002\u0002\u0002\u11a5\u11a7\u0007\u004a\u0002\u0002\u11a6\u11a5\u0003\u0002\u0002\u0002\u11a6\u11a7\u0003\u0002\u0002\u0002\u11a7\u11a8\u0003\u0002\u0002\u0002\u11a8\u11aa\u0007\u01ae\u0002\u0002\u11a9\u11ab\u0007\u0100\u0002\u0002\u11aa\u11a9\u0003\u0002\u0002\u0002\u11aa\u11ab\u0003\u0002\u0002\u0002\u11ab\u11ad\u0003\u0002\u0002\u0002\u11ac\u11ae\u0005\u045c\u022f\u0002\u11ad\u11ac\u0003\u0002\u0002\u0002\u11ae\u11af\u0003\u0002\u0002\u0002\u11af\u11ad\u0003\u0002\u0002\u0002\u11af\u11b0\u0003\u0002\u0002\u0002\u11b0\u11b2\u0003\u0002\u0002\u0002\u11b1\u11b3\u0005\u02ea\u0176\u0002\u11b2\u11b1\u0003\u0002\u0002\u0002\u11b2\u11b3\u0003\u0002\u0002\u0002\u11b3\u11b5\u0003\u0002\u0002\u0002\u11b4\u11b6\u0005\u02ec\u0177\u0002\u11b5\u11b4\u0003\u0002\u0002\u0002\u11b5\u11b6\u0003\u0002\u0002\u0002\u11b6\u02e9\u0003\u0002\u0002\u0002\u11b7\u11b9\u0007\u00d6\u0002\u0002\u11b8\u11b7\u0003\u0002\u0002\u0002\u11b8\u11b9\u0003\u0002\u0002\u0002\u11b9\u11ba\u0003\u0002\u0002\u0002\u11ba\u11bb\u0007\u0010\u0002\u0002\u11bb\u11bc\u0007\u0100\u0002\u0002\u11bc\u11bd\u0005\u045c\u022f\u0002\u11bd\u02eb\u0003\u0002\u0002\u0002\u11be\u11c0\u0007\u00d6\u0002\u0002\u11bf\u11be\u0003\u0002\u0002\u0002\u11bf\u11c0\u0003\u0002\u0002\u0002\u11c0\u11c1\u0003\u0002\u0002\u0002\u11c1\u11c3\u0007\u0132\u0002\u0002\u11c2\u11c4\u0007\u0100\u0002\u0002\u11c3\u11c2\u0003\u0002\u0002\u0002\u11c3\u11c4\u0003\u0002\u0002\u0002\u11c4\u11c5\u0003\u0002\u0002\u0002\u11c5\u11c6\u0005\u045c\u022f\u0002\u11c6\u02ed\u0003\u0002\u0002\u0002\u11c7\u11c9\u0007\u01fc\u0002\u0002\u11c8\u11ca\u0005\u0470\u0239\u0002\u11c9\u11c8\u0003\u0002\u0002\u0002\u11ca\u11cb\u0003\u0002\u0002\u0002\u11cb\u11c9\u0003\u0002\u0002\u0002\u11cb\u11cc\u0003\u0002\u0002\u0002\u11cc\u02ef\u0003\u0002\u0002\u0002\u11cd\u11ce\u0007\u0150\u0002\u0002\u11ce\u11d0\u0007\u0166\u0002\u0002\u11cf\u11d1\u0007\u0100\u0002\u0002\u11d0\u11cf\u0003\u0002\u0002\u0002\u11d0\u11d1\u0003\u0002\u0002\u0002\u11d1\u11d2\u0003\u0002\u0002\u0002\u11d2\u11d4\u0005\u0480\u0241\u0002\u11d3\u11d5\u0005\u02f2\u017a\u0002\u11d4\u11d3\u0003\u0002\u0002\u0002\u11d4\u11d5\u0003\u0002\u0002\u0002\u11d5\u02f1\u0003\u0002\u0002\u0002\u11d6\u11d7\u0009\u0006\u0002\u0002\u11d7\u11d8\u0005\u0480\u0241\u0002\u11d8\u02f3\u0003\u0002\u0002\u0002\u11d9\u11db\u0007\u00e0\u0002\u0002\u11da\u11dc\u0005\u02f6\u017c\u0002\u11db\u11da\u0003\u0002\u0002\u0002\u11dc\u11dd\u0003\u0002\u0002\u0002\u11dd\u11db\u0003\u0002\u0002\u0002\u11dd\u11de\u0003\u0002\u0002\u0002\u11de\u02f5\u0003\u0002\u0002\u0002\u11df\u11e9\u0005\u0470\u0239\u0002\u11e0\u11ea\u0007\u0120\u0002\u0002\u11e1\u11ea\u0007\u01a1\u0002\u0002\u11e2\u11e3\u0007\u0138\u0002\u0002\u11e3\u11ea\u0007\u0199\u0002\u0002\u11e4\u11ea\u0007\u006c\u0002\u0002\u11e5\u11ea\u0007\u0185\u0002\u0002\u11e6\u11e7\u0007\u0204\u0002\u0002\u11e7\u11e8\u0007\u0189\u0002\u0002\u11e8\u11ea\u0007\u006c\u0002\u0002\u11e9\u11e0\u0003\u0002\u0002\u0002\u11e9\u11e1\u0003\u0002\u0002\u0002\u11e9\u11e2\u0003\u0002\u0002\u0002\u11e9\u11e4\u0003\u0002\u0002\u0002\u11e9\u11e5\u0003\u0002\u0002\u0002\u11e9\u11e6\u0003\u0002\u0002\u0002\u11e9\u11ea\u0003\u0002\u0002\u0002\u11ea\u02f7\u0003\u0002\u0002\u0002\u11eb\u11ed\u0007\u012e\u0002\u0002\u11ec\u11ee\u0007\u000b\u0002\u0002\u11ed\u11ec\u0003\u0002\u0002\u0002\u11ed\u11ee\u0003\u0002\u0002\u0002\u11ee\u11f1\u0003\u0002\u0002\u0002\u11ef\u11f2\u0005\u02fa\u017e\u0002\u11f0\u11f2\u0005\u02fe\u0180\u0002\u11f1\u11ef\u0003\u0002\u0002\u0002\u11f1\u11f0\u0003\u0002\u0002\u0002\u11f2\u02f9\u0003\u0002\u0002\u0002\u11f3\u11f4\u0005\u02fc\u017f\u0002\u11f4\u11f6\u0007\u01eb\u0002\u0002\u11f5\u11f7\u0005\u0434\u021b\u0002\u11f6\u11f5\u0003\u0002\u0002\u0002\u11f7\u11f8\u0003\u0002\u0002\u0002\u11f8\u11f6\u0003\u0002\u0002\u0002\u11f8\u11f9\u0003\u0002\u0002\u0002\u11f9\u02fb\u0003\u0002\u0002\u0002\u11fa\u11fd\u0005\u0434\u021b\u0002\u11fb\u11fd\u0005\u0496\u024c\u0002\u11fc\u11fa\u0003\u0002\u0002\u0002\u11fc\u11fb\u0003\u0002\u0002\u0002\u11fd\u02fd\u0003\u0002\u0002\u0002\u11fe\u11ff\u0009\u0034\u0002\u0002\u11ff\u1200\u0005\u0300\u0181\u0002\u1200\u1202\u0007\u01eb\u0002\u0002\u1201\u1203\u0005\u0434\u021b\u0002\u1202\u1201\u0003\u0002\u0002\u0002\u1203\u1204\u0003\u0002\u0002\u0002\u1204\u1202\u0003\u0002\u0002\u0002\u1204\u1205\u0003\u0002\u0002\u0002\u1205\u02ff\u0003\u0002\u0002\u0002\u1206\u1207\u0005\u0434\u021b\u0002\u1207\u0301\u0003\u0002\u0002\u0002\u1208\u120b\u0007\u0130\u0002\u0002\u1209\u120c\u0005\u0434\u021b\u0002\u120a\u120c\u0005\u0496\u024c\u0002\u120b\u1209\u0003\u0002\u0002\u0002\u120b\u120a\u0003\u0002\u0002\u0002\u120c\u120d\u0003\u0002\u0002\u0002\u120d\u1210\u0007\u0033\u0002\u0002\u120e\u1211\u0005\u0304\u0183\u0002\u120f\u1211\u0005\u0308\u0185\u0002\u1210\u120e\u0003\u0002\u0002\u0002\u1210\u120f\u0003\u0002\u0002\u0002\u1211\u1213\u0003\u0002\u0002\u0002\u1212\u1214\u0005\u0402\u0202\u0002\u1213\u1212\u0003\u0002\u0002\u0002\u1213\u1214\u0003\u0002\u0002\u0002\u1214\u1216\u0003\u0002\u0002\u0002\u1215\u1217\u0005\u0404\u0203\u0002\u1216\u1215\u0003\u0002\u0002\u0002\u1216\u1217\u0003\u0002\u0002\u0002\u1217\u1219\u0003\u0002\u0002\u0002\u1218\u121a\u0007\u00a9\u0002\u0002\u1219\u1218\u0003\u0002\u0002\u0002\u1219\u121a\u0003\u0002\u0002\u0002\u121a\u0303\u0003\u0002\u0002\u0002\u121b\u121d\u0005\u0306\u0184\u0002\u121c\u121b\u0003\u0002\u0002\u0002\u121d\u121e\u0003\u0002\u0002\u0002\u121e\u121c\u0003\u0002\u0002\u0002\u121e\u121f\u0003\u0002\u0002\u0002\u121f\u0305\u0003\u0002\u0002\u0002\u1220\u1222\u0005\u0434\u021b\u0002\u1221\u1223\u0007\u019e\u0002\u0002\u1222\u1221\u0003\u0002\u0002\u0002\u1222\u1223\u0003\u0002\u0002\u0002\u1223\u0307\u0003\u0002\u0002\u0002\u1224\u1225\u0005\u030a\u0186\u0002\u1225\u1227\u0007\u00e0\u0002\u0002\u1226\u1228\u0005\u030c\u0187\u0002\u1227\u1226\u0003\u0002\u0002\u0002\u1228\u1229\u0003\u0002\u0002\u0002\u1229\u1227\u0003\u0002\u0002\u0002\u1229\u122a\u0003\u0002\u0002\u0002\u122a\u0309\u0003\u0002\u0002\u0002\u122b\u122e\u0005\u0434\u021b\u0002\u122c\u122e\u0005\u0496\u024c\u0002\u122d\u122b\u0003\u0002\u0002\u0002\u122d\u122c\u0003\u0002\u0002\u0002\u122e\u030b\u0003\u0002\u0002\u0002\u122f\u1231\u0005\u0434\u021b\u0002\u1230\u1232\u0007\u019e\u0002\u0002\u1231\u1230\u0003\u0002\u0002\u0002\u1231\u1232\u0003\u0002\u0002\u0002\u1232\u030d\u0003\u0002\u0002\u0002\u1233\u1238\u0007\u0149\u0002\u0002\u1234\u1239\u0005\u0310\u0189\u0002\u1235\u1239\u0005\u0314\u018b\u0002\u1236\u1239\u0005\u0318\u018d\u0002\u1237\u1239\u0005\u031a\u018e\u0002\u1238\u1234\u0003\u0002\u0002\u0002\u1238\u1235\u0003\u0002\u0002\u0002\u1238\u1236\u0003\u0002\u0002\u0002\u1238\u1237\u0003\u0002\u0002\u0002\u1239\u123a\u0003\u0002\u0002\u0002\u123a\u1238\u0003\u0002\u0002\u0002\u123a\u123b\u0003\u0002\u0002\u0002\u123b\u030f\u0003\u0002\u0002\u0002\u123c\u123e\u0007\u00f8\u0002\u0002\u123d\u123f\u0005\u0312\u018a\u0002\u123e\u123d\u0003\u0002\u0002\u0002\u123f\u1240\u0003\u0002\u0002\u0002\u1240\u123e\u0003\u0002\u0002\u0002\u1240\u1241\u0003\u0002\u0002\u0002\u1241\u0311\u0003\u0002\u0002\u0002\u1242\u1249\u0005\u0470\u0239\u0002\u1243\u124a\u0007\u0198\u0002\u0002\u1244\u1246\u0007\u0204\u0002\u0002\u1245\u1244\u0003\u0002\u0002\u0002\u1245\u1246\u0003\u0002\u0002\u0002\u1246\u1247\u0003\u0002\u0002\u0002\u1247\u1248\u0007\u0138\u0002\u0002\u1248\u124a\u0007\u0199\u0002\u0002\u1249\u1243\u0003\u0002\u0002\u0002\u1249\u1245\u0003\u0002\u0002\u0002\u1249\u124a\u0003\u0002\u0002\u0002\u124a\u0313\u0003\u0002\u0002\u0002\u124b\u124d\u0007\u0150\u0002\u0002\u124c\u124e\u0005\u0316\u018c\u0002\u124d\u124c\u0003\u0002\u0002\u0002\u124e\u124f\u0003\u0002\u0002\u0002\u124f\u124d\u0003\u0002\u0002\u0002\u124f\u1250\u0003\u0002\u0002\u0002\u1250\u0315\u0003\u0002\u0002\u0002\u1251\u1257\u0005\u0470\u0239\u0002\u1252\u1254\u0007\u0204\u0002\u0002\u1253\u1252\u0003\u0002\u0002\u0002\u1253\u1254\u0003\u0002\u0002\u0002\u1254\u1255\u0003\u0002\u0002\u0002\u1255\u1256\u0007\u0138\u0002\u0002\u1256\u1258\u0007\u0199\u0002\u0002\u1257\u1253\u0003\u0002\u0002\u0002\u1257\u1258\u0003\u0002\u0002\u0002\u1258\u0317\u0003\u0002\u0002\u0002\u1259\u125b\u0007\u00ea\u0002\u0002\u125a\u125c\u0005\u0470\u0239\u0002\u125b\u125a\u0003\u0002\u0002\u0002\u125c\u125d\u0003\u0002\u0002\u0002\u125d\u125b\u0003\u0002\u0002\u0002\u125d\u125e\u0003\u0002\u0002\u0002\u125e\u0319\u0003\u0002\u0002\u0002\u125f\u1261\u0007\u00cb\u0002\u0002\u1260\u1262\u0005\u0470\u0239\u0002\u1261\u1260\u0003\u0002\u0002\u0002\u1262\u1263\u0003\u0002\u0002\u0002\u1263\u1261\u0003\u0002\u0002\u0002\u1263\u1264\u0003\u0002\u0002\u0002\u1264\u031b\u0003\u0002\u0002\u0002\u1265\u1268\u0007\u0159\u0002\u0002\u1266\u1269\u0005\u031e\u0190\u0002\u1267\u1269\u0005\u0320\u0191\u0002\u1268\u1266\u0003\u0002\u0002\u0002\u1268\u1267\u0003\u0002\u0002\u0002\u1269\u031d\u0003\u0002\u0002\u0002\u126a\u126c\u0005\u0322\u0192\u0002\u126b\u126a\u0003\u0002\u0002\u0002\u126b\u126c\u0003\u0002\u0002\u0002\u126c\u1270\u0003\u0002\u0002\u0002\u126d\u126f\u0005\u021a\u010e\u0002\u126e\u126d\u0003\u0002\u0002\u0002\u126f\u1272\u0003\u0002\u0002\u0002\u1270\u126e\u0003\u0002\u0002\u0002\u1270\u1271\u0003\u0002\u0002\u0002\u1271\u1273\u0003\u0002\u0002\u0002\u1272\u1270\u0003\u0002\u0002\u0002\u1273\u1274\u0007\u00ab\u0002\u0002\u1274\u031f\u0003\u0002\u0002\u0002\u1275\u1278\u0005\u0480\u0241\u0002\u1276\u1277\u0009\u0006\u0002\u0002\u1277\u1279\u0005\u0480\u0241\u0002\u1278\u1276\u0003\u0002\u0002\u0002\u1278\u1279\u0003\u0002\u0002\u0002\u1279\u127b\u0003\u0002\u0002\u0002\u127a\u127c\u0005\u0322\u0192\u0002\u127b\u127a\u0003\u0002\u0002\u0002\u127b\u127c\u0003\u0002\u0002\u0002\u127c\u0321\u0003\u0002\u0002\u0002\u127d\u1281\u0005\u0324\u0193\u0002\u127e\u1281\u0005\u0326\u0194\u0002\u127f\u1281\u0005\u0328\u0195\u0002\u1280\u127d\u0003\u0002\u0002\u0002\u1280\u127e\u0003\u0002\u0002\u0002\u1280\u127f\u0003\u0002\u0002\u0002\u1281\u0323\u0003\u0002\u0002\u0002\u1282\u1285\u0005\u0434\u021b\u0002\u1283\u1285\u0005\u049c\u024f\u0002\u1284\u1282\u0003\u0002\u0002\u0002\u1284\u1283\u0003\u0002\u0002\u0002\u1285\u1286\u0003\u0002\u0002\u0002\u1286\u1287\u0007\u01e9\u0002\u0002\u1287\u0325\u0003\u0002\u0002\u0002\u1288\u128a\u0005\u0334\u019b\u0002\u1289\u1288\u0003\u0002\u0002\u0002\u1289\u128a\u0003\u0002\u0002\u0002\u128a\u128b\u0003\u0002\u0002\u0002\u128b\u128c\u0007\u01f7\u0002\u0002\u128c\u128d\u0005\u0418\u020d\u0002\u128d\u0327\u0003\u0002\u0002\u0002\u128e\u128f\u0005\u0334\u019b\u0002\u128f\u1290\u0005\u032a\u0196\u0002\u1290\u1296\u0003\u0002\u0002\u0002\u1291\u1293\u0005\u032a\u0196\u0002\u1292\u1294\u0005\u0334\u019b\u0002\u1293\u1292\u0003\u0002\u0002\u0002\u1293\u1294\u0003\u0002\u0002\u0002\u1294\u1296\u0003\u0002\u0002\u0002\u1295\u128e\u0003\u0002\u0002\u0002\u1295\u1291\u0003\u0002\u0002\u0002\u1296\u0329\u0003\u0002\u0002\u0002\u1297\u1298\u0007\u01ff\u0002\u0002\u1298\u129c\u0005\u032c\u0197\u0002\u1299\u129b\u0005\u032e\u0198\u0002\u129a\u1299\u0003\u0002\u0002\u0002\u129b\u129e\u0003\u0002\u0002\u0002\u129c\u129a\u0003\u0002\u0002\u0002\u129c\u129d\u0003\u0002\u0002\u0002\u129d\u032b\u0003\u0002\u0002\u0002\u129e\u129c\u0003\u0002\u0002\u0002\u129f\u12a2\u0005\u0434\u021b\u0002\u12a0\u12a2\u0005\u0496\u024c\u0002\u12a1\u129f\u0003\u0002\u0002\u0002\u12a1\u12a0\u0003\u0002\u0002\u0002\u12a2\u12a3\u0003\u0002\u0002\u0002\u12a3\u12a4\u0005\u0330\u0199\u0002\u12a4\u12a5\u0005\u0332\u019a\u0002\u12a5\u12a6\u0005\u0326\u0194\u0002\u12a6\u032d\u0003\u0002\u0002\u0002\u12a7\u12a8\u0007\u0009\u0002\u0002\u12a8\u12a9\u0005\u032c\u0197\u0002\u12a9\u032f\u0003\u0002\u0002\u0002\u12aa\u12ae\u0007\u00d9\u0002\u0002\u12ab\u12af\u0005\u0434\u021b\u0002\u12ac\u12af\u0005\u0496\u024c\u0002\u12ad\u12af\u0005\u040a\u0206\u0002\u12ae\u12ab\u0003\u0002\u0002\u0002\u12ae\u12ac\u0003\u0002\u0002\u0002\u12ae\u12ad\u0003\u0002\u0002\u0002\u12af\u0331\u0003\u0002\u0002\u0002\u12b0\u12b4\u0007\u0033\u0002\u0002\u12b1\u12b5\u0005\u0434\u021b\u0002\u12b2\u12b5\u0005\u0496\u024c\u0002\u12b3\u12b5\u0005\u040a\u0206\u0002\u12b4\u12b1\u0003\u0002\u0002\u0002\u12b4\u12b2\u0003\u0002\u0002\u0002\u12b4\u12b3\u0003\u0002\u0002\u0002\u12b5\u0333\u0003\u0002\u0002\u0002\u12b6\u12b8\u0007\u0204\u0002\u0002\u12b7\u12b6\u0003\u0002\u0002\u0002\u12b7\u12b8\u0003\u0002\u0002\u0002\u12b8\u12b9\u0003\u0002\u0002\u0002\u12b9\u12ba\u0007\u01df\u0002\u0002\u12ba\u12bb\u0009\u003a\u0002\u0002\u12bb\u0335\u0003\u0002\u0002\u0002\u12bc\u12be\u0007\u016f\u0002\u0002\u12bd\u12bf\u0005\u0462\u0232\u0002\u12be\u12bd\u0003\u0002\u0002\u0002\u12bf\u12c0\u0003\u0002\u0002\u0002\u12c0\u12be\u0003\u0002\u0002\u0002\u12c0\u12c1\u0003\u0002\u0002\u0002\u12c1\u0337\u0003\u0002\u0002\u0002\u12c2\u12c3\u0007\u0178\u0002\u0002\u12c3\u12c5\u0005\u0470\u0239\u0002\u12c4\u12c6\u0007\u0137\u0002\u0002\u12c5\u12c4\u0003\u0002\u0002\u0002\u12c5\u12c6\u0003\u0002\u0002\u0002\u12c6\u12c8\u0003\u0002\u0002\u0002\u12c7\u12c9\u0007\u017b\u0002\u0002\u12c8\u12c7\u0003\u0002\u0002\u0002\u12c8\u12c9\u0003\u0002\u0002\u0002\u12c9\u12cb\u0003\u0002\u0002\u0002\u12ca\u12cc\u0005\u033a\u019e\u0002\u12cb\u12ca\u0003\u0002\u0002\u0002\u12cb\u12cc\u0003\u0002\u0002\u0002\u12cc\u12ce\u0003\u0002\u0002\u0002\u12cd\u12cf\u0005\u033c\u019f\u0002\u12ce\u12cd\u0003\u0002\u0002\u0002\u12ce\u12cf\u0003\u0002\u0002\u0002\u12cf\u12d1\u0003\u0002\u0002\u0002\u12d0\u12d2\u0005\u033e\u01a0\u0002\u12d1\u12d0\u0003\u0002\u0002\u0002\u12d1\u12d2\u0003\u0002\u0002\u0002\u12d2\u12d4\u0003\u0002\u0002\u0002\u12d3\u12d5\u0005\u03fa\u01fe\u0002\u12d4\u12d3\u0003\u0002\u0002\u0002\u12d4\u12d5\u0003\u0002\u0002\u0002\u12d5\u12d7\u0003\u0002\u0002\u0002\u12d6\u12d8\u0005\u03fc\u01ff\u0002\u12d7\u12d6\u0003\u0002\u0002\u0002\u12d7\u12d8\u0003\u0002\u0002\u0002\u12d8\u12da\u0003\u0002\u0002\u0002\u12d9\u12db\u0005\u03f6\u01fc\u0002\u12da\u12d9\u0003\u0002\u0002\u0002\u12da\u12db\u0003\u0002\u0002\u0002\u12db\u12dd\u0003\u0002\u0002\u0002\u12dc\u12de\u0005\u03f8\u01fd\u0002\u12dd\u12dc\u0003\u0002\u0002\u0002\u12dd\u12de\u0003\u0002\u0002\u0002\u12de\u12e0\u0003\u0002\u0002\u0002\u12df\u12e1\u0007\u00ac\u0002\u0002\u12e0\u12df\u0003\u0002\u0002\u0002\u12e0\u12e1\u0003\u0002\u0002\u0002\u12e1\u0339\u0003\u0002\u0002\u0002\u12e2\u12e3\u0007\u00fd\u0002\u0002\u12e3\u12e4\u0005\u0434\u021b\u0002\u12e4\u033b\u0003\u0002\u0002\u0002\u12e5\u12e7\u0007\u0204\u0002\u0002\u12e6\u12e5\u0003\u0002\u0002\u0002\u12e6\u12e7\u0003\u0002\u0002\u0002\u12e7\u12eb\u0003\u0002\u0002\u0002\u12e8\u12e9\u0009\u003b\u0002\u0002\u12e9\u12ec\u0007\u0120\u0002\u0002\u12ea\u12ec\u0007\u0201\u0002\u0002\u12eb\u12e8\u0003\u0002\u0002\u0002\u12eb\u12ea\u0003\u0002\u0002\u0002\u12ec\u033d\u0003\u0002\u0002\u0002\u12ed\u12ef\u0007\u0105\u0002\u0002\u12ee\u12f0\u0007\u0100\u0002\u0002\u12ef\u12ee\u0003\u0002\u0002\u0002\u12ef\u12f0\u0003\u0002\u0002\u0002\u12f0\u12f1\u0003\u0002\u0002\u0002\u12f1\u12f2\u0005\u0444\u0223\u0002\u12f2\u033f\u0003\u0002\u0002\u0002\u12f3\u12f6\u0007\u0179\u0002\u0002\u12f4\u12f7\u0005\u0342\u01a2\u0002\u12f5\u12f7\u0005\u0346\u01a4\u0002\u12f6\u12f4\u0003\u0002\u0002\u0002\u12f6\u12f5\u0003\u0002\u0002\u0002\u12f7\u12f9\u0003\u0002\u0002\u0002\u12f8\u12fa\u0005\u0406\u0204\u0002\u12f9\u12f8\u0003\u0002\u0002\u0002\u12f9\u12fa\u0003\u0002\u0002\u0002\u12fa\u12fc\u0003\u0002\u0002\u0002\u12fb\u12fd\u0005\u0408\u0205\u0002\u12fc\u12fb\u0003\u0002\u0002\u0002\u12fc\u12fd\u0003\u0002\u0002\u0002\u12fd\u12ff\u0003\u0002\u0002\u0002\u12fe\u1300\u0007\u00ad\u0002\u0002\u12ff\u12fe\u0003\u0002\u0002\u0002\u12ff\u1300\u0003\u0002\u0002\u0002\u1300\u0341\u0003\u0002\u0002\u0002\u1301\u1302\u0005\u046a\u0236\u0002\u1302\u1303\u0007\u00d9\u0002\u0002\u1303\u130b\u0005\u0344\u01a3\u0002\u1304\u130a\u0005\u034c\u01a7\u0002\u1305\u130a\u0005\u034e\u01a8\u0002\u1306\u130a\u0005\u0350\u01a9\u0002\u1307\u130a\u0005\u0352\u01aa\u0002\u1308\u130a\u0005\u0354\u01ab\u0002\u1309\u1304\u0003\u0002\u0002\u0002\u1309\u1305\u0003\u0002\u0002\u0002\u1309\u1306\u0003\u0002\u0002\u0002\u1309\u1307\u0003\u0002\u0002\u0002\u1309\u1308\u0003\u0002\u0002\u0002\u130a\u130d\u0003\u0002\u0002\u0002\u130b\u1309\u0003\u0002\u0002\u0002\u130b\u130c\u0003\u0002\u0002\u0002\u130c\u0343\u0003\u0002\u0002\u0002\u130d\u130b\u0003\u0002\u0002\u0002\u130e\u130f\u0007\u01e3\u0002\u0002\u130f\u1315\u0005\u046a\u0236\u0002\u1310\u1311\u0007\u0109\u0002\u0002\u1311\u1315\u0007\u01e3\u0002\u0002\u1312\u1313\u0007\u0016\u0002\u0002\u1313\u1315\u0007\u01e3\u0002\u0002\u1314\u130e\u0003\u0002\u0002\u0002\u1314\u1310\u0003\u0002\u0002\u0002\u1314\u1312\u0003\u0002\u0002\u0002\u1315\u0345\u0003\u0002\u0002\u0002\u1316\u1317\u0005\u0462\u0232\u0002\u1317\u1319\u0009\u003c\u0002\u0002\u1318\u131a\u0007\u00fd\u0002\u0002\u1319\u1318\u0003\u0002\u0002\u0002\u1319\u131a\u0003\u0002\u0002\u0002\u131a\u131b\u0003\u0002\u0002\u0002\u131b\u131d\u0005\u0434\u021b\u0002\u131c\u131e\u0005\u0348\u01a5\u0002\u131d\u131c\u0003\u0002\u0002\u0002\u131d\u131e\u0003\u0002\u0002\u0002\u131e\u1320\u0003\u0002\u0002\u0002\u131f\u1321\u0005\u034a\u01a6\u0002\u1320\u131f\u0003\u0002\u0002\u0002\u1320\u1321\u0003\u0002\u0002\u0002\u1321\u0347\u0003\u0002\u0002\u0002\u1322\u1323\u0007\u0138\u0002\u0002\u1323\u1327\u0007\u006f\u0002\u0002\u1324\u1326\u0005\u021a\u010e\u0002\u1325\u1324\u0003\u0002\u0002\u0002\u1326\u1329\u0003\u0002\u0002\u0002\u1327\u1325\u0003\u0002\u0002\u0002\u1327\u1328\u0003\u0002\u0002\u0002\u1328\u0349\u0003\u0002\u0002\u0002\u1329\u1327\u0003\u0002\u0002\u0002\u132a\u132b\u0007\u0204\u0002\u0002\u132b\u132f\u0007\u006f\u0002\u0002\u132c\u132e\u0005\u021a\u010e\u0002\u132d\u132c\u0003\u0002\u0002\u0002\u132e\u1331\u0003\u0002\u0002\u0002\u132f\u132d\u0003\u0002\u0002\u0002\u132f\u1330\u0003\u0002\u0002\u0002\u1330\u034b\u0003\u0002\u0002\u0002\u1331\u132f\u0003\u0002\u0002\u0002\u1332\u1334\u0007\u0029\u0002\u0002\u1333\u1335\u0007\u01e7\u0002\u0002\u1334\u1333\u0003\u0002\u0002\u0002\u1334\u1335\u0003\u0002\u0002\u0002\u1335\u1338\u0003\u0002\u0002\u0002\u1336\u1339\u0005\u049a\u024e\u0002\u1337\u1339\u0005\u0434\u021b\u0002\u1338\u1336\u0003\u0002\u0002\u0002\u1338\u1337\u0003\u0002\u0002\u0002\u1339\u034d\u0003\u0002\u0002\u0002\u133a\u133c\u0007\u0204\u0002\u0002\u133b\u133a\u0003\u0002\u0002\u0002\u133b\u133c\u0003\u0002\u0002\u0002\u133c\u133d\u0003\u0002\u0002\u0002\u133d\u133e\u0007\u0138\u0002\u0002\u133e\u133f\u0007\u0201\u0002\u0002\u133f\u034f\u0003\u0002\u0002\u0002\u1340\u1342\u0007\u01e3\u0002\u0002\u1341\u1343\u0007\u00f1\u0002\u0002\u1342\u1341\u0003\u0002\u0002\u0002\u1342\u1343\u0003\u0002\u0002\u0002\u1343\u1344\u0003\u0002\u0002\u0002\u1344\u1345\u0005\u046a\u0236\u0002\u1345\u0351\u0003\u0002\u0002\u0002\u1346\u1348\u0007\u01b9\u0002\u0002\u1347\u1349\u0007\u00f1\u0002\u0002\u1348\u1347\u0003\u0002\u0002\u0002\u1348\u1349\u0003\u0002\u0002\u0002\u1349\u134c\u0003\u0002\u0002\u0002\u134a\u134d\u0005\u049a\u024e\u0002\u134b\u134d\u0005\u0434\u021b\u0002\u134c\u134a\u0003\u0002\u0002\u0002\u134c\u134b\u0003\u0002\u0002\u0002\u134d\u0353\u0003\u0002\u0002\u0002\u134e\u1350\u0007\u01cb\u0002\u0002\u134f\u1351\u0007\u00f1\u0002\u0002\u1350\u134f\u0003\u0002\u0002\u0002\u1350\u1351\u0003\u0002\u0002\u0002\u1351\u1352\u0003\u0002\u0002\u0002\u1352\u1353\u0005\u0434\u021b\u0002\u1353\u0355\u0003\u0002\u0002\u0002\u1354\u1355\u0007\u0185\u0002\u0002\u1355\u1358\u0005\u0484\u0243\u0002\u1356\u1357\u0007\u00d9\u0002\u0002\u1357\u1359\u0005\u0444\u0223\u0002\u1358\u1356\u0003\u0002\u0002\u0002\u1358\u1359\u0003\u0002\u0002\u0002\u1359\u0357\u0003\u0002\u0002\u0002\u135a\u135b\u0007\u0195\u0002\u0002\u135b\u135d\u0005\u0470\u0239\u0002\u135c\u135e\u0007\u017b\u0002\u0002\u135d\u135c\u0003\u0002\u0002\u0002\u135d\u135e\u0003\u0002\u0002\u0002\u135e\u1360\u0003\u0002\u0002\u0002\u135f\u1361\u0005\u035a\u01ae\u0002\u1360\u135f\u0003\u0002\u0002\u0002\u1360\u1361\u0003\u0002\u0002\u0002\u1361\u1362\u0003\u0002\u0002\u0002\u1362\u1364\u0005\u03f6\u01fc\u0002\u1363\u1365\u0005\u03f8\u01fd\u0002\u1364\u1363\u0003\u0002\u0002\u0002\u1364\u1365\u0003\u0002\u0002\u0002\u1365\u1367\u0003\u0002\u0002\u0002\u1366\u1368\u0007\u00ae\u0002\u0002\u1367\u1366\u0003\u0002\u0002\u0002\u1367\u1368\u0003\u0002\u0002\u0002\u1368\u0359\u0003\u0002\u0002\u0002\u1369\u136a\u0007\u00fd\u0002\u0002\u136a\u136b\u0005\u0444\u0223\u0002\u136b\u035b\u0003\u0002\u0002\u0002\u136c\u136d\u0007\u019a\u0002\u0002\u136d\u136f\u0005\u0484\u0243\u0002\u136e\u1370\u0005\u035e\u01b0\u0002\u136f\u136e\u0003\u0002\u0002\u0002\u136f\u1370\u0003\u0002\u0002\u0002\u1370\u1372\u0003\u0002\u0002\u0002\u1371\u1373\u0005\u03fa\u01fe\u0002\u1372\u1371\u0003\u0002\u0002\u0002\u1372\u1373\u0003\u0002\u0002\u0002\u1373\u1375\u0003\u0002\u0002\u0002\u1374\u1376\u0005\u03fc\u01ff\u0002\u1375\u1374\u0003\u0002\u0002\u0002\u1375\u1376\u0003\u0002\u0002\u0002\u1376\u1378\u0003\u0002\u0002\u0002\u1377\u1379\u0007\u00af\u0002\u0002\u1378\u1377\u0003\u0002\u0002\u0002\u1378\u1379\u0003\u0002\u0002\u0002\u1379\u035d\u0003\u0002\u0002\u0002\u137a\u137b\u0007\u00d9\u0002\u0002\u137b\u137c\u0005\u0434\u021b\u0002\u137c\u035f\u0003\u0002\u0002\u0002\u137d\u137f\u0007\u01a4\u0002\u0002\u137e\u1380\u0007\u000b\u0002\u0002\u137f\u137e\u0003\u0002\u0002\u0002\u137f\u1380\u0003\u0002\u0002\u0002\u1380\u1381\u0003\u0002\u0002\u0002\u1381\u1383\u0005\u0444\u0223\u0002\u1382\u1384\u0005\u0362\u01b2\u0002\u1383\u1382\u0003\u0002\u0002\u0002\u1383\u1384\u0003\u0002\u0002\u0002\u1384\u1386\u0003\u0002\u0002\u0002\u1385\u1387\u0005\u03f6\u01fc\u0002\u1386\u1385\u0003\u0002\u0002\u0002\u1386\u1387\u0003\u0002\u0002\u0002\u1387\u1389\u0003\u0002\u0002\u0002\u1388\u138a\u0005\u0364\u01b3\u0002\u1389\u1388\u0003\u0002\u0002\u0002\u138a\u138b\u0003\u0002\u0002\u0002\u138b\u1389\u0003\u0002\u0002\u0002\u138b\u138c\u0003\u0002\u0002\u0002\u138c\u138e\u0003\u0002\u0002\u0002\u138d\u138f\u0007\u00b0\u0002\u0002\u138e\u138d\u0003\u0002\u0002\u0002\u138e\u138f\u0003\u0002\u0002\u0002\u138f\u0361\u0003\u0002\u0002\u0002\u1390\u1391\u0007\u01ff\u0002\u0002\u1391\u1392\u0005\u0444\u0223\u0002\u1392\u0363\u0003\u0002\u0002\u0002\u1393\u1394\u0007\u0202\u0002\u0002\u1394\u139d\u0005\u0418\u020d\u0002\u1395\u1396\u0007\u0137\u0002\u0002\u1396\u139e\u0007\u01ac\u0002\u0002\u1397\u1399\u0005\u021a\u010e\u0002\u1398\u1397\u0003\u0002\u0002\u0002\u1399\u139c\u0003\u0002\u0002\u0002\u139a\u1398\u0003\u0002\u0002\u0002\u139a\u139b\u0003\u0002\u0002\u0002\u139b\u139e\u0003\u0002\u0002\u0002\u139c\u139a\u0003\u0002\u0002\u0002\u139d\u1395\u0003\u0002\u0002\u0002\u139d\u139a\u0003\u0002\u0002\u0002\u139e\u0365\u0003\u0002\u0002\u0002\u139f\u13a2\u0007\u01ab\u0002\u0002\u13a0\u13a3\u0005\u0368\u01b5\u0002\u13a1\u13a3\u0005\u036a\u01b6\u0002\u13a2\u13a0\u0003\u0002\u0002\u0002\u13a2\u13a1\u0003\u0002\u0002\u0002\u13a3\u13a5\u0003\u0002\u0002\u0002\u13a4\u13a6\u0005\u0406\u0204\u0002\u13a5\u13a4\u0003\u0002\u0002\u0002\u13a5\u13a6\u0003\u0002\u0002\u0002\u13a6\u13a8\u0003\u0002\u0002\u0002\u13a7\u13a9\u0005\u0408\u0205\u0002\u13a8\u13a7\u0003\u0002\u0002\u0002\u13a8\u13a9\u0003\u0002\u0002\u0002\u13a9\u0367\u0003\u0002\u0002\u0002\u13aa\u13ad\u0005\u0434\u021b\u0002\u13ab\u13ad\u0005\u0496\u024c\u0002\u13ac\u13aa\u0003\u0002\u0002\u0002\u13ac\u13ab\u0003\u0002\u0002\u0002\u13ad\u13af\u0003\u0002\u0002\u0002\u13ae\u13b0\u0005\u036c\u01b7\u0002\u13af\u13ae\u0003\u0002\u0002\u0002\u13af\u13b0\u0003\u0002\u0002\u0002\u13b0\u13b2\u0003\u0002\u0002\u0002\u13b1\u13b3\u0005\u036e\u01b8\u0002\u13b2\u13b1\u0003\u0002\u0002\u0002\u13b2\u13b3\u0003\u0002\u0002\u0002\u13b3\u13b5\u0003\u0002\u0002\u0002\u13b4\u13b6\u0005\u0370\u01b9\u0002\u13b5\u13b4\u0003\u0002\u0002\u0002\u13b5\u13b6\u0003\u0002\u0002\u0002\u13b6\u13b8\u0003\u0002\u0002\u0002\u13b7\u13b9\u0005\u0372\u01ba\u0002\u13b8\u13b7\u0003\u0002\u0002\u0002\u13b8\u13b9\u0003\u0002\u0002\u0002\u13b9\u0369\u0003\u0002\u0002\u0002\u13ba\u13bb\u0007\u01eb\u0002\u0002\u13bb\u13bc\u0009\u003d\u0002\u0002\u13bc\u13bd\u0005\u0434\u021b\u0002\u13bd\u036b\u0003\u0002\u0002\u0002\u13be\u13bf\u0007\u00d9\u0002\u0002\u13bf\u13c0\u0005\u0434\u021b\u0002\u13c0\u036d\u0003\u0002\u0002\u0002\u13c1\u13c6\u0007\u0204\u0002\u0002\u13c2\u13c7\u0007\u009b\u0002\u0002\u13c3\u13c7\u0007\u009d\u0002\u0002\u13c4\u13c7\u0007\u00c2\u0002\u0002\u13c5\u13c7\u0005\u0434\u021b\u0002\u13c6\u13c2\u0003\u0002\u0002\u0002\u13c6\u13c3\u0003\u0002\u0002\u0002\u13c6\u13c4\u0003\u0002\u0002\u0002\u13c6\u13c5\u0003\u0002\u0002\u0002\u13c7\u036f\u0003\u0002\u0002\u0002\u13c8\u13ca\u0007\u018c\u0002\u0002\u13c9\u13cb\u0007\u0119\u0002\u0002\u13ca\u13c9\u0003\u0002\u0002\u0002\u13ca\u13cb\u0003\u0002\u0002\u0002\u13cb\u0371\u0003\u0002\u0002\u0002\u13cc\u13ce\u0009\u003a\u0002\u0002\u13cd\u13cf\u0007\u0008\u0002\u0002\u13ce\u13cd\u0003\u0002\u0002\u0002\u13ce\u13cf\u0003\u0002\u0002\u0002\u13cf\u13d3\u0003\u0002\u0002\u0002\u13d0\u13d4\u0005\u0374\u01bb\u0002\u13d1\u13d4\u0005\u0376\u01bc\u0002\u13d2\u13d4\u0005\u0378\u01bd\u0002\u13d3\u13d0\u0003\u0002\u0002\u0002\u13d3\u13d1\u0003\u0002\u0002\u0002\u13d3\u13d2\u0003\u0002\u0002\u0002\u13d4\u0373\u0003\u0002\u0002\u0002\u13d5\u13d6\u0007\u0156\u0002\u0002\u13d6\u0375\u0003\u0002\u0002\u0002\u13d7\u13da\u0005\u0434\u021b\u0002\u13d8\u13da\u0005\u0496\u024c\u0002\u13d9\u13d7\u0003\u0002\u0002\u0002\u13d9\u13d8\u0003\u0002\u0002\u0002\u13da\u13dc\u0003\u0002\u0002\u0002\u13db\u13dd\u0009\u0023\u0002\u0002\u13dc\u13db\u0003\u0002\u0002\u0002\u13dc\u13dd\u0003\u0002\u0002\u0002\u13dd\u0377\u0003\u0002\u0002\u0002\u13de\u13df\u0005\u047c\u023f\u0002\u13df\u0379\u0003\u0002\u0002\u0002\u13e0\u13e7\u0007\u01b0\u0002\u0002\u13e1\u13e3\u0005\u037c\u01bf\u0002\u13e2\u13e1\u0003\u0002\u0002\u0002\u13e3\u13e4\u0003\u0002\u0002\u0002\u13e4\u13e2\u0003\u0002\u0002\u0002\u13e4\u13e5\u0003\u0002\u0002\u0002\u13e5\u13e8\u0003\u0002\u0002\u0002\u13e6\u13e8\u0005\u037e\u01c0\u0002\u13e7\u13e2\u0003\u0002\u0002\u0002\u13e7\u13e6\u0003\u0002\u0002\u0002\u13e8\u037b\u0003\u0002\u0002\u0002\u13e9\u13eb\u0005\u0380\u01c1\u0002\u13ea\u13e9\u0003\u0002\u0002\u0002\u13eb\u13ec\u0003\u0002\u0002\u0002\u13ec\u13ea\u0003\u0002\u0002\u0002\u13ec\u13ed\u0003\u0002\u0002\u0002\u13ed\u13ee\u0003\u0002\u0002\u0002\u13ee\u13f0\u0007\u01eb\u0002\u0002\u13ef\u13f1\u0005\u0382\u01c2\u0002\u13f0\u13ef\u0003\u0002\u0002\u0002\u13f1\u13f2\u0003\u0002\u0002\u0002\u13f2\u13f0\u0003\u0002\u0002\u0002\u13f2\u13f3\u0003\u0002\u0002\u0002\u13f3\u037d\u0003\u0002\u0002\u0002\u13f4\u13f6\u0005\u0380\u01c1\u0002\u13f5\u13f4\u0003\u0002\u0002\u0002\u13f6\u13f7\u0003\u0002\u0002\u0002\u13f7\u13f5\u0003\u0002\u0002\u0002\u13f7\u13f8\u0003\u0002\u0002\u0002\u13f8\u13fd\u0003\u0002\u0002\u0002\u13f9\u13fa\u0007\u01f8\u0002\u0002\u13fa\u13fe\u0007\u0033\u0002\u0002\u13fb\u13fc\u0007\u0096\u0002\u0002\u13fc\u13fe\u0007\u0033\u0002\u0002\u13fd\u13f9\u0003\u0002\u0002\u0002\u13fd\u13fb\u0003\u0002\u0002\u0002\u13fe\u13ff\u0003\u0002\u0002\u0002\u13ff\u1400\u0005\u0384\u01c3\u0002\u1400\u037f\u0003\u0002\u0002\u0002\u1401\u1402\u0005\u0434\u021b\u0002\u1402\u0381\u0003\u0002\u0002\u0002\u1403\u140d\u0007\u0148\u0002\u0002\u1404\u140d\u0007\u0146\u0002\u0002\u1405\u1408\u0007\u00b8\u0002\u0002\u1406\u1409\u0005\u0434\u021b\u0002\u1407\u1409\u0005\u0496\u024c\u0002\u1408\u1406\u0003\u0002\u0002\u0002\u1408\u1407\u0003\u0002\u0002\u0002\u1409\u140d\u0003\u0002\u0002\u0002\u140a\u140d\u0005\u0434\u021b\u0002\u140b\u140d\u0005\u0496\u024c\u0002\u140c\u1403\u0003\u0002\u0002\u0002\u140c\u1404\u0003\u0002\u0002\u0002\u140c\u1405\u0003\u0002\u0002\u0002\u140c\u140a\u0003\u0002\u0002\u0002\u140c\u140b\u0003\u0002\u0002\u0002\u140d\u0383\u0003\u0002\u0002\u0002\u140e\u1411\u0005\u0434\u021b\u0002\u140f\u1411\u0005\u0496\u024c\u0002\u1410\u140e\u0003\u0002\u0002\u0002\u1410\u140f\u0003\u0002\u0002\u0002\u1411\u0385\u0003\u0002\u0002\u0002\u1412\u1413\u0007\u01ba\u0002\u0002\u1413\u1415\u0005\u0470\u0239\u0002\u1414\u1416\u0005\u0388\u01c5\u0002\u1415\u1414\u0003\u0002\u0002\u0002\u1416\u1417\u0003\u0002\u0002\u0002\u1417\u1415\u0003\u0002\u0002\u0002\u1417\u1418\u0003\u0002\u0002\u0002\u1418\u141a\u0003\u0002\u0002\u0002\u1419\u141b\u0005\u038a\u01c6\u0002\u141a\u1419\u0003\u0002\u0002\u0002\u141a\u141b\u0003\u0002\u0002\u0002\u141b\u141d\u0003\u0002\u0002\u0002\u141c\u141e\u0005\u038c\u01c7\u0002\u141d\u141c\u0003\u0002\u0002\u0002\u141d\u141e\u0003\u0002\u0002\u0002\u141e\u1420\u0003\u0002\u0002\u0002\u141f\u1421\u0005\u0392\u01ca\u0002\u1420\u141f\u0003\u0002\u0002\u0002\u1420\u1421\u0003\u0002\u0002\u0002\u1421\u1425\u0003\u0002\u0002\u0002\u1422\u1424\u0005\u0396\u01cc\u0002\u1423\u1422\u0003\u0002\u0002\u0002\u1424\u1427\u0003\u0002\u0002\u0002\u1425\u1423\u0003\u0002\u0002\u0002\u1425\u1426\u0003\u0002\u0002\u0002\u1426\u1429\u0003\u0002\u0002\u0002\u1427\u1425\u0003\u0002\u0002\u0002\u1428\u142a\u0005\u0398\u01cd\u0002\u1429\u1428\u0003\u0002\u0002\u0002\u1429\u142a\u0003\u0002\u0002\u0002\u142a\u142e\u0003\u0002\u0002\u0002\u142b\u142d\u0005\u039c\u01cf\u0002\u142c\u142b\u0003\u0002\u0002\u0002\u142d\u1430\u0003\u0002\u0002\u0002\u142e\u142c\u0003\u0002\u0002\u0002\u142e\u142f\u0003\u0002\u0002\u0002\u142f\u0387\u0003\u0002\u0002\u0002\u1430\u142e\u0003\u0002\u0002\u0002\u1431\u1433\u0007\u0148\u0002\u0002\u1432\u1431\u0003\u0002\u0002\u0002\u1432\u1433\u0003\u0002\u0002\u0002\u1433\u1434\u0003\u0002\u0002\u0002\u1434\u1436\u0009\u002b\u0002\u0002\u1435\u1437\u0007\u0105\u0002\u0002\u1436\u1435\u0003\u0002\u0002\u0002\u1436\u1437\u0003\u0002\u0002\u0002\u1437\u1439\u0003\u0002\u0002\u0002\u1438\u143a\u0005\u0444\u0223\u0002\u1439\u1438\u0003\u0002\u0002\u0002\u143a\u143b\u0003\u0002\u0002\u0002\u143b\u1439\u0003\u0002\u0002\u0002\u143b\u143c\u0003\u0002\u0002\u0002\u143c\u0389\u0003\u0002\u0002\u0002\u143d\u143f\u0007\u0204\u0002\u0002\u143e\u143d\u0003\u0002\u0002\u0002\u143e\u143f\u0003\u0002\u0002\u0002\u143f\u1440\u0003\u0002\u0002\u0002\u1440\u1442\u0007\u0097\u0002\u0002\u1441\u1443\u0007\u00f1\u0002\u0002\u1442\u1441\u0003\u0002\u0002\u0002\u1442\u1443\u0003\u0002\u0002\u0002\u1443\u1445\u0003\u0002\u0002\u0002\u1444\u1446\u0007\u014c\u0002\u0002\u1445\u1444\u0003\u0002\u0002\u0002\u1445\u1446\u0003\u0002\u0002\u0002\u1446\u038b\u0003\u0002\u0002\u0002\u1447\u1449\u0007\u004a\u0002\u0002\u1448\u1447\u0003\u0002\u0002\u0002\u1448\u1449\u0003\u0002\u0002\u0002\u1449\u144a\u0003\u0002\u0002\u0002\u144a\u144c\u0007\u01ae\u0002\u0002\u144b\u144d\u0007\u0100\u0002\u0002\u144c\u144b\u0003\u0002\u0002\u0002\u144c\u144d\u0003\u0002\u0002\u0002\u144d\u144f\u0003\u0002\u0002\u0002\u144e\u1450\u0005\u045c\u022f\u0002\u144f\u144e\u0003\u0002\u0002\u0002\u1450\u1451\u0003\u0002\u0002\u0002\u1451\u144f\u0003\u0002\u0002\u0002\u1451\u1452\u0003\u0002\u0002\u0002\u1452\u1454\u0003\u0002\u0002\u0002\u1453\u1455\u0005\u038e\u01c8\u0002\u1454\u1453\u0003\u0002\u0002\u0002\u1454\u1455\u0003\u0002\u0002\u0002\u1455\u1457\u0003\u0002\u0002\u0002\u1456\u1458\u0005\u0390\u01c9\u0002\u1457\u1456\u0003\u0002\u0002\u0002\u1457\u1458\u0003\u0002\u0002\u0002\u1458\u038d\u0003\u0002\u0002\u0002\u1459\u145b\u0007\u00d6\u0002\u0002\u145a\u1459\u0003\u0002\u0002\u0002\u145a\u145b\u0003\u0002\u0002\u0002\u145b\u145c\u0003\u0002\u0002\u0002\u145c\u145d\u0007\u0010\u0002\u0002\u145d\u145e\u0007\u0100\u0002\u0002\u145e\u145f\u0005\u045c\u022f\u0002\u145f\u038f\u0003\u0002\u0002\u0002\u1460\u1462\u0007\u00d6\u0002\u0002\u1461\u1460\u0003\u0002\u0002\u0002\u1461\u1462\u0003\u0002\u0002\u0002\u1462\u1463\u0003\u0002\u0002\u0002\u1463\u1465\u0007\u0132\u0002\u0002\u1464\u1466\u0007\u0100\u0002\u0002\u1465\u1464\u0003\u0002\u0002\u0002\u1465\u1466\u0003\u0002\u0002\u0002\u1466\u1467\u0003\u0002\u0002\u0002\u1467\u1468\u0005\u045c\u022f\u0002\u1468\u0391\u0003\u0002\u0002\u0002\u1469\u146a\u0007\u00f8\u0002\u0002\u146a\u146c\u0007\u0166\u0002\u0002\u146b\u146d\u0007\u0100\u0002\u0002\u146c\u146b\u0003\u0002\u0002\u0002\u146c\u146d\u0003\u0002\u0002\u0002\u146d\u146e\u0003\u0002\u0002\u0002\u146e\u1470\u0005\u0480\u0241\u0002\u146f\u1471\u0005\u0394\u01cb\u0002\u1470\u146f\u0003\u0002\u0002\u0002\u1470\u1471\u0003\u0002\u0002\u0002\u1471\u0393\u0003\u0002\u0002\u0002\u1472\u1473\u0009\u0006\u0002\u0002\u1473\u1474\u0005\u0480\u0241\u0002\u1474\u0395\u0003\u0002\u0002\u0002\u1475\u1477\u0007\u01fc\u0002\u0002\u1476\u1478\u0005\u0470\u0239\u0002\u1477\u1476\u0003\u0002\u0002\u0002\u1478\u1479\u0003\u0002\u0002\u0002\u1479\u1477\u0003\u0002\u0002\u0002\u1479\u147a\u0003\u0002\u0002\u0002\u147a\u0397\u0003\u0002\u0002\u0002\u147b\u147c\u0007\u0150\u0002\u0002\u147c\u147e\u0007\u0166\u0002\u0002\u147d\u147f\u0007\u0100\u0002\u0002\u147e\u147d\u0003\u0002\u0002\u0002\u147e\u147f\u0003\u0002\u0002\u0002\u147f\u1480\u0003\u0002\u0002\u0002\u1480\u1482\u0005\u0480\u0241\u0002\u1481\u1483\u0005\u039a\u01ce\u0002\u1482\u1481\u0003\u0002\u0002\u0002\u1482\u1483\u0003\u0002\u0002\u0002\u1483\u0399\u0003\u0002\u0002\u0002\u1484\u1485\u0009\u0006\u0002\u0002\u1485\u1486\u0005\u0480\u0241\u0002\u1486\u039b\u0003\u0002\u0002\u0002\u1487\u1489\u0007\u00e0\u0002\u0002\u1488\u148a\u0005\u039e\u01d0\u0002\u1489\u1488\u0003\u0002\u0002\u0002\u148a\u148b\u0003\u0002\u0002\u0002\u148b\u1489\u0003\u0002\u0002\u0002\u148b\u148c\u0003\u0002\u0002\u0002\u148c\u039d\u0003\u0002\u0002\u0002\u148d\u1497\u0005\u0470\u0239\u0002\u148e\u1498\u0007\u0120\u0002\u0002\u148f\u1498\u0007\u01a1\u0002\u0002\u1490\u1491\u0007\u0138\u0002\u0002\u1491\u1498\u0007\u0199\u0002\u0002\u1492\u1498\u0007\u006c\u0002\u0002\u1493\u1498\u0007\u0185\u0002\u0002\u1494\u1495\u0007\u0204\u0002\u0002\u1495\u1496\u0007\u0189\u0002\u0002\u1496\u1498\u0007\u006c\u0002\u0002\u1497\u148e\u0003\u0002\u0002\u0002\u1497\u148f\u0003\u0002\u0002\u0002\u1497\u1490\u0003\u0002\u0002\u0002\u1497\u1492\u0003\u0002\u0002\u0002\u1497\u1493\u0003\u0002\u0002\u0002\u1497\u1494\u0003\u0002\u0002\u0002\u1497\u1498\u0003\u0002\u0002\u0002\u1498\u039f\u0003\u0002\u0002\u0002\u1499\u149a\u0007\u01ca\u0002\u0002\u149a\u149c\u0005\u0470\u0239\u0002\u149b\u149d\u0005\u03a2\u01d2\u0002\u149c\u149b\u0003\u0002\u0002\u0002\u149c\u149d\u0003\u0002\u0002\u0002\u149d\u149f\u0003\u0002\u0002\u0002\u149e\u14a0\u0005\u03fa\u01fe\u0002\u149f\u149e\u0003\u0002\u0002\u0002\u149f\u14a0\u0003\u0002\u0002\u0002\u14a0\u14a2\u0003\u0002\u0002\u0002\u14a1\u14a3\u0005\u03fc\u01ff\u0002\u14a2\u14a1\u0003\u0002\u0002\u0002\u14a2\u14a3\u0003\u0002\u0002\u0002\u14a3\u14a5\u0003\u0002\u0002\u0002\u14a4\u14a6\u0007\u00b1\u0002\u0002\u14a5\u14a4\u0003\u0002\u0002\u0002\u14a5\u14a6\u0003\u0002\u0002\u0002\u14a6\u03a1\u0003\u0002\u0002\u0002\u14a7\u14a9\u0007\u0105\u0002\u0002\u14a8\u14aa\u0007\u0100\u0002\u0002\u14a9\u14a8\u0003\u0002\u0002\u0002\u14a9\u14aa\u0003\u0002\u0002\u0002\u14aa\u14c6\u0003\u0002\u0002\u0002\u14ab\u14ad\u0007\u00bc\u0002\u0002\u14ac\u14ae\u0007\u01eb\u0002\u0002\u14ad\u14ac\u0003\u0002\u0002\u0002\u14ad\u14ae\u0003\u0002\u0002\u0002\u14ae\u14c7\u0003\u0002\u0002\u0002\u14af\u14c7\u0007\u021a\u0002\u0002\u14b0\u14b2\u0007\u00e3\u0002\u0002\u14b1\u14b3\u0007\u01e1\u0002\u0002\u14b2\u14b1\u0003\u0002\u0002\u0002\u14b2\u14b3\u0003\u0002\u0002\u0002\u14b3\u14c7\u0003\u0002\u0002\u0002\u14b4\u14c7\u0007\u0222\u0002\u0002\u14b5\u14b6\u0007\u013a\u0002\u0002\u14b6\u14b8\u0007\u0111\u0002\u0002\u14b7\u14b9\u0007\u01e1\u0002\u0002\u14b8\u14b7\u0003\u0002\u0002\u0002\u14b8\u14b9\u0003\u0002\u0002\u0002\u14b9\u14c7\u0003\u0002\u0002\u0002\u14ba\u14bb\u0007\u013a\u0002\u0002\u14bb\u14c7\u0007\u021e\u0002\u0002\u14bc\u14be\u0007\u00e3\u0002\u0002\u14bd\u14bf\u0007\u01e1\u0002\u0002\u14be\u14bd\u0003\u0002\u0002\u0002\u14be\u14bf\u0003\u0002\u0002\u0002\u14bf\u14c0\u0003\u0002\u0002\u0002\u14c0\u14c1\u0007\u014b\u0002\u0002\u14c1\u14c3\u0007\u00bc\u0002\u0002\u14c2\u14c4\u0007\u01eb\u0002\u0002\u14c3\u14c2\u0003\u0002\u0002\u0002\u14c3\u14c4\u0003\u0002\u0002\u0002\u14c4\u14c7\u0003\u0002\u0002\u0002\u14c5\u14c7\u0007\u0223\u0002\u0002\u14c6\u14ab\u0003\u0002\u0002\u0002\u14c6\u14af\u0003\u0002\u0002\u0002\u14c6\u14b0\u0003\u0002\u0002\u0002\u14c6\u14b4\u0003\u0002\u0002\u0002\u14c6\u14b5\u0003\u0002\u0002\u0002\u14c6\u14ba\u0003\u0002\u0002\u0002\u14c6\u14bc\u0003\u0002\u0002\u0002\u14c6\u14c5\u0003\u0002\u0002\u0002\u14c7\u14c8\u0003\u0002\u0002\u0002\u14c8\u14c9\u0005\u0444\u0223\u0002\u14c9\u03a3\u0003\u0002\u0002\u0002\u14ca\u14cd\u0007\u01cc\u0002\u0002\u14cb\u14ce\u0007\u019f\u0002\u0002\u14cc\u14ce\u0005\u0496\u024c\u0002\u14cd\u14cb\u0003\u0002\u0002\u0002\u14cd\u14cc\u0003\u0002\u0002\u0002\u14ce\u03a5\u0003\u0002\u0002\u0002\u14cf\u14d1\u0007\u01cd\u0002\u0002\u14d0\u14d2\u0005\u03a8\u01d5\u0002\u14d1\u14d0\u0003\u0002\u0002\u0002\u14d2\u14d3\u0003\u0002\u0002\u0002\u14d3\u14d1\u0003\u0002\u0002\u0002\u14d3\u14d4\u0003\u0002\u0002\u0002\u14d4\u14d5\u0003\u0002\u0002\u0002\u14d5\u14d7\u0005\u03b0\u01d9\u0002\u14d6\u14d8\u0005\u03b2\u01da\u0002\u14d7\u14d6\u0003\u0002\u0002\u0002\u14d7\u14d8\u0003\u0002\u0002\u0002\u14d8\u14da\u0003\u0002\u0002\u0002\u14d9\u14db\u0005\u03fe\u0200\u0002\u14da\u14d9\u0003\u0002\u0002\u0002\u14da\u14db\u0003\u0002\u0002\u0002\u14db\u14dd\u0003\u0002\u0002\u0002\u14dc\u14de\u0005\u0400\u0201\u0002\u14dd\u14dc\u0003\u0002\u0002\u0002\u14dd\u14de\u0003\u0002\u0002\u0002\u14de\u14e0\u0003\u0002\u0002\u0002\u14df\u14e1\u0007\u00b2\u0002\u0002\u14e0\u14df\u0003\u0002\u0002\u0002\u14e0\u14e1\u0003\u0002\u0002\u0002\u14e1\u03a7\u0003\u0002\u0002\u0002\u14e2\u14e4\u0005\u03aa\u01d6\u0002\u14e3\u14e2\u0003\u0002\u0002\u0002\u14e4\u14e5\u0003\u0002\u0002\u0002\u14e5\u14e3\u0003\u0002\u0002\u0002\u14e5\u14e6\u0003\u0002\u0002\u0002\u14e6\u14e9\u0003\u0002\u0002\u0002\u14e7\u14ea\u0005\u03ac\u01d7\u0002\u14e8\u14ea\u0005\u03ae\u01d8\u0002\u14e9\u14e7\u0003\u0002\u0002\u0002\u14e9\u14e8\u0003\u0002\u0002\u0002\u14ea\u03a9\u0003\u0002\u0002\u0002\u14eb\u14ee\u0005\u0434\u021b\u0002\u14ec\u14ee\u0005\u0496\u024c\u0002\u14ed\u14eb\u0003\u0002\u0002\u0002\u14ed\u14ec\u0003\u0002\u0002\u0002\u14ee\u03ab\u0003\u0002\u0002\u0002\u14ef\u14f1\u0007\u0086\u0002\u0002\u14f0\u14f2\u0007\u0033\u0002\u0002\u14f1\u14f0\u0003\u0002\u0002\u0002\u14f1\u14f2\u0003\u0002\u0002\u0002\u14f2\u14f6\u0003\u0002\u0002\u0002\u14f3\u14f7\u0007\u01b9\u0002\u0002\u14f4\u14f7\u0005\u0434\u021b\u0002\u14f5\u14f7\u0005\u0496\u024c\u0002\u14f6\u14f3\u0003\u0002\u0002\u0002\u14f6\u14f4\u0003\u0002\u0002\u0002\u14f6\u14f5\u0003\u0002\u0002\u0002\u14f7\u03ad\u0003\u0002\u0002\u0002\u14f8\u14fb\u0007\u00d6\u0002\u0002\u14f9\u14fc\u0005\u0434\u021b\u0002\u14fa\u14fc\u0005\u0496\u024c\u0002\u14fb\u14f9\u0003\u0002\u0002\u0002\u14fb\u14fa\u0003\u0002\u0002\u0002\u14fc\u03af\u0003\u0002\u0002\u0002\u14fd\u14fe\u0007\u00fd\u0002\u0002\u14fe\u14ff\u0005\u0434\u021b\u0002\u14ff\u03b1\u0003\u0002\u0002\u0002\u1500\u1502\u0007\u0204\u0002\u0002\u1501\u1500\u0003\u0002\u0002\u0002\u1501\u1502\u0003\u0002\u0002\u0002\u1502\u1503\u0003\u0002\u0002\u0002\u1503\u1504\u0007\u015f\u0002\u0002\u1504\u1505\u0005\u0444\u0223\u0002\u1505\u03b3\u0003\u0002\u0002\u0002\u1506\u150a\u0007\u01d1\u0002\u0002\u1507\u150b\u0005\u03b6\u01dc\u0002\u1508\u150b\u0005\u03b8\u01dd\u0002\u1509\u150b\u0005\u03ba\u01de\u0002\u150a\u1507\u0003\u0002\u0002\u0002\u150a\u1508\u0003\u0002\u0002\u0002\u150a\u1509\u0003\u0002\u0002\u0002\u150b\u150d\u0003\u0002\u0002\u0002\u150c\u150e\u0005\u0402\u0202\u0002\u150d\u150c\u0003\u0002\u0002\u0002\u150d\u150e\u0003\u0002\u0002\u0002\u150e\u1510\u0003\u0002\u0002\u0002\u150f\u1511\u0005\u0404\u0203\u0002\u1510\u150f\u0003\u0002\u0002\u0002\u1510\u1511\u0003\u0002\u0002\u0002\u1511\u1513\u0003\u0002\u0002\u0002\u1512\u1514\u0007\u00b3\u0002\u0002\u1513\u1512\u0003\u0002\u0002\u0002\u1513\u1514\u0003\u0002\u0002\u0002\u1514\u03b5\u0003\u0002\u0002\u0002\u1515\u1517\u0005\u03bc\u01df\u0002\u1516\u1515\u0003\u0002\u0002\u0002\u1517\u1518\u0003\u0002\u0002\u0002\u1518\u1516\u0003\u0002\u0002\u0002\u1518\u1519\u0003\u0002\u0002\u0002\u1519\u151a\u0003\u0002\u0002\u0002\u151a\u151c\u0007\u00d9\u0002\u0002\u151b\u151d\u0005\u03be\u01e0\u0002\u151c\u151b\u0003\u0002\u0002\u0002\u151d\u151e\u0003\u0002\u0002\u0002\u151e\u151c\u0003\u0002\u0002\u0002\u151e\u151f\u0003\u0002\u0002\u0002\u151f\u03b7\u0003\u0002\u0002\u0002\u1520\u1522\u0005\u03bc\u01df\u0002\u1521\u1520\u0003\u0002\u0002\u0002\u1522\u1523\u0003\u0002\u0002\u0002\u1523\u1521\u0003\u0002\u0002\u0002\u1523\u1524\u0003\u0002\u0002\u0002\u1524\u1525\u0003\u0002\u0002\u0002\u1525\u1526\u0007\u00d9\u0002\u0002\u1526\u1527\u0005\u03c0\u01e1\u0002\u1527\u1529\u0007\u00e0\u0002\u0002\u1528\u152a\u0005\u03c2\u01e2\u0002\u1529\u1528\u0003\u0002\u0002\u0002\u152a\u152b\u0003\u0002\u0002\u0002\u152b\u1529\u0003\u0002\u0002\u0002\u152b\u152c\u0003\u0002\u0002\u0002\u152c\u03b9\u0003\u0002\u0002\u0002\u152d\u152e\u0009\u0034\u0002\u0002\u152e\u152f\u0005\u0444\u0223\u0002\u152f\u1530\u0007\u00d9\u0002\u0002\u1530\u1531\u0005\u03c4\u01e3\u0002\u1531\u03bb\u0003\u0002\u0002\u0002\u1532\u1535\u0005\u0434\u021b\u0002\u1533\u1535\u0005\u0496\u024c\u0002\u1534\u1532\u0003\u0002\u0002\u0002\u1534\u1533\u0003\u0002\u0002\u0002\u1535\u03bd\u0003\u0002\u0002\u0002\u1536\u1538\u0005\u0434\u021b\u0002\u1537\u1539\u0007\u019e\u0002\u0002\u1538\u1537\u0003\u0002\u0002\u0002\u1538\u1539\u0003\u0002\u0002\u0002\u1539\u03bf\u0003\u0002\u0002\u0002\u153a\u153d\u0005\u0434\u021b\u0002\u153b\u153d\u0005\u0496\u024c\u0002\u153c\u153a\u0003\u0002\u0002\u0002\u153c\u153b\u0003\u0002\u0002\u0002\u153d\u03c1\u0003\u0002\u0002\u0002\u153e\u1540\u0005\u0434\u021b\u0002\u153f\u1541\u0007\u019e\u0002\u0002\u1540\u153f\u0003\u0002\u0002\u0002\u1540\u1541\u0003\u0002\u0002\u0002\u1541\u03c3\u0003\u0002\u0002\u0002\u1542\u1544\u0005\u0444\u0223\u0002\u1543\u1545\u0007\u019e\u0002\u0002\u1544\u1543\u0003\u0002\u0002\u0002\u1544\u1545\u0003\u0002\u0002\u0002\u1545\u03c5\u0003\u0002\u0002\u0002\u1546\u1547\u0007\u01de\u0002\u0002\u1547\u1548\u0005\u0486\u0244\u0002\u1548\u03c7\u0003\u0002\u0002\u0002\u1549\u154a\u0007\u01f6\u0002\u0002\u154a\u154b\u0005\u03ca\u01e6\u0002\u154b\u154d\u0005\u03d0\u01e9\u0002\u154c\u154e\u0005\u03d8\u01ed\u0002\u154d\u154c\u0003\u0002\u0002\u0002\u154d\u154e\u0003\u0002\u0002\u0002\u154e\u1550\u0003\u0002\u0002\u0002\u154f\u1551\u0005\u03da\u01ee\u0002\u1550\u154f\u0003\u0002\u0002\u0002\u1550\u1551\u0003\u0002\u0002\u0002\u1551\u1553\u0003\u0002\u0002\u0002\u1552\u1554\u0005\u03fe\u0200\u0002\u1553\u1552\u0003\u0002\u0002\u0002\u1553\u1554\u0003\u0002\u0002\u0002\u1554\u1556\u0003\u0002\u0002\u0002\u1555\u1557\u0005\u0400\u0201\u0002\u1556\u1555\u0003\u0002\u0002\u0002\u1556\u1557\u0003\u0002\u0002\u0002\u1557\u1559\u0003\u0002\u0002\u0002\u1558\u155a\u0007\u00b4\u0002\u0002\u1559\u1558\u0003\u0002\u0002\u0002\u1559\u155a\u0003\u0002\u0002\u0002\u155a\u03c9\u0003\u0002\u0002\u0002\u155b\u1563\u0005\u0434\u021b\u0002\u155c\u1560\u0005\u03cc\u01e7\u0002\u155d\u155f\u0005\u03ce\u01e8\u0002\u155e\u155d\u0003\u0002\u0002\u0002\u155f\u1562\u0003\u0002\u0002\u0002\u1560\u155e\u0003\u0002\u0002\u0002\u1560\u1561\u0003\u0002\u0002\u0002\u1561\u1564\u0003\u0002\u0002\u0002\u1562\u1560\u0003\u0002\u0002\u0002\u1563\u155c\u0003\u0002\u0002\u0002\u1563\u1564\u0003\u0002\u0002\u0002\u1564\u03cb\u0003\u0002\u0002\u0002\u1565\u1567\u0007\u0086\u0002\u0002\u1566\u1568\u0007\u0033\u0002\u0002\u1567\u1566\u0003\u0002\u0002\u0002\u1567\u1568\u0003\u0002\u0002\u0002\u1568\u156a\u0003\u0002\u0002\u0002\u1569\u156b\u0007\u000b\u0002\u0002\u156a\u1569\u0003\u0002\u0002\u0002\u156a\u156b\u0003\u0002\u0002\u0002\u156b\u156e\u0003\u0002\u0002\u0002\u156c\u156f\u0005\u0434\u021b\u0002\u156d\u156f\u0005\u0496\u024c\u0002\u156e\u156c\u0003\u0002\u0002\u0002\u156e\u156d\u0003\u0002\u0002\u0002\u156f\u03cd\u0003\u0002\u0002\u0002\u1570\u1572\u0007\u014b\u0002\u0002\u1571\u1573\u0007\u000b\u0002\u0002\u1572\u1571\u0003\u0002\u0002\u0002\u1572\u1573\u0003\u0002\u0002\u0002\u1573\u1576\u0003\u0002\u0002\u0002\u1574\u1577\u0005\u0434\u021b\u0002\u1575\u1577\u0005\u0496\u024c\u0002\u1576\u1574\u0003\u0002\u0002\u0002\u1576\u1575\u0003\u0002\u0002\u0002\u1577\u03cf\u0003\u0002\u0002\u0002\u1578\u157a\u0007\u00fd\u0002\u0002\u1579\u157b\u0005\u03d2\u01ea\u0002\u157a\u1579\u0003\u0002\u0002\u0002\u157b\u157c\u0003\u0002\u0002\u0002\u157c\u157a\u0003\u0002\u0002\u0002\u157c\u157d\u0003\u0002\u0002\u0002\u157d\u03d1\u0003\u0002\u0002\u0002\u157e\u1580\u0005\u0434\u021b\u0002\u157f\u1581\u0005\u03d4\u01eb\u0002\u1580\u157f\u0003\u0002\u0002\u0002\u1580\u1581\u0003\u0002\u0002\u0002\u1581\u1583\u0003\u0002\u0002\u0002\u1582\u1584\u0005\u03d6\u01ec\u0002\u1583\u1582\u0003\u0002\u0002\u0002\u1583\u1584\u0003\u0002\u0002\u0002\u1584\u03d3\u0003\u0002\u0002\u0002\u1585\u1587\u0007\u0087\u0002\u0002\u1586\u1588\u0007\u00f1\u0002\u0002\u1587\u1586\u0003\u0002\u0002\u0002\u1587\u1588\u0003\u0002\u0002\u0002\u1588\u1589\u0003\u0002\u0002\u0002\u1589\u158a\u0005\u0434\u021b\u0002\u158a\u03d5\u0003\u0002\u0002\u0002\u158b\u158d\u0007\u006b\u0002\u0002\u158c\u158e\u0007\u00f1\u0002\u0002\u158d\u158c\u0003\u0002\u0002\u0002\u158d\u158e\u0003\u0002\u0002\u0002\u158e\u158f\u0003\u0002\u0002\u0002\u158f\u1590\u0005\u0434\u021b\u0002\u1590\u03d7\u0003\u0002\u0002\u0002\u1591\u1593\u0007\u0204\u0002\u0002\u1592\u1591\u0003\u0002\u0002\u0002\u1592\u1593\u0003\u0002\u0002\u0002\u1593\u1594\u0003\u0002\u0002\u0002\u1594\u1595\u0007\u015f\u0002\u0002\u1595\u1596\u0005\u0444\u0223\u0002\u1596\u03d9\u0003\u0002\u0002\u0002\u1597\u1599\u0007\u01da\u0002\u0002\u1598\u159a\u0007\u00f1\u0002\u0002\u1599\u1598\u0003\u0002\u0002\u0002\u1599\u159a\u0003\u0002\u0002\u0002\u159a\u159b\u0003\u0002\u0002\u0002\u159b\u159c\u0005\u0444\u0223\u0002\u159c\u03db\u0003\u0002\u0002\u0002\u159d\u15a0\u0007\u01fb\u0002\u0002\u159e\u15a1\u0005\u03de\u01f0\u0002\u159f\u15a1\u0005\u03e2\u01f2\u0002\u15a0\u159e\u0003\u0002\u0002\u0002\u15a0\u159f\u0003\u0002\u0002\u0002\u15a1\u03dd\u0003\u0002\u0002\u0002\u15a2\u15a4\u0007\u00e1\u0002\u0002\u15a3\u15a2\u0003\u0002\u0002\u0002\u15a3\u15a4\u0003\u0002\u0002\u0002\u15a4\u15a5\u0003\u0002\u0002\u0002\u15a5\u15a7\u0007\u0009\u0002\u0002\u15a6\u15a8\u0007\u01c7\u0002\u0002\u15a7\u15a6\u0003\u0002\u0002\u0002\u15a7\u15a8\u0003\u0002\u0002\u0002\u15a8\u15a9\u0003\u0002\u0002\u0002\u15a9\u15aa\u0009\u003e\u0002\u0002\u15aa\u15ac\u0007\u0166\u0002\u0002\u15ab\u15ad\u0007\u0148\u0002\u0002\u15ac\u15ab\u0003\u0002\u0002\u0002\u15ac\u15ad\u0003\u0002\u0002\u0002\u15ad\u15ae\u0003\u0002\u0002\u0002\u15ae\u15af\u0005\u03e0\u01f1\u0002\u15af\u03df\u0003\u0002\u0002\u0002\u15b0\u15ba\u0007\u00f8\u0002\u0002\u15b1\u15ba\u0007\u0150\u0002\u0002\u15b2\u15ba\u0007\u00ea\u0002\u0002\u15b3\u15ba\u0007\u00cb\u0002\u0002\u15b4\u15b6\u0005\u0470\u0239\u0002\u15b5\u15b4\u0003\u0002\u0002\u0002\u15b6\u15b7\u0003\u0002\u0002\u0002\u15b7\u15b5\u0003\u0002\u0002\u0002\u15b7\u15b8\u0003\u0002\u0002\u0002\u15b8\u15ba\u0003\u0002\u0002\u0002\u15b9\u15b0\u0003\u0002\u0002\u0002\u15b9\u15b1\u0003\u0002\u0002\u0002\u15b9\u15b2\u0003\u0002\u0002\u0002\u15b9\u15b3\u0003\u0002\u0002\u0002\u15b9\u15b5\u0003\u0002\u0002\u0002\u15ba\u03e1\u0003\u0002\u0002\u0002\u15bb\u15bd\u0007\u00d6\u0002\u0002\u15bc\u15bb\u0003\u0002\u0002\u0002\u15bc\u15bd\u0003\u0002\u0002\u0002\u15bd\u15be\u0003\u0002\u0002\u0002\u15be\u15c0\u0007\u007f\u0002\u0002\u15bf\u15c1\u0007\u0148\u0002\u0002\u15c0\u15bf\u0003\u0002\u0002\u0002\u15c0\u15c1\u0003\u0002\u0002\u0002\u15c1\u15c3\u0003\u0002\u0002\u0002\u15c2\u15c4\u0005\u03e4\u01f3\u0002\u15c3\u15c2\u0003\u0002\u0002\u0002\u15c4\u15c5\u0003\u0002\u0002\u0002\u15c5\u15c3\u0003\u0002\u0002\u0002\u15c5\u15c6\u0003\u0002\u0002\u0002\u15c6\u03e3\u0003\u0002\u0002\u0002\u15c7\u15c8\u0007\u000b\u0002\u0002\u15c8\u15d4\u0007\u0168\u0002\u0002\u15c9\u15cb\u0007\u000b\u0002\u0002\u15ca\u15cc\u0007\u0183\u0002\u0002\u15cb\u15ca\u0003\u0002\u0002\u0002\u15cb\u15cc\u0003\u0002\u0002\u0002\u15cc\u15ce\u0003\u0002\u0002\u0002\u15cd\u15cf\u0007\u0145\u0002\u0002\u15ce\u15cd\u0003\u0002\u0002\u0002\u15ce\u15cf\u0003\u0002\u0002\u0002\u15cf\u15d0\u0003\u0002\u0002\u0002\u15d0\u15d4\u0005\u0434\u021b\u0002\u15d1\u15d4\u0005\u0480\u0241\u0002\u15d2\u15d4\u0005\u0470\u0239\u0002\u15d3\u15c7\u0003\u0002\u0002\u0002\u15d3\u15c9\u0003\u0002\u0002\u0002\u15d3\u15d1\u0003\u0002\u0002\u0002\u15d3\u15d2\u0003\u0002\u0002\u0002\u15d4\u03e5\u0003\u0002\u0002\u0002\u15d5\u15d6\u0007\u0207\u0002\u0002\u15d6\u15d8\u0005\u0484\u0243\u0002\u15d7\u15d9\u0005\u03e8\u01f5\u0002\u15d8\u15d7\u0003\u0002\u0002\u0002\u15d8\u15d9\u0003\u0002\u0002\u0002\u15d9\u15db\u0003\u0002\u0002\u0002\u15da\u15dc\u0005\u03ea\u01f6\u0002\u15db\u15da\u0003\u0002\u0002\u0002\u15db\u15dc\u0003\u0002\u0002\u0002\u15dc\u15de\u0003\u0002\u0002\u0002\u15dd\u15df\u0005\u03f2\u01fa\u0002\u15de\u15dd\u0003\u0002\u0002\u0002\u15de\u15df\u0003\u0002\u0002\u0002\u15df\u15e1\u0003\u0002\u0002\u0002\u15e0\u15e2\u0005\u03f4\u01fb\u0002\u15e1\u15e0\u0003\u0002\u0002\u0002\u15e1\u15e2\u0003\u0002\u0002\u0002\u15e2\u15e4\u0003\u0002\u0002\u0002\u15e3\u15e5\u0005\u03fa\u01fe\u0002\u15e4\u15e3\u0003\u0002\u0002\u0002\u15e4\u15e5\u0003\u0002\u0002\u0002\u15e5\u15e7\u0003\u0002\u0002\u0002\u15e6\u15e8\u0005\u03fc\u01ff\u0002\u15e7\u15e6\u0003\u0002\u0002\u0002\u15e7\u15e8\u0003\u0002\u0002\u0002\u15e8\u15ea\u0003\u0002\u0002\u0002\u15e9\u15eb\u0007\u00b5\u0002\u0002\u15ea\u15e9\u0003\u0002\u0002\u0002\u15ea\u15eb\u0003\u0002\u0002\u0002\u15eb\u03e7\u0003\u0002\u0002\u0002\u15ec\u15ef\u0007\u00d9\u0002\u0002\u15ed\u15f0\u0005\u0434\u021b\u0002\u15ee\u15f0\u0005\u0496\u024c\u0002\u15ef\u15ed\u0003\u0002\u0002\u0002\u15ef\u15ee\u0003\u0002\u0002\u0002\u15f0\u03e9\u0003\u0002\u0002\u0002\u15f1\u15f3\u0009\u003a\u0002\u0002\u15f2\u15f4\u0007\u0008\u0002\u0002\u15f3\u15f2\u0003\u0002\u0002\u0002\u15f3\u15f4\u0003\u0002\u0002\u0002\u15f4\u15f8\u0003\u0002\u0002\u0002\u15f5\u15f9\u0005\u03ec\u01f7\u0002\u15f6\u15f9\u0005\u03ee\u01f8\u0002\u15f7\u15f9\u0005\u03f0\u01f9\u0002\u15f8\u15f5\u0003\u0002\u0002\u0002\u15f8\u15f6\u0003\u0002\u0002\u0002\u15f8\u15f7\u0003\u0002\u0002\u0002\u15f9\u03eb\u0003\u0002\u0002\u0002\u15fa\u15fb\u0007\u0156\u0002\u0002\u15fb\u03ed\u0003\u0002\u0002\u0002\u15fc\u15ff\u0005\u0434\u021b\u0002\u15fd\u15ff\u0005\u0496\u024c\u0002\u15fe\u15fc\u0003\u0002\u0002\u0002\u15fe\u15fd\u0003\u0002\u0002\u0002\u15ff\u1601\u0003\u0002\u0002\u0002\u1600\u1602\u0009\u0023\u0002\u0002\u1601\u1600\u0003\u0002\u0002\u0002\u1601\u1602\u0003\u0002\u0002\u0002\u1602\u03ef\u0003\u0002\u0002\u0002\u1603\u1604\u0005\u047c\u023f\u0002\u1604\u03f1\u0003\u0002\u0002\u0002\u1605\u1607\u0007\u0020\u0002\u0002\u1606\u1605\u0003\u0002\u0002\u0002\u1606\u1607\u0003\u0002\u0002\u0002\u1607\u1608\u0003\u0002\u0002\u0002\u1608\u160c\u0009\u003f\u0002\u0002\u1609\u160b\u0005\u021a\u010e\u0002\u160a\u1609\u0003\u0002\u0002\u0002\u160b\u160e\u0003\u0002\u0002\u0002\u160c\u160a\u0003\u0002\u0002\u0002\u160c\u160d\u0003\u0002\u0002\u0002\u160d\u03f3\u0003\u0002\u0002\u0002\u160e\u160c\u0003\u0002\u0002\u0002\u160f\u1611\u0007\u013a\u0002\u0002\u1610\u1612\u0007\u0020\u0002\u0002\u1611\u1610\u0003\u0002\u0002\u0002\u1611\u1612\u0003\u0002\u0002\u0002\u1612\u1613\u0003\u0002\u0002\u0002\u1613\u1617\u0009\u003f\u0002\u0002\u1614\u1616\u0005\u021a\u010e\u0002\u1615\u1614\u0003\u0002\u0002\u0002\u1616\u1619\u0003\u0002\u0002\u0002\u1617\u1615\u0003\u0002\u0002\u0002\u1617\u1618\u0003\u0002\u0002\u0002\u1618\u03f5\u0003\u0002\u0002\u0002\u1619\u1617\u0003\u0002\u0002\u0002\u161a\u161c\u0007\u0020\u0002\u0002\u161b\u161a\u0003\u0002\u0002\u0002\u161b\u161c\u0003\u0002\u0002\u0002\u161c\u161d\u0003\u0002\u0002\u0002\u161d\u1621\u0007\u00a0\u0002\u0002\u161e\u1620\u0005\u021a\u010e\u0002\u161f\u161e\u0003\u0002\u0002\u0002\u1620\u1623\u0003\u0002\u0002\u0002\u1621\u161f\u0003\u0002\u0002\u0002\u1621\u1622\u0003\u0002\u0002\u0002\u1622\u03f7\u0003\u0002\u0002\u0002\u1623\u1621\u0003\u0002\u0002\u0002\u1624\u1626\u0007\u013a\u0002\u0002\u1625\u1627\u0007\u0020\u0002\u0002\u1626\u1625\u0003\u0002\u0002\u0002\u1626\u1627\u0003\u0002\u0002\u0002\u1627\u1628\u0003\u0002\u0002\u0002\u1628\u162c\u0007\u00a0\u0002\u0002\u1629\u162b\u0005\u021a\u010e\u0002\u162a\u1629\u0003\u0002\u0002\u0002\u162b\u162e\u0003\u0002\u0002\u0002\u162c\u162a\u0003\u0002\u0002\u0002\u162c\u162d\u0003\u0002\u0002\u0002\u162d\u03f9\u0003\u0002\u0002\u0002\u162e\u162c\u0003\u0002\u0002\u0002\u162f\u1631\u0007\u00fe\u0002\u0002\u1630\u1632\u0007\u0105\u0002\u0002\u1631\u1630\u0003\u0002\u0002\u0002\u1631\u1632\u0003\u0002\u0002\u0002\u1632\u1636\u0003\u0002\u0002\u0002\u1633\u1635\u0005\u021a\u010e\u0002\u1634\u1633\u0003\u0002\u0002\u0002\u1635\u1638\u0003\u0002\u0002\u0002\u1636\u1634\u0003\u0002\u0002\u0002\u1636\u1637\u0003\u0002\u0002\u0002\u1637\u03fb\u0003\u0002\u0002\u0002\u1638\u1636\u0003\u0002\u0002\u0002\u1639\u163a\u0007\u013a\u0002\u0002\u163a\u163c\u0007\u00fe\u0002\u0002\u163b\u163d\u0007\u0105\u0002\u0002\u163c\u163b\u0003\u0002\u0002\u0002\u163c\u163d\u0003\u0002\u0002\u0002\u163d\u1641\u0003\u0002\u0002\u0002\u163e\u1640\u0005\u021a\u010e\u0002\u163f\u163e\u0003\u0002\u0002\u0002\u1640\u1643\u0003\u0002\u0002\u0002\u1641\u163f\u0003\u0002\u0002\u0002\u1641\u1642\u0003\u0002\u0002\u0002\u1642\u03fd\u0003\u0002\u0002\u0002\u1643\u1641\u0003\u0002\u0002\u0002\u1644\u1646\u0007\u0148\u0002\u0002\u1645\u1644\u0003\u0002\u0002\u0002\u1645\u1646\u0003\u0002\u0002\u0002\u1646\u1647\u0003\u0002\u0002\u0002\u1647\u164b\u0007\u0151\u0002\u0002\u1648\u164a\u0005\u021a\u010e\u0002\u1649\u1648\u0003\u0002\u0002\u0002\u164a\u164d\u0003\u0002\u0002\u0002\u164b\u1649\u0003\u0002\u0002\u0002\u164b\u164c\u0003\u0002\u0002\u0002\u164c\u03ff\u0003\u0002\u0002\u0002\u164d\u164b\u0003\u0002\u0002\u0002\u164e\u1650\u0007\u013a\u0002\u0002\u164f\u1651\u0007\u0148\u0002\u0002\u1650\u164f\u0003\u0002\u0002\u0002\u1650\u1651\u0003\u0002\u0002\u0002\u1651\u1652\u0003\u0002\u0002\u0002\u1652\u1656\u0007\u0151\u0002\u0002\u1653\u1655\u0005\u021a\u010e\u0002\u1654\u1653\u0003\u0002\u0002\u0002\u1655\u1658\u0003\u0002\u0002\u0002\u1656\u1654\u0003\u0002\u0002\u0002\u1656\u1657\u0003\u0002\u0002\u0002\u1657\u0401\u0003\u0002\u0002\u0002\u1658\u1656\u0003\u0002\u0002\u0002\u1659\u165b\u0007\u0148\u0002\u0002\u165a\u1659\u0003\u0002\u0002\u0002\u165a\u165b\u0003\u0002\u0002\u0002\u165b\u165c\u0003\u0002\u0002\u0002\u165c\u165d\u0007\u01b9\u0002\u0002\u165d\u1661\u0007\u00be\u0002\u0002\u165e\u1660\u0005\u021a\u010e\u0002\u165f\u165e\u0003\u0002\u0002\u0002\u1660\u1663\u0003\u0002\u0002\u0002\u1661\u165f\u0003\u0002\u0002\u0002\u1661\u1662\u0003\u0002\u0002\u0002\u1662\u0403\u0003\u0002\u0002\u0002\u1663\u1661\u0003\u0002\u0002\u0002\u1664\u1666\u0007\u013a\u0002\u0002\u1665\u1667\u0007\u0148\u0002\u0002\u1666\u1665\u0003\u0002\u0002\u0002\u1666\u1667\u0003\u0002\u0002\u0002\u1667\u1668\u0003\u0002\u0002\u0002\u1668\u1669\u0007\u01b9\u0002\u0002\u1669\u166d\u0007\u00be\u0002\u0002\u166a\u166c\u0005\u021a\u010e\u0002\u166b\u166a\u0003\u0002\u0002\u0002\u166c\u166f\u0003\u0002\u0002\u0002\u166d\u166b\u0003\u0002\u0002\u0002\u166d\u166e\u0003\u0002\u0002\u0002\u166e\u0405\u0003\u0002\u0002\u0002\u166f\u166d\u0003\u0002\u0002\u0002\u1670\u1672\u0007\u0148\u0002\u0002\u1671\u1670\u0003\u0002\u0002\u0002\u1671\u1672\u0003\u0002\u0002\u0002\u1672\u1673\u0003\u0002\u0002\u0002\u1673\u1677\u0007\u00c6\u0002\u0002\u1674\u1676\u0005\u021a\u010e\u0002\u1675\u1674\u0003\u0002\u0002\u0002\u1676\u1679\u0003\u0002\u0002\u0002\u1677\u1675\u0003\u0002\u0002\u0002\u1677\u1678\u0003\u0002\u0002\u0002\u1678\u0407\u0003\u0002\u0002\u0002\u1679\u1677\u0003\u0002\u0002\u0002\u167a\u167c\u0007\u013a\u0002\u0002\u167b\u167d\u0007\u0148\u0002\u0002\u167c\u167b\u0003\u0002\u0002\u0002\u167c\u167d\u0003\u0002\u0002\u0002\u167d\u167e\u0003\u0002\u0002\u0002\u167e\u1682\u0007\u00c6\u0002\u0002\u167f\u1681\u0005\u021a\u010e\u0002\u1680\u167f\u0003\u0002\u0002\u0002\u1681\u1684\u0003\u0002\u0002\u0002\u1682\u1680\u0003\u0002\u0002\u0002\u1682\u1683\u0003\u0002\u0002\u0002\u1683\u0409\u0003\u0002\u0002\u0002\u1684\u1682\u0003\u0002\u0002\u0002\u1685\u1689\u0005\u040e\u0208\u0002\u1686\u1688\u0005\u040c\u0207\u0002\u1687\u1686\u0003\u0002\u0002\u0002\u1688\u168b\u0003\u0002\u0002\u0002\u1689\u1687\u0003\u0002\u0002\u0002\u1689\u168a\u0003\u0002\u0002\u0002\u168a\u040b\u0003\u0002\u0002\u0002\u168b\u1689\u0003\u0002\u0002\u0002\u168c\u168d\u0009\u0040\u0002\u0002\u168d\u168e\u0005\u040e\u0208\u0002\u168e\u040d\u0003\u0002\u0002\u0002\u168f\u1693\u0005\u0412\u020a\u0002\u1690\u1692\u0005\u0410\u0209\u0002\u1691\u1690\u0003\u0002\u0002\u0002\u1692\u1695\u0003\u0002\u0002\u0002\u1693\u1691\u0003\u0002\u0002\u0002\u1693\u1694\u0003\u0002\u0002\u0002\u1694\u040f\u0003\u0002\u0002\u0002\u1695\u1693\u0003\u0002\u0002\u0002\u1696\u1697\u0009\u0041\u0002\u0002\u1697\u1698\u0005\u0412\u020a\u0002\u1698\u0411\u0003\u0002\u0002\u0002\u1699\u169b\u0009\u0040\u0002\u0002\u169a\u1699\u0003\u0002\u0002\u0002\u169a\u169b\u0003\u0002\u0002\u0002\u169b\u169c\u0003\u0002\u0002\u0002\u169c\u16a0\u0005\u0416\u020c\u0002\u169d\u169f\u0005\u0414\u020b\u0002\u169e\u169d\u0003\u0002\u0002\u0002\u169f\u16a2\u0003\u0002\u0002\u0002\u16a0\u169e\u0003\u0002\u0002\u0002\u16a0\u16a1\u0003\u0002\u0002\u0002\u16a1\u0413\u0003\u0002\u0002\u0002\u16a2\u16a0\u0003\u0002\u0002\u0002\u16a3\u16a4\u0007\u0211\u0002\u0002\u16a4\u16a5\u0005\u0416\u020c\u0002\u16a5\u0415\u0003\u0002\u0002\u0002\u16a6\u16a7\u0007\u0220\u0002\u0002\u16a7\u16a8\u0005\u040a\u0206\u0002\u16a8\u16a9\u0007\u0227\u0002\u0002\u16a9\u16ad\u0003\u0002\u0002\u0002\u16aa\u16ad\u0005\u0434\u021b\u0002\u16ab\u16ad\u0005\u0496\u024c\u0002\u16ac\u16a6\u0003\u0002\u0002\u0002\u16ac\u16aa\u0003\u0002\u0002\u0002\u16ac\u16ab\u0003\u0002\u0002\u0002\u16ad\u0417\u0003\u0002\u0002\u0002\u16ae\u16b2\u0005\u041c\u020f\u0002\u16af\u16b1\u0005\u041a\u020e\u0002\u16b0\u16af\u0003\u0002\u0002\u0002\u16b1\u16b4\u0003\u0002\u0002\u0002\u16b2\u16b0\u0003\u0002\u0002\u0002\u16b2\u16b3\u0003\u0002\u0002\u0002\u16b3\u0419\u0003\u0002\u0002\u0002\u16b4\u16b2\u0003\u0002\u0002\u0002\u16b5\u16bc\u0009\u0042\u0002\u0002\u16b6\u16bd\u0005\u041c\u020f\u0002\u16b7\u16b9\u0005\u0432\u021a\u0002\u16b8\u16b7\u0003\u0002\u0002\u0002\u16b9\u16ba\u0003\u0002\u0002\u0002\u16ba\u16b8\u0003\u0002\u0002\u0002\u16ba\u16bb\u0003\u0002\u0002\u0002\u16bb\u16bd\u0003\u0002\u0002\u0002\u16bc\u16b6\u0003\u0002\u0002\u0002\u16bc\u16b8\u0003\u0002\u0002\u0002\u16bd\u041b\u0003\u0002\u0002\u0002\u16be\u16c0\u0007\u013a\u0002\u0002\u16bf\u16be\u0003\u0002\u0002\u0002\u16bf\u16c0\u0003\u0002\u0002\u0002\u16c0\u16c1\u0003\u0002\u0002\u0002\u16c1\u16c2\u0005\u041e\u0210\u0002\u16c2\u041d\u0003\u0002\u0002\u0002\u16c3\u16c4\u0007\u0220\u0002\u0002\u16c4\u16c5\u0005\u0418\u020d\u0002\u16c5\u16c6\u0007\u0227\u0002\u0002\u16c6\u16cb\u0003\u0002\u0002\u0002\u16c7\u16cb\u0005\u0426\u0214\u0002\u16c8\u16cb\u0005\u0420\u0211\u0002\u16c9\u16cb\u0005\u0422\u0212\u0002\u16ca\u16c3\u0003\u0002\u0002\u0002\u16ca\u16c7\u0003\u0002\u0002\u0002\u16ca\u16c8\u0003\u0002\u0002\u0002\u16ca\u16c9\u0003\u0002\u0002\u0002\u16cb\u041f\u0003\u0002\u0002\u0002\u16cc\u16ce\u0005\u0434\u021b\u0002\u16cd\u16cf\u0007\u0100\u0002\u0002\u16ce\u16cd\u0003\u0002\u0002\u0002\u16ce\u16cf\u0003\u0002\u0002\u0002\u16cf\u16d1\u0003\u0002\u0002\u0002\u16d0\u16d2\u0007\u013a\u0002\u0002\u16d1\u16d0\u0003\u0002\u0002\u0002\u16d1\u16d2\u0003\u0002\u0002\u0002\u16d2\u16da\u0003\u0002\u0002\u0002\u16d3\u16db\u0007\u013e\u0002\u0002\u16d4\u16db\u0007\u000d\u0002\u0002\u16d5\u16db\u0007\u000e\u0002\u0002\u16d6\u16db\u0007\u000f\u0002\u0002\u16d7\u16db\u0007\u0076\u0002\u0002\u16d8\u16db\u0007\u0103\u0002\u0002\u16d9\u16db\u0005\u0464\u0233\u0002\u16da\u16d3\u0003\u0002\u0002\u0002\u16da\u16d4\u0003\u0002\u0002\u0002\u16da\u16d5\u0003\u0002\u0002\u0002\u16da\u16d6\u0003\u0002\u0002\u0002\u16da\u16d7\u0003\u0002\u0002\u0002\u16da\u16d8\u0003\u0002\u0002\u0002\u16da\u16d9\u0003\u0002\u0002\u0002\u16db\u0421\u0003\u0002\u0002\u0002\u16dc\u16f2\u0005\u0468\u0235\u0002\u16dd\u16df\u0005\u0450\u0229\u0002\u16de\u16dd\u0003\u0002\u0002\u0002\u16df\u16e2\u0003\u0002\u0002\u0002\u16e0\u16de\u0003\u0002\u0002\u0002\u16e0\u16e1\u0003\u0002\u0002\u0002\u16e1\u16e4\u0003\u0002\u0002\u0002\u16e2\u16e0\u0003\u0002\u0002\u0002\u16e3\u16e5\u0005\u0452\u022a\u0002\u16e4\u16e3\u0003\u0002\u0002\u0002\u16e4\u16e5\u0003\u0002\u0002\u0002\u16e5\u16e9\u0003\u0002\u0002\u0002\u16e6\u16e8\u0005\u0424\u0213\u0002\u16e7\u16e6\u0003\u0002\u0002\u0002\u16e8\u16eb\u0003\u0002\u0002\u0002\u16e9\u16e7\u0003\u0002\u0002\u0002\u16e9\u16ea\u0003\u0002\u0002\u0002\u16ea\u16f3\u0003\u0002\u0002\u0002\u16eb\u16e9\u0003\u0002\u0002\u0002\u16ec\u16ee\u0005\u0454\u022b\u0002\u16ed\u16ec\u0003\u0002\u0002\u0002\u16ee\u16f1\u0003\u0002\u0002\u0002\u16ef\u16ed\u0003\u0002\u0002\u0002\u16ef\u16f0\u0003\u0002\u0002\u0002\u16f0\u16f3\u0003\u0002\u0002\u0002\u16f1\u16ef\u0003\u0002\u0002\u0002\u16f2\u16e0\u0003\u0002\u0002\u0002\u16f2\u16ef\u0003\u0002\u0002\u0002\u16f3\u0423\u0003\u0002\u0002\u0002\u16f4\u16f5\u0007\u0220\u0002\u0002\u16f5\u16fc\u0005\u0440\u0221\u0002\u16f6\u16f8\u0007\u0213\u0002\u0002\u16f7\u16f6\u0003\u0002\u0002\u0002\u16f7\u16f8\u0003\u0002\u0002\u0002\u16f8\u16f9\u0003\u0002\u0002\u0002\u16f9\u16fb\u0005\u0440\u0221\u0002\u16fa\u16f7\u0003\u0002\u0002\u0002\u16fb\u16fe\u0003\u0002\u0002\u0002\u16fc\u16fa\u0003\u0002\u0002\u0002\u16fc\u16fd\u0003\u0002\u0002\u0002\u16fd\u16ff\u0003\u0002\u0002\u0002\u16fe\u16fc\u0003\u0002\u0002\u0002\u16ff\u1700\u0007\u0227\u0002\u0002\u1700\u0425\u0003\u0002\u0002\u0002\u1701\u1705\u0005\u0428\u0215\u0002\u1702\u1705\u0005\u042a\u0216\u0002\u1703\u1705\u0005\u042c\u0217\u0002\u1704\u1701\u0003\u0002\u0002\u0002\u1704\u1702\u0003\u0002\u0002\u0002\u1704\u1703\u0003\u0002\u0002\u0002\u1705\u0427\u0003\u0002\u0002\u0002\u1706\u1708\u0005\u040a\u0206\u0002\u1707\u1709\u0007\u0100\u0002\u0002\u1708\u1707\u0003\u0002\u0002\u0002\u1708\u1709\u0003\u0002\u0002\u0002\u1709\u170b\u0003\u0002\u0002\u0002\u170a\u170c\u0007\u013a\u0002\u0002\u170b\u170a\u0003\u0002\u0002\u0002\u170b\u170c\u0003\u0002\u0002\u0002\u170c\u170d\u0003\u0002\u0002\u0002\u170d\u170e\u0009\u0043\u0002\u0002\u170e\u0429\u0003\u0002\u0002\u0002\u170f\u1710\u0005\u040a\u0206\u0002\u1710\u1711\u0005\u0430\u0219\u0002\u1711\u1712\u0005\u040a\u0206\u0002\u1712\u042b\u0003\u0002\u0002\u0002\u1713\u1714\u0005\u040a\u0206\u0002\u1714\u1715\u0005\u0430\u0219\u0002\u1715\u1716\u0007\u0220\u0002\u0002\u1716\u1717\u0005\u042e\u0218\u0002\u1717\u1718\u0007\u0227\u0002\u0002\u1718\u042d\u0003\u0002\u0002\u0002\u1719\u171c\u0005\u040a\u0206\u0002\u171a\u171b\u0009\u0042\u0002\u0002\u171b\u171d\u0005\u040a\u0206\u0002\u171c\u171a\u0003\u0002\u0002\u0002\u171d\u171e\u0003\u0002\u0002\u0002\u171e\u171c\u0003\u0002\u0002\u0002\u171e\u171f\u0003\u0002\u0002\u0002\u171f\u042f\u0003\u0002\u0002\u0002\u1720\u1722\u0009\u000a\u0002\u0002\u1721\u1720\u0003\u0002\u0002\u0002\u1721\u1722\u0003\u0002\u0002\u0002\u1722\u174c\u0003\u0002\u0002\u0002\u1723\u1725\u0007\u013a\u0002\u0002\u1724\u1723\u0003\u0002\u0002\u0002\u1724\u1725\u0003\u0002\u0002\u0002\u1725\u1735\u0003\u0002\u0002\u0002\u1726\u1728\u0007\u00e3\u0002\u0002\u1727\u1729\u0007\u01e1\u0002\u0002\u1728\u1727\u0003\u0002\u0002\u0002\u1728\u1729\u0003\u0002\u0002\u0002\u1729\u1736\u0003\u0002\u0002\u0002\u172a\u1736\u0007\u0222\u0002\u0002\u172b\u172d\u0007\u0111\u0002\u0002\u172c\u172e\u0007\u01e1\u0002\u0002\u172d\u172c\u0003\u0002\u0002\u0002\u172d\u172e\u0003\u0002\u0002\u0002\u172e\u1736\u0003\u0002\u0002\u0002\u172f\u1736\u0007\u021e\u0002\u0002\u1730\u1732\u0007\u00bc\u0002\u0002\u1731\u1733\u0007\u01eb\u0002\u0002\u1732\u1731\u0003\u0002\u0002\u0002\u1732\u1733\u0003\u0002\u0002\u0002\u1733\u1736\u0003\u0002\u0002\u0002\u1734\u1736\u0007\u021a\u0002\u0002\u1735\u1726\u0003\u0002\u0002\u0002\u1735\u172a\u0003\u0002\u0002\u0002\u1735\u172b\u0003\u0002\u0002\u0002\u1735\u172f\u0003\u0002\u0002\u0002\u1735\u1730\u0003\u0002\u0002\u0002\u1735\u1734\u0003\u0002\u0002\u0002\u1736\u174d\u0003\u0002\u0002\u0002\u1737\u174d\u0007\u0224\u0002\u0002\u1738\u173a\u0007\u00e3\u0002\u0002\u1739\u173b\u0007\u01e1\u0002\u0002\u173a\u1739\u0003\u0002\u0002\u0002\u173a\u173b\u0003\u0002\u0002\u0002\u173b\u173c\u0003\u0002\u0002\u0002\u173c\u173d\u0007\u014b\u0002\u0002\u173d\u173f\u0007\u00bc\u0002\u0002\u173e\u1740\u0007\u01eb\u0002\u0002\u173f\u173e\u0003\u0002\u0002\u0002\u173f\u1740\u0003\u0002\u0002\u0002\u1740\u174d\u0003\u0002\u0002\u0002\u1741\u174d\u0007\u0223\u0002\u0002\u1742\u1744\u0007\u0111\u0002\u0002\u1743\u1745\u0007\u01e1\u0002\u0002\u1744\u1743\u0003\u0002\u0002\u0002\u1744\u1745\u0003\u0002\u0002\u0002\u1745\u1746\u0003\u0002\u0002\u0002\u1746\u1747\u0007\u014b\u0002\u0002\u1747\u1749\u0007\u00bc\u0002\u0002\u1748\u174a\u0007\u01eb\u0002\u0002\u1749\u1748\u0003\u0002\u0002\u0002\u1749\u174a\u0003\u0002\u0002\u0002\u174a\u174d\u0003\u0002\u0002\u0002\u174b\u174d\u0007\u021f\u0002\u0002\u174c\u1724\u0003\u0002\u0002\u0002\u174c\u1737\u0003\u0002\u0002\u0002\u174c\u1738\u0003\u0002\u0002\u0002\u174c\u1741\u0003\u0002\u0002\u0002\u174c\u1742\u0003\u0002\u0002\u0002\u174c\u174b\u0003\u0002\u0002\u0002\u174d\u0431\u0003\u0002\u0002\u0002\u174e\u1750\u0007\u013a\u0002\u0002\u174f\u174e\u0003\u0002\u0002\u0002\u174f\u1750\u0003\u0002\u0002\u0002\u1750\u1752\u0003\u0002\u0002\u0002\u1751\u1753\u0005\u0430\u0219\u0002\u1752\u1751\u0003\u0002\u0002\u0002\u1752\u1753\u0003\u0002\u0002\u0002\u1753\u175a\u0003\u0002\u0002\u0002\u1754\u175b\u0005\u040a\u0206\u0002\u1755\u1756\u0007\u0220\u0002\u0002\u1756\u1757\u0005\u040a\u0206\u0002\u1757\u1758\u0005\u0432\u021a\u0002\u1758\u1759\u0007\u0227\u0002\u0002\u1759\u175b\u0003\u0002\u0002\u0002\u175a\u1754\u0003\u0002\u0002\u0002\u175a\u1755\u0003\u0002\u0002\u0002\u175b\u0433\u0003\u0002\u0002\u0002\u175c\u1761\u0005\u0444\u0223\u0002\u175d\u1761\u0005\u0436\u021c\u0002\u175e\u1761\u0005\u0438\u021d\u0002\u175f\u1761\u0005\u04a4\u0253\u0002\u1760\u175c\u0003\u0002\u0002\u0002\u1760\u175d\u0003\u0002\u0002\u0002\u1760\u175e\u0003\u0002\u0002\u0002\u1760\u175f\u0003\u0002\u0002\u0002\u1761\u0435\u0003\u0002\u0002\u0002\u1762\u1772\u0005\u0444\u0223\u0002\u1763\u1764\u0007\u0220\u0002\u0002\u1764\u176b\u0005\u0440\u0221\u0002\u1765\u1767\u0007\u0213\u0002\u0002\u1766\u1765\u0003\u0002\u0002\u0002\u1766\u1767\u0003\u0002\u0002\u0002\u1767\u1768\u0003\u0002\u0002\u0002\u1768\u176a\u0005\u0440\u0221\u0002\u1769\u1766\u0003\u0002\u0002\u0002\u176a\u176d\u0003\u0002\u0002\u0002\u176b\u1769\u0003\u0002\u0002\u0002\u176b\u176c\u0003\u0002\u0002\u0002\u176c\u176e\u0003\u0002\u0002\u0002\u176d\u176b\u0003\u0002\u0002\u0002\u176e\u176f\u0007\u0227\u0002\u0002\u176f\u1771\u0003\u0002\u0002\u0002\u1770\u1763\u0003\u0002\u0002\u0002\u1771\u1774\u0003\u0002\u0002\u0002\u1772\u1770\u0003\u0002\u0002\u0002\u1772\u1773\u0003\u0002\u0002\u0002\u1773\u1776\u0003\u0002\u0002\u0002\u1774\u1772\u0003\u0002\u0002\u0002\u1775\u1777\u0005\u043a\u021e\u0002\u1776\u1775\u0003\u0002\u0002\u0002\u1776\u1777\u0003\u0002\u0002\u0002\u1777\u0437\u0003\u0002\u0002\u0002\u1778\u1779\u0007\u00db\u0002\u0002\u1779\u1789\u0005\u0472\u023a\u0002\u177a\u177b\u0007\u0220\u0002\u0002\u177b\u1782\u0005\u0442\u0222\u0002\u177c\u177e\u0007\u0213\u0002\u0002\u177d\u177c\u0003\u0002\u0002\u0002\u177d\u177e\u0003\u0002\u0002\u0002\u177e\u177f\u0003\u0002\u0002\u0002\u177f\u1781\u0005\u0442\u0222\u0002\u1780\u177d\u0003\u0002\u0002\u0002\u1781\u1784\u0003\u0002\u0002\u0002\u1782\u1780\u0003\u0002\u0002\u0002\u1782\u1783\u0003\u0002\u0002\u0002\u1783\u1785\u0003\u0002\u0002\u0002\u1784\u1782\u0003\u0002\u0002\u0002\u1785\u1786\u0007\u0227\u0002\u0002\u1786\u1788\u0003\u0002\u0002\u0002\u1787\u177a\u0003\u0002\u0002\u0002\u1788\u178b\u0003\u0002\u0002\u0002\u1789\u1787\u0003\u0002\u0002\u0002\u1789\u178a\u0003\u0002\u0002\u0002\u178a\u178d\u0003\u0002\u0002\u0002\u178b\u1789\u0003\u0002\u0002\u0002\u178c\u178e\u0005\u043a\u021e\u0002\u178d\u178c\u0003\u0002\u0002\u0002\u178d\u178e\u0003\u0002\u0002\u0002\u178e\u0439\u0003\u0002\u0002\u0002\u178f\u1790\u0007\u0220\u0002\u0002\u1790\u1791\u0005\u043c\u021f\u0002\u1791\u1793\u0007\u0212\u0002\u0002\u1792\u1794\u0005\u043e\u0220\u0002\u1793\u1792\u0003\u0002\u0002\u0002\u1793\u1794\u0003\u0002\u0002\u0002\u1794\u1795\u0003\u0002\u0002\u0002\u1795\u1796\u0007\u0227\u0002\u0002\u1796\u043b\u0003\u0002\u0002\u0002\u1797\u1798\u0005\u040a\u0206\u0002\u1798\u043d\u0003\u0002\u0002\u0002\u1799\u179a\u0005\u040a\u0206\u0002\u179a\u043f\u0003\u0002\u0002\u0002\u179b\u17a7\u0007\u000b\u0002\u0002\u179c\u17a7\u0005\u049c\u024f\u0002\u179d\u179f\u0005\u0444\u0223\u0002\u179e\u17a0\u0005\u049c\u024f\u0002\u179f\u179e\u0003\u0002\u0002\u0002\u179f\u17a0\u0003\u0002\u0002\u0002\u17a0\u17a7\u0003\u0002\u0002\u0002\u17a1\u17a3\u0005\u0474\u023b\u0002\u17a2\u17a4\u0005\u049c\u024f\u0002\u17a3\u17a2\u0003\u0002\u0002\u0002\u17a3\u17a4\u0003\u0002\u0002\u0002\u17a4\u17a7\u0003\u0002\u0002\u0002\u17a5\u17a7\u0005\u040a\u0206\u0002\u17a6\u179b\u0003\u0002\u0002\u0002\u17a6\u179c\u0003\u0002\u0002\u0002\u17a6\u179d\u0003\u0002\u0002\u0002\u17a6\u17a1\u0003\u0002\u0002\u0002\u17a6\u17a5\u0003\u0002\u0002\u0002\u17a7\u0441\u0003\u0002\u0002\u0002\u17a8\u17b4\u0005\u0496\u024c\u0002\u17a9\u17b4\u0005\u0434\u021b\u0002\u17aa\u17ac\u0005\u0444\u0223\u0002\u17ab\u17ad\u0005\u049c\u024f\u0002\u17ac\u17ab\u0003\u0002\u0002\u0002\u17ac\u17ad\u0003\u0002\u0002\u0002\u17ad\u17b4\u0003\u0002\u0002\u0002\u17ae\u17b0\u0005\u0474\u023b\u0002\u17af\u17b1\u0005\u049c\u024f\u0002\u17b0\u17af\u0003\u0002\u0002\u0002\u17b0\u17b1\u0003\u0002\u0002\u0002\u17b1\u17b4\u0003\u0002\u0002\u0002\u17b2\u17b4\u0005\u040a\u0206\u0002\u17b3\u17a8\u0003\u0002\u0002\u0002\u17b3\u17a9\u0003\u0002\u0002\u0002\u17b3\u17aa\u0003\u0002\u0002\u0002\u17b3\u17ae\u0003\u0002\u0002\u0002\u17b3\u17b2\u0003\u0002\u0002\u0002\u17b4\u0443\u0003\u0002\u0002\u0002\u17b5\u17ba\u0005\u0446\u0224\u0002\u17b6\u17ba\u0005\u0448\u0225\u0002\u17b7\u17ba\u0005\u044a\u0226\u0002\u17b8\u17ba\u0005\u044c\u0227\u0002\u17b9\u17b5\u0003\u0002\u0002\u0002\u17b9\u17b6\u0003\u0002\u0002\u0002\u17b9\u17b7\u0003\u0002\u0002\u0002\u17b9\u17b8\u0003\u0002\u0002\u0002\u17ba\u0445\u0003\u0002\u0002\u0002\u17bb\u17be\u0005\u046a\u0236\u0002\u17bc\u17be\u0005\u0468\u0235\u0002\u17bd\u17bb\u0003\u0002\u0002\u0002\u17bd\u17bc\u0003\u0002\u0002\u0002\u17be\u17c8\u0003\u0002\u0002\u0002\u17bf\u17c1\u0005\u044e\u0228\u0002\u17c0\u17bf\u0003\u0002\u0002\u0002\u17c1\u17c2\u0003\u0002\u0002\u0002\u17c2\u17c0\u0003\u0002\u0002\u0002\u17c2\u17c3\u0003\u0002\u0002\u0002\u17c3\u17c5\u0003\u0002\u0002\u0002\u17c4\u17c6\u0005\u0452\u022a\u0002\u17c5\u17c4\u0003\u0002\u0002\u0002\u17c5\u17c6\u0003\u0002\u0002\u0002\u17c6\u17c9\u0003\u0002\u0002\u0002\u17c7\u17c9\u0005\u0452\u022a\u0002\u17c8\u17c0\u0003\u0002\u0002\u0002\u17c8\u17c7\u0003\u0002\u0002\u0002\u17c8\u17c9\u0003\u0002\u0002\u0002\u17c9\u0447\u0003\u0002\u0002\u0002\u17ca\u17cb\u0005\u047e\u0240\u0002\u17cb\u17cc\u0005\u0456\u022c\u0002\u17cc\u0449\u0003\u0002\u0002\u0002\u17cd\u17ce\u0005\u0492\u024a\u0002\u17ce\u17cf\u0005\u0458\u022d\u0002\u17cf\u044b\u0003\u0002\u0002\u0002\u17d0\u17d1\u0007\u0118\u0002\u0002\u17d1\u17d2\u0005\u0452\u022a\u0002\u17d2\u044d\u0003\u0002\u0002\u0002\u17d3\u17d6\u0005\u0450\u0229\u0002\u17d4\u17d6\u0005\u045a\u022e\u0002\u17d5\u17d3\u0003\u0002\u0002\u0002\u17d5\u17d4\u0003\u0002\u0002\u0002\u17d6\u044f\u0003\u0002\u0002\u0002\u17d7\u17d8\u0009\u0044\u0002\u0002\u17d8\u17d9\u0005\u046a\u0236\u0002\u17d9\u0451\u0003\u0002\u0002\u0002\u17da\u17db\u0009\u0044\u0002\u0002\u17db\u17dc\u0005\u0470\u0239\u0002\u17dc\u0453\u0003\u0002\u0002\u0002\u17dd\u17de\u0009\u0044\u0002\u0002\u17de\u17df\u0005\u047c\u023f\u0002\u17df\u0455\u0003\u0002\u0002\u0002\u17e0\u17e1\u0009\u0044\u0002\u0002\u17e1\u17e2\u0005\u048c\u0247\u0002\u17e2\u0457\u0003\u0002\u0002\u0002\u17e3\u17e4\u0009\u0044\u0002\u0002\u17e4\u17e5\u0005\u0478\u023d\u0002\u17e5\u0459\u0003\u0002\u0002\u0002\u17e6\u17e7\u0009\u0044\u0002\u0002\u17e7\u17e8\u0005\u0436\u021c\u0002\u17e8\u045b\u0003\u0002\u0002\u0002\u17e9\u17ea\u0005\u0494\u024b\u0002\u17ea\u045d\u0003\u0002\u0002\u0002\u17eb\u17ec\u0005\u048e\u0248\u0002\u17ec\u045f\u0003\u0002\u0002\u0002\u17ed\u17ee\u0005\u0482\u0242\u0002\u17ee\u0461\u0003\u0002\u0002\u0002\u17ef\u17f0\u0005\u0494\u024b\u0002\u17f0\u0463\u0003\u0002\u0002\u0002\u17f1\u17f2\u0005\u0494\u024b\u0002\u17f2\u0465\u0003\u0002\u0002\u0002\u17f3\u17f4\u0005\u048e\u0248\u0002\u17f4\u0467\u0003\u0002\u0002\u0002\u17f5\u17f6\u0005\u0494\u024b\u0002\u17f6\u0469\u0003\u0002\u0002\u0002\u17f7\u17f8\u0005\u0494\u024b\u0002\u17f8\u046b\u0003\u0002\u0002\u0002\u17f9\u17fd\u0007\u00d2\u0002\u0002\u17fa\u17fd\u0007\u006e\u0002\u0002\u17fb\u17fd\u0005\u046a\u0236\u0002\u17fc\u17f9\u0003\u0002\u0002\u0002\u17fc\u17fa\u0003\u0002\u0002\u0002\u17fc\u17fb\u0003\u0002\u0002\u0002\u17fd\u046d\u0003\u0002\u0002\u0002\u17fe\u17ff\u0005\u048e\u0248\u0002\u17ff\u046f\u0003\u0002\u0002\u0002\u1800\u1801\u0005\u0494\u024b\u0002\u1801\u0471\u0003\u0002\u0002\u0002\u1802\u1809\u0007\u00fc\u0002\u0002\u1803\u1809\u0007\u010f\u0002\u0002\u1804\u1809\u0007\u0173\u0002\u0002\u1805\u1809\u0007\u01d2\u0002\u0002\u1806\u1809\u0007\u0203\u0002\u0002\u1807\u1809\u0005\u0494\u024b\u0002\u1808\u1802\u0003\u0002\u0002\u0002\u1808\u1803\u0003\u0002\u0002\u0002\u1808\u1804\u0003\u0002\u0002\u0002\u1808\u1805\u0003\u0002\u0002\u0002\u1808\u1806\u0003\u0002\u0002\u0002\u1808\u1807\u0003\u0002\u0002\u0002\u1809\u0473\u0003\u0002\u0002\u0002\u180a\u180b\u0005\u0494\u024b\u0002\u180b\u0475\u0003\u0002\u0002\u0002\u180c\u180d\u0005\u048e\u0248\u0002\u180d\u0477\u0003\u0002\u0002\u0002\u180e\u180f\u0005\u0494\u024b\u0002\u180f\u0479\u0003\u0002\u0002\u0002\u1810\u1811\u0005\u0494\u024b\u0002\u1811\u047b\u0003\u0002\u0002\u0002\u1812\u1813\u0005\u0494\u024b\u0002\u1813\u047d\u0003\u0002\u0002\u0002\u1814\u1817\u0005\u0494\u024b\u0002\u1815\u1817\u0005\u049c\u024f\u0002\u1816\u1814\u0003\u0002\u0002\u0002\u1816\u1815\u0003\u0002\u0002\u0002\u1817\u047f\u0003\u0002\u0002\u0002\u1818\u181a\u0005\u047e\u0240\u0002\u1819\u181b\u0005\u0456\u022c\u0002\u181a\u1819\u0003\u0002\u0002\u0002\u181a\u181b\u0003\u0002\u0002\u0002\u181b\u181e\u0003\u0002\u0002\u0002\u181c\u181e\u0005\u048c\u0247\u0002\u181d\u1818\u0003\u0002\u0002\u0002\u181d\u181c\u0003\u0002\u0002\u0002\u181e\u0481\u0003\u0002\u0002\u0002\u181f\u1822\u0007\u0229\u0002\u0002\u1820\u1822\u0005\u0494\u024b\u0002\u1821\u181f\u0003\u0002\u0002\u0002\u1821\u1820\u0003\u0002\u0002\u0002\u1822\u0483\u0003\u0002\u0002\u0002\u1823\u1824\u0005\u0444\u0223\u0002\u1824\u0485\u0003\u0002\u0002\u0002\u1825\u1826\u0005\u0444\u0223\u0002\u1826\u0487\u0003\u0002\u0002\u0002\u1827\u1828\u0005\u0494\u024b\u0002\u1828\u0489\u0003\u0002\u0002\u0002\u1829\u182a\u0005\u0494\u024b\u0002\u182a\u048b\u0003\u0002\u0002\u0002\u182b\u182e\u0005\u0494\u024b\u0002\u182c\u182e\u0005\u049c\u024f\u0002\u182d\u182b\u0003\u0002\u0002\u0002\u182d\u182c\u0003\u0002\u0002\u0002\u182e\u048d\u0003\u0002\u0002\u0002\u182f\u1830\u0005\u0494\u024b\u0002\u1830\u048f\u0003\u0002\u0002\u0002\u1831\u1832\u0005\u0494\u024b\u0002\u1832\u0491\u0003\u0002\u0002\u0002\u1833\u1834\u0005\u0494\u024b\u0002\u1834\u0493\u0003\u0002\u0002\u0002\u1835\u1836\u0009\u0045\u0002\u0002\u1836\u0495\u0003\u0002\u0002\u0002\u1837\u183e\u0007\u0229\u0002\u0002\u1838\u183e\u0005\u04a2\u0252\u0002\u1839\u183e\u0005\u049a\u024e\u0002\u183a\u183e\u0005\u0498\u024d\u0002\u183b\u183e\u0005\u049e\u0250\u0002\u183c\u183e\u0005\u04a0\u0251\u0002\u183d\u1837\u0003\u0002\u0002\u0002\u183d\u1838\u0003\u0002\u0002\u0002\u183d\u1839\u0003\u0002\u0002\u0002\u183d\u183a\u0003\u0002\u0002\u0002\u183d\u183b\u0003\u0002\u0002\u0002\u183d\u183c\u0003\u0002\u0002\u0002\u183e\u0497\u0003\u0002\u0002\u0002\u183f\u1840\u0009\u0046\u0002\u0002\u1840\u0499\u0003\u0002\u0002\u0002\u1841\u1845\u0007\u022e\u0002\u0002\u1842\u1845\u0007\u020b\u0002\u0002\u1843\u1845\u0005\u049c\u024f\u0002\u1844\u1841\u0003\u0002\u0002\u0002\u1844\u1842\u0003\u0002\u0002\u0002\u1844\u1843\u0003\u0002\u0002\u0002\u1845\u049b\u0003\u0002\u0002\u0002\u1846\u1847\u0009\u0047\u0002\u0002\u1847\u049d\u0003\u0002\u0002\u0002\u1848\u1849\u0007\u008c\u0002\u0002\u1849\u184c\u0007\u0220\u0002\u0002\u184a\u184d\u0005\u0494\u024b\u0002\u184b\u184d\u0005\u0496\u024c\u0002\u184c\u184a\u0003\u0002\u0002\u0002\u184c\u184b\u0003\u0002\u0002\u0002\u184d\u184e\u0003\u0002\u0002\u0002\u184e\u184f\u0007\u0227\u0002\u0002\u184f\u049f\u0003\u0002\u0002\u0002\u1850\u1851\u0007\u008d\u0002\u0002\u1851\u1854\u0007\u0220\u0002\u0002\u1852\u1855\u0005\u0494\u024b\u0002\u1853\u1855\u0005\u0496\u024c\u0002\u1854\u1852\u0003\u0002\u0002\u0002\u1854\u1853\u0003\u0002\u0002\u0002\u1855\u1856\u0003\u0002\u0002\u0002\u1856\u1857\u0007\u0227\u0002\u0002\u1857\u04a1\u0003\u0002\u0002\u0002\u1858\u1859\u0007\u000b\u0002\u0002\u1859\u1868\u0005\u0496\u024c\u0002\u185a\u1868\u0007\u00e8\u0002\u0002\u185b\u1868\u0007\u00e9\u0002\u0002\u185c\u1868\u0007\u0125\u0002\u0002\u185d\u1868\u0007\u0126\u0002\u0002\u185e\u1868\u0007\u013b\u0002\u0002\u185f\u1868\u0007\u013c\u0002\u0002\u1860\u1868\u0007\u0171\u0002\u0002\u1861\u1868\u0007\u0172\u0002\u0002\u1862\u1868\u0007\u01c4\u0002\u0002\u1863\u1868\u0007\u01c5\u0002\u0002\u1864\u1868\u0007\u020b\u0002\u0002\u1865\u1868\u0007\u020d\u0002\u0002\u1866\u1868\u0007\u020e\u0002\u0002\u1867\u1858\u0003\u0002\u0002\u0002\u1867\u185a\u0003\u0002\u0002\u0002\u1867\u185b\u0003\u0002\u0002\u0002\u1867\u185c\u0003\u0002\u0002\u0002\u1867\u185d\u0003\u0002\u0002\u0002\u1867\u185e\u0003\u0002\u0002\u0002\u1867\u185f\u0003\u0002\u0002\u0002\u1867\u1860\u0003\u0002\u0002\u0002\u1867\u1861\u0003\u0002\u0002\u0002\u1867\u1862\u0003\u0002\u0002\u0002\u1867\u1863\u0003\u0002\u0002\u0002\u1867\u1864\u0003\u0002\u0002\u0002\u1867\u1865\u0003\u0002\u0002\u0002\u1867\u1866\u0003\u0002\u0002\u0002\u1868\u04a3\u0003\u0002\u0002\u0002\u1869\u186a\u0007\u0007\u0002\u0002\u186a\u186b\u0007\u0145\u0002\u0002\u186b\u188b\u0005\u0434\u021b\u0002\u186c\u188b\u0007\u0071\u0002\u0002\u186d\u188b\u0007\u0074\u0002\u0002\u186e\u188b\u0007\u0075\u0002\u0002\u186f\u188b\u0007\u0078\u0002\u0002\u1870\u188b\u0007\u0079\u0002\u0002\u1871\u188b\u0007\u007a\u0002\u0002\u1872\u188b\u0007\u007b\u0002\u0002\u1873\u188b\u0007\u007c\u0002\u0002\u1874\u188b\u0007\u007d\u0002\u0002\u1875\u188b\u0007\u007e\u0002\u0002\u1876\u1878\u0007\u010f\u0002\u0002\u1877\u1879\u0007\u0145\u0002\u0002\u1878\u1877\u0003\u0002\u0002\u0002\u1878\u1879\u0003\u0002\u0002\u0002\u1879\u187a\u0003\u0002\u0002\u0002\u187a\u188b\u0005\u0434\u021b\u0002\u187b\u188b\u0007\u0118\u0002\u0002\u187c\u188b\u0007\u011b\u0002\u0002\u187d\u188b\u0007\u0157\u0002\u0002\u187e\u188b\u0007\u0196\u0002\u0002\u187f\u188b\u0007\u01b5\u0002\u0002\u1880\u188b\u0007\u01b6\u0002\u0002\u1881\u188b\u0007\u01bb\u0002\u0002\u1882\u188b\u0007\u01bc\u0002\u0002\u1883\u188b\u0007\u01bd\u0002\u0002\u1884\u188b\u0007\u01bf\u0002\u0002\u1885\u188b\u0007\u01c0\u0002\u0002\u1886\u188b\u0007\u01c1\u0002\u0002\u1887\u188b\u0007\u01d9\u0002\u0002\u1888\u188b\u0007\u01e7\u0002\u0002\u1889\u188b\u0007\u0203\u0002\u0002\u188a\u1869\u0003\u0002\u0002\u0002\u188a\u186c\u0003\u0002\u0002\u0002\u188a\u186d\u0003\u0002\u0002\u0002\u188a\u186e\u0003\u0002\u0002\u0002\u188a\u186f\u0003\u0002\u0002\u0002\u188a\u1870\u0003\u0002\u0002\u0002\u188a\u1871\u0003\u0002\u0002\u0002\u188a\u1872\u0003\u0002\u0002\u0002\u188a\u1873\u0003\u0002\u0002\u0002\u188a\u1874\u0003\u0002\u0002\u0002\u188a\u1875\u0003\u0002\u0002\u0002\u188a\u1876\u0003\u0002\u0002\u0002\u188a\u187b\u0003\u0002\u0002\u0002\u188a\u187c\u0003\u0002\u0002\u0002\u188a\u187d\u0003\u0002\u0002\u0002\u188a\u187e\u0003\u0002\u0002\u0002\u188a\u187f\u0003\u0002\u0002\u0002\u188a\u1880\u0003\u0002\u0002\u0002\u188a\u1881\u0003\u0002\u0002\u0002\u188a\u1882\u0003\u0002\u0002\u0002\u188a\u1883\u0003\u0002\u0002\u0002\u188a\u1884\u0003\u0002\u0002\u0002\u188a\u1885\u0003\u0002\u0002\u0002\u188a\u1886\u0003\u0002\u0002\u0002\u188a\u1887\u0003\u0002\u0002\u0002\u188a\u1888\u0003\u0002\u0002\u0002\u188a\u1889\u0003\u0002\u0002\u0002\u188b\u04a5\u0003\u0002\u0002\u0002\u188c\u188e\u0007\u0234\u0002\u0002\u188d\u188c\u0003\u0002\u0002\u0002\u188e\u188f\u0003\u0002\u0002\u0002\u188f\u188d\u0003\u0002\u0002\u0002\u188f\u1890\u0003\u0002\u0002\u0002\u1890\u04a7\u0003\u0002\u0002\u0002\u03d5\u04ae\u04b2\u04b5\u04b8\u04bd\u04c1\u04cf\u04d8\u04de\u04e2\u04e4\u04e7\u04ea\u04ef\u04f4\u04f9\u04fe\u0503\u0508\u0510\u0516\u051e\u0524\u052a\u052e\u0538\u0542\u0546\u054a\u054d\u0551\u0554\u0558\u055b\u055e\u0561\u0565\u056a\u056d\u0570\u0573\u0577\u057c\u0580\u0586\u0593\u0597\u05a4\u05a8\u05ae\u05b1\u05bc\u05be\u05c5\u05c7\u05d0\u05d5\u05d9\u05de\u05e3\u05ea\u05ed\u05f0\u05f5\u05fa\u05fe\u0602\u0606\u0609\u060d\u0612\u0616\u061c\u0620\u0622\u0625\u0629\u062e\u0630\u0635\u0637\u063b\u063f\u0642\u0646\u0649\u064e\u0651\u0654\u0658\u065b\u0660\u0663\u0666\u0668\u066c\u0672\u0675\u0678\u067c\u0680\u0683\u0686\u068b\u068f\u0694\u0697\u069c\u06a4\u06a9\u06ad\u06b2\u06bb\u06c0\u06cf\u06d3\u06e0\u06e5\u06e8\u06eb\u06ef\u06f1\u06f8\u06fe\u0701\u0705\u070a\u070f\u0713\u0716\u071c\u071f\u0723\u0726\u0729\u072e\u0731\u0735\u0738\u073b\u073f\u0744\u0748\u074c\u0750\u0753\u075c\u0761\u0765\u076b\u0771\u0773\u0779\u077f\u0782\u078a\u078e\u0791\u0794\u0799\u079e\u07a1\u07a6\u07ab\u07b0\u07ba\u07c6\u07ce\u07d4\u07d9\u07e0\u07ee\u07f1\u07f6\u07fc\u0800\u0803\u080c\u080f\u0813\u0816\u081a\u081d\u0820\u0824\u0827\u0829\u082d\u0830\u0833\u0838\u0840\u0844\u0846\u084d\u084f\u0856\u085a\u085e\u0863\u0867\u0869\u086e\u0872\u0876\u0879\u087e\u0884\u0887\u088b\u088f\u0892\u0895\u089a\u089d\u08a0\u08a5\u08a9\u08ac\u08b4\u08ba\u08be\u08c0\u08c5\u08cd\u08db\u08e4\u08ec\u08ee\u08f4\u08f9\u08fc\u0908\u090b\u090d\u0915\u091e\u0920\u0928\u0932\u0935\u0937\u093f\u094d\u094f\u0954\u095b\u0960\u0964\u096b\u0972\u0979\u097e\u0982\u0987\u098b\u0990\u0994\u0999\u099d\u09a2\u09a6\u09ad\u09b8\u09bd\u09c6\u09cc\u09e0\u09ec\u09ee\u0a07\u0a0b\u0a0f\u0a12\u0a15\u0a19\u0a1d\u0a20\u0a23\u0a27\u0a2b\u0a2f\u0a33\u0a37\u0a3b\u0a41\u0a47\u0a4e\u0a51\u0a5b\u0a61\u0a67\u0a6b\u0a6d\u0a72\u0a74\u0a7e\u0a81\u0a85\u0a88\u0a8d\u0a99\u0aa0\u0aa5\u0aa9\u0aac\u0aaf\u0ab2\u0ab4\u0ab9\u0ac0\u0ac4\u0ac6\u0aca\u0add\u0ae2\u0ae5\u0ae9\u0aef\u0af2\u0af9\u0b06\u0b09\u0b0b\u0b12\u0b18\u0b1b\u0b21\u0b25\u0b28\u0b2b\u0b2e\u0b32\u0b36\u0b3a\u0b42\u0b47\u0b51\u0b57\u0b5b\u0b5f\u0b64\u0b68\u0b6f\u0b74\u0b7a\u0b7f\u0b82\u0b86\u0b8f\u0b94\u0b99\u0b9e\u0ba2\u0ba9\u0bad\u0bb1\u0bb3\u0bba\u0bbf\u0bc3\u0bcd\u0bd2\u0bd8\u0bdb\u0be1\u0be4\u0be8\u0bea\u0bf0\u0bf3\u0bf7\u0bfb\u0bfe\u0c01\u0c04\u0c0c\u0c12\u0c19\u0c1e\u0c21\u0c24\u0c27\u0c33\u0c37\u0c3d\u0c41\u0c44\u0c49\u0c51\u0c56\u0c6d\u0c6f\u0c81\u0c84\u0c8a\u0c91\u0c96\u0c99\u0ca1\u0ca6\u0ca9\u0cad\u0cb0\u0cb5\u0cba\u0cbd\u0cc2\u0cc4\u0ccb\u0cce\u0cd3\u0cd7\u0cde\u0ce1\u0ce5\u0cf7\u0cfe\u0d01\u0d0f\u0d13\u0d15\u0d1a\u0d1c\u0d20\u0d23\u0d29\u0d2e\u0d34\u0d36\u0d3a\u0d59\u0d5e\u0d62\u0d66\u0d6a\u0d6c\u0d70\u0d75\u0d7a\u0d7e\u0d84\u0d8c\u0d8f\u0d93\u0d9b\u0da2\u0da5\u0da8\u0dad\u0db0\u0db4\u0db7\u0dba\u0dc0\u0dc5\u0dcc\u0ddb\u0de1\u0deb\u0df1\u0dfa\u0dfd\u0e02\u0e38\u0e40\u0e43\u0e46\u0e49\u0e4e\u0e52\u0e59\u0e5f\u0e69\u0e71\u0e74\u0e77\u0e7a\u0e7f\u0e85\u0e8a\u0e90\u0e92\u0e98\u0ea1\u0ea5\u0ea9\u0ead\u0eb1\u0eb9\u0ebf\u0ec6\u0ec9\u0ecc\u0ecf\u0ed2\u0ed5\u0ed8\u0ede\u0ee3\u0ee6\u0ee9\u0eee\u0ef4\u0ef9\u0efc\u0eff\u0f05\u0f0b\u0f0d\u0f11\u0f14\u0f1a\u0f20\u0f22\u0f27\u0f30\u0f37\u0f3d\u0f43\u0f47\u0f4a\u0f4d\u0f52\u0f54\u0f57\u0f5c\u0f5f\u0f65\u0f6b\u0f6d\u0f72\u0f76\u0f7d\u0f81\u0f85\u0f8b\u0f90\u0f93\u0f96\u0f9a\u0fa1\u0fa4\u0fa7\u0faa\u0faf\u0fb4\u0fb8\u0fbd\u0fc3\u0fc6\u0fc9\u0fcc\u0fd0\u0fd5\u0fda\u0fdd\u0fe5\u0fea\u0fed\u0ff0\u0ff3\u0ff6\u0ffc\u1001\u1004\u1009\u100c\u1012\u1016\u101a\u1022\u1027\u102b\u1030\u1038\u103a\u1041\u1047\u104a\u104d\u1053\u105b\u1060\u1068\u106d\u1071\u1075\u1082\u1088\u108d\u1092\u1097\u109b\u109e\u10a3\u10a7\u10ab\u10b4\u10b8\u10c0\u10c4\u10c7\u10c9\u10cf\u10d2\u10d5\u10dc\u10df\u10e7\u10ea\u10f0\u10f3\u10f9\u10fd\u1102\u1108\u1110\u1116\u111b\u111d\u1123\u1128\u112d\u1133\u113a\u113c\u1142\u114a\u1151\u1157\u115b\u1160\u1165\u116b\u1171\u1176\u117a\u117e\u1185\u1188\u118d\u1191\u1196\u119a\u119e\u11a3\u11a6\u11aa\u11af\u11b2\u11b5\u11b8\u11bf\u11c3\u11cb\u11d0\u11d4\u11dd\u11e9\u11ed\u11f1\u11f8\u11fc\u1204\u120b\u1210\u1213\u1216\u1219\u121e\u1222\u1229\u122d\u1231\u1238\u123a\u1240\u1245\u1249\u124f\u1253\u1257\u125d\u1263\u1268\u126b\u1270\u1278\u127b\u1280\u1284\u1289\u1293\u1295\u129c\u12a1\u12ae\u12b4\u12b7\u12c0\u12c5\u12c8\u12cb\u12ce\u12d1\u12d4\u12d7\u12da\u12dd\u12e0\u12e6\u12eb\u12ef\u12f6\u12f9\u12fc\u12ff\u1309\u130b\u1314\u1319\u131d\u1320\u1327\u132f\u1334\u1338\u133b\u1342\u1348\u134c\u1350\u1358\u135d\u1360\u1364\u1367\u136f\u1372\u1375\u1378\u137f\u1383\u1386\u138b\u138e\u139a\u139d\u13a2\u13a5\u13a8\u13ac\u13af\u13b2\u13b5\u13b8\u13c6\u13ca\u13ce\u13d3\u13d9\u13dc\u13e4\u13e7\u13ec\u13f2\u13f7\u13fd\u1408\u140c\u1410\u1417\u141a\u141d\u1420\u1425\u1429\u142e\u1432\u1436\u143b\u143e\u1442\u1445\u1448\u144c\u1451\u1454\u1457\u145a\u1461\u1465\u146c\u1470\u1479\u147e\u1482\u148b\u1497\u149c\u149f\u14a2\u14a5\u14a9\u14ad\u14b2\u14b8\u14be\u14c3\u14c6\u14cd\u14d3\u14d7\u14da\u14dd\u14e0\u14e5\u14e9\u14ed\u14f1\u14f6\u14fb\u1501\u150a\u150d\u1510\u1513\u1518\u151e\u1523\u152b\u1534\u1538\u153c\u1540\u1544\u154d\u1550\u1553\u1556\u1559\u1560\u1563\u1567\u156a\u156e\u1572\u1576\u157c\u1580\u1583\u1587\u158d\u1592\u1599\u15a0\u15a3\u15a7\u15ac\u15b7\u15b9\u15bc\u15c0\u15c5\u15cb\u15ce\u15d3\u15d8\u15db\u15de\u15e1\u15e4\u15e7\u15ea\u15ef\u15f3\u15f8\u15fe\u1601\u1606\u160c\u1611\u1617\u161b\u1621\u1626\u162c\u1631\u1636\u163c\u1641\u1645\u164b\u1650\u1656\u165a\u1661\u1666\u166d\u1671\u1677\u167c\u1682\u1689\u1693\u169a\u16a0\u16ac\u16b2\u16ba\u16bc\u16bf\u16ca\u16ce\u16d1\u16da\u16e0\u16e4\u16e9\u16ef\u16f2\u16f7\u16fc\u1704\u1708\u170b\u171e\u1721\u1724\u1728\u172d\u1732\u1735\u173a\u173f\u1744\u1749\u174c\u174f\u1752\u175a\u1760\u1766\u176b\u1772\u1776\u177d\u1782\u1789\u178d\u1793\u179f\u17a3\u17a6\u17ac\u17b0\u17b3\u17b9\u17bd\u17c2\u17c5\u17c8\u17d5\u17fc\u1808\u1816\u181a\u181d\u1821\u182d\u183d\u1844\u184c\u1854\u1867\u1878\u188a\u188f";
        private val serializedATN : String = Utils.join(
        	listOf(serializedATNSegment0,
        serializedATNSegment1,
        serializedATNSegment2).iterator(),
        	""
        )
        val ATN = ATNDeserializer().deserialize(serializedATN.toCharArray())
        init {
        	decisionToDFA = Array<DFA>(ATN.numberOfDecisions, {
        		DFA(ATN.getDecisionState(it)!!, it)
        	})


        }
	}

    private val ABORT = Tokens.ABORT.id
    private val ACCEPT = Tokens.ACCEPT.id
    private val ACCESS = Tokens.ACCESS.id
    private val ADD = Tokens.ADD.id
    private val ADDRESS = Tokens.ADDRESS.id
    private val ADVANCING = Tokens.ADVANCING.id
    private val AFTER = Tokens.AFTER.id
    private val ALIGNED = Tokens.ALIGNED.id
    private val ALL = Tokens.ALL.id
    private val ALPHABET = Tokens.ALPHABET.id
    private val ALPHABETIC = Tokens.ALPHABETIC.id
    private val ALPHABETIC_LOWER = Tokens.ALPHABETIC_LOWER.id
    private val ALPHABETIC_UPPER = Tokens.ALPHABETIC_UPPER.id
    private val ALPHANUMERIC = Tokens.ALPHANUMERIC.id
    private val ALPHANUMERIC_EDITED = Tokens.ALPHANUMERIC_EDITED.id
    private val ALSO = Tokens.ALSO.id
    private val ALTER = Tokens.ALTER.id
    private val ALTERNATE = Tokens.ALTERNATE.id
    private val AND = Tokens.AND.id
    private val ANY = Tokens.ANY.id
    private val ARE = Tokens.ARE.id
    private val AREA = Tokens.AREA.id
    private val AREAS = Tokens.AREAS.id
    private val AS = Tokens.AS.id
    private val ASCENDING = Tokens.ASCENDING.id
    private val ASCII = Tokens.ASCII.id
    private val ASSIGN = Tokens.ASSIGN.id
    private val ASSOCIATED_DATA = Tokens.ASSOCIATED_DATA.id
    private val ASSOCIATED_DATA_LENGTH = Tokens.ASSOCIATED_DATA_LENGTH.id
    private val AT = Tokens.AT.id
    private val ATTRIBUTE = Tokens.ATTRIBUTE.id
    private val AUTHOR = Tokens.AUTHOR.id
    private val AUTO = Tokens.AUTO.id
    private val AUTO_SKIP = Tokens.AUTO_SKIP.id
    private val BACKGROUND_COLOR = Tokens.BACKGROUND_COLOR.id
    private val BACKGROUND_COLOUR = Tokens.BACKGROUND_COLOUR.id
    private val BASIS = Tokens.BASIS.id
    private val BEEP = Tokens.BEEP.id
    private val BEFORE = Tokens.BEFORE.id
    private val BEGINNING = Tokens.BEGINNING.id
    private val BELL = Tokens.BELL.id
    private val BINARY = Tokens.BINARY.id
    private val BIT = Tokens.BIT.id
    private val BLANK = Tokens.BLANK.id
    private val BLINK = Tokens.BLINK.id
    private val BLOCK = Tokens.BLOCK.id
    private val BOUNDS = Tokens.BOUNDS.id
    private val BOTTOM = Tokens.BOTTOM.id
    private val BY = Tokens.BY.id
    private val BYFUNCTION = Tokens.BYFUNCTION.id
    private val BYTITLE = Tokens.BYTITLE.id
    private val CALL = Tokens.CALL.id
    private val CANCEL = Tokens.CANCEL.id
    private val CAPABLE = Tokens.CAPABLE.id
    private val CCSVERSION = Tokens.CCSVERSION.id
    private val CD = Tokens.CD.id
    private val CF = Tokens.CF.id
    private val CH = Tokens.CH.id
    private val CHAINING = Tokens.CHAINING.id
    private val CHANGED = Tokens.CHANGED.id
    private val CHANNEL = Tokens.CHANNEL.id
    private val CHARACTER = Tokens.CHARACTER.id
    private val CHARACTERS = Tokens.CHARACTERS.id
    private val CLASS = Tokens.CLASS.id
    private val CLASS_ID = Tokens.CLASS_ID.id
    private val CLOCK_UNITS = Tokens.CLOCK_UNITS.id
    private val CLOSE = Tokens.CLOSE.id
    private val CLOSE_DISPOSITION = Tokens.CLOSE_DISPOSITION.id
    private val COBOL = Tokens.COBOL.id
    private val CODE = Tokens.CODE.id
    private val CODE_SET = Tokens.CODE_SET.id
    private val COLLATING = Tokens.COLLATING.id
    private val COL = Tokens.COL.id
    private val COLUMN = Tokens.COLUMN.id
    private val COM_REG = Tokens.COM_REG.id
    private val COMMA = Tokens.COMMA.id
    private val COMMITMENT = Tokens.COMMITMENT.id
    private val COMMON = Tokens.COMMON.id
    private val COMMUNICATION = Tokens.COMMUNICATION.id
    private val COMP = Tokens.COMP.id
    private val COMP_1 = Tokens.COMP_1.id
    private val COMP_2 = Tokens.COMP_2.id
    private val COMP_3 = Tokens.COMP_3.id
    private val COMP_4 = Tokens.COMP_4.id
    private val COMP_5 = Tokens.COMP_5.id
    private val COMPUTATIONAL = Tokens.COMPUTATIONAL.id
    private val COMPUTATIONAL_1 = Tokens.COMPUTATIONAL_1.id
    private val COMPUTATIONAL_2 = Tokens.COMPUTATIONAL_2.id
    private val COMPUTATIONAL_3 = Tokens.COMPUTATIONAL_3.id
    private val COMPUTATIONAL_4 = Tokens.COMPUTATIONAL_4.id
    private val COMPUTATIONAL_5 = Tokens.COMPUTATIONAL_5.id
    private val COMPUTE = Tokens.COMPUTE.id
    private val CONFIGURATION = Tokens.CONFIGURATION.id
    private val CONTAINS = Tokens.CONTAINS.id
    private val CONTENT = Tokens.CONTENT.id
    private val CONTINUE = Tokens.CONTINUE.id
    private val CONTROL = Tokens.CONTROL.id
    private val CONTROL_POINT = Tokens.CONTROL_POINT.id
    private val CONTROLS = Tokens.CONTROLS.id
    private val CONVENTION = Tokens.CONVENTION.id
    private val CONVERTING = Tokens.CONVERTING.id
    private val COPY = Tokens.COPY.id
    private val CORR = Tokens.CORR.id
    private val CORRESPONDING = Tokens.CORRESPONDING.id
    private val COUNT = Tokens.COUNT.id
    private val CRUNCH = Tokens.CRUNCH.id
    private val CURRENCY = Tokens.CURRENCY.id
    private val CURSOR = Tokens.CURSOR.id
    private val DATA = Tokens.DATA.id
    private val DATA_BASE = Tokens.DATA_BASE.id
    private val DATE = Tokens.DATE.id
    private val DATE_COMPILED = Tokens.DATE_COMPILED.id
    private val DATE_WRITTEN = Tokens.DATE_WRITTEN.id
    private val DAY = Tokens.DAY.id
    private val DAY_OF_WEEK = Tokens.DAY_OF_WEEK.id
    private val DBCS = Tokens.DBCS.id
    private val DE = Tokens.DE.id
    private val DEBUG_CONTENTS = Tokens.DEBUG_CONTENTS.id
    private val DEBUG_ITEM = Tokens.DEBUG_ITEM.id
    private val DEBUG_LINE = Tokens.DEBUG_LINE.id
    private val DEBUG_NAME = Tokens.DEBUG_NAME.id
    private val DEBUG_SUB_1 = Tokens.DEBUG_SUB_1.id
    private val DEBUG_SUB_2 = Tokens.DEBUG_SUB_2.id
    private val DEBUG_SUB_3 = Tokens.DEBUG_SUB_3.id
    private val DEBUGGING = Tokens.DEBUGGING.id
    private val DECIMAL_POINT = Tokens.DECIMAL_POINT.id
    private val DECLARATIVES = Tokens.DECLARATIVES.id
    private val DEFAULT = Tokens.DEFAULT.id
    private val DEFAULT_DISPLAY = Tokens.DEFAULT_DISPLAY.id
    private val DEFINITION = Tokens.DEFINITION.id
    private val DELETE = Tokens.DELETE.id
    private val DELIMITED = Tokens.DELIMITED.id
    private val DELIMITER = Tokens.DELIMITER.id
    private val DEPENDING = Tokens.DEPENDING.id
    private val DESCENDING = Tokens.DESCENDING.id
    private val DESTINATION = Tokens.DESTINATION.id
    private val DETAIL = Tokens.DETAIL.id
    private val DFHRESP = Tokens.DFHRESP.id
    private val DFHVALUE = Tokens.DFHVALUE.id
    private val DISABLE = Tokens.DISABLE.id
    private val DISK = Tokens.DISK.id
    private val DISPLAY = Tokens.DISPLAY.id
    private val DISPLAY_1 = Tokens.DISPLAY_1.id
    private val DIVIDE = Tokens.DIVIDE.id
    private val DIVISION = Tokens.DIVISION.id
    private val DONTCARE = Tokens.DONTCARE.id
    private val DOUBLE = Tokens.DOUBLE.id
    private val DOWN = Tokens.DOWN.id
    private val DUPLICATES = Tokens.DUPLICATES.id
    private val DYNAMIC = Tokens.DYNAMIC.id
    private val EBCDIC = Tokens.EBCDIC.id
    private val EGCS = Tokens.EGCS.id
    private val EGI = Tokens.EGI.id
    private val ELSE = Tokens.ELSE.id
    private val EMI = Tokens.EMI.id
    private val EMPTY_CHECK = Tokens.EMPTY_CHECK.id
    private val ENABLE = Tokens.ENABLE.id
    private val END = Tokens.END.id
    private val END_ACCEPT = Tokens.END_ACCEPT.id
    private val END_ADD = Tokens.END_ADD.id
    private val END_CALL = Tokens.END_CALL.id
    private val END_COMPUTE = Tokens.END_COMPUTE.id
    private val END_DELETE = Tokens.END_DELETE.id
    private val END_DIVIDE = Tokens.END_DIVIDE.id
    private val END_EVALUATE = Tokens.END_EVALUATE.id
    private val END_IF = Tokens.END_IF.id
    private val END_MULTIPLY = Tokens.END_MULTIPLY.id
    private val END_OF_PAGE = Tokens.END_OF_PAGE.id
    private val END_PERFORM = Tokens.END_PERFORM.id
    private val END_READ = Tokens.END_READ.id
    private val END_RECEIVE = Tokens.END_RECEIVE.id
    private val END_RETURN = Tokens.END_RETURN.id
    private val END_REWRITE = Tokens.END_REWRITE.id
    private val END_SEARCH = Tokens.END_SEARCH.id
    private val END_START = Tokens.END_START.id
    private val END_STRING = Tokens.END_STRING.id
    private val END_SUBTRACT = Tokens.END_SUBTRACT.id
    private val END_UNSTRING = Tokens.END_UNSTRING.id
    private val END_WRITE = Tokens.END_WRITE.id
    private val ENDING = Tokens.ENDING.id
    private val ENTER = Tokens.ENTER.id
    private val ENTRY = Tokens.ENTRY.id
    private val ENTRY_PROCEDURE = Tokens.ENTRY_PROCEDURE.id
    private val ENVIRONMENT = Tokens.ENVIRONMENT.id
    private val EOP = Tokens.EOP.id
    private val EQUAL = Tokens.EQUAL.id
    private val ERASE = Tokens.ERASE.id
    private val ERROR = Tokens.ERROR.id
    private val EOL = Tokens.EOL.id
    private val EOS = Tokens.EOS.id
    private val ESCAPE = Tokens.ESCAPE.id
    private val ESI = Tokens.ESI.id
    private val EVALUATE = Tokens.EVALUATE.id
    private val EVENT = Tokens.EVENT.id
    private val EVERY = Tokens.EVERY.id
    private val EXCEPTION = Tokens.EXCEPTION.id
    private val EXCLUSIVE = Tokens.EXCLUSIVE.id
    private val EXHIBIT = Tokens.EXHIBIT.id
    private val EXIT = Tokens.EXIT.id
    private val EXPORT = Tokens.EXPORT.id
    private val EXTEND = Tokens.EXTEND.id
    private val EXTENDED = Tokens.EXTENDED.id
    private val EXTERNAL = Tokens.EXTERNAL.id
    private val FALSE = Tokens.FALSE.id
    private val FD = Tokens.FD.id
    private val FILE = Tokens.FILE.id
    private val FILE_CONTROL = Tokens.FILE_CONTROL.id
    private val FILLER = Tokens.FILLER.id
    private val FINAL = Tokens.FINAL.id
    private val FIRST = Tokens.FIRST.id
    private val FOOTING = Tokens.FOOTING.id
    private val FOR = Tokens.FOR.id
    private val FOREGROUND_COLOR = Tokens.FOREGROUND_COLOR.id
    private val FOREGROUND_COLOUR = Tokens.FOREGROUND_COLOUR.id
    private val FROM = Tokens.FROM.id
    private val FULL = Tokens.FULL.id
    private val FUNCTION = Tokens.FUNCTION.id
    private val FUNCTIONNAME = Tokens.FUNCTIONNAME.id
    private val FUNCTION_POINTER = Tokens.FUNCTION_POINTER.id
    private val GENERATE = Tokens.GENERATE.id
    private val GOBACK = Tokens.GOBACK.id
    private val GIVING = Tokens.GIVING.id
    private val GLOBAL = Tokens.GLOBAL.id
    private val GO = Tokens.GO.id
    private val GREATER = Tokens.GREATER.id
    private val GRID = Tokens.GRID.id
    private val GROUP = Tokens.GROUP.id
    private val HEADING = Tokens.HEADING.id
    private val HIGHLIGHT = Tokens.HIGHLIGHT.id
    private val HIGH_VALUE = Tokens.HIGH_VALUE.id
    private val HIGH_VALUES = Tokens.HIGH_VALUES.id
    private val I_O = Tokens.I_O.id
    private val I_O_CONTROL = Tokens.I_O_CONTROL.id
    private val ID = Tokens.ID.id
    private val IDENTIFICATION = Tokens.IDENTIFICATION.id
    private val IF = Tokens.IF.id
    private val IMPLICIT = Tokens.IMPLICIT.id
    private val IMPORT = Tokens.IMPORT.id
    private val IN = Tokens.IN.id
    private val INDEX = Tokens.INDEX.id
    private val INDEXED = Tokens.INDEXED.id
    private val INDICATE = Tokens.INDICATE.id
    private val INITIAL = Tokens.INITIAL.id
    private val INITIALIZE = Tokens.INITIALIZE.id
    private val INITIATE = Tokens.INITIATE.id
    private val INPUT = Tokens.INPUT.id
    private val INPUT_OUTPUT = Tokens.INPUT_OUTPUT.id
    private val INSPECT = Tokens.INSPECT.id
    private val INSTALLATION = Tokens.INSTALLATION.id
    private val INTEGER = Tokens.INTEGER.id
    private val INTO = Tokens.INTO.id
    private val INVALID = Tokens.INVALID.id
    private val INVOKE = Tokens.INVOKE.id
    private val IS = Tokens.IS.id
    private val JUST = Tokens.JUST.id
    private val JUSTIFIED = Tokens.JUSTIFIED.id
    private val KANJI = Tokens.KANJI.id
    private val KEPT = Tokens.KEPT.id
    private val KEY = Tokens.KEY.id
    private val KEYBOARD = Tokens.KEYBOARD.id
    private val LABEL = Tokens.LABEL.id
    private val LANGUAGE = Tokens.LANGUAGE.id
    private val LAST = Tokens.LAST.id
    private val LB = Tokens.LB.id
    private val LD = Tokens.LD.id
    private val LEADING = Tokens.LEADING.id
    private val LEFT = Tokens.LEFT.id
    private val LEFTLINE = Tokens.LEFTLINE.id
    private val LENGTH = Tokens.LENGTH.id
    private val LENGTH_CHECK = Tokens.LENGTH_CHECK.id
    private val LESS = Tokens.LESS.id
    private val LIBACCESS = Tokens.LIBACCESS.id
    private val LIBPARAMETER = Tokens.LIBPARAMETER.id
    private val LIBRARY = Tokens.LIBRARY.id
    private val LIMIT = Tokens.LIMIT.id
    private val LIMITS = Tokens.LIMITS.id
    private val LINAGE = Tokens.LINAGE.id
    private val LINAGE_COUNTER = Tokens.LINAGE_COUNTER.id
    private val LINE = Tokens.LINE.id
    private val LINES = Tokens.LINES.id
    private val LINE_COUNTER = Tokens.LINE_COUNTER.id
    private val LINKAGE = Tokens.LINKAGE.id
    private val LIST = Tokens.LIST.id
    private val LOCAL = Tokens.LOCAL.id
    private val LOCAL_STORAGE = Tokens.LOCAL_STORAGE.id
    private val LOCK = Tokens.LOCK.id
    private val LONG_DATE = Tokens.LONG_DATE.id
    private val LONG_TIME = Tokens.LONG_TIME.id
    private val LOWER = Tokens.LOWER.id
    private val LOWLIGHT = Tokens.LOWLIGHT.id
    private val LOW_VALUE = Tokens.LOW_VALUE.id
    private val LOW_VALUES = Tokens.LOW_VALUES.id
    private val MEMORY = Tokens.MEMORY.id
    private val MERGE = Tokens.MERGE.id
    private val MESSAGE = Tokens.MESSAGE.id
    private val MMDDYYYY = Tokens.MMDDYYYY.id
    private val MODE = Tokens.MODE.id
    private val MODULES = Tokens.MODULES.id
    private val MORE_LABELS = Tokens.MORE_LABELS.id
    private val MOVE = Tokens.MOVE.id
    private val MULTIPLE = Tokens.MULTIPLE.id
    private val MULTIPLY = Tokens.MULTIPLY.id
    private val NAMED = Tokens.NAMED.id
    private val NATIONAL = Tokens.NATIONAL.id
    private val NATIONAL_EDITED = Tokens.NATIONAL_EDITED.id
    private val NATIVE = Tokens.NATIVE.id
    private val NEGATIVE = Tokens.NEGATIVE.id
    private val NETWORK = Tokens.NETWORK.id
    private val NEXT = Tokens.NEXT.id
    private val NO = Tokens.NO.id
    private val NO_ECHO = Tokens.NO_ECHO.id
    private val NOT = Tokens.NOT.id
    private val NULL = Tokens.NULL.id
    private val NULLS = Tokens.NULLS.id
    private val NUMBER = Tokens.NUMBER.id
    private val NUMERIC = Tokens.NUMERIC.id
    private val NUMERIC_DATE = Tokens.NUMERIC_DATE.id
    private val NUMERIC_EDITED = Tokens.NUMERIC_EDITED.id
    private val NUMERIC_TIME = Tokens.NUMERIC_TIME.id
    private val OBJECT_COMPUTER = Tokens.OBJECT_COMPUTER.id
    private val OCCURS = Tokens.OCCURS.id
    private val ODT = Tokens.ODT.id
    private val OF = Tokens.OF.id
    private val OFF = Tokens.OFF.id
    private val OMITTED = Tokens.OMITTED.id
    private val ON = Tokens.ON.id
    private val OPEN = Tokens.OPEN.id
    private val OPTIONAL = Tokens.OPTIONAL.id
    private val OR = Tokens.OR.id
    private val ORDER = Tokens.ORDER.id
    private val ORDERLY = Tokens.ORDERLY.id
    private val ORGANIZATION = Tokens.ORGANIZATION.id
    private val OTHER = Tokens.OTHER.id
    private val OUTPUT = Tokens.OUTPUT.id
    private val OVERFLOW = Tokens.OVERFLOW.id
    private val OVERLINE = Tokens.OVERLINE.id
    private val OWN = Tokens.OWN.id
    private val PACKED_DECIMAL = Tokens.PACKED_DECIMAL.id
    private val PADDING = Tokens.PADDING.id
    private val PAGE = Tokens.PAGE.id
    private val PAGE_COUNTER = Tokens.PAGE_COUNTER.id
    private val PASSWORD = Tokens.PASSWORD.id
    private val PERFORM = Tokens.PERFORM.id
    private val PF = Tokens.PF.id
    private val PH = Tokens.PH.id
    private val PIC = Tokens.PIC.id
    private val PICTURE = Tokens.PICTURE.id
    private val PLUS = Tokens.PLUS.id
    private val POINTER = Tokens.POINTER.id
    private val POSITION = Tokens.POSITION.id
    private val POSITIVE = Tokens.POSITIVE.id
    private val PORT = Tokens.PORT.id
    private val PRINTER = Tokens.PRINTER.id
    private val PRINTING = Tokens.PRINTING.id
    private val PRIVATE = Tokens.PRIVATE.id
    private val PROCEDURE = Tokens.PROCEDURE.id
    private val PROCEDURE_POINTER = Tokens.PROCEDURE_POINTER.id
    private val PROCEDURES = Tokens.PROCEDURES.id
    private val PROCEED = Tokens.PROCEED.id
    private val PROCESS = Tokens.PROCESS.id
    private val PROGRAM = Tokens.PROGRAM.id
    private val PROGRAM_ID = Tokens.PROGRAM_ID.id
    private val PROGRAM_LIBRARY = Tokens.PROGRAM_LIBRARY.id
    private val PROMPT = Tokens.PROMPT.id
    private val PURGE = Tokens.PURGE.id
    private val QUEUE = Tokens.QUEUE.id
    private val QUOTE = Tokens.QUOTE.id
    private val QUOTES = Tokens.QUOTES.id
    private val RANDOM = Tokens.RANDOM.id
    private val READER = Tokens.READER.id
    private val REMOTE = Tokens.REMOTE.id
    private val RD = Tokens.RD.id
    private val REAL = Tokens.REAL.id
    private val READ = Tokens.READ.id
    private val RECEIVE = Tokens.RECEIVE.id
    private val RECEIVED = Tokens.RECEIVED.id
    private val RECORD = Tokens.RECORD.id
    private val RECORDING = Tokens.RECORDING.id
    private val RECORDS = Tokens.RECORDS.id
    private val RECURSIVE = Tokens.RECURSIVE.id
    private val REDEFINES = Tokens.REDEFINES.id
    private val REEL = Tokens.REEL.id
    private val REF = Tokens.REF.id
    private val REFERENCE = Tokens.REFERENCE.id
    private val REFERENCES = Tokens.REFERENCES.id
    private val RELATIVE = Tokens.RELATIVE.id
    private val RELEASE = Tokens.RELEASE.id
    private val REMAINDER = Tokens.REMAINDER.id
    private val REMARKS = Tokens.REMARKS.id
    private val REMOVAL = Tokens.REMOVAL.id
    private val REMOVE = Tokens.REMOVE.id
    private val RENAMES = Tokens.RENAMES.id
    private val REPLACE = Tokens.REPLACE.id
    private val REPLACING = Tokens.REPLACING.id
    private val REPORT = Tokens.REPORT.id
    private val REPORTING = Tokens.REPORTING.id
    private val REPORTS = Tokens.REPORTS.id
    private val REQUIRED = Tokens.REQUIRED.id
    private val RERUN = Tokens.RERUN.id
    private val RESERVE = Tokens.RESERVE.id
    private val REVERSE_VIDEO = Tokens.REVERSE_VIDEO.id
    private val RESET = Tokens.RESET.id
    private val RETURN = Tokens.RETURN.id
    private val RETURN_CODE = Tokens.RETURN_CODE.id
    private val RETURNING = Tokens.RETURNING.id
    private val REVERSED = Tokens.REVERSED.id
    private val REWIND = Tokens.REWIND.id
    private val REWRITE = Tokens.REWRITE.id
    private val RF = Tokens.RF.id
    private val RH = Tokens.RH.id
    private val RIGHT = Tokens.RIGHT.id
    private val ROUNDED = Tokens.ROUNDED.id
    private val RUN = Tokens.RUN.id
    private val SAME = Tokens.SAME.id
    private val SAVE = Tokens.SAVE.id
    private val SCREEN = Tokens.SCREEN.id
    private val SD = Tokens.SD.id
    private val SEARCH = Tokens.SEARCH.id
    private val SECTION = Tokens.SECTION.id
    private val SECURE = Tokens.SECURE.id
    private val SECURITY = Tokens.SECURITY.id
    private val SEGMENT = Tokens.SEGMENT.id
    private val SEGMENT_LIMIT = Tokens.SEGMENT_LIMIT.id
    private val SELECT = Tokens.SELECT.id
    private val SEND = Tokens.SEND.id
    private val SENTENCE = Tokens.SENTENCE.id
    private val SEPARATE = Tokens.SEPARATE.id
    private val SEQUENCE = Tokens.SEQUENCE.id
    private val SEQUENTIAL = Tokens.SEQUENTIAL.id
    private val SET = Tokens.SET.id
    private val SHARED = Tokens.SHARED.id
    private val SHAREDBYALL = Tokens.SHAREDBYALL.id
    private val SHAREDBYRUNUNIT = Tokens.SHAREDBYRUNUNIT.id
    private val SHARING = Tokens.SHARING.id
    private val SHIFT_IN = Tokens.SHIFT_IN.id
    private val SHIFT_OUT = Tokens.SHIFT_OUT.id
    private val SHORT_DATE = Tokens.SHORT_DATE.id
    private val SIGN = Tokens.SIGN.id
    private val SIZE = Tokens.SIZE.id
    private val SORT = Tokens.SORT.id
    private val SORT_CONTROL = Tokens.SORT_CONTROL.id
    private val SORT_CORE_SIZE = Tokens.SORT_CORE_SIZE.id
    private val SORT_FILE_SIZE = Tokens.SORT_FILE_SIZE.id
    private val SORT_MERGE = Tokens.SORT_MERGE.id
    private val SORT_MESSAGE = Tokens.SORT_MESSAGE.id
    private val SORT_MODE_SIZE = Tokens.SORT_MODE_SIZE.id
    private val SORT_RETURN = Tokens.SORT_RETURN.id
    private val SOURCE = Tokens.SOURCE.id
    private val SOURCE_COMPUTER = Tokens.SOURCE_COMPUTER.id
    private val SPACE = Tokens.SPACE.id
    private val SPACES = Tokens.SPACES.id
    private val SPECIAL_NAMES = Tokens.SPECIAL_NAMES.id
    private val STANDARD = Tokens.STANDARD.id
    private val STANDARD_1 = Tokens.STANDARD_1.id
    private val STANDARD_2 = Tokens.STANDARD_2.id
    private val START = Tokens.START.id
    private val STATUS = Tokens.STATUS.id
    private val STOP = Tokens.STOP.id
    private val STRING = Tokens.STRING.id
    private val SUB_QUEUE_1 = Tokens.SUB_QUEUE_1.id
    private val SUB_QUEUE_2 = Tokens.SUB_QUEUE_2.id
    private val SUB_QUEUE_3 = Tokens.SUB_QUEUE_3.id
    private val SUBTRACT = Tokens.SUBTRACT.id
    private val SUM = Tokens.SUM.id
    private val SUPPRESS = Tokens.SUPPRESS.id
    private val SYMBOL = Tokens.SYMBOL.id
    private val SYMBOLIC = Tokens.SYMBOLIC.id
    private val SYNC = Tokens.SYNC.id
    private val SYNCHRONIZED = Tokens.SYNCHRONIZED.id
    private val TABLE = Tokens.TABLE.id
    private val TALLY = Tokens.TALLY.id
    private val TALLYING = Tokens.TALLYING.id
    private val TASK = Tokens.TASK.id
    private val TAPE = Tokens.TAPE.id
    private val TERMINAL = Tokens.TERMINAL.id
    private val TERMINATE = Tokens.TERMINATE.id
    private val TEST = Tokens.TEST.id
    private val TEXT = Tokens.TEXT.id
    private val THAN = Tokens.THAN.id
    private val THEN = Tokens.THEN.id
    private val THREAD = Tokens.THREAD.id
    private val THREAD_LOCAL = Tokens.THREAD_LOCAL.id
    private val THROUGH = Tokens.THROUGH.id
    private val THRU = Tokens.THRU.id
    private val TIME = Tokens.TIME.id
    private val TIMER = Tokens.TIMER.id
    private val TIMES = Tokens.TIMES.id
    private val TITLE = Tokens.TITLE.id
    private val TO = Tokens.TO.id
    private val TODAYS_DATE = Tokens.TODAYS_DATE.id
    private val TODAYS_NAME = Tokens.TODAYS_NAME.id
    private val TOP = Tokens.TOP.id
    private val TRAILING = Tokens.TRAILING.id
    private val TRUE = Tokens.TRUE.id
    private val TRUNCATED = Tokens.TRUNCATED.id
    private val TYPE = Tokens.TYPE.id
    private val TYPEDEF = Tokens.TYPEDEF.id
    private val UNDERLINE = Tokens.UNDERLINE.id
    private val UNIT = Tokens.UNIT.id
    private val UNSTRING = Tokens.UNSTRING.id
    private val UNTIL = Tokens.UNTIL.id
    private val UP = Tokens.UP.id
    private val UPON = Tokens.UPON.id
    private val USAGE = Tokens.USAGE.id
    private val USE = Tokens.USE.id
    private val USING = Tokens.USING.id
    private val VALUE = Tokens.VALUE.id
    private val VALUES = Tokens.VALUES.id
    private val VARYING = Tokens.VARYING.id
    private val VIRTUAL = Tokens.VIRTUAL.id
    private val WAIT = Tokens.WAIT.id
    private val WHEN = Tokens.WHEN.id
    private val WHEN_COMPILED = Tokens.WHEN_COMPILED.id
    private val WITH = Tokens.WITH.id
    private val WORDS = Tokens.WORDS.id
    private val WORKING_STORAGE = Tokens.WORKING_STORAGE.id
    private val WRITE = Tokens.WRITE.id
    private val YEAR = Tokens.YEAR.id
    private val YYYYMMDD = Tokens.YYYYMMDD.id
    private val YYYYDDD = Tokens.YYYYDDD.id
    private val ZERO = Tokens.ZERO.id
    private val ZERO_FILL = Tokens.ZERO_FILL.id
    private val ZEROS = Tokens.ZEROS.id
    private val ZEROES = Tokens.ZEROES.id
    private val AMPCHAR = Tokens.AMPCHAR.id
    private val ASTERISKCHAR = Tokens.ASTERISKCHAR.id
    private val DOUBLEASTERISKCHAR = Tokens.DOUBLEASTERISKCHAR.id
    private val COLONCHAR = Tokens.COLONCHAR.id
    private val COMMACHAR = Tokens.COMMACHAR.id
    private val COMMENTENTRYTAG = Tokens.COMMENTENTRYTAG.id
    private val COMMENTTAG = Tokens.COMMENTTAG.id
    private val DOLLARCHAR = Tokens.DOLLARCHAR.id
    private val DOUBLEQUOTE = Tokens.DOUBLEQUOTE.id
    private val DOT_FS = Tokens.DOT_FS.id
    private val DOT = Tokens.DOT.id
    private val EQUALCHAR = Tokens.EQUALCHAR.id
    private val EXECCICSTAG = Tokens.EXECCICSTAG.id
    private val EXECSQLTAG = Tokens.EXECSQLTAG.id
    private val EXECSQLIMSTAG = Tokens.EXECSQLIMSTAG.id
    private val LESSTHANCHAR = Tokens.LESSTHANCHAR.id
    private val LESSTHANOREQUAL = Tokens.LESSTHANOREQUAL.id
    private val LPARENCHAR = Tokens.LPARENCHAR.id
    private val MINUSCHAR = Tokens.MINUSCHAR.id
    private val MORETHANCHAR = Tokens.MORETHANCHAR.id
    private val MORETHANOREQUAL = Tokens.MORETHANOREQUAL.id
    private val NOTEQUALCHAR = Tokens.NOTEQUALCHAR.id
    private val PLUSCHAR = Tokens.PLUSCHAR.id
    private val SINGLEQUOTE = Tokens.SINGLEQUOTE.id
    private val RPARENCHAR = Tokens.RPARENCHAR.id
    private val SLASHCHAR = Tokens.SLASHCHAR.id
    private val NONNUMERICLITERAL = Tokens.NONNUMERICLITERAL.id
    private val LEVEL_NUMBER_66 = Tokens.LEVEL_NUMBER_66.id
    private val LEVEL_NUMBER_77 = Tokens.LEVEL_NUMBER_77.id
    private val LEVEL_NUMBER_88 = Tokens.LEVEL_NUMBER_88.id
    private val INTEGERLITERAL = Tokens.INTEGERLITERAL.id
    private val NUMERICLITERAL = Tokens.NUMERICLITERAL.id
    private val IDENTIFIER = Tokens.IDENTIFIER.id
    private val NEWLINE = Tokens.NEWLINE.id
    private val EXECCICSLINE = Tokens.EXECCICSLINE.id
    private val EXECSQLIMSLINE = Tokens.EXECSQLIMSLINE.id
    private val EXECSQLLINE = Tokens.EXECSQLLINE.id
    private val COMMENTENTRYLINE = Tokens.COMMENTENTRYLINE.id
    private val COMMENTLINE = Tokens.COMMENTLINE.id
    private val WS = Tokens.WS.id
    private val SEPARATOR = Tokens.SEPARATOR.id

    /* Named actions */
	init {
		interpreter = ParserATNSimulator(this, ATN, decisionToDFA, sharedContextCache)
	}
	/* Funcs */
	open class StartRuleContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_startRule.id
	        set(value) { throw RuntimeException() }
		fun findCompilationUnit() : CompilationUnitContext? = getRuleContext(solver.getType("CompilationUnitContext"),0)
		fun EOF() : TerminalNode? = getToken(Cobol85Parser.Tokens.EOF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStartRule(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStartRule(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStartRule(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  startRule() : StartRuleContext {
		var _localctx : StartRuleContext = StartRuleContext(context, state)
		enterRule(_localctx, 0, Rules.RULE_startRule.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1190
			compilationUnit()
			this.state = 1191
			match(EOF) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CompilationUnitContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_compilationUnit.id
	        set(value) { throw RuntimeException() }
		fun findProgramUnit() : List<ProgramUnitContext> = getRuleContexts(solver.getType("ProgramUnitContext"))
		fun findProgramUnit(i: Int) : ProgramUnitContext? = getRuleContext(solver.getType("ProgramUnitContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCompilationUnit(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCompilationUnit(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCompilationUnit(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  compilationUnit() : CompilationUnitContext {
		var _localctx : CompilationUnitContext = CompilationUnitContext(context, state)
		enterRule(_localctx, 2, Rules.RULE_compilationUnit.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1194 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 1193
				programUnit()
				}
				}
				this.state = 1196 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( _la==ID || _la==IDENTIFICATION )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProgramUnitContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_programUnit.id
	        set(value) { throw RuntimeException() }
		fun findIdentificationDivision() : IdentificationDivisionContext? = getRuleContext(solver.getType("IdentificationDivisionContext"),0)
		fun findEnvironmentDivision() : EnvironmentDivisionContext? = getRuleContext(solver.getType("EnvironmentDivisionContext"),0)
		fun findDataDivision() : DataDivisionContext? = getRuleContext(solver.getType("DataDivisionContext"),0)
		fun findProcedureDivision() : ProcedureDivisionContext? = getRuleContext(solver.getType("ProcedureDivisionContext"),0)
		fun findProgramUnit() : List<ProgramUnitContext> = getRuleContexts(solver.getType("ProgramUnitContext"))
		fun findProgramUnit(i: Int) : ProgramUnitContext? = getRuleContext(solver.getType("ProgramUnitContext"),i)
		fun findEndProgramStatement() : EndProgramStatementContext? = getRuleContext(solver.getType("EndProgramStatementContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProgramUnit(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProgramUnit(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProgramUnit(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  programUnit() : ProgramUnitContext {
		var _localctx : ProgramUnitContext = ProgramUnitContext(context, state)
		enterRule(_localctx, 4, Rules.RULE_programUnit.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1198
			identificationDivision()
			this.state = 1200
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ENVIRONMENT) {
				if (true){
				this.state = 1199
				environmentDivision()
				}
			}

			this.state = 1203
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DATA) {
				if (true){
				this.state = 1202
				dataDivision()
				}
			}

			this.state = 1206
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==PROCEDURE) {
				if (true){
				this.state = 1205
				procedureDivision()
				}
			}

			this.state = 1211
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,4,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 1208
					programUnit()
					}
					} 
				}
				this.state = 1213
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,4,context)
			}
			this.state = 1215
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,5,context) ) {
			1   -> if (true){
			this.state = 1214
			endProgramStatement()
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EndProgramStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_endProgramStatement.id
	        set(value) { throw RuntimeException() }
		fun END() : TerminalNode? = getToken(Cobol85Parser.Tokens.END.id, 0)
		fun PROGRAM() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROGRAM.id, 0)
		fun findProgramName() : ProgramNameContext? = getRuleContext(solver.getType("ProgramNameContext"),0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEndProgramStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEndProgramStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEndProgramStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  endProgramStatement() : EndProgramStatementContext {
		var _localctx : EndProgramStatementContext = EndProgramStatementContext(context, state)
		enterRule(_localctx, 6, Rules.RULE_endProgramStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1217
			match(END) as Token
			this.state = 1218
			match(PROGRAM) as Token
			this.state = 1219
			programName()
			this.state = 1220
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class IdentificationDivisionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_identificationDivision.id
	        set(value) { throw RuntimeException() }
		fun DIVISION() : TerminalNode? = getToken(Cobol85Parser.Tokens.DIVISION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findProgramIdParagraph() : ProgramIdParagraphContext? = getRuleContext(solver.getType("ProgramIdParagraphContext"),0)
		fun IDENTIFICATION() : TerminalNode? = getToken(Cobol85Parser.Tokens.IDENTIFICATION.id, 0)
		fun ID() : TerminalNode? = getToken(Cobol85Parser.Tokens.ID.id, 0)
		fun findIdentificationDivisionBody() : List<IdentificationDivisionBodyContext> = getRuleContexts(solver.getType("IdentificationDivisionBodyContext"))
		fun findIdentificationDivisionBody(i: Int) : IdentificationDivisionBodyContext? = getRuleContext(solver.getType("IdentificationDivisionBodyContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterIdentificationDivision(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitIdentificationDivision(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitIdentificationDivision(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  identificationDivision() : IdentificationDivisionContext {
		var _localctx : IdentificationDivisionContext = IdentificationDivisionContext(context, state)
		enterRule(_localctx, 8, Rules.RULE_identificationDivision.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1222
			_la = _input!!.LA(1)
			if ( !(_la==ID || _la==IDENTIFICATION) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 1223
			match(DIVISION) as Token
			this.state = 1224
			match(DOT_FS) as Token
			this.state = 1225
			programIdParagraph()
			this.state = 1229
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==AUTHOR || _la==DATE_COMPILED || _la==DATE_WRITTEN || _la==INSTALLATION || _la==REMARKS || _la==SECURITY) {
				if (true){
				if (true){
				this.state = 1226
				identificationDivisionBody()
				}
				}
				this.state = 1231
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class IdentificationDivisionBodyContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_identificationDivisionBody.id
	        set(value) { throw RuntimeException() }
		fun findAuthorParagraph() : AuthorParagraphContext? = getRuleContext(solver.getType("AuthorParagraphContext"),0)
		fun findInstallationParagraph() : InstallationParagraphContext? = getRuleContext(solver.getType("InstallationParagraphContext"),0)
		fun findDateWrittenParagraph() : DateWrittenParagraphContext? = getRuleContext(solver.getType("DateWrittenParagraphContext"),0)
		fun findDateCompiledParagraph() : DateCompiledParagraphContext? = getRuleContext(solver.getType("DateCompiledParagraphContext"),0)
		fun findSecurityParagraph() : SecurityParagraphContext? = getRuleContext(solver.getType("SecurityParagraphContext"),0)
		fun findRemarksParagraph() : RemarksParagraphContext? = getRuleContext(solver.getType("RemarksParagraphContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterIdentificationDivisionBody(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitIdentificationDivisionBody(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitIdentificationDivisionBody(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  identificationDivisionBody() : IdentificationDivisionBodyContext {
		var _localctx : IdentificationDivisionBodyContext = IdentificationDivisionBodyContext(context, state)
		enterRule(_localctx, 10, Rules.RULE_identificationDivisionBody.id)
		try {
			this.state = 1238
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			AUTHOR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1232
			authorParagraph()
			}}
			INSTALLATION  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1233
			installationParagraph()
			}}
			DATE_WRITTEN  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 1234
			dateWrittenParagraph()
			}}
			DATE_COMPILED  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 1235
			dateCompiledParagraph()
			}}
			SECURITY  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 1236
			securityParagraph()
			}}
			REMARKS  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 6)
			if (true){
			this.state = 1237
			remarksParagraph()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProgramIdParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_programIdParagraph.id
	        set(value) { throw RuntimeException() }
		fun PROGRAM_ID() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROGRAM_ID.id, 0)
		fun DOT_FS() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.DOT_FS.id)
		fun DOT_FS(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.DOT_FS.id, i) as TerminalNode
		fun findProgramName() : ProgramNameContext? = getRuleContext(solver.getType("ProgramNameContext"),0)
		fun findCommentEntry() : CommentEntryContext? = getRuleContext(solver.getType("CommentEntryContext"),0)
		fun COMMON() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMMON.id, 0)
		fun INITIAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.INITIAL.id, 0)
		fun LIBRARY() : TerminalNode? = getToken(Cobol85Parser.Tokens.LIBRARY.id, 0)
		fun DEFINITION() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEFINITION.id, 0)
		fun RECURSIVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECURSIVE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun PROGRAM() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROGRAM.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProgramIdParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProgramIdParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProgramIdParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  programIdParagraph() : ProgramIdParagraphContext {
		var _localctx : ProgramIdParagraphContext = ProgramIdParagraphContext(context, state)
		enterRule(_localctx, 12, Rules.RULE_programIdParagraph.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1240
			match(PROGRAM_ID) as Token
			this.state = 1241
			match(DOT_FS) as Token
			this.state = 1242
			programName()
			this.state = 1250
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COMMON || _la==DEFINITION || ((((_la - 243)) and 0x3f.inv()) == 0 && ((1L shl (_la - 243)) and ((1L shl (INITIAL - 243)) or (1L shl (IS - 243)) or (1L shl (LIBRARY - 243)))) != 0L) || _la==RECURSIVE) {
				if (true){
				this.state = 1244
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 1243
					match(IS) as Token
					}
				}

				this.state = 1246
				_la = _input!!.LA(1)
				if ( !(_la==COMMON || _la==DEFINITION || _la==INITIAL || _la==LIBRARY || _la==RECURSIVE) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				this.state = 1248
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==PROGRAM) {
					if (true){
					this.state = 1247
					match(PROGRAM) as Token
					}
				}

				}
			}

			this.state = 1253
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DOT_FS) {
				if (true){
				this.state = 1252
				match(DOT_FS) as Token
				}
			}

			this.state = 1256
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COMMENTENTRYLINE) {
				if (true){
				this.state = 1255
				commentEntry()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AuthorParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_authorParagraph.id
	        set(value) { throw RuntimeException() }
		fun AUTHOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.AUTHOR.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findCommentEntry() : CommentEntryContext? = getRuleContext(solver.getType("CommentEntryContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAuthorParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAuthorParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAuthorParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  authorParagraph() : AuthorParagraphContext {
		var _localctx : AuthorParagraphContext = AuthorParagraphContext(context, state)
		enterRule(_localctx, 14, Rules.RULE_authorParagraph.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1258
			match(AUTHOR) as Token
			this.state = 1259
			match(DOT_FS) as Token
			this.state = 1261
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COMMENTENTRYLINE) {
				if (true){
				this.state = 1260
				commentEntry()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InstallationParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_installationParagraph.id
	        set(value) { throw RuntimeException() }
		fun INSTALLATION() : TerminalNode? = getToken(Cobol85Parser.Tokens.INSTALLATION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findCommentEntry() : CommentEntryContext? = getRuleContext(solver.getType("CommentEntryContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInstallationParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInstallationParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInstallationParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  installationParagraph() : InstallationParagraphContext {
		var _localctx : InstallationParagraphContext = InstallationParagraphContext(context, state)
		enterRule(_localctx, 16, Rules.RULE_installationParagraph.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1263
			match(INSTALLATION) as Token
			this.state = 1264
			match(DOT_FS) as Token
			this.state = 1266
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COMMENTENTRYLINE) {
				if (true){
				this.state = 1265
				commentEntry()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DateWrittenParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dateWrittenParagraph.id
	        set(value) { throw RuntimeException() }
		fun DATE_WRITTEN() : TerminalNode? = getToken(Cobol85Parser.Tokens.DATE_WRITTEN.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findCommentEntry() : CommentEntryContext? = getRuleContext(solver.getType("CommentEntryContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDateWrittenParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDateWrittenParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDateWrittenParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dateWrittenParagraph() : DateWrittenParagraphContext {
		var _localctx : DateWrittenParagraphContext = DateWrittenParagraphContext(context, state)
		enterRule(_localctx, 18, Rules.RULE_dateWrittenParagraph.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1268
			match(DATE_WRITTEN) as Token
			this.state = 1269
			match(DOT_FS) as Token
			this.state = 1271
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COMMENTENTRYLINE) {
				if (true){
				this.state = 1270
				commentEntry()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DateCompiledParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dateCompiledParagraph.id
	        set(value) { throw RuntimeException() }
		fun DATE_COMPILED() : TerminalNode? = getToken(Cobol85Parser.Tokens.DATE_COMPILED.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findCommentEntry() : CommentEntryContext? = getRuleContext(solver.getType("CommentEntryContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDateCompiledParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDateCompiledParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDateCompiledParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dateCompiledParagraph() : DateCompiledParagraphContext {
		var _localctx : DateCompiledParagraphContext = DateCompiledParagraphContext(context, state)
		enterRule(_localctx, 20, Rules.RULE_dateCompiledParagraph.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1273
			match(DATE_COMPILED) as Token
			this.state = 1274
			match(DOT_FS) as Token
			this.state = 1276
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COMMENTENTRYLINE) {
				if (true){
				this.state = 1275
				commentEntry()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SecurityParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_securityParagraph.id
	        set(value) { throw RuntimeException() }
		fun SECURITY() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECURITY.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findCommentEntry() : CommentEntryContext? = getRuleContext(solver.getType("CommentEntryContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSecurityParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSecurityParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSecurityParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  securityParagraph() : SecurityParagraphContext {
		var _localctx : SecurityParagraphContext = SecurityParagraphContext(context, state)
		enterRule(_localctx, 22, Rules.RULE_securityParagraph.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1278
			match(SECURITY) as Token
			this.state = 1279
			match(DOT_FS) as Token
			this.state = 1281
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COMMENTENTRYLINE) {
				if (true){
				this.state = 1280
				commentEntry()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RemarksParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_remarksParagraph.id
	        set(value) { throw RuntimeException() }
		fun REMARKS() : TerminalNode? = getToken(Cobol85Parser.Tokens.REMARKS.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findCommentEntry() : CommentEntryContext? = getRuleContext(solver.getType("CommentEntryContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRemarksParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRemarksParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRemarksParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  remarksParagraph() : RemarksParagraphContext {
		var _localctx : RemarksParagraphContext = RemarksParagraphContext(context, state)
		enterRule(_localctx, 24, Rules.RULE_remarksParagraph.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1283
			match(REMARKS) as Token
			this.state = 1284
			match(DOT_FS) as Token
			this.state = 1286
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COMMENTENTRYLINE) {
				if (true){
				this.state = 1285
				commentEntry()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EnvironmentDivisionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_environmentDivision.id
	        set(value) { throw RuntimeException() }
		fun ENVIRONMENT() : TerminalNode? = getToken(Cobol85Parser.Tokens.ENVIRONMENT.id, 0)
		fun DIVISION() : TerminalNode? = getToken(Cobol85Parser.Tokens.DIVISION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findEnvironmentDivisionBody() : List<EnvironmentDivisionBodyContext> = getRuleContexts(solver.getType("EnvironmentDivisionBodyContext"))
		fun findEnvironmentDivisionBody(i: Int) : EnvironmentDivisionBodyContext? = getRuleContext(solver.getType("EnvironmentDivisionBodyContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEnvironmentDivision(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEnvironmentDivision(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEnvironmentDivision(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  environmentDivision() : EnvironmentDivisionContext {
		var _localctx : EnvironmentDivisionContext = EnvironmentDivisionContext(context, state)
		enterRule(_localctx, 26, Rules.RULE_environmentDivision.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1288
			match(ENVIRONMENT) as Token
			this.state = 1289
			match(DIVISION) as Token
			this.state = 1290
			match(DOT_FS) as Token
			this.state = 1294
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==CONFIGURATION || _la==INPUT_OUTPUT || _la==SPECIAL_NAMES) {
				if (true){
				if (true){
				this.state = 1291
				environmentDivisionBody()
				}
				}
				this.state = 1296
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EnvironmentDivisionBodyContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_environmentDivisionBody.id
	        set(value) { throw RuntimeException() }
		fun findConfigurationSection() : ConfigurationSectionContext? = getRuleContext(solver.getType("ConfigurationSectionContext"),0)
		fun findSpecialNamesParagraph() : SpecialNamesParagraphContext? = getRuleContext(solver.getType("SpecialNamesParagraphContext"),0)
		fun findInputOutputSection() : InputOutputSectionContext? = getRuleContext(solver.getType("InputOutputSectionContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEnvironmentDivisionBody(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEnvironmentDivisionBody(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEnvironmentDivisionBody(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  environmentDivisionBody() : EnvironmentDivisionBodyContext {
		var _localctx : EnvironmentDivisionBodyContext = EnvironmentDivisionBodyContext(context, state)
		enterRule(_localctx, 28, Rules.RULE_environmentDivisionBody.id)
		try {
			this.state = 1300
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			CONFIGURATION  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1297
			configurationSection()
			}}
			SPECIAL_NAMES  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1298
			specialNamesParagraph()
			}}
			INPUT_OUTPUT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 1299
			inputOutputSection()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ConfigurationSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_configurationSection.id
	        set(value) { throw RuntimeException() }
		fun CONFIGURATION() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONFIGURATION.id, 0)
		fun SECTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECTION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findConfigurationSectionParagraph() : List<ConfigurationSectionParagraphContext> = getRuleContexts(solver.getType("ConfigurationSectionParagraphContext"))
		fun findConfigurationSectionParagraph(i: Int) : ConfigurationSectionParagraphContext? = getRuleContext(solver.getType("ConfigurationSectionParagraphContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterConfigurationSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitConfigurationSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitConfigurationSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  configurationSection() : ConfigurationSectionContext {
		var _localctx : ConfigurationSectionContext = ConfigurationSectionContext(context, state)
		enterRule(_localctx, 30, Rules.RULE_configurationSection.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1302
			match(CONFIGURATION) as Token
			this.state = 1303
			match(SECTION) as Token
			this.state = 1304
			match(DOT_FS) as Token
			this.state = 1308
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,21,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 1305
					configurationSectionParagraph()
					}
					} 
				}
				this.state = 1310
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,21,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ConfigurationSectionParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_configurationSectionParagraph.id
	        set(value) { throw RuntimeException() }
		fun findSourceComputerParagraph() : SourceComputerParagraphContext? = getRuleContext(solver.getType("SourceComputerParagraphContext"),0)
		fun findObjectComputerParagraph() : ObjectComputerParagraphContext? = getRuleContext(solver.getType("ObjectComputerParagraphContext"),0)
		fun findSpecialNamesParagraph() : SpecialNamesParagraphContext? = getRuleContext(solver.getType("SpecialNamesParagraphContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterConfigurationSectionParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitConfigurationSectionParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitConfigurationSectionParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  configurationSectionParagraph() : ConfigurationSectionParagraphContext {
		var _localctx : ConfigurationSectionParagraphContext = ConfigurationSectionParagraphContext(context, state)
		enterRule(_localctx, 32, Rules.RULE_configurationSectionParagraph.id)
		try {
			this.state = 1314
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			SOURCE_COMPUTER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1311
			sourceComputerParagraph()
			}}
			OBJECT_COMPUTER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1312
			objectComputerParagraph()
			}}
			SPECIAL_NAMES  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 1313
			specialNamesParagraph()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SourceComputerParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sourceComputerParagraph.id
	        set(value) { throw RuntimeException() }
		fun SOURCE_COMPUTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.SOURCE_COMPUTER.id, 0)
		fun DOT_FS() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.DOT_FS.id)
		fun DOT_FS(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.DOT_FS.id, i) as TerminalNode
		fun findComputerName() : ComputerNameContext? = getRuleContext(solver.getType("ComputerNameContext"),0)
		fun DEBUGGING() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEBUGGING.id, 0)
		fun MODE() : TerminalNode? = getToken(Cobol85Parser.Tokens.MODE.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSourceComputerParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSourceComputerParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSourceComputerParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sourceComputerParagraph() : SourceComputerParagraphContext {
		var _localctx : SourceComputerParagraphContext = SourceComputerParagraphContext(context, state)
		enterRule(_localctx, 34, Rules.RULE_sourceComputerParagraph.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1316
			match(SOURCE_COMPUTER) as Token
			this.state = 1317
			match(DOT_FS) as Token
			this.state = 1318
			computerName()
			this.state = 1324
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DEBUGGING || _la==WITH) {
				if (true){
				this.state = 1320
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==WITH) {
					if (true){
					this.state = 1319
					match(WITH) as Token
					}
				}

				this.state = 1322
				match(DEBUGGING) as Token
				this.state = 1323
				match(MODE) as Token
				}
			}

			this.state = 1326
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ObjectComputerParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_objectComputerParagraph.id
	        set(value) { throw RuntimeException() }
		fun OBJECT_COMPUTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.OBJECT_COMPUTER.id, 0)
		fun DOT_FS() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.DOT_FS.id)
		fun DOT_FS(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.DOT_FS.id, i) as TerminalNode
		fun findComputerName() : ComputerNameContext? = getRuleContext(solver.getType("ComputerNameContext"),0)
		fun findObjectComputerClause() : List<ObjectComputerClauseContext> = getRuleContexts(solver.getType("ObjectComputerClauseContext"))
		fun findObjectComputerClause(i: Int) : ObjectComputerClauseContext? = getRuleContext(solver.getType("ObjectComputerClauseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterObjectComputerParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitObjectComputerParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitObjectComputerParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  objectComputerParagraph() : ObjectComputerParagraphContext {
		var _localctx : ObjectComputerParagraphContext = ObjectComputerParagraphContext(context, state)
		enterRule(_localctx, 36, Rules.RULE_objectComputerParagraph.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1328
			match(OBJECT_COMPUTER) as Token
			this.state = 1329
			match(DOT_FS) as Token
			this.state = 1330
			computerName()
			this.state = 1334
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==CHARACTER || _la==COLLATING || _la==DISK || _la==MEMORY || _la==PROGRAM || _la==SEGMENT_LIMIT || _la==SEQUENCE) {
				if (true){
				if (true){
				this.state = 1331
				objectComputerClause()
				}
				}
				this.state = 1336
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 1337
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ObjectComputerClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_objectComputerClause.id
	        set(value) { throw RuntimeException() }
		fun findMemorySizeClause() : MemorySizeClauseContext? = getRuleContext(solver.getType("MemorySizeClauseContext"),0)
		fun findDiskSizeClause() : DiskSizeClauseContext? = getRuleContext(solver.getType("DiskSizeClauseContext"),0)
		fun findCollatingSequenceClause() : CollatingSequenceClauseContext? = getRuleContext(solver.getType("CollatingSequenceClauseContext"),0)
		fun findSegmentLimitClause() : SegmentLimitClauseContext? = getRuleContext(solver.getType("SegmentLimitClauseContext"),0)
		fun findCharacterSetClause() : CharacterSetClauseContext? = getRuleContext(solver.getType("CharacterSetClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterObjectComputerClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitObjectComputerClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitObjectComputerClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  objectComputerClause() : ObjectComputerClauseContext {
		var _localctx : ObjectComputerClauseContext = ObjectComputerClauseContext(context, state)
		enterRule(_localctx, 38, Rules.RULE_objectComputerClause.id)
		try {
			this.state = 1344
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			MEMORY  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1339
			memorySizeClause()
			}}
			DISK  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1340
			diskSizeClause()
			}}
			COLLATING , PROGRAM , SEQUENCE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 1341
			collatingSequenceClause()
			}}
			SEGMENT_LIMIT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 1342
			segmentLimitClause()
			}}
			CHARACTER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 1343
			characterSetClause()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MemorySizeClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_memorySizeClause.id
	        set(value) { throw RuntimeException() }
		fun MEMORY() : TerminalNode? = getToken(Cobol85Parser.Tokens.MEMORY.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		fun SIZE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIZE.id, 0)
		fun WORDS() : TerminalNode? = getToken(Cobol85Parser.Tokens.WORDS.id, 0)
		fun CHARACTERS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTERS.id, 0)
		fun MODULES() : TerminalNode? = getToken(Cobol85Parser.Tokens.MODULES.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMemorySizeClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMemorySizeClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMemorySizeClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  memorySizeClause() : MemorySizeClauseContext {
		var _localctx : MemorySizeClauseContext = MemorySizeClauseContext(context, state)
		enterRule(_localctx, 40, Rules.RULE_memorySizeClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1346
			match(MEMORY) as Token
			this.state = 1348
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SIZE) {
				if (true){
				this.state = 1347
				match(SIZE) as Token
				}
			}

			this.state = 1352
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 1350
			integerLiteral()
			}}
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 1351
			cobolWord()
			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 1355
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CHARACTERS || _la==MODULES || _la==WORDS) {
				if (true){
				this.state = 1354
				_la = _input!!.LA(1)
				if ( !(_la==CHARACTERS || _la==MODULES || _la==WORDS) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DiskSizeClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_diskSizeClause.id
	        set(value) { throw RuntimeException() }
		fun DISK() : TerminalNode? = getToken(Cobol85Parser.Tokens.DISK.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		fun SIZE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIZE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun WORDS() : TerminalNode? = getToken(Cobol85Parser.Tokens.WORDS.id, 0)
		fun MODULES() : TerminalNode? = getToken(Cobol85Parser.Tokens.MODULES.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDiskSizeClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDiskSizeClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDiskSizeClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  diskSizeClause() : DiskSizeClauseContext {
		var _localctx : DiskSizeClauseContext = DiskSizeClauseContext(context, state)
		enterRule(_localctx, 42, Rules.RULE_diskSizeClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1357
			match(DISK) as Token
			this.state = 1359
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SIZE) {
				if (true){
				this.state = 1358
				match(SIZE) as Token
				}
			}

			this.state = 1362
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1361
				match(IS) as Token
				}
			}

			this.state = 1366
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 1364
			integerLiteral()
			}}
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 1365
			cobolWord()
			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 1369
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==MODULES || _la==WORDS) {
				if (true){
				this.state = 1368
				_la = _input!!.LA(1)
				if ( !(_la==MODULES || _la==WORDS) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CollatingSequenceClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_collatingSequenceClause.id
	        set(value) { throw RuntimeException() }
		fun SEQUENCE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEQUENCE.id, 0)
		fun PROGRAM() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROGRAM.id, 0)
		fun COLLATING() : TerminalNode? = getToken(Cobol85Parser.Tokens.COLLATING.id, 0)
		fun findCollatingSequenceClauseAlphanumeric() : CollatingSequenceClauseAlphanumericContext? = getRuleContext(solver.getType("CollatingSequenceClauseAlphanumericContext"),0)
		fun findCollatingSequenceClauseNational() : CollatingSequenceClauseNationalContext? = getRuleContext(solver.getType("CollatingSequenceClauseNationalContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findAlphabetName() : List<AlphabetNameContext> = getRuleContexts(solver.getType("AlphabetNameContext"))
		fun findAlphabetName(i: Int) : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCollatingSequenceClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCollatingSequenceClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCollatingSequenceClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  collatingSequenceClause() : CollatingSequenceClauseContext {
		var _localctx : CollatingSequenceClauseContext = CollatingSequenceClauseContext(context, state)
		enterRule(_localctx, 44, Rules.RULE_collatingSequenceClause.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1372
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==PROGRAM) {
				if (true){
				this.state = 1371
				match(PROGRAM) as Token
				}
			}

			this.state = 1375
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COLLATING) {
				if (true){
				this.state = 1374
				match(COLLATING) as Token
				}
			}

			this.state = 1377
			match(SEQUENCE) as Token
			if (true){
			this.state = 1379
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1378
				match(IS) as Token
				}
			}

			this.state = 1382 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 1381
				alphabetName()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 1384 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,37,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
			this.state = 1387
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,38,context) ) {
			1   -> if (true){
			this.state = 1386
			collatingSequenceClauseAlphanumeric()
			}
			}
			this.state = 1390
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR || _la==NATIONAL) {
				if (true){
				this.state = 1389
				collatingSequenceClauseNational()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CollatingSequenceClauseAlphanumericContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_collatingSequenceClauseAlphanumeric.id
	        set(value) { throw RuntimeException() }
		fun ALPHANUMERIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHANUMERIC.id, 0)
		fun findAlphabetName() : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCollatingSequenceClauseAlphanumeric(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCollatingSequenceClauseAlphanumeric(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCollatingSequenceClauseAlphanumeric(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  collatingSequenceClauseAlphanumeric() : CollatingSequenceClauseAlphanumericContext {
		var _localctx : CollatingSequenceClauseAlphanumericContext = CollatingSequenceClauseAlphanumericContext(context, state)
		enterRule(_localctx, 46, Rules.RULE_collatingSequenceClauseAlphanumeric.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1393
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 1392
				match(FOR) as Token
				}
			}

			this.state = 1395
			match(ALPHANUMERIC) as Token
			this.state = 1397
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1396
				match(IS) as Token
				}
			}

			this.state = 1399
			alphabetName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CollatingSequenceClauseNationalContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_collatingSequenceClauseNational.id
	        set(value) { throw RuntimeException() }
		fun NATIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIONAL.id, 0)
		fun findAlphabetName() : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCollatingSequenceClauseNational(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCollatingSequenceClauseNational(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCollatingSequenceClauseNational(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  collatingSequenceClauseNational() : CollatingSequenceClauseNationalContext {
		var _localctx : CollatingSequenceClauseNationalContext = CollatingSequenceClauseNationalContext(context, state)
		enterRule(_localctx, 48, Rules.RULE_collatingSequenceClauseNational.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1402
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 1401
				match(FOR) as Token
				}
			}

			this.state = 1404
			match(NATIONAL) as Token
			this.state = 1406
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1405
				match(IS) as Token
				}
			}

			this.state = 1408
			alphabetName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SegmentLimitClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_segmentLimitClause.id
	        set(value) { throw RuntimeException() }
		fun SEGMENT_LIMIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEGMENT_LIMIT.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSegmentLimitClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSegmentLimitClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSegmentLimitClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  segmentLimitClause() : SegmentLimitClauseContext {
		var _localctx : SegmentLimitClauseContext = SegmentLimitClauseContext(context, state)
		enterRule(_localctx, 50, Rules.RULE_segmentLimitClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1410
			match(SEGMENT_LIMIT) as Token
			this.state = 1412
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1411
				match(IS) as Token
				}
			}

			this.state = 1414
			integerLiteral()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CharacterSetClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_characterSetClause.id
	        set(value) { throw RuntimeException() }
		fun CHARACTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTER.id, 0)
		fun SET() : TerminalNode? = getToken(Cobol85Parser.Tokens.SET.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCharacterSetClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCharacterSetClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCharacterSetClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  characterSetClause() : CharacterSetClauseContext {
		var _localctx : CharacterSetClauseContext = CharacterSetClauseContext(context, state)
		enterRule(_localctx, 52, Rules.RULE_characterSetClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1416
			match(CHARACTER) as Token
			this.state = 1417
			match(SET) as Token
			this.state = 1418
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SpecialNamesParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_specialNamesParagraph.id
	        set(value) { throw RuntimeException() }
		fun SPECIAL_NAMES() : TerminalNode? = getToken(Cobol85Parser.Tokens.SPECIAL_NAMES.id, 0)
		fun DOT_FS() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.DOT_FS.id)
		fun DOT_FS(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.DOT_FS.id, i) as TerminalNode
		fun findSpecialNameClause() : List<SpecialNameClauseContext> = getRuleContexts(solver.getType("SpecialNameClauseContext"))
		fun findSpecialNameClause(i: Int) : SpecialNameClauseContext? = getRuleContext(solver.getType("SpecialNameClauseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSpecialNamesParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSpecialNamesParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSpecialNamesParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  specialNamesParagraph() : SpecialNamesParagraphContext {
		var _localctx : SpecialNamesParagraphContext = SpecialNamesParagraphContext(context, state)
		enterRule(_localctx, 54, Rules.RULE_specialNamesParagraph.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1420
			match(SPECIAL_NAMES) as Token
			this.state = 1421
			match(DOT_FS) as Token
			this.state = 1429
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ALPHABET) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 64)) and 0x3f.inv()) == 0 && ((1L shl (_la - 64)) and ((1L shl (CLASS - 64)) or (1L shl (CLOSE_DISPOSITION - 64)) or (1L shl (COBOL - 64)) or (1L shl (COMMITMENT - 64)) or (1L shl (CONTROL_POINT - 64)) or (1L shl (CONVENTION - 64)) or (1L shl (CRUNCH - 64)) or (1L shl (CURRENCY - 64)) or (1L shl (CURSOR - 64)) or (1L shl (DECIMAL_POINT - 64)))) != 0L) || ((((_la - 128)) and 0x3f.inv()) == 0 && ((1L shl (_la - 128)) and ((1L shl (DEFAULT - 128)) or (1L shl (DEFAULT_DISPLAY - 128)) or (1L shl (DEFINITION - 128)) or (1L shl (DFHRESP - 128)) or (1L shl (DFHVALUE - 128)) or (1L shl (DISK - 128)) or (1L shl (DONTCARE - 128)) or (1L shl (DOUBLE - 128)) or (1L shl (EBCDIC - 128)) or (1L shl (EMPTY_CHECK - 128)) or (1L shl (ENTER - 128)) or (1L shl (ENTRY_PROCEDURE - 128)) or (1L shl (ERASE - 128)) or (1L shl (EOL - 128)) or (1L shl (EOS - 128)) or (1L shl (ESCAPE - 128)))) != 0L) || ((((_la - 194)) and 0x3f.inv()) == 0 && ((1L shl (_la - 194)) and ((1L shl (EVENT - 194)) or (1L shl (EXCLUSIVE - 194)) or (1L shl (EXPORT - 194)) or (1L shl (EXTENDED - 194)) or (1L shl (FOREGROUND_COLOR - 194)) or (1L shl (FOREGROUND_COLOUR - 194)) or (1L shl (FULL - 194)) or (1L shl (FUNCTIONNAME - 194)) or (1L shl (FUNCTION_POINTER - 194)) or (1L shl (GRID - 194)) or (1L shl (HIGHLIGHT - 194)) or (1L shl (IMPLICIT - 194)) or (1L shl (IMPORT - 194)) or (1L shl (INTEGER - 194)))) != 0L) || ((((_la - 258)) and 0x3f.inv()) == 0 && ((1L shl (_la - 258)) and ((1L shl (KEPT - 258)) or (1L shl (KEYBOARD - 258)) or (1L shl (LANGUAGE - 258)) or (1L shl (LB - 258)) or (1L shl (LD - 258)) or (1L shl (LEFTLINE - 258)) or (1L shl (LENGTH_CHECK - 258)) or (1L shl (LIBACCESS - 258)) or (1L shl (LIBPARAMETER - 258)) or (1L shl (LIBRARY - 258)) or (1L shl (LIST - 258)) or (1L shl (LOCAL - 258)) or (1L shl (LONG_DATE - 258)) or (1L shl (LONG_TIME - 258)) or (1L shl (LOWER - 258)) or (1L shl (LOWLIGHT - 258)) or (1L shl (MMDDYYYY - 258)) or (1L shl (NAMED - 258)) or (1L shl (NATIONAL - 258)) or (1L shl (NATIONAL_EDITED - 258)) or (1L shl (NETWORK - 258)) or (1L shl (NO_ECHO - 258)) or (1L shl (NUMERIC_DATE - 258)) or (1L shl (NUMERIC_TIME - 258)))) != 0L) || ((((_la - 322)) and 0x3f.inv()) == 0 && ((1L shl (_la - 322)) and ((1L shl (ODT - 322)) or (1L shl (OFF - 322)) or (1L shl (ON - 322)) or (1L shl (ORDERLY - 322)) or (1L shl (OVERLINE - 322)) or (1L shl (OWN - 322)) or (1L shl (PASSWORD - 322)) or (1L shl (PORT - 322)) or (1L shl (PRINTER - 322)) or (1L shl (PRIVATE - 322)) or (1L shl (PROCESS - 322)) or (1L shl (PROGRAM - 322)) or (1L shl (PROMPT - 322)) or (1L shl (READER - 322)) or (1L shl (REMOTE - 322)) or (1L shl (REAL - 322)) or (1L shl (RECEIVED - 322)) or (1L shl (RECURSIVE - 322)) or (1L shl (REF - 322)))) != 0L) || ((((_la - 391)) and 0x3f.inv()) == 0 && ((1L shl (_la - 391)) and ((1L shl (REMOVE - 391)) or (1L shl (REQUIRED - 391)) or (1L shl (RESERVE - 391)) or (1L shl (REVERSE_VIDEO - 391)) or (1L shl (SAVE - 391)) or (1L shl (SECURE - 391)) or (1L shl (SHARED - 391)) or (1L shl (SHAREDBYALL - 391)) or (1L shl (SHAREDBYRUNUNIT - 391)) or (1L shl (SHARING - 391)) or (1L shl (SHORT_DATE - 391)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (SYMBOLIC - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER) {
				if (true){
				this.state = 1423 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				do {
					if (true){
					if (true){
					this.state = 1422
					specialNameClause()
					}
					}
					this.state = 1425 
					errorHandler.sync(this)
					_la = _input!!.LA(1)
				} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ALPHABET) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 64)) and 0x3f.inv()) == 0 && ((1L shl (_la - 64)) and ((1L shl (CLASS - 64)) or (1L shl (CLOSE_DISPOSITION - 64)) or (1L shl (COBOL - 64)) or (1L shl (COMMITMENT - 64)) or (1L shl (CONTROL_POINT - 64)) or (1L shl (CONVENTION - 64)) or (1L shl (CRUNCH - 64)) or (1L shl (CURRENCY - 64)) or (1L shl (CURSOR - 64)) or (1L shl (DECIMAL_POINT - 64)))) != 0L) || ((((_la - 128)) and 0x3f.inv()) == 0 && ((1L shl (_la - 128)) and ((1L shl (DEFAULT - 128)) or (1L shl (DEFAULT_DISPLAY - 128)) or (1L shl (DEFINITION - 128)) or (1L shl (DFHRESP - 128)) or (1L shl (DFHVALUE - 128)) or (1L shl (DISK - 128)) or (1L shl (DONTCARE - 128)) or (1L shl (DOUBLE - 128)) or (1L shl (EBCDIC - 128)) or (1L shl (EMPTY_CHECK - 128)) or (1L shl (ENTER - 128)) or (1L shl (ENTRY_PROCEDURE - 128)) or (1L shl (ERASE - 128)) or (1L shl (EOL - 128)) or (1L shl (EOS - 128)) or (1L shl (ESCAPE - 128)))) != 0L) || ((((_la - 194)) and 0x3f.inv()) == 0 && ((1L shl (_la - 194)) and ((1L shl (EVENT - 194)) or (1L shl (EXCLUSIVE - 194)) or (1L shl (EXPORT - 194)) or (1L shl (EXTENDED - 194)) or (1L shl (FOREGROUND_COLOR - 194)) or (1L shl (FOREGROUND_COLOUR - 194)) or (1L shl (FULL - 194)) or (1L shl (FUNCTIONNAME - 194)) or (1L shl (FUNCTION_POINTER - 194)) or (1L shl (GRID - 194)) or (1L shl (HIGHLIGHT - 194)) or (1L shl (IMPLICIT - 194)) or (1L shl (IMPORT - 194)) or (1L shl (INTEGER - 194)))) != 0L) || ((((_la - 258)) and 0x3f.inv()) == 0 && ((1L shl (_la - 258)) and ((1L shl (KEPT - 258)) or (1L shl (KEYBOARD - 258)) or (1L shl (LANGUAGE - 258)) or (1L shl (LB - 258)) or (1L shl (LD - 258)) or (1L shl (LEFTLINE - 258)) or (1L shl (LENGTH_CHECK - 258)) or (1L shl (LIBACCESS - 258)) or (1L shl (LIBPARAMETER - 258)) or (1L shl (LIBRARY - 258)) or (1L shl (LIST - 258)) or (1L shl (LOCAL - 258)) or (1L shl (LONG_DATE - 258)) or (1L shl (LONG_TIME - 258)) or (1L shl (LOWER - 258)) or (1L shl (LOWLIGHT - 258)) or (1L shl (MMDDYYYY - 258)) or (1L shl (NAMED - 258)) or (1L shl (NATIONAL - 258)) or (1L shl (NATIONAL_EDITED - 258)) or (1L shl (NETWORK - 258)) or (1L shl (NO_ECHO - 258)) or (1L shl (NUMERIC_DATE - 258)) or (1L shl (NUMERIC_TIME - 258)))) != 0L) || ((((_la - 322)) and 0x3f.inv()) == 0 && ((1L shl (_la - 322)) and ((1L shl (ODT - 322)) or (1L shl (OFF - 322)) or (1L shl (ON - 322)) or (1L shl (ORDERLY - 322)) or (1L shl (OVERLINE - 322)) or (1L shl (OWN - 322)) or (1L shl (PASSWORD - 322)) or (1L shl (PORT - 322)) or (1L shl (PRINTER - 322)) or (1L shl (PRIVATE - 322)) or (1L shl (PROCESS - 322)) or (1L shl (PROGRAM - 322)) or (1L shl (PROMPT - 322)) or (1L shl (READER - 322)) or (1L shl (REMOTE - 322)) or (1L shl (REAL - 322)) or (1L shl (RECEIVED - 322)) or (1L shl (RECURSIVE - 322)) or (1L shl (REF - 322)))) != 0L) || ((((_la - 391)) and 0x3f.inv()) == 0 && ((1L shl (_la - 391)) and ((1L shl (REMOVE - 391)) or (1L shl (REQUIRED - 391)) or (1L shl (RESERVE - 391)) or (1L shl (REVERSE_VIDEO - 391)) or (1L shl (SAVE - 391)) or (1L shl (SECURE - 391)) or (1L shl (SHARED - 391)) or (1L shl (SHAREDBYALL - 391)) or (1L shl (SHAREDBYRUNUNIT - 391)) or (1L shl (SHARING - 391)) or (1L shl (SHORT_DATE - 391)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (SYMBOLIC - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
				this.state = 1427
				match(DOT_FS) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SpecialNameClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_specialNameClause.id
	        set(value) { throw RuntimeException() }
		fun findChannelClause() : ChannelClauseContext? = getRuleContext(solver.getType("ChannelClauseContext"),0)
		fun findOdtClause() : OdtClauseContext? = getRuleContext(solver.getType("OdtClauseContext"),0)
		fun findAlphabetClause() : AlphabetClauseContext? = getRuleContext(solver.getType("AlphabetClauseContext"),0)
		fun findClassClause() : ClassClauseContext? = getRuleContext(solver.getType("ClassClauseContext"),0)
		fun findCurrencySignClause() : CurrencySignClauseContext? = getRuleContext(solver.getType("CurrencySignClauseContext"),0)
		fun findDecimalPointClause() : DecimalPointClauseContext? = getRuleContext(solver.getType("DecimalPointClauseContext"),0)
		fun findSymbolicCharactersClause() : SymbolicCharactersClauseContext? = getRuleContext(solver.getType("SymbolicCharactersClauseContext"),0)
		fun findEnvironmentSwitchNameClause() : EnvironmentSwitchNameClauseContext? = getRuleContext(solver.getType("EnvironmentSwitchNameClauseContext"),0)
		fun findDefaultDisplaySignClause() : DefaultDisplaySignClauseContext? = getRuleContext(solver.getType("DefaultDisplaySignClauseContext"),0)
		fun findDefaultComputationalSignClause() : DefaultComputationalSignClauseContext? = getRuleContext(solver.getType("DefaultComputationalSignClauseContext"),0)
		fun findReserveNetworkClause() : ReserveNetworkClauseContext? = getRuleContext(solver.getType("ReserveNetworkClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSpecialNameClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSpecialNameClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSpecialNameClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  specialNameClause() : SpecialNameClauseContext {
		var _localctx : SpecialNameClauseContext = SpecialNameClauseContext(context, state)
		enterRule(_localctx, 56, Rules.RULE_specialNameClause.id)
		try {
			this.state = 1442
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,47,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1431
			channelClause()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1432
			odtClause()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 1433
			alphabetClause()
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 1434
			classClause()
			}}
			5 -> {
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 1435
			currencySignClause()
			}}
			6 -> {
			enterOuterAlt(_localctx, 6)
			if (true){
			this.state = 1436
			decimalPointClause()
			}}
			7 -> {
			enterOuterAlt(_localctx, 7)
			if (true){
			this.state = 1437
			symbolicCharactersClause()
			}}
			8 -> {
			enterOuterAlt(_localctx, 8)
			if (true){
			this.state = 1438
			environmentSwitchNameClause()
			}}
			9 -> {
			enterOuterAlt(_localctx, 9)
			if (true){
			this.state = 1439
			defaultDisplaySignClause()
			}}
			10 -> {
			enterOuterAlt(_localctx, 10)
			if (true){
			this.state = 1440
			defaultComputationalSignClause()
			}}
			11 -> {
			enterOuterAlt(_localctx, 11)
			if (true){
			this.state = 1441
			reserveNetworkClause()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AlphabetClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_alphabetClause.id
	        set(value) { throw RuntimeException() }
		fun findAlphabetClauseFormat1() : AlphabetClauseFormat1Context? = getRuleContext(solver.getType("AlphabetClauseFormat1Context"),0)
		fun findAlphabetClauseFormat2() : AlphabetClauseFormat2Context? = getRuleContext(solver.getType("AlphabetClauseFormat2Context"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAlphabetClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAlphabetClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAlphabetClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  alphabetClause() : AlphabetClauseContext {
		var _localctx : AlphabetClauseContext = AlphabetClauseContext(context, state)
		enterRule(_localctx, 58, Rules.RULE_alphabetClause.id)
		try {
			this.state = 1446
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,48,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1444
			alphabetClauseFormat1()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1445
			alphabetClauseFormat2()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AlphabetClauseFormat1Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_alphabetClauseFormat1.id
	        set(value) { throw RuntimeException() }
		fun ALPHABET() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHABET.id, 0)
		fun findAlphabetName() : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),0)
		fun EBCDIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.EBCDIC.id, 0)
		fun ASCII() : TerminalNode? = getToken(Cobol85Parser.Tokens.ASCII.id, 0)
		fun STANDARD_1() : TerminalNode? = getToken(Cobol85Parser.Tokens.STANDARD_1.id, 0)
		fun STANDARD_2() : TerminalNode? = getToken(Cobol85Parser.Tokens.STANDARD_2.id, 0)
		fun NATIVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIVE.id, 0)
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun ALPHANUMERIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHANUMERIC.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findAlphabetLiterals() : List<AlphabetLiteralsContext> = getRuleContexts(solver.getType("AlphabetLiteralsContext"))
		fun findAlphabetLiterals(i: Int) : AlphabetLiteralsContext? = getRuleContext(solver.getType("AlphabetLiteralsContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAlphabetClauseFormat1(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAlphabetClauseFormat1(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAlphabetClauseFormat1(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  alphabetClauseFormat1() : AlphabetClauseFormat1Context {
		var _localctx : AlphabetClauseFormat1Context = AlphabetClauseFormat1Context(context, state)
		enterRule(_localctx, 60, Rules.RULE_alphabetClauseFormat1.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1448
			match(ALPHABET) as Token
			this.state = 1449
			alphabetName()
			this.state = 1452
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 1450
				match(FOR) as Token
				this.state = 1451
				match(ALPHANUMERIC) as Token
				}
			}

			this.state = 1455
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1454
				match(IS) as Token
				}
			}

			this.state = 1468
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,52,context) ) {
			1 -> {if (true){
			this.state = 1457
			match(EBCDIC) as Token
			}}
			2 -> {if (true){
			this.state = 1458
			match(ASCII) as Token
			}}
			3 -> {if (true){
			this.state = 1459
			match(STANDARD_1) as Token
			}}
			4 -> {if (true){
			this.state = 1460
			match(STANDARD_2) as Token
			}}
			5 -> {if (true){
			this.state = 1461
			match(NATIVE) as Token
			}}
			6 -> {if (true){
			this.state = 1462
			cobolWord()
			}}
			7 -> {if (true){
			this.state = 1464 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 1463
				alphabetLiterals()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 1466 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,51,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AlphabetLiteralsContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_alphabetLiterals.id
	        set(value) { throw RuntimeException() }
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findAlphabetThrough() : AlphabetThroughContext? = getRuleContext(solver.getType("AlphabetThroughContext"),0)
		fun findAlphabetAlso() : List<AlphabetAlsoContext> = getRuleContexts(solver.getType("AlphabetAlsoContext"))
		fun findAlphabetAlso(i: Int) : AlphabetAlsoContext? = getRuleContext(solver.getType("AlphabetAlsoContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAlphabetLiterals(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAlphabetLiterals(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAlphabetLiterals(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  alphabetLiterals() : AlphabetLiteralsContext {
		var _localctx : AlphabetLiteralsContext = AlphabetLiteralsContext(context, state)
		enterRule(_localctx, 62, Rules.RULE_alphabetLiterals.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1470
			literal()
			this.state = 1477
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			THROUGH , THRU  -> 
				if (true){
				this.state = 1471
				alphabetThrough()
				}
			ALSO  -> 
				if (true){
				this.state = 1473 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				do {
					if (true){
					if (true){
					this.state = 1472
					alphabetAlso()
					}
					}
					this.state = 1475 
					errorHandler.sync(this)
					_la = _input!!.LA(1)
				} while ( _la==ALSO )
				}
			ABORT , ALL , ALPHABET , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLASS , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURRENCY , CURSOR , DECIMAL_POINT , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FALSE , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , HIGH_VALUE , HIGH_VALUES , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , LOW_VALUE , LOW_VALUES , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NULL , NULLS , NUMERIC_DATE , NUMERIC_TIME , ODT , OFF , ON , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , QUOTE , QUOTES , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , RESERVE , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SPACE , SPACES , SYMBOL , SYMBOLIC , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUE , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO , ZERO_FILL , ZEROS , ZEROES , DOT_FS , NONNUMERICLITERAL , LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL , NUMERICLITERAL , IDENTIFIER  -> 
				Unit
			else -> Unit
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AlphabetThroughContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_alphabetThrough.id
	        set(value) { throw RuntimeException() }
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun THROUGH() : TerminalNode? = getToken(Cobol85Parser.Tokens.THROUGH.id, 0)
		fun THRU() : TerminalNode? = getToken(Cobol85Parser.Tokens.THRU.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAlphabetThrough(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAlphabetThrough(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAlphabetThrough(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  alphabetThrough() : AlphabetThroughContext {
		var _localctx : AlphabetThroughContext = AlphabetThroughContext(context, state)
		enterRule(_localctx, 64, Rules.RULE_alphabetThrough.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1479
			_la = _input!!.LA(1)
			if ( !(_la==THROUGH || _la==THRU) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 1480
			literal()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AlphabetAlsoContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_alphabetAlso.id
	        set(value) { throw RuntimeException() }
		fun ALSO() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALSO.id, 0)
		fun findLiteral() : List<LiteralContext> = getRuleContexts(solver.getType("LiteralContext"))
		fun findLiteral(i: Int) : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAlphabetAlso(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAlphabetAlso(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAlphabetAlso(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  alphabetAlso() : AlphabetAlsoContext {
		var _localctx : AlphabetAlsoContext = AlphabetAlsoContext(context, state)
		enterRule(_localctx, 66, Rules.RULE_alphabetAlso.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1482
			match(ALSO) as Token
			this.state = 1484 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 1483
				literal()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 1486 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,55,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AlphabetClauseFormat2Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_alphabetClauseFormat2.id
	        set(value) { throw RuntimeException() }
		fun ALPHABET() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHABET.id, 0)
		fun findAlphabetName() : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),0)
		fun NATIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIONAL.id, 0)
		fun NATIVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIVE.id, 0)
		fun CCSVERSION() : TerminalNode? = getToken(Cobol85Parser.Tokens.CCSVERSION.id, 0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAlphabetClauseFormat2(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAlphabetClauseFormat2(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAlphabetClauseFormat2(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  alphabetClauseFormat2() : AlphabetClauseFormat2Context {
		var _localctx : AlphabetClauseFormat2Context = AlphabetClauseFormat2Context(context, state)
		enterRule(_localctx, 68, Rules.RULE_alphabetClauseFormat2.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1488
			match(ALPHABET) as Token
			this.state = 1489
			alphabetName()
			this.state = 1491
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 1490
				match(FOR) as Token
				}
			}

			this.state = 1493
			match(NATIONAL) as Token
			this.state = 1495
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1494
				match(IS) as Token
				}
			}

			this.state = 1500
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			NATIVE  ->  /*LL1AltBlock*/{if (true){
			this.state = 1497
			match(NATIVE) as Token
			}}
			CCSVERSION  ->  /*LL1AltBlock*/{if (true){
			this.state = 1498
			match(CCSVERSION) as Token
			this.state = 1499
			literal()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ChannelClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_channelClause.id
	        set(value) { throw RuntimeException() }
		fun CHANNEL() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHANNEL.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun findMnemonicName() : MnemonicNameContext? = getRuleContext(solver.getType("MnemonicNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterChannelClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitChannelClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitChannelClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  channelClause() : ChannelClauseContext {
		var _localctx : ChannelClauseContext = ChannelClauseContext(context, state)
		enterRule(_localctx, 70, Rules.RULE_channelClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1502
			match(CHANNEL) as Token
			this.state = 1503
			integerLiteral()
			this.state = 1505
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1504
				match(IS) as Token
				}
			}

			this.state = 1507
			mnemonicName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ClassClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_classClause.id
	        set(value) { throw RuntimeException() }
		fun CLASS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CLASS.id, 0)
		fun findClassName() : ClassNameContext? = getRuleContext(solver.getType("ClassNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findClassClauseThrough() : List<ClassClauseThroughContext> = getRuleContexts(solver.getType("ClassClauseThroughContext"))
		fun findClassClauseThrough(i: Int) : ClassClauseThroughContext? = getRuleContext(solver.getType("ClassClauseThroughContext"),i)
		fun ALPHANUMERIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHANUMERIC.id, 0)
		fun NATIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIONAL.id, 0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterClassClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitClassClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitClassClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  classClause() : ClassClauseContext {
		var _localctx : ClassClauseContext = ClassClauseContext(context, state)
		enterRule(_localctx, 72, Rules.RULE_classClause.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1509
			match(CLASS) as Token
			this.state = 1510
			className()
			this.state = 1515
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,61,context) ) {
			1   -> if (true){
			this.state = 1512
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 1511
				match(FOR) as Token
				}
			}

			this.state = 1514
			_la = _input!!.LA(1)
			if ( !(_la==ALPHANUMERIC || _la==NATIONAL) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
			}
			this.state = 1518
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1517
				match(IS) as Token
				}
			}

			this.state = 1521 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 1520
				classClauseThrough()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 1523 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,63,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ClassClauseThroughContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_classClauseThrough.id
	        set(value) { throw RuntimeException() }
		fun findClassClauseFrom() : ClassClauseFromContext? = getRuleContext(solver.getType("ClassClauseFromContext"),0)
		fun findClassClauseTo() : ClassClauseToContext? = getRuleContext(solver.getType("ClassClauseToContext"),0)
		fun THROUGH() : TerminalNode? = getToken(Cobol85Parser.Tokens.THROUGH.id, 0)
		fun THRU() : TerminalNode? = getToken(Cobol85Parser.Tokens.THRU.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterClassClauseThrough(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitClassClauseThrough(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitClassClauseThrough(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  classClauseThrough() : ClassClauseThroughContext {
		var _localctx : ClassClauseThroughContext = ClassClauseThroughContext(context, state)
		enterRule(_localctx, 74, Rules.RULE_classClauseThrough.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1525
			classClauseFrom()
			this.state = 1528
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THROUGH || _la==THRU) {
				if (true){
				this.state = 1526
				_la = _input!!.LA(1)
				if ( !(_la==THROUGH || _la==THRU) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				this.state = 1527
				classClauseTo()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ClassClauseFromContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_classClauseFrom.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterClassClauseFrom(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitClassClauseFrom(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitClassClauseFrom(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  classClauseFrom() : ClassClauseFromContext {
		var _localctx : ClassClauseFromContext = ClassClauseFromContext(context, state)
		enterRule(_localctx, 76, Rules.RULE_classClauseFrom.id)
		try {
			this.state = 1532
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,65,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1530
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1531
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ClassClauseToContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_classClauseTo.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterClassClauseTo(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitClassClauseTo(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitClassClauseTo(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  classClauseTo() : ClassClauseToContext {
		var _localctx : ClassClauseToContext = ClassClauseToContext(context, state)
		enterRule(_localctx, 78, Rules.RULE_classClauseTo.id)
		try {
			this.state = 1536
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,66,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1534
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1535
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CurrencySignClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_currencySignClause.id
	        set(value) { throw RuntimeException() }
		fun CURRENCY() : TerminalNode? = getToken(Cobol85Parser.Tokens.CURRENCY.id, 0)
		fun findLiteral() : List<LiteralContext> = getRuleContexts(solver.getType("LiteralContext"))
		fun findLiteral(i: Int) : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),i)
		fun SIGN() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIGN.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun PICTURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PICTURE.id, 0)
		fun SYMBOL() : TerminalNode? = getToken(Cobol85Parser.Tokens.SYMBOL.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCurrencySignClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCurrencySignClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCurrencySignClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  currencySignClause() : CurrencySignClauseContext {
		var _localctx : CurrencySignClauseContext = CurrencySignClauseContext(context, state)
		enterRule(_localctx, 80, Rules.RULE_currencySignClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1538
			match(CURRENCY) as Token
			this.state = 1540
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SIGN) {
				if (true){
				this.state = 1539
				match(SIGN) as Token
				}
			}

			this.state = 1543
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1542
				match(IS) as Token
				}
			}

			this.state = 1545
			literal()
			this.state = 1552
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==PICTURE || _la==WITH) {
				if (true){
				this.state = 1547
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==WITH) {
					if (true){
					this.state = 1546
					match(WITH) as Token
					}
				}

				this.state = 1549
				match(PICTURE) as Token
				this.state = 1550
				match(SYMBOL) as Token
				this.state = 1551
				literal()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DecimalPointClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_decimalPointClause.id
	        set(value) { throw RuntimeException() }
		fun DECIMAL_POINT() : TerminalNode? = getToken(Cobol85Parser.Tokens.DECIMAL_POINT.id, 0)
		fun COMMA() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMMA.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDecimalPointClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDecimalPointClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDecimalPointClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  decimalPointClause() : DecimalPointClauseContext {
		var _localctx : DecimalPointClauseContext = DecimalPointClauseContext(context, state)
		enterRule(_localctx, 82, Rules.RULE_decimalPointClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1554
			match(DECIMAL_POINT) as Token
			this.state = 1556
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1555
				match(IS) as Token
				}
			}

			this.state = 1558
			match(COMMA) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DefaultComputationalSignClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_defaultComputationalSignClause.id
	        set(value) { throw RuntimeException() }
		fun DEFAULT() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEFAULT.id, 0)
		fun SEPARATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEPARATE.id, 0)
		fun SIGN() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIGN.id, 0)
		fun COMPUTATIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMPUTATIONAL.id, 0)
		fun COMP() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMP.id, 0)
		fun LEADING() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEADING.id, 0)
		fun TRAILING() : TerminalNode? = getToken(Cobol85Parser.Tokens.TRAILING.id, 0)
		fun CHARACTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTER.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDefaultComputationalSignClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDefaultComputationalSignClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDefaultComputationalSignClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  defaultComputationalSignClause() : DefaultComputationalSignClauseContext {
		var _localctx : DefaultComputationalSignClauseContext = DefaultComputationalSignClauseContext(context, state)
		enterRule(_localctx, 84, Rules.RULE_defaultComputationalSignClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1560
			match(DEFAULT) as Token
			this.state = 1562
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COMP || _la==COMPUTATIONAL) {
				if (true){
				this.state = 1561
				_la = _input!!.LA(1)
				if ( !(_la==COMP || _la==COMPUTATIONAL) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			this.state = 1568
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SIGN) {
				if (true){
				this.state = 1564
				match(SIGN) as Token
				this.state = 1566
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 1565
					match(IS) as Token
					}
				}

				}
			}

			this.state = 1571
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LEADING || _la==TRAILING) {
				if (true){
				this.state = 1570
				_la = _input!!.LA(1)
				if ( !(_la==LEADING || _la==TRAILING) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			if (true){
			this.state = 1573
			match(SEPARATE) as Token
			this.state = 1575
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CHARACTER) {
				if (true){
				this.state = 1574
				match(CHARACTER) as Token
				}
			}

			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DefaultDisplaySignClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_defaultDisplaySignClause.id
	        set(value) { throw RuntimeException() }
		fun DEFAULT_DISPLAY() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEFAULT_DISPLAY.id, 0)
		fun LEADING() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEADING.id, 0)
		fun TRAILING() : TerminalNode? = getToken(Cobol85Parser.Tokens.TRAILING.id, 0)
		fun SIGN() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIGN.id, 0)
		fun SEPARATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEPARATE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun CHARACTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTER.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDefaultDisplaySignClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDefaultDisplaySignClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDefaultDisplaySignClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  defaultDisplaySignClause() : DefaultDisplaySignClauseContext {
		var _localctx : DefaultDisplaySignClauseContext = DefaultDisplaySignClauseContext(context, state)
		enterRule(_localctx, 86, Rules.RULE_defaultDisplaySignClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1577
			match(DEFAULT_DISPLAY) as Token
			this.state = 1582
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SIGN) {
				if (true){
				this.state = 1578
				match(SIGN) as Token
				this.state = 1580
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 1579
					match(IS) as Token
					}
				}

				}
			}

			this.state = 1584
			_la = _input!!.LA(1)
			if ( !(_la==LEADING || _la==TRAILING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 1589
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SEPARATE) {
				if (true){
				this.state = 1585
				match(SEPARATE) as Token
				this.state = 1587
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==CHARACTER) {
					if (true){
					this.state = 1586
					match(CHARACTER) as Token
					}
				}

				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EnvironmentSwitchNameClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_environmentSwitchNameClause.id
	        set(value) { throw RuntimeException() }
		fun findEnvironmentName() : EnvironmentNameContext? = getRuleContext(solver.getType("EnvironmentNameContext"),0)
		fun findMnemonicName() : MnemonicNameContext? = getRuleContext(solver.getType("MnemonicNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findEnvironmentSwitchNameSpecialNamesStatusPhrase() : EnvironmentSwitchNameSpecialNamesStatusPhraseContext? = getRuleContext(solver.getType("EnvironmentSwitchNameSpecialNamesStatusPhraseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEnvironmentSwitchNameClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEnvironmentSwitchNameClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEnvironmentSwitchNameClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  environmentSwitchNameClause() : EnvironmentSwitchNameClauseContext {
		var _localctx : EnvironmentSwitchNameClauseContext = EnvironmentSwitchNameClauseContext(context, state)
		enterRule(_localctx, 88, Rules.RULE_environmentSwitchNameClause.id)
		var _la: Int
		try {
			this.state = 1600
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1591
			environmentName()
			this.state = 1593
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1592
				match(IS) as Token
				}
			}

			this.state = 1595
			mnemonicName()
			this.state = 1597
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,82,context) ) {
			1   -> if (true){
			this.state = 1596
			environmentSwitchNameSpecialNamesStatusPhrase()
			}
			}
			}}
			OFF , ON  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1599
			environmentSwitchNameSpecialNamesStatusPhrase()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EnvironmentSwitchNameSpecialNamesStatusPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_environmentSwitchNameSpecialNamesStatusPhrase.id
	        set(value) { throw RuntimeException() }
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun findCondition() : List<ConditionContext> = getRuleContexts(solver.getType("ConditionContext"))
		fun findCondition(i: Int) : ConditionContext? = getRuleContext(solver.getType("ConditionContext"),i)
		fun STATUS() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.STATUS.id)
		fun STATUS(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.STATUS.id, i) as TerminalNode
		fun IS() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.IS.id)
		fun IS(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.IS.id, i) as TerminalNode
		fun OFF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OFF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEnvironmentSwitchNameSpecialNamesStatusPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEnvironmentSwitchNameSpecialNamesStatusPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEnvironmentSwitchNameSpecialNamesStatusPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  environmentSwitchNameSpecialNamesStatusPhrase() : EnvironmentSwitchNameSpecialNamesStatusPhraseContext {
		var _localctx : EnvironmentSwitchNameSpecialNamesStatusPhraseContext = EnvironmentSwitchNameSpecialNamesStatusPhraseContext(context, state)
		enterRule(_localctx, 90, Rules.RULE_environmentSwitchNameSpecialNamesStatusPhrase.id)
		var _la: Int
		try {
			this.state = 1638
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ON  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1602
			match(ON) as Token
			this.state = 1604
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==STATUS) {
				if (true){
				this.state = 1603
				match(STATUS) as Token
				}
			}

			this.state = 1607
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1606
				match(IS) as Token
				}
			}

			this.state = 1609
			condition()
			this.state = 1618
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,88,context) ) {
			1   -> if (true){
			this.state = 1610
			match(OFF) as Token
			this.state = 1612
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==STATUS) {
				if (true){
				this.state = 1611
				match(STATUS) as Token
				}
			}

			this.state = 1615
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1614
				match(IS) as Token
				}
			}

			this.state = 1617
			condition()
			}
			}
			}}
			OFF  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1620
			match(OFF) as Token
			this.state = 1622
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==STATUS) {
				if (true){
				this.state = 1621
				match(STATUS) as Token
				}
			}

			this.state = 1625
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1624
				match(IS) as Token
				}
			}

			this.state = 1627
			condition()
			this.state = 1636
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,93,context) ) {
			1   -> if (true){
			this.state = 1628
			match(ON) as Token
			this.state = 1630
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==STATUS) {
				if (true){
				this.state = 1629
				match(STATUS) as Token
				}
			}

			this.state = 1633
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1632
				match(IS) as Token
				}
			}

			this.state = 1635
			condition()
			}
			}
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class OdtClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_odtClause.id
	        set(value) { throw RuntimeException() }
		fun ODT() : TerminalNode? = getToken(Cobol85Parser.Tokens.ODT.id, 0)
		fun findMnemonicName() : MnemonicNameContext? = getRuleContext(solver.getType("MnemonicNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterOdtClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitOdtClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitOdtClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  odtClause() : OdtClauseContext {
		var _localctx : OdtClauseContext = OdtClauseContext(context, state)
		enterRule(_localctx, 92, Rules.RULE_odtClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1640
			match(ODT) as Token
			this.state = 1642
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1641
				match(IS) as Token
				}
			}

			this.state = 1644
			mnemonicName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReserveNetworkClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reserveNetworkClause.id
	        set(value) { throw RuntimeException() }
		fun RESERVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.RESERVE.id, 0)
		fun NETWORK() : TerminalNode? = getToken(Cobol85Parser.Tokens.NETWORK.id, 0)
		fun WORDS() : TerminalNode? = getToken(Cobol85Parser.Tokens.WORDS.id, 0)
		fun LIST() : TerminalNode? = getToken(Cobol85Parser.Tokens.LIST.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun CAPABLE() : TerminalNode? = getToken(Cobol85Parser.Tokens.CAPABLE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReserveNetworkClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReserveNetworkClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReserveNetworkClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reserveNetworkClause() : ReserveNetworkClauseContext {
		var _localctx : ReserveNetworkClauseContext = ReserveNetworkClauseContext(context, state)
		enterRule(_localctx, 94, Rules.RULE_reserveNetworkClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1646
			match(RESERVE) as Token
			this.state = 1648
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WORDS) {
				if (true){
				this.state = 1647
				match(WORDS) as Token
				}
			}

			this.state = 1651
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LIST) {
				if (true){
				this.state = 1650
				match(LIST) as Token
				}
			}

			this.state = 1654
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1653
				match(IS) as Token
				}
			}

			this.state = 1656
			match(NETWORK) as Token
			this.state = 1658
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,99,context) ) {
			1   -> if (true){
			this.state = 1657
			match(CAPABLE) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SymbolicCharactersClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_symbolicCharactersClause.id
	        set(value) { throw RuntimeException() }
		fun SYMBOLIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.SYMBOLIC.id, 0)
		fun CHARACTERS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTERS.id, 0)
		fun findSymbolicCharacters() : List<SymbolicCharactersContext> = getRuleContexts(solver.getType("SymbolicCharactersContext"))
		fun findSymbolicCharacters(i: Int) : SymbolicCharactersContext? = getRuleContext(solver.getType("SymbolicCharactersContext"),i)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		fun findAlphabetName() : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),0)
		fun ALPHANUMERIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHANUMERIC.id, 0)
		fun NATIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIONAL.id, 0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSymbolicCharactersClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSymbolicCharactersClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSymbolicCharactersClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  symbolicCharactersClause() : SymbolicCharactersClauseContext {
		var _localctx : SymbolicCharactersClauseContext = SymbolicCharactersClauseContext(context, state)
		enterRule(_localctx, 96, Rules.RULE_symbolicCharactersClause.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1660
			match(SYMBOLIC) as Token
			this.state = 1662
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CHARACTERS) {
				if (true){
				this.state = 1661
				match(CHARACTERS) as Token
				}
			}

			this.state = 1668
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,102,context) ) {
			1   -> if (true){
			this.state = 1665
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 1664
				match(FOR) as Token
				}
			}

			this.state = 1667
			_la = _input!!.LA(1)
			if ( !(_la==ALPHANUMERIC || _la==NATIONAL) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
			}
			this.state = 1671 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 1670
				symbolicCharacters()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 1673 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,103,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			this.state = 1677
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IN) {
				if (true){
				this.state = 1675
				match(IN) as Token
				this.state = 1676
				alphabetName()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SymbolicCharactersContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_symbolicCharacters.id
	        set(value) { throw RuntimeException() }
		fun findSymbolicCharacter() : List<SymbolicCharacterContext> = getRuleContexts(solver.getType("SymbolicCharacterContext"))
		fun findSymbolicCharacter(i: Int) : SymbolicCharacterContext? = getRuleContext(solver.getType("SymbolicCharacterContext"),i)
		fun findIntegerLiteral() : List<IntegerLiteralContext> = getRuleContexts(solver.getType("IntegerLiteralContext"))
		fun findIntegerLiteral(i: Int) : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),i)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun ARE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ARE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSymbolicCharacters(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSymbolicCharacters(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSymbolicCharacters(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  symbolicCharacters() : SymbolicCharactersContext {
		var _localctx : SymbolicCharactersContext = SymbolicCharactersContext(context, state)
		enterRule(_localctx, 98, Rules.RULE_symbolicCharacters.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1680 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 1679
				symbolicCharacter()
				}
				}
				this.state = 1682 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			this.state = 1685
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ARE || _la==IS) {
				if (true){
				this.state = 1684
				_la = _input!!.LA(1)
				if ( !(_la==ARE || _la==IS) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			this.state = 1688 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 1687
				integerLiteral()
				}
				}
				this.state = 1690 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InputOutputSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inputOutputSection.id
	        set(value) { throw RuntimeException() }
		fun INPUT_OUTPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.INPUT_OUTPUT.id, 0)
		fun SECTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECTION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findInputOutputSectionParagraph() : List<InputOutputSectionParagraphContext> = getRuleContexts(solver.getType("InputOutputSectionParagraphContext"))
		fun findInputOutputSectionParagraph(i: Int) : InputOutputSectionParagraphContext? = getRuleContext(solver.getType("InputOutputSectionParagraphContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInputOutputSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInputOutputSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInputOutputSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inputOutputSection() : InputOutputSectionContext {
		var _localctx : InputOutputSectionContext = InputOutputSectionContext(context, state)
		enterRule(_localctx, 100, Rules.RULE_inputOutputSection.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1692
			match(INPUT_OUTPUT) as Token
			this.state = 1693
			match(SECTION) as Token
			this.state = 1694
			match(DOT_FS) as Token
			this.state = 1698
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==FILE_CONTROL || _la==I_O_CONTROL) {
				if (true){
				if (true){
				this.state = 1695
				inputOutputSectionParagraph()
				}
				}
				this.state = 1700
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InputOutputSectionParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inputOutputSectionParagraph.id
	        set(value) { throw RuntimeException() }
		fun findFileControlParagraph() : FileControlParagraphContext? = getRuleContext(solver.getType("FileControlParagraphContext"),0)
		fun findIoControlParagraph() : IoControlParagraphContext? = getRuleContext(solver.getType("IoControlParagraphContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInputOutputSectionParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInputOutputSectionParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInputOutputSectionParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inputOutputSectionParagraph() : InputOutputSectionParagraphContext {
		var _localctx : InputOutputSectionParagraphContext = InputOutputSectionParagraphContext(context, state)
		enterRule(_localctx, 102, Rules.RULE_inputOutputSectionParagraph.id)
		try {
			this.state = 1703
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			FILE_CONTROL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1701
			fileControlParagraph()
			}}
			I_O_CONTROL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1702
			ioControlParagraph()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class FileControlParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_fileControlParagraph.id
	        set(value) { throw RuntimeException() }
		fun FILE_CONTROL() : TerminalNode? = getToken(Cobol85Parser.Tokens.FILE_CONTROL.id, 0)
		fun DOT_FS() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.DOT_FS.id)
		fun DOT_FS(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.DOT_FS.id, i) as TerminalNode
		fun findFileControlEntry() : List<FileControlEntryContext> = getRuleContexts(solver.getType("FileControlEntryContext"))
		fun findFileControlEntry(i: Int) : FileControlEntryContext? = getRuleContext(solver.getType("FileControlEntryContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterFileControlParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitFileControlParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitFileControlParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  fileControlParagraph() : FileControlParagraphContext {
		var _localctx : FileControlParagraphContext = FileControlParagraphContext(context, state)
		enterRule(_localctx, 104, Rules.RULE_fileControlParagraph.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1705
			match(FILE_CONTROL) as Token
			this.state = 1712
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,111,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 1707
					errorHandler.sync(this)
					_la = _input!!.LA(1)
					if (_la==DOT_FS) {
						if (true){
						this.state = 1706
						match(DOT_FS) as Token
						}
					}

					this.state = 1709
					fileControlEntry()
					}
					} 
				}
				this.state = 1714
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,111,context)
			}
			this.state = 1715
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class FileControlEntryContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_fileControlEntry.id
	        set(value) { throw RuntimeException() }
		fun findSelectClause() : SelectClauseContext? = getRuleContext(solver.getType("SelectClauseContext"),0)
		fun findFileControlClause() : List<FileControlClauseContext> = getRuleContexts(solver.getType("FileControlClauseContext"))
		fun findFileControlClause(i: Int) : FileControlClauseContext? = getRuleContext(solver.getType("FileControlClauseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterFileControlEntry(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitFileControlEntry(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitFileControlEntry(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  fileControlEntry() : FileControlEntryContext {
		var _localctx : FileControlEntryContext = FileControlEntryContext(context, state)
		enterRule(_localctx, 106, Rules.RULE_fileControlEntry.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1717
			selectClause()
			this.state = 1721
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ACCESS) or (1L shl ALTERNATE) or (1L shl ASSIGN) or (1L shl BINARY))) != 0L) || _la==FILE || _la==INDEXED || ((((_la - 279)) and 0x3f.inv()) == 0 && ((1L shl (_la - 279)) and ((1L shl (LINE - 279)) or (1L shl (ORGANIZATION - 279)) or (1L shl (PADDING - 279)) or (1L shl (PASSWORD - 279)))) != 0L) || ((((_la - 377)) and 0x3f.inv()) == 0 && ((1L shl (_la - 377)) and ((1L shl (RECORD - 377)) or (1L shl (RELATIVE - 377)) or (1L shl (RESERVE - 377)) or (1L shl (SEQUENTIAL - 377)))) != 0L) || _la==STATUS) {
				if (true){
				if (true){
				this.state = 1718
				fileControlClause()
				}
				}
				this.state = 1723
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SelectClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_selectClause.id
	        set(value) { throw RuntimeException() }
		fun SELECT() : TerminalNode? = getToken(Cobol85Parser.Tokens.SELECT.id, 0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun OPTIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.OPTIONAL.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSelectClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSelectClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSelectClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  selectClause() : SelectClauseContext {
		var _localctx : SelectClauseContext = SelectClauseContext(context, state)
		enterRule(_localctx, 108, Rules.RULE_selectClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1724
			match(SELECT) as Token
			this.state = 1726
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OPTIONAL) {
				if (true){
				this.state = 1725
				match(OPTIONAL) as Token
				}
			}

			this.state = 1728
			fileName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class FileControlClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_fileControlClause.id
	        set(value) { throw RuntimeException() }
		fun findAssignClause() : AssignClauseContext? = getRuleContext(solver.getType("AssignClauseContext"),0)
		fun findReserveClause() : ReserveClauseContext? = getRuleContext(solver.getType("ReserveClauseContext"),0)
		fun findOrganizationClause() : OrganizationClauseContext? = getRuleContext(solver.getType("OrganizationClauseContext"),0)
		fun findPaddingCharacterClause() : PaddingCharacterClauseContext? = getRuleContext(solver.getType("PaddingCharacterClauseContext"),0)
		fun findRecordDelimiterClause() : RecordDelimiterClauseContext? = getRuleContext(solver.getType("RecordDelimiterClauseContext"),0)
		fun findAccessModeClause() : AccessModeClauseContext? = getRuleContext(solver.getType("AccessModeClauseContext"),0)
		fun findRecordKeyClause() : RecordKeyClauseContext? = getRuleContext(solver.getType("RecordKeyClauseContext"),0)
		fun findAlternateRecordKeyClause() : AlternateRecordKeyClauseContext? = getRuleContext(solver.getType("AlternateRecordKeyClauseContext"),0)
		fun findFileStatusClause() : FileStatusClauseContext? = getRuleContext(solver.getType("FileStatusClauseContext"),0)
		fun findPasswordClause() : PasswordClauseContext? = getRuleContext(solver.getType("PasswordClauseContext"),0)
		fun findRelativeKeyClause() : RelativeKeyClauseContext? = getRuleContext(solver.getType("RelativeKeyClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterFileControlClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitFileControlClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitFileControlClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  fileControlClause() : FileControlClauseContext {
		var _localctx : FileControlClauseContext = FileControlClauseContext(context, state)
		enterRule(_localctx, 110, Rules.RULE_fileControlClause.id)
		try {
			this.state = 1741
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,114,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1730
			assignClause()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1731
			reserveClause()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 1732
			organizationClause()
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 1733
			paddingCharacterClause()
			}}
			5 -> {
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 1734
			recordDelimiterClause()
			}}
			6 -> {
			enterOuterAlt(_localctx, 6)
			if (true){
			this.state = 1735
			accessModeClause()
			}}
			7 -> {
			enterOuterAlt(_localctx, 7)
			if (true){
			this.state = 1736
			recordKeyClause()
			}}
			8 -> {
			enterOuterAlt(_localctx, 8)
			if (true){
			this.state = 1737
			alternateRecordKeyClause()
			}}
			9 -> {
			enterOuterAlt(_localctx, 9)
			if (true){
			this.state = 1738
			fileStatusClause()
			}}
			10 -> {
			enterOuterAlt(_localctx, 10)
			if (true){
			this.state = 1739
			passwordClause()
			}}
			11 -> {
			enterOuterAlt(_localctx, 11)
			if (true){
			this.state = 1740
			relativeKeyClause()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AssignClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_assignClause.id
	        set(value) { throw RuntimeException() }
		fun ASSIGN() : TerminalNode? = getToken(Cobol85Parser.Tokens.ASSIGN.id, 0)
		fun DISK() : TerminalNode? = getToken(Cobol85Parser.Tokens.DISK.id, 0)
		fun DISPLAY() : TerminalNode? = getToken(Cobol85Parser.Tokens.DISPLAY.id, 0)
		fun KEYBOARD() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEYBOARD.id, 0)
		fun PORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.PORT.id, 0)
		fun PRINTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.PRINTER.id, 0)
		fun READER() : TerminalNode? = getToken(Cobol85Parser.Tokens.READER.id, 0)
		fun REMOTE() : TerminalNode? = getToken(Cobol85Parser.Tokens.REMOTE.id, 0)
		fun TAPE() : TerminalNode? = getToken(Cobol85Parser.Tokens.TAPE.id, 0)
		fun VIRTUAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.VIRTUAL.id, 0)
		fun findAssignmentName() : AssignmentNameContext? = getRuleContext(solver.getType("AssignmentNameContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAssignClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAssignClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAssignClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  assignClause() : AssignClauseContext {
		var _localctx : AssignClauseContext = AssignClauseContext(context, state)
		enterRule(_localctx, 112, Rules.RULE_assignClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1743
			match(ASSIGN) as Token
			this.state = 1745
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TO) {
				if (true){
				this.state = 1744
				match(TO) as Token
				}
			}

			this.state = 1758
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,116,context) ) {
			1 -> {if (true){
			this.state = 1747
			match(DISK) as Token
			}}
			2 -> {if (true){
			this.state = 1748
			match(DISPLAY) as Token
			}}
			3 -> {if (true){
			this.state = 1749
			match(KEYBOARD) as Token
			}}
			4 -> {if (true){
			this.state = 1750
			match(PORT) as Token
			}}
			5 -> {if (true){
			this.state = 1751
			match(PRINTER) as Token
			}}
			6 -> {if (true){
			this.state = 1752
			match(READER) as Token
			}}
			7 -> {if (true){
			this.state = 1753
			match(REMOTE) as Token
			}}
			8 -> {if (true){
			this.state = 1754
			match(TAPE) as Token
			}}
			9 -> {if (true){
			this.state = 1755
			match(VIRTUAL) as Token
			}}
			10 -> {if (true){
			this.state = 1756
			assignmentName()
			}}
			11 -> {if (true){
			this.state = 1757
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReserveClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reserveClause.id
	        set(value) { throw RuntimeException() }
		fun RESERVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.RESERVE.id, 0)
		fun NO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun ALTERNATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALTERNATE.id, 0)
		fun AREA() : TerminalNode? = getToken(Cobol85Parser.Tokens.AREA.id, 0)
		fun AREAS() : TerminalNode? = getToken(Cobol85Parser.Tokens.AREAS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReserveClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReserveClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReserveClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reserveClause() : ReserveClauseContext {
		var _localctx : ReserveClauseContext = ReserveClauseContext(context, state)
		enterRule(_localctx, 114, Rules.RULE_reserveClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1760
			match(RESERVE) as Token
			this.state = 1763
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			NO  ->  /*LL1AltBlock*/{if (true){
			this.state = 1761
			match(NO) as Token
			}}
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 1762
			integerLiteral()
			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 1766
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,118,context) ) {
			1   -> if (true){
			this.state = 1765
			match(ALTERNATE) as Token
			}
			}
			this.state = 1769
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==AREA || _la==AREAS) {
				if (true){
				this.state = 1768
				_la = _input!!.LA(1)
				if ( !(_la==AREA || _la==AREAS) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class OrganizationClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_organizationClause.id
	        set(value) { throw RuntimeException() }
		fun SEQUENTIAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEQUENTIAL.id, 0)
		fun RELATIVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.RELATIVE.id, 0)
		fun INDEXED() : TerminalNode? = getToken(Cobol85Parser.Tokens.INDEXED.id, 0)
		fun ORGANIZATION() : TerminalNode? = getToken(Cobol85Parser.Tokens.ORGANIZATION.id, 0)
		fun LINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINE.id, 0)
		fun RECORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORD.id, 0)
		fun BINARY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BINARY.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterOrganizationClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitOrganizationClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitOrganizationClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  organizationClause() : OrganizationClauseContext {
		var _localctx : OrganizationClauseContext = OrganizationClauseContext(context, state)
		enterRule(_localctx, 116, Rules.RULE_organizationClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1775
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ORGANIZATION) {
				if (true){
				this.state = 1771
				match(ORGANIZATION) as Token
				this.state = 1773
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 1772
					match(IS) as Token
					}
				}

				}
			}

			this.state = 1782
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,122,context) ) {
			1   -> if (true){
			this.state = 1777
			match(LINE) as Token
			}
			2   -> if (true){
			this.state = 1778
			match(RECORD) as Token
			this.state = 1779
			match(BINARY) as Token
			}
			3   -> if (true){
			this.state = 1780
			match(RECORD) as Token
			}
			4   -> if (true){
			this.state = 1781
			match(BINARY) as Token
			}
			}
			this.state = 1784
			_la = _input!!.LA(1)
			if ( !(_la==INDEXED || _la==RELATIVE || _la==SEQUENTIAL) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PaddingCharacterClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_paddingCharacterClause.id
	        set(value) { throw RuntimeException() }
		fun PADDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.PADDING.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun CHARACTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTER.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPaddingCharacterClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPaddingCharacterClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPaddingCharacterClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  paddingCharacterClause() : PaddingCharacterClauseContext {
		var _localctx : PaddingCharacterClauseContext = PaddingCharacterClauseContext(context, state)
		enterRule(_localctx, 118, Rules.RULE_paddingCharacterClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1786
			match(PADDING) as Token
			this.state = 1788
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CHARACTER) {
				if (true){
				this.state = 1787
				match(CHARACTER) as Token
				}
			}

			this.state = 1791
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1790
				match(IS) as Token
				}
			}

			this.state = 1795
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,125,context) ) {
			1 -> {if (true){
			this.state = 1793
			qualifiedDataName()
			}}
			2 -> {if (true){
			this.state = 1794
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RecordDelimiterClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_recordDelimiterClause.id
	        set(value) { throw RuntimeException() }
		fun RECORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORD.id, 0)
		fun DELIMITER() : TerminalNode? = getToken(Cobol85Parser.Tokens.DELIMITER.id, 0)
		fun STANDARD_1() : TerminalNode? = getToken(Cobol85Parser.Tokens.STANDARD_1.id, 0)
		fun IMPLICIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.IMPLICIT.id, 0)
		fun findAssignmentName() : AssignmentNameContext? = getRuleContext(solver.getType("AssignmentNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRecordDelimiterClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRecordDelimiterClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRecordDelimiterClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  recordDelimiterClause() : RecordDelimiterClauseContext {
		var _localctx : RecordDelimiterClauseContext = RecordDelimiterClauseContext(context, state)
		enterRule(_localctx, 120, Rules.RULE_recordDelimiterClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1797
			match(RECORD) as Token
			this.state = 1798
			match(DELIMITER) as Token
			this.state = 1800
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1799
				match(IS) as Token
				}
			}

			this.state = 1805
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,127,context) ) {
			1 -> {if (true){
			this.state = 1802
			match(STANDARD_1) as Token
			}}
			2 -> {if (true){
			this.state = 1803
			match(IMPLICIT) as Token
			}}
			3 -> {if (true){
			this.state = 1804
			assignmentName()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AccessModeClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_accessModeClause.id
	        set(value) { throw RuntimeException() }
		fun ACCESS() : TerminalNode? = getToken(Cobol85Parser.Tokens.ACCESS.id, 0)
		fun SEQUENTIAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEQUENTIAL.id, 0)
		fun RANDOM() : TerminalNode? = getToken(Cobol85Parser.Tokens.RANDOM.id, 0)
		fun DYNAMIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.DYNAMIC.id, 0)
		fun EXCLUSIVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXCLUSIVE.id, 0)
		fun MODE() : TerminalNode? = getToken(Cobol85Parser.Tokens.MODE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAccessModeClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAccessModeClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAccessModeClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  accessModeClause() : AccessModeClauseContext {
		var _localctx : AccessModeClauseContext = AccessModeClauseContext(context, state)
		enterRule(_localctx, 122, Rules.RULE_accessModeClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1807
			match(ACCESS) as Token
			this.state = 1809
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==MODE) {
				if (true){
				this.state = 1808
				match(MODE) as Token
				}
			}

			this.state = 1812
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1811
				match(IS) as Token
				}
			}

			this.state = 1814
			_la = _input!!.LA(1)
			if ( !(_la==DYNAMIC || _la==EXCLUSIVE || _la==RANDOM || _la==SEQUENTIAL) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RecordKeyClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_recordKeyClause.id
	        set(value) { throw RuntimeException() }
		fun RECORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORD.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findPasswordClause() : PasswordClauseContext? = getRuleContext(solver.getType("PasswordClauseContext"),0)
		fun DUPLICATES() : TerminalNode? = getToken(Cobol85Parser.Tokens.DUPLICATES.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRecordKeyClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRecordKeyClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRecordKeyClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  recordKeyClause() : RecordKeyClauseContext {
		var _localctx : RecordKeyClauseContext = RecordKeyClauseContext(context, state)
		enterRule(_localctx, 124, Rules.RULE_recordKeyClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1816
			match(RECORD) as Token
			this.state = 1818
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==KEY) {
				if (true){
				this.state = 1817
				match(KEY) as Token
				}
			}

			this.state = 1821
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1820
				match(IS) as Token
				}
			}

			this.state = 1823
			qualifiedDataName()
			this.state = 1825
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,132,context) ) {
			1   -> if (true){
			this.state = 1824
			passwordClause()
			}
			}
			this.state = 1831
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DUPLICATES || _la==WITH) {
				if (true){
				this.state = 1828
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==WITH) {
					if (true){
					this.state = 1827
					match(WITH) as Token
					}
				}

				this.state = 1830
				match(DUPLICATES) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AlternateRecordKeyClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_alternateRecordKeyClause.id
	        set(value) { throw RuntimeException() }
		fun ALTERNATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALTERNATE.id, 0)
		fun RECORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORD.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findPasswordClause() : PasswordClauseContext? = getRuleContext(solver.getType("PasswordClauseContext"),0)
		fun DUPLICATES() : TerminalNode? = getToken(Cobol85Parser.Tokens.DUPLICATES.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAlternateRecordKeyClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAlternateRecordKeyClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAlternateRecordKeyClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  alternateRecordKeyClause() : AlternateRecordKeyClauseContext {
		var _localctx : AlternateRecordKeyClauseContext = AlternateRecordKeyClauseContext(context, state)
		enterRule(_localctx, 126, Rules.RULE_alternateRecordKeyClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1833
			match(ALTERNATE) as Token
			this.state = 1834
			match(RECORD) as Token
			this.state = 1836
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==KEY) {
				if (true){
				this.state = 1835
				match(KEY) as Token
				}
			}

			this.state = 1839
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1838
				match(IS) as Token
				}
			}

			this.state = 1841
			qualifiedDataName()
			this.state = 1843
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,137,context) ) {
			1   -> if (true){
			this.state = 1842
			passwordClause()
			}
			}
			this.state = 1849
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DUPLICATES || _la==WITH) {
				if (true){
				this.state = 1846
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==WITH) {
					if (true){
					this.state = 1845
					match(WITH) as Token
					}
				}

				this.state = 1848
				match(DUPLICATES) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PasswordClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_passwordClause.id
	        set(value) { throw RuntimeException() }
		fun PASSWORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.PASSWORD.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPasswordClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPasswordClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPasswordClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  passwordClause() : PasswordClauseContext {
		var _localctx : PasswordClauseContext = PasswordClauseContext(context, state)
		enterRule(_localctx, 128, Rules.RULE_passwordClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1851
			match(PASSWORD) as Token
			this.state = 1853
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1852
				match(IS) as Token
				}
			}

			this.state = 1855
			dataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class FileStatusClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_fileStatusClause.id
	        set(value) { throw RuntimeException() }
		fun STATUS() : TerminalNode? = getToken(Cobol85Parser.Tokens.STATUS.id, 0)
		fun findQualifiedDataName() : List<QualifiedDataNameContext> = getRuleContexts(solver.getType("QualifiedDataNameContext"))
		fun findQualifiedDataName(i: Int) : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),i)
		fun FILE() : TerminalNode? = getToken(Cobol85Parser.Tokens.FILE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterFileStatusClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitFileStatusClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitFileStatusClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  fileStatusClause() : FileStatusClauseContext {
		var _localctx : FileStatusClauseContext = FileStatusClauseContext(context, state)
		enterRule(_localctx, 130, Rules.RULE_fileStatusClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1858
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FILE) {
				if (true){
				this.state = 1857
				match(FILE) as Token
				}
			}

			this.state = 1860
			match(STATUS) as Token
			this.state = 1862
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1861
				match(IS) as Token
				}
			}

			this.state = 1864
			qualifiedDataName()
			this.state = 1866
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,143,context) ) {
			1   -> if (true){
			this.state = 1865
			qualifiedDataName()
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RelativeKeyClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_relativeKeyClause.id
	        set(value) { throw RuntimeException() }
		fun RELATIVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.RELATIVE.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRelativeKeyClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRelativeKeyClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRelativeKeyClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  relativeKeyClause() : RelativeKeyClauseContext {
		var _localctx : RelativeKeyClauseContext = RelativeKeyClauseContext(context, state)
		enterRule(_localctx, 132, Rules.RULE_relativeKeyClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1868
			match(RELATIVE) as Token
			this.state = 1870
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==KEY) {
				if (true){
				this.state = 1869
				match(KEY) as Token
				}
			}

			this.state = 1873
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 1872
				match(IS) as Token
				}
			}

			this.state = 1875
			qualifiedDataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class IoControlParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_ioControlParagraph.id
	        set(value) { throw RuntimeException() }
		fun I_O_CONTROL() : TerminalNode? = getToken(Cobol85Parser.Tokens.I_O_CONTROL.id, 0)
		fun DOT_FS() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.DOT_FS.id)
		fun DOT_FS(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.DOT_FS.id, i) as TerminalNode
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun findIoControlClause() : List<IoControlClauseContext> = getRuleContexts(solver.getType("IoControlClauseContext"))
		fun findIoControlClause(i: Int) : IoControlClauseContext? = getRuleContext(solver.getType("IoControlClauseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterIoControlParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitIoControlParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitIoControlParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  ioControlParagraph() : IoControlParagraphContext {
		var _localctx : IoControlParagraphContext = IoControlParagraphContext(context, state)
		enterRule(_localctx, 134, Rules.RULE_ioControlParagraph.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1877
			match(I_O_CONTROL) as Token
			this.state = 1878
			match(DOT_FS) as Token
			this.state = 1882
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,146,context) ) {
			1   -> if (true){
			this.state = 1879
			fileName()
			this.state = 1880
			match(DOT_FS) as Token
			}
			}
			this.state = 1891
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COMMITMENT || _la==MULTIPLE || _la==RERUN || _la==SAME || _la==DOT_FS) {
				if (true){
				this.state = 1887
				errorHandler.sync(this);
				_la = _input!!.LA(1)
				while (_la==COMMITMENT || _la==MULTIPLE || _la==RERUN || _la==SAME) {
					if (true){
					if (true){
					this.state = 1884
					ioControlClause()
					}
					}
					this.state = 1889
					errorHandler.sync(this)
					_la = _input!!.LA(1)
				}
				this.state = 1890
				match(DOT_FS) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class IoControlClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_ioControlClause.id
	        set(value) { throw RuntimeException() }
		fun findRerunClause() : RerunClauseContext? = getRuleContext(solver.getType("RerunClauseContext"),0)
		fun findSameClause() : SameClauseContext? = getRuleContext(solver.getType("SameClauseContext"),0)
		fun findMultipleFileClause() : MultipleFileClauseContext? = getRuleContext(solver.getType("MultipleFileClauseContext"),0)
		fun findCommitmentControlClause() : CommitmentControlClauseContext? = getRuleContext(solver.getType("CommitmentControlClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterIoControlClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitIoControlClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitIoControlClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  ioControlClause() : IoControlClauseContext {
		var _localctx : IoControlClauseContext = IoControlClauseContext(context, state)
		enterRule(_localctx, 136, Rules.RULE_ioControlClause.id)
		try {
			this.state = 1897
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			RERUN  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1893
			rerunClause()
			}}
			SAME  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1894
			sameClause()
			}}
			MULTIPLE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 1895
			multipleFileClause()
			}}
			COMMITMENT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 1896
			commitmentControlClause()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RerunClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_rerunClause.id
	        set(value) { throw RuntimeException() }
		fun RERUN() : TerminalNode? = getToken(Cobol85Parser.Tokens.RERUN.id, 0)
		fun EVERY() : TerminalNode? = getToken(Cobol85Parser.Tokens.EVERY.id, 0)
		fun findRerunEveryRecords() : RerunEveryRecordsContext? = getRuleContext(solver.getType("RerunEveryRecordsContext"),0)
		fun findRerunEveryOf() : RerunEveryOfContext? = getRuleContext(solver.getType("RerunEveryOfContext"),0)
		fun findRerunEveryClock() : RerunEveryClockContext? = getRuleContext(solver.getType("RerunEveryClockContext"),0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun findAssignmentName() : AssignmentNameContext? = getRuleContext(solver.getType("AssignmentNameContext"),0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRerunClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRerunClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRerunClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  rerunClause() : RerunClauseContext {
		var _localctx : RerunClauseContext = RerunClauseContext(context, state)
		enterRule(_localctx, 138, Rules.RULE_rerunClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1899
			match(RERUN) as Token
			this.state = 1905
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 1900
				match(ON) as Token
				this.state = 1903
				errorHandler.sync(this)
				when ( interpreter!!.adaptivePredict(_input!!,150,context) ) {
				1 -> {if (true){
				this.state = 1901
				assignmentName()
				}}
				2 -> {if (true){
				this.state = 1902
				fileName()
				}}
				}
				}
			}

			this.state = 1907
			match(EVERY) as Token
			this.state = 1911
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,152,context) ) {
			1 -> {if (true){
			this.state = 1908
			rerunEveryRecords()
			}}
			2 -> {if (true){
			this.state = 1909
			rerunEveryOf()
			}}
			3 -> {if (true){
			this.state = 1910
			rerunEveryClock()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RerunEveryRecordsContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_rerunEveryRecords.id
	        set(value) { throw RuntimeException() }
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun RECORDS() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORDS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRerunEveryRecords(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRerunEveryRecords(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRerunEveryRecords(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  rerunEveryRecords() : RerunEveryRecordsContext {
		var _localctx : RerunEveryRecordsContext = RerunEveryRecordsContext(context, state)
		enterRule(_localctx, 140, Rules.RULE_rerunEveryRecords.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1913
			integerLiteral()
			this.state = 1914
			match(RECORDS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RerunEveryOfContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_rerunEveryOf.id
	        set(value) { throw RuntimeException() }
		fun OF() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.OF.id)
		fun OF(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.OF.id, i) as TerminalNode
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun REEL() : TerminalNode? = getToken(Cobol85Parser.Tokens.REEL.id, 0)
		fun UNIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.UNIT.id, 0)
		fun END() : TerminalNode? = getToken(Cobol85Parser.Tokens.END.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRerunEveryOf(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRerunEveryOf(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRerunEveryOf(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  rerunEveryOf() : RerunEveryOfContext {
		var _localctx : RerunEveryOfContext = RerunEveryOfContext(context, state)
		enterRule(_localctx, 142, Rules.RULE_rerunEveryOf.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1917
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==END) {
				if (true){
				this.state = 1916
				match(END) as Token
				}
			}

			this.state = 1920
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OF) {
				if (true){
				this.state = 1919
				match(OF) as Token
				}
			}

			this.state = 1922
			_la = _input!!.LA(1)
			if ( !(_la==REEL || _la==UNIT) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 1923
			match(OF) as Token
			this.state = 1924
			fileName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RerunEveryClockContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_rerunEveryClock.id
	        set(value) { throw RuntimeException() }
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun CLOCK_UNITS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CLOCK_UNITS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRerunEveryClock(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRerunEveryClock(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRerunEveryClock(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  rerunEveryClock() : RerunEveryClockContext {
		var _localctx : RerunEveryClockContext = RerunEveryClockContext(context, state)
		enterRule(_localctx, 144, Rules.RULE_rerunEveryClock.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1926
			integerLiteral()
			this.state = 1928
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CLOCK_UNITS) {
				if (true){
				this.state = 1927
				match(CLOCK_UNITS) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SameClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sameClause.id
	        set(value) { throw RuntimeException() }
		fun SAME() : TerminalNode? = getToken(Cobol85Parser.Tokens.SAME.id, 0)
		fun AREA() : TerminalNode? = getToken(Cobol85Parser.Tokens.AREA.id, 0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun findFileName() : List<FileNameContext> = getRuleContexts(solver.getType("FileNameContext"))
		fun findFileName(i: Int) : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),i)
		fun RECORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORD.id, 0)
		fun SORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.SORT.id, 0)
		fun SORT_MERGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SORT_MERGE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSameClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSameClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSameClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sameClause() : SameClauseContext {
		var _localctx : SameClauseContext = SameClauseContext(context, state)
		enterRule(_localctx, 146, Rules.RULE_sameClause.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1930
			match(SAME) as Token
			this.state = 1932
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==RECORD || _la==SORT || _la==SORT_MERGE) {
				if (true){
				this.state = 1931
				_la = _input!!.LA(1)
				if ( !(_la==RECORD || _la==SORT || _la==SORT_MERGE) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			this.state = 1935
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==AREA) {
				if (true){
				this.state = 1934
				match(AREA) as Token
				}
			}

			this.state = 1938
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 1937
				match(FOR) as Token
				}
			}

			this.state = 1941 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 1940
				fileName()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 1943 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,159,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MultipleFileClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_multipleFileClause.id
	        set(value) { throw RuntimeException() }
		fun MULTIPLE() : TerminalNode? = getToken(Cobol85Parser.Tokens.MULTIPLE.id, 0)
		fun FILE() : TerminalNode? = getToken(Cobol85Parser.Tokens.FILE.id, 0)
		fun TAPE() : TerminalNode? = getToken(Cobol85Parser.Tokens.TAPE.id, 0)
		fun CONTAINS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTAINS.id, 0)
		fun findMultipleFilePosition() : List<MultipleFilePositionContext> = getRuleContexts(solver.getType("MultipleFilePositionContext"))
		fun findMultipleFilePosition(i: Int) : MultipleFilePositionContext? = getRuleContext(solver.getType("MultipleFilePositionContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMultipleFileClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMultipleFileClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMultipleFileClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  multipleFileClause() : MultipleFileClauseContext {
		var _localctx : MultipleFileClauseContext = MultipleFileClauseContext(context, state)
		enterRule(_localctx, 148, Rules.RULE_multipleFileClause.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1945
			match(MULTIPLE) as Token
			this.state = 1946
			match(FILE) as Token
			this.state = 1948
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TAPE) {
				if (true){
				this.state = 1947
				match(TAPE) as Token
				}
			}

			this.state = 1951
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CONTAINS) {
				if (true){
				this.state = 1950
				match(CONTAINS) as Token
				}
			}

			this.state = 1954 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 1953
				multipleFilePosition()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 1956 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,162,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MultipleFilePositionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_multipleFilePosition.id
	        set(value) { throw RuntimeException() }
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun POSITION() : TerminalNode? = getToken(Cobol85Parser.Tokens.POSITION.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMultipleFilePosition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMultipleFilePosition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMultipleFilePosition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  multipleFilePosition() : MultipleFilePositionContext {
		var _localctx : MultipleFilePositionContext = MultipleFilePositionContext(context, state)
		enterRule(_localctx, 150, Rules.RULE_multipleFilePosition.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1958
			fileName()
			this.state = 1961
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==POSITION) {
				if (true){
				this.state = 1959
				match(POSITION) as Token
				this.state = 1960
				integerLiteral()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CommitmentControlClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_commitmentControlClause.id
	        set(value) { throw RuntimeException() }
		fun COMMITMENT() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMMITMENT.id, 0)
		fun CONTROL() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTROL.id, 0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCommitmentControlClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCommitmentControlClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCommitmentControlClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  commitmentControlClause() : CommitmentControlClauseContext {
		var _localctx : CommitmentControlClauseContext = CommitmentControlClauseContext(context, state)
		enterRule(_localctx, 152, Rules.RULE_commitmentControlClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1963
			match(COMMITMENT) as Token
			this.state = 1964
			match(CONTROL) as Token
			this.state = 1966
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 1965
				match(FOR) as Token
				}
			}

			this.state = 1968
			fileName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataDivisionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataDivision.id
	        set(value) { throw RuntimeException() }
		fun DATA() : TerminalNode? = getToken(Cobol85Parser.Tokens.DATA.id, 0)
		fun DIVISION() : TerminalNode? = getToken(Cobol85Parser.Tokens.DIVISION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findDataDivisionSection() : List<DataDivisionSectionContext> = getRuleContexts(solver.getType("DataDivisionSectionContext"))
		fun findDataDivisionSection(i: Int) : DataDivisionSectionContext? = getRuleContext(solver.getType("DataDivisionSectionContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataDivision(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataDivision(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataDivision(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataDivision() : DataDivisionContext {
		var _localctx : DataDivisionContext = DataDivisionContext(context, state)
		enterRule(_localctx, 154, Rules.RULE_dataDivision.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1970
			match(DATA) as Token
			this.state = 1971
			match(DIVISION) as Token
			this.state = 1972
			match(DOT_FS) as Token
			this.state = 1976
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==COMMUNICATION || _la==DATA_BASE || _la==FILE || _la==LINKAGE || _la==LOCAL_STORAGE || ((((_la - 363)) and 0x3f.inv()) == 0 && ((1L shl (_la - 363)) and ((1L shl (PROGRAM_LIBRARY - 363)) or (1L shl (REPORT - 363)) or (1L shl (SCREEN - 363)))) != 0L) || _la==WORKING_STORAGE) {
				if (true){
				if (true){
				this.state = 1973
				dataDivisionSection()
				}
				}
				this.state = 1978
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataDivisionSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataDivisionSection.id
	        set(value) { throw RuntimeException() }
		fun findFileSection() : FileSectionContext? = getRuleContext(solver.getType("FileSectionContext"),0)
		fun findDataBaseSection() : DataBaseSectionContext? = getRuleContext(solver.getType("DataBaseSectionContext"),0)
		fun findWorkingStorageSection() : WorkingStorageSectionContext? = getRuleContext(solver.getType("WorkingStorageSectionContext"),0)
		fun findLinkageSection() : LinkageSectionContext? = getRuleContext(solver.getType("LinkageSectionContext"),0)
		fun findCommunicationSection() : CommunicationSectionContext? = getRuleContext(solver.getType("CommunicationSectionContext"),0)
		fun findLocalStorageSection() : LocalStorageSectionContext? = getRuleContext(solver.getType("LocalStorageSectionContext"),0)
		fun findScreenSection() : ScreenSectionContext? = getRuleContext(solver.getType("ScreenSectionContext"),0)
		fun findReportSection() : ReportSectionContext? = getRuleContext(solver.getType("ReportSectionContext"),0)
		fun findProgramLibrarySection() : ProgramLibrarySectionContext? = getRuleContext(solver.getType("ProgramLibrarySectionContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataDivisionSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataDivisionSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataDivisionSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataDivisionSection() : DataDivisionSectionContext {
		var _localctx : DataDivisionSectionContext = DataDivisionSectionContext(context, state)
		enterRule(_localctx, 156, Rules.RULE_dataDivisionSection.id)
		try {
			this.state = 1988
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			FILE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1979
			fileSection()
			}}
			DATA_BASE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 1980
			dataBaseSection()
			}}
			WORKING_STORAGE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 1981
			workingStorageSection()
			}}
			LINKAGE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 1982
			linkageSection()
			}}
			COMMUNICATION  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 1983
			communicationSection()
			}}
			LOCAL_STORAGE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 6)
			if (true){
			this.state = 1984
			localStorageSection()
			}}
			SCREEN  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 7)
			if (true){
			this.state = 1985
			screenSection()
			}}
			REPORT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 8)
			if (true){
			this.state = 1986
			reportSection()
			}}
			PROGRAM_LIBRARY  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 9)
			if (true){
			this.state = 1987
			programLibrarySection()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class FileSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_fileSection.id
	        set(value) { throw RuntimeException() }
		fun FILE() : TerminalNode? = getToken(Cobol85Parser.Tokens.FILE.id, 0)
		fun SECTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECTION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findFileDescriptionEntry() : List<FileDescriptionEntryContext> = getRuleContexts(solver.getType("FileDescriptionEntryContext"))
		fun findFileDescriptionEntry(i: Int) : FileDescriptionEntryContext? = getRuleContext(solver.getType("FileDescriptionEntryContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterFileSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitFileSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitFileSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  fileSection() : FileSectionContext {
		var _localctx : FileSectionContext = FileSectionContext(context, state)
		enterRule(_localctx, 158, Rules.RULE_fileSection.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1990
			match(FILE) as Token
			this.state = 1991
			match(SECTION) as Token
			this.state = 1992
			match(DOT_FS) as Token
			this.state = 1996
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==FD || _la==SD) {
				if (true){
				if (true){
				this.state = 1993
				fileDescriptionEntry()
				}
				}
				this.state = 1998
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class FileDescriptionEntryContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_fileDescriptionEntry.id
	        set(value) { throw RuntimeException() }
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun DOT_FS() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.DOT_FS.id)
		fun DOT_FS(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.DOT_FS.id, i) as TerminalNode
		fun FD() : TerminalNode? = getToken(Cobol85Parser.Tokens.FD.id, 0)
		fun SD() : TerminalNode? = getToken(Cobol85Parser.Tokens.SD.id, 0)
		fun findFileDescriptionEntryClause() : List<FileDescriptionEntryClauseContext> = getRuleContexts(solver.getType("FileDescriptionEntryClauseContext"))
		fun findFileDescriptionEntryClause(i: Int) : FileDescriptionEntryClauseContext? = getRuleContext(solver.getType("FileDescriptionEntryClauseContext"),i)
		fun findDataDescriptionEntry() : List<DataDescriptionEntryContext> = getRuleContexts(solver.getType("DataDescriptionEntryContext"))
		fun findDataDescriptionEntry(i: Int) : DataDescriptionEntryContext? = getRuleContext(solver.getType("DataDescriptionEntryContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterFileDescriptionEntry(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitFileDescriptionEntry(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitFileDescriptionEntry(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  fileDescriptionEntry() : FileDescriptionEntryContext {
		var _localctx : FileDescriptionEntryContext = FileDescriptionEntryContext(context, state)
		enterRule(_localctx, 160, Rules.RULE_fileDescriptionEntry.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 1999
			_la = _input!!.LA(1)
			if ( !(_la==FD || _la==SD) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 2000
			fileName()
			this.state = 2007
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,169,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 2002
					errorHandler.sync(this)
					_la = _input!!.LA(1)
					if (_la==DOT_FS) {
						if (true){
						this.state = 2001
						match(DOT_FS) as Token
						}
					}

					this.state = 2004
					fileDescriptionEntryClause()
					}
					} 
				}
				this.state = 2009
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,169,context)
			}
			this.state = 2010
			match(DOT_FS) as Token
			this.state = 2014
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (EXECSQLLINE - 552)))) != 0L)) {
				if (true){
				if (true){
				this.state = 2011
				dataDescriptionEntry()
				}
				}
				this.state = 2016
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class FileDescriptionEntryClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_fileDescriptionEntryClause.id
	        set(value) { throw RuntimeException() }
		fun findExternalClause() : ExternalClauseContext? = getRuleContext(solver.getType("ExternalClauseContext"),0)
		fun findGlobalClause() : GlobalClauseContext? = getRuleContext(solver.getType("GlobalClauseContext"),0)
		fun findBlockContainsClause() : BlockContainsClauseContext? = getRuleContext(solver.getType("BlockContainsClauseContext"),0)
		fun findRecordContainsClause() : RecordContainsClauseContext? = getRuleContext(solver.getType("RecordContainsClauseContext"),0)
		fun findLabelRecordsClause() : LabelRecordsClauseContext? = getRuleContext(solver.getType("LabelRecordsClauseContext"),0)
		fun findValueOfClause() : ValueOfClauseContext? = getRuleContext(solver.getType("ValueOfClauseContext"),0)
		fun findDataRecordsClause() : DataRecordsClauseContext? = getRuleContext(solver.getType("DataRecordsClauseContext"),0)
		fun findLinageClause() : LinageClauseContext? = getRuleContext(solver.getType("LinageClauseContext"),0)
		fun findCodeSetClause() : CodeSetClauseContext? = getRuleContext(solver.getType("CodeSetClauseContext"),0)
		fun findReportClause() : ReportClauseContext? = getRuleContext(solver.getType("ReportClauseContext"),0)
		fun findRecordingModeClause() : RecordingModeClauseContext? = getRuleContext(solver.getType("RecordingModeClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterFileDescriptionEntryClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitFileDescriptionEntryClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitFileDescriptionEntryClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  fileDescriptionEntryClause() : FileDescriptionEntryClauseContext {
		var _localctx : FileDescriptionEntryClauseContext = FileDescriptionEntryClauseContext(context, state)
		enterRule(_localctx, 162, Rules.RULE_fileDescriptionEntryClause.id)
		try {
			this.state = 2028
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,171,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2017
			externalClause()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 2018
			globalClause()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 2019
			blockContainsClause()
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 2020
			recordContainsClause()
			}}
			5 -> {
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 2021
			labelRecordsClause()
			}}
			6 -> {
			enterOuterAlt(_localctx, 6)
			if (true){
			this.state = 2022
			valueOfClause()
			}}
			7 -> {
			enterOuterAlt(_localctx, 7)
			if (true){
			this.state = 2023
			dataRecordsClause()
			}}
			8 -> {
			enterOuterAlt(_localctx, 8)
			if (true){
			this.state = 2024
			linageClause()
			}}
			9 -> {
			enterOuterAlt(_localctx, 9)
			if (true){
			this.state = 2025
			codeSetClause()
			}}
			10 -> {
			enterOuterAlt(_localctx, 10)
			if (true){
			this.state = 2026
			reportClause()
			}}
			11 -> {
			enterOuterAlt(_localctx, 11)
			if (true){
			this.state = 2027
			recordingModeClause()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ExternalClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_externalClause.id
	        set(value) { throw RuntimeException() }
		fun EXTERNAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXTERNAL.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterExternalClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitExternalClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitExternalClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  externalClause() : ExternalClauseContext {
		var _localctx : ExternalClauseContext = ExternalClauseContext(context, state)
		enterRule(_localctx, 164, Rules.RULE_externalClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2031
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2030
				match(IS) as Token
				}
			}

			this.state = 2033
			match(EXTERNAL) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class GlobalClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_globalClause.id
	        set(value) { throw RuntimeException() }
		fun GLOBAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.GLOBAL.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterGlobalClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitGlobalClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitGlobalClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  globalClause() : GlobalClauseContext {
		var _localctx : GlobalClauseContext = GlobalClauseContext(context, state)
		enterRule(_localctx, 166, Rules.RULE_globalClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2036
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2035
				match(IS) as Token
				}
			}

			this.state = 2038
			match(GLOBAL) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class BlockContainsClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_blockContainsClause.id
	        set(value) { throw RuntimeException() }
		fun BLOCK() : TerminalNode? = getToken(Cobol85Parser.Tokens.BLOCK.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun CONTAINS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTAINS.id, 0)
		fun findBlockContainsTo() : BlockContainsToContext? = getRuleContext(solver.getType("BlockContainsToContext"),0)
		fun RECORDS() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORDS.id, 0)
		fun CHARACTERS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTERS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterBlockContainsClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitBlockContainsClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitBlockContainsClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  blockContainsClause() : BlockContainsClauseContext {
		var _localctx : BlockContainsClauseContext = BlockContainsClauseContext(context, state)
		enterRule(_localctx, 168, Rules.RULE_blockContainsClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2040
			match(BLOCK) as Token
			this.state = 2042
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CONTAINS) {
				if (true){
				this.state = 2041
				match(CONTAINS) as Token
				}
			}

			this.state = 2044
			integerLiteral()
			this.state = 2046
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TO) {
				if (true){
				this.state = 2045
				blockContainsTo()
				}
			}

			this.state = 2049
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CHARACTERS || _la==RECORDS) {
				if (true){
				this.state = 2048
				_la = _input!!.LA(1)
				if ( !(_la==CHARACTERS || _la==RECORDS) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class BlockContainsToContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_blockContainsTo.id
	        set(value) { throw RuntimeException() }
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterBlockContainsTo(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitBlockContainsTo(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitBlockContainsTo(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  blockContainsTo() : BlockContainsToContext {
		var _localctx : BlockContainsToContext = BlockContainsToContext(context, state)
		enterRule(_localctx, 170, Rules.RULE_blockContainsTo.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2051
			match(TO) as Token
			this.state = 2052
			integerLiteral()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RecordContainsClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_recordContainsClause.id
	        set(value) { throw RuntimeException() }
		fun RECORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORD.id, 0)
		fun findRecordContainsClauseFormat1() : RecordContainsClauseFormat1Context? = getRuleContext(solver.getType("RecordContainsClauseFormat1Context"),0)
		fun findRecordContainsClauseFormat2() : RecordContainsClauseFormat2Context? = getRuleContext(solver.getType("RecordContainsClauseFormat2Context"),0)
		fun findRecordContainsClauseFormat3() : RecordContainsClauseFormat3Context? = getRuleContext(solver.getType("RecordContainsClauseFormat3Context"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRecordContainsClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRecordContainsClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRecordContainsClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  recordContainsClause() : RecordContainsClauseContext {
		var _localctx : RecordContainsClauseContext = RecordContainsClauseContext(context, state)
		enterRule(_localctx, 172, Rules.RULE_recordContainsClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2054
			match(RECORD) as Token
			this.state = 2058
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,177,context) ) {
			1 -> {if (true){
			this.state = 2055
			recordContainsClauseFormat1()
			}}
			2 -> {if (true){
			this.state = 2056
			recordContainsClauseFormat2()
			}}
			3 -> {if (true){
			this.state = 2057
			recordContainsClauseFormat3()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RecordContainsClauseFormat1Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_recordContainsClauseFormat1.id
	        set(value) { throw RuntimeException() }
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun CONTAINS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTAINS.id, 0)
		fun CHARACTERS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTERS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRecordContainsClauseFormat1(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRecordContainsClauseFormat1(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRecordContainsClauseFormat1(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  recordContainsClauseFormat1() : RecordContainsClauseFormat1Context {
		var _localctx : RecordContainsClauseFormat1Context = RecordContainsClauseFormat1Context(context, state)
		enterRule(_localctx, 174, Rules.RULE_recordContainsClauseFormat1.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2061
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CONTAINS) {
				if (true){
				this.state = 2060
				match(CONTAINS) as Token
				}
			}

			this.state = 2063
			integerLiteral()
			this.state = 2065
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CHARACTERS) {
				if (true){
				this.state = 2064
				match(CHARACTERS) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RecordContainsClauseFormat2Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_recordContainsClauseFormat2.id
	        set(value) { throw RuntimeException() }
		fun VARYING() : TerminalNode? = getToken(Cobol85Parser.Tokens.VARYING.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		fun SIZE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIZE.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun DEPENDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEPENDING.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun findRecordContainsTo() : RecordContainsToContext? = getRuleContext(solver.getType("RecordContainsToContext"),0)
		fun CHARACTERS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTERS.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRecordContainsClauseFormat2(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRecordContainsClauseFormat2(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRecordContainsClauseFormat2(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  recordContainsClauseFormat2() : RecordContainsClauseFormat2Context {
		var _localctx : RecordContainsClauseFormat2Context = RecordContainsClauseFormat2Context(context, state)
		enterRule(_localctx, 176, Rules.RULE_recordContainsClauseFormat2.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2068
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2067
				match(IS) as Token
				}
			}

			this.state = 2070
			match(VARYING) as Token
			this.state = 2072
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IN) {
				if (true){
				this.state = 2071
				match(IN) as Token
				}
			}

			this.state = 2075
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SIZE) {
				if (true){
				this.state = 2074
				match(SIZE) as Token
				}
			}

			this.state = 2087
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FROM || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)))) != 0L)) {
				if (true){
				this.state = 2078
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==FROM) {
					if (true){
					this.state = 2077
					match(FROM) as Token
					}
				}

				this.state = 2080
				integerLiteral()
				this.state = 2082
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==TO) {
					if (true){
					this.state = 2081
					recordContainsTo()
					}
				}

				this.state = 2085
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==CHARACTERS) {
					if (true){
					this.state = 2084
					match(CHARACTERS) as Token
					}
				}

				}
			}

			this.state = 2094
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DEPENDING) {
				if (true){
				this.state = 2089
				match(DEPENDING) as Token
				this.state = 2091
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==ON) {
					if (true){
					this.state = 2090
					match(ON) as Token
					}
				}

				this.state = 2093
				qualifiedDataName()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RecordContainsClauseFormat3Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_recordContainsClauseFormat3.id
	        set(value) { throw RuntimeException() }
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun findRecordContainsTo() : RecordContainsToContext? = getRuleContext(solver.getType("RecordContainsToContext"),0)
		fun CONTAINS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTAINS.id, 0)
		fun CHARACTERS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTERS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRecordContainsClauseFormat3(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRecordContainsClauseFormat3(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRecordContainsClauseFormat3(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  recordContainsClauseFormat3() : RecordContainsClauseFormat3Context {
		var _localctx : RecordContainsClauseFormat3Context = RecordContainsClauseFormat3Context(context, state)
		enterRule(_localctx, 178, Rules.RULE_recordContainsClauseFormat3.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2097
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CONTAINS) {
				if (true){
				this.state = 2096
				match(CONTAINS) as Token
				}
			}

			this.state = 2099
			integerLiteral()
			this.state = 2100
			recordContainsTo()
			this.state = 2102
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CHARACTERS) {
				if (true){
				this.state = 2101
				match(CHARACTERS) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RecordContainsToContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_recordContainsTo.id
	        set(value) { throw RuntimeException() }
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRecordContainsTo(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRecordContainsTo(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRecordContainsTo(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  recordContainsTo() : RecordContainsToContext {
		var _localctx : RecordContainsToContext = RecordContainsToContext(context, state)
		enterRule(_localctx, 180, Rules.RULE_recordContainsTo.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2104
			match(TO) as Token
			this.state = 2105
			integerLiteral()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LabelRecordsClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_labelRecordsClause.id
	        set(value) { throw RuntimeException() }
		fun LABEL() : TerminalNode? = getToken(Cobol85Parser.Tokens.LABEL.id, 0)
		fun RECORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORD.id, 0)
		fun RECORDS() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORDS.id, 0)
		fun OMITTED() : TerminalNode? = getToken(Cobol85Parser.Tokens.OMITTED.id, 0)
		fun STANDARD() : TerminalNode? = getToken(Cobol85Parser.Tokens.STANDARD.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun ARE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ARE.id, 0)
		fun findDataName() : List<DataNameContext> = getRuleContexts(solver.getType("DataNameContext"))
		fun findDataName(i: Int) : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLabelRecordsClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLabelRecordsClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLabelRecordsClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  labelRecordsClause() : LabelRecordsClauseContext {
		var _localctx : LabelRecordsClauseContext = LabelRecordsClauseContext(context, state)
		enterRule(_localctx, 182, Rules.RULE_labelRecordsClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2107
			match(LABEL) as Token
			this.state = 2116
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			RECORD  ->  /*LL1AltBlock*/{if (true){
			this.state = 2108
			match(RECORD) as Token
			this.state = 2110
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2109
				match(IS) as Token
				}
			}

			}}
			RECORDS  ->  /*LL1AltBlock*/{if (true){
			this.state = 2112
			match(RECORDS) as Token
			this.state = 2114
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ARE) {
				if (true){
				this.state = 2113
				match(ARE) as Token
				}
			}

			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 2125
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			OMITTED  ->  /*LL1AltBlock*/{if (true){
			this.state = 2118
			match(OMITTED) as Token
			}}
			STANDARD  ->  /*LL1AltBlock*/{if (true){
			this.state = 2119
			match(STANDARD) as Token
			}}
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 2121 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 2120
				dataName()
				}
				}
				this.state = 2123 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ValueOfClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_valueOfClause.id
	        set(value) { throw RuntimeException() }
		fun VALUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.VALUE.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		fun findValuePair() : List<ValuePairContext> = getRuleContexts(solver.getType("ValuePairContext"))
		fun findValuePair(i: Int) : ValuePairContext? = getRuleContext(solver.getType("ValuePairContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterValueOfClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitValueOfClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitValueOfClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  valueOfClause() : ValueOfClauseContext {
		var _localctx : ValueOfClauseContext = ValueOfClauseContext(context, state)
		enterRule(_localctx, 184, Rules.RULE_valueOfClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2127
			match(VALUE) as Token
			this.state = 2128
			match(OF) as Token
			this.state = 2130 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 2129
				valuePair()
				}
				}
				this.state = 2132 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ValuePairContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_valuePair.id
	        set(value) { throw RuntimeException() }
		fun findSystemName() : SystemNameContext? = getRuleContext(solver.getType("SystemNameContext"),0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterValuePair(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitValuePair(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitValuePair(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  valuePair() : ValuePairContext {
		var _localctx : ValuePairContext = ValuePairContext(context, state)
		enterRule(_localctx, 186, Rules.RULE_valuePair.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2134
			systemName()
			this.state = 2136
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2135
				match(IS) as Token
				}
			}

			this.state = 2140
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,198,context) ) {
			1 -> {if (true){
			this.state = 2138
			qualifiedDataName()
			}}
			2 -> {if (true){
			this.state = 2139
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataRecordsClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataRecordsClause.id
	        set(value) { throw RuntimeException() }
		fun DATA() : TerminalNode? = getToken(Cobol85Parser.Tokens.DATA.id, 0)
		fun RECORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORD.id, 0)
		fun RECORDS() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORDS.id, 0)
		fun findDataName() : List<DataNameContext> = getRuleContexts(solver.getType("DataNameContext"))
		fun findDataName(i: Int) : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),i)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun ARE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ARE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataRecordsClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataRecordsClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataRecordsClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataRecordsClause() : DataRecordsClauseContext {
		var _localctx : DataRecordsClauseContext = DataRecordsClauseContext(context, state)
		enterRule(_localctx, 188, Rules.RULE_dataRecordsClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2142
			match(DATA) as Token
			this.state = 2151
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			RECORD  ->  /*LL1AltBlock*/{if (true){
			this.state = 2143
			match(RECORD) as Token
			this.state = 2145
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2144
				match(IS) as Token
				}
			}

			}}
			RECORDS  ->  /*LL1AltBlock*/{if (true){
			this.state = 2147
			match(RECORDS) as Token
			this.state = 2149
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ARE) {
				if (true){
				this.state = 2148
				match(ARE) as Token
				}
			}

			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 2154 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 2153
				dataName()
				}
				}
				this.state = 2156 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LinageClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_linageClause.id
	        set(value) { throw RuntimeException() }
		fun LINAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINAGE.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun LINES() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINES.id, 0)
		fun findLinageAt() : List<LinageAtContext> = getRuleContexts(solver.getType("LinageAtContext"))
		fun findLinageAt(i: Int) : LinageAtContext? = getRuleContext(solver.getType("LinageAtContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLinageClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLinageClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLinageClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  linageClause() : LinageClauseContext {
		var _localctx : LinageClauseContext = LinageClauseContext(context, state)
		enterRule(_localctx, 190, Rules.RULE_linageClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2158
			match(LINAGE) as Token
			this.state = 2160
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2159
				match(IS) as Token
				}
			}

			this.state = 2164
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 2162
			dataName()
			}}
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 2163
			integerLiteral()
			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 2167
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,205,context) ) {
			1   -> if (true){
			this.state = 2166
			match(LINES) as Token
			}
			}
			this.state = 2172
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==AT || _la==BOTTOM || _la==FOOTING || _la==LINES || _la==TOP || _la==WITH) {
				if (true){
				if (true){
				this.state = 2169
				linageAt()
				}
				}
				this.state = 2174
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LinageAtContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_linageAt.id
	        set(value) { throw RuntimeException() }
		fun findLinageFootingAt() : LinageFootingAtContext? = getRuleContext(solver.getType("LinageFootingAtContext"),0)
		fun findLinageLinesAtTop() : LinageLinesAtTopContext? = getRuleContext(solver.getType("LinageLinesAtTopContext"),0)
		fun findLinageLinesAtBottom() : LinageLinesAtBottomContext? = getRuleContext(solver.getType("LinageLinesAtBottomContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLinageAt(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLinageAt(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLinageAt(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  linageAt() : LinageAtContext {
		var _localctx : LinageAtContext = LinageAtContext(context, state)
		enterRule(_localctx, 192, Rules.RULE_linageAt.id)
		try {
			this.state = 2178
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,207,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2175
			linageFootingAt()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 2176
			linageLinesAtTop()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 2177
			linageLinesAtBottom()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LinageFootingAtContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_linageFootingAt.id
	        set(value) { throw RuntimeException() }
		fun FOOTING() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOOTING.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		fun AT() : TerminalNode? = getToken(Cobol85Parser.Tokens.AT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLinageFootingAt(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLinageFootingAt(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLinageFootingAt(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  linageFootingAt() : LinageFootingAtContext {
		var _localctx : LinageFootingAtContext = LinageFootingAtContext(context, state)
		enterRule(_localctx, 194, Rules.RULE_linageFootingAt.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2181
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 2180
				match(WITH) as Token
				}
			}

			this.state = 2183
			match(FOOTING) as Token
			this.state = 2185
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==AT) {
				if (true){
				this.state = 2184
				match(AT) as Token
				}
			}

			this.state = 2189
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 2187
			dataName()
			}}
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 2188
			integerLiteral()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LinageLinesAtTopContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_linageLinesAtTop.id
	        set(value) { throw RuntimeException() }
		fun TOP() : TerminalNode? = getToken(Cobol85Parser.Tokens.TOP.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun LINES() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINES.id, 0)
		fun AT() : TerminalNode? = getToken(Cobol85Parser.Tokens.AT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLinageLinesAtTop(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLinageLinesAtTop(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLinageLinesAtTop(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  linageLinesAtTop() : LinageLinesAtTopContext {
		var _localctx : LinageLinesAtTopContext = LinageLinesAtTopContext(context, state)
		enterRule(_localctx, 196, Rules.RULE_linageLinesAtTop.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2192
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LINES) {
				if (true){
				this.state = 2191
				match(LINES) as Token
				}
			}

			this.state = 2195
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==AT) {
				if (true){
				this.state = 2194
				match(AT) as Token
				}
			}

			this.state = 2197
			match(TOP) as Token
			this.state = 2200
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 2198
			dataName()
			}}
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 2199
			integerLiteral()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LinageLinesAtBottomContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_linageLinesAtBottom.id
	        set(value) { throw RuntimeException() }
		fun BOTTOM() : TerminalNode? = getToken(Cobol85Parser.Tokens.BOTTOM.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun LINES() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINES.id, 0)
		fun AT() : TerminalNode? = getToken(Cobol85Parser.Tokens.AT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLinageLinesAtBottom(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLinageLinesAtBottom(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLinageLinesAtBottom(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  linageLinesAtBottom() : LinageLinesAtBottomContext {
		var _localctx : LinageLinesAtBottomContext = LinageLinesAtBottomContext(context, state)
		enterRule(_localctx, 198, Rules.RULE_linageLinesAtBottom.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2203
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LINES) {
				if (true){
				this.state = 2202
				match(LINES) as Token
				}
			}

			this.state = 2206
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==AT) {
				if (true){
				this.state = 2205
				match(AT) as Token
				}
			}

			this.state = 2208
			match(BOTTOM) as Token
			this.state = 2211
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 2209
			dataName()
			}}
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 2210
			integerLiteral()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RecordingModeClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_recordingModeClause.id
	        set(value) { throw RuntimeException() }
		fun RECORDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORDING.id, 0)
		fun findModeStatement() : ModeStatementContext? = getRuleContext(solver.getType("ModeStatementContext"),0)
		fun MODE() : TerminalNode? = getToken(Cobol85Parser.Tokens.MODE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRecordingModeClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRecordingModeClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRecordingModeClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  recordingModeClause() : RecordingModeClauseContext {
		var _localctx : RecordingModeClauseContext = RecordingModeClauseContext(context, state)
		enterRule(_localctx, 200, Rules.RULE_recordingModeClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2213
			match(RECORDING) as Token
			this.state = 2215
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==MODE) {
				if (true){
				this.state = 2214
				match(MODE) as Token
				}
			}

			this.state = 2218
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2217
				match(IS) as Token
				}
			}

			this.state = 2220
			modeStatement()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ModeStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_modeStatement.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterModeStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitModeStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitModeStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  modeStatement() : ModeStatementContext {
		var _localctx : ModeStatementContext = ModeStatementContext(context, state)
		enterRule(_localctx, 202, Rules.RULE_modeStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2222
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CodeSetClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_codeSetClause.id
	        set(value) { throw RuntimeException() }
		fun CODE_SET() : TerminalNode? = getToken(Cobol85Parser.Tokens.CODE_SET.id, 0)
		fun findAlphabetName() : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCodeSetClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCodeSetClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCodeSetClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  codeSetClause() : CodeSetClauseContext {
		var _localctx : CodeSetClauseContext = CodeSetClauseContext(context, state)
		enterRule(_localctx, 204, Rules.RULE_codeSetClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2224
			match(CODE_SET) as Token
			this.state = 2226
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2225
				match(IS) as Token
				}
			}

			this.state = 2228
			alphabetName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportClause.id
	        set(value) { throw RuntimeException() }
		fun REPORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.REPORT.id, 0)
		fun REPORTS() : TerminalNode? = getToken(Cobol85Parser.Tokens.REPORTS.id, 0)
		fun findReportName() : List<ReportNameContext> = getRuleContexts(solver.getType("ReportNameContext"))
		fun findReportName(i: Int) : ReportNameContext? = getRuleContext(solver.getType("ReportNameContext"),i)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun ARE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ARE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportClause() : ReportClauseContext {
		var _localctx : ReportClauseContext = ReportClauseContext(context, state)
		enterRule(_localctx, 206, Rules.RULE_reportClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2238
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			REPORT  ->  /*LL1AltBlock*/{if (true){
			this.state = 2230
			match(REPORT) as Token
			this.state = 2232
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2231
				match(IS) as Token
				}
			}

			}}
			REPORTS  ->  /*LL1AltBlock*/{if (true){
			this.state = 2234
			match(REPORTS) as Token
			this.state = 2236
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ARE) {
				if (true){
				this.state = 2235
				match(ARE) as Token
				}
			}

			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 2241 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 2240
				reportName()
				}
				}
				this.state = 2243 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataBaseSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataBaseSection.id
	        set(value) { throw RuntimeException() }
		fun DATA_BASE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DATA_BASE.id, 0)
		fun SECTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECTION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findDataBaseSectionEntry() : List<DataBaseSectionEntryContext> = getRuleContexts(solver.getType("DataBaseSectionEntryContext"))
		fun findDataBaseSectionEntry(i: Int) : DataBaseSectionEntryContext? = getRuleContext(solver.getType("DataBaseSectionEntryContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataBaseSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataBaseSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataBaseSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataBaseSection() : DataBaseSectionContext {
		var _localctx : DataBaseSectionContext = DataBaseSectionContext(context, state)
		enterRule(_localctx, 208, Rules.RULE_dataBaseSection.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2245
			match(DATA_BASE) as Token
			this.state = 2246
			match(SECTION) as Token
			this.state = 2247
			match(DOT_FS) as Token
			this.state = 2251
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)))) != 0L)) {
				if (true){
				if (true){
				this.state = 2248
				dataBaseSectionEntry()
				}
				}
				this.state = 2253
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataBaseSectionEntryContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataBaseSectionEntry.id
	        set(value) { throw RuntimeException() }
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun findLiteral() : List<LiteralContext> = getRuleContexts(solver.getType("LiteralContext"))
		fun findLiteral(i: Int) : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),i)
		fun INVOKE() : TerminalNode? = getToken(Cobol85Parser.Tokens.INVOKE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataBaseSectionEntry(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataBaseSectionEntry(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataBaseSectionEntry(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataBaseSectionEntry() : DataBaseSectionEntryContext {
		var _localctx : DataBaseSectionEntryContext = DataBaseSectionEntryContext(context, state)
		enterRule(_localctx, 210, Rules.RULE_dataBaseSectionEntry.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2254
			integerLiteral()
			this.state = 2255
			literal()
			this.state = 2256
			match(INVOKE) as Token
			this.state = 2257
			literal()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class WorkingStorageSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_workingStorageSection.id
	        set(value) { throw RuntimeException() }
		fun WORKING_STORAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.WORKING_STORAGE.id, 0)
		fun SECTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECTION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findDataDescriptionEntry() : List<DataDescriptionEntryContext> = getRuleContexts(solver.getType("DataDescriptionEntryContext"))
		fun findDataDescriptionEntry(i: Int) : DataDescriptionEntryContext? = getRuleContext(solver.getType("DataDescriptionEntryContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterWorkingStorageSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitWorkingStorageSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitWorkingStorageSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  workingStorageSection() : WorkingStorageSectionContext {
		var _localctx : WorkingStorageSectionContext = WorkingStorageSectionContext(context, state)
		enterRule(_localctx, 212, Rules.RULE_workingStorageSection.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2259
			match(WORKING_STORAGE) as Token
			this.state = 2260
			match(SECTION) as Token
			this.state = 2261
			match(DOT_FS) as Token
			this.state = 2265
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (EXECSQLLINE - 552)))) != 0L)) {
				if (true){
				if (true){
				this.state = 2262
				dataDescriptionEntry()
				}
				}
				this.state = 2267
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LinkageSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_linkageSection.id
	        set(value) { throw RuntimeException() }
		fun LINKAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINKAGE.id, 0)
		fun SECTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECTION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findDataDescriptionEntry() : List<DataDescriptionEntryContext> = getRuleContexts(solver.getType("DataDescriptionEntryContext"))
		fun findDataDescriptionEntry(i: Int) : DataDescriptionEntryContext? = getRuleContext(solver.getType("DataDescriptionEntryContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLinkageSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLinkageSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLinkageSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  linkageSection() : LinkageSectionContext {
		var _localctx : LinkageSectionContext = LinkageSectionContext(context, state)
		enterRule(_localctx, 214, Rules.RULE_linkageSection.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2268
			match(LINKAGE) as Token
			this.state = 2269
			match(SECTION) as Token
			this.state = 2270
			match(DOT_FS) as Token
			this.state = 2274
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (EXECSQLLINE - 552)))) != 0L)) {
				if (true){
				if (true){
				this.state = 2271
				dataDescriptionEntry()
				}
				}
				this.state = 2276
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CommunicationSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_communicationSection.id
	        set(value) { throw RuntimeException() }
		fun COMMUNICATION() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMMUNICATION.id, 0)
		fun SECTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECTION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findCommunicationDescriptionEntry() : List<CommunicationDescriptionEntryContext> = getRuleContexts(solver.getType("CommunicationDescriptionEntryContext"))
		fun findCommunicationDescriptionEntry(i: Int) : CommunicationDescriptionEntryContext? = getRuleContext(solver.getType("CommunicationDescriptionEntryContext"),i)
		fun findDataDescriptionEntry() : List<DataDescriptionEntryContext> = getRuleContexts(solver.getType("DataDescriptionEntryContext"))
		fun findDataDescriptionEntry(i: Int) : DataDescriptionEntryContext? = getRuleContext(solver.getType("DataDescriptionEntryContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCommunicationSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCommunicationSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCommunicationSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  communicationSection() : CommunicationSectionContext {
		var _localctx : CommunicationSectionContext = CommunicationSectionContext(context, state)
		enterRule(_localctx, 216, Rules.RULE_communicationSection.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2277
			match(COMMUNICATION) as Token
			this.state = 2278
			match(SECTION) as Token
			this.state = 2279
			match(DOT_FS) as Token
			this.state = 2284
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==CD || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (EXECSQLLINE - 552)))) != 0L)) {
				if (true){
				this.state = 2282
				errorHandler.sync(this)
				when (_input!!.LA(1)) {
				CD  ->  /*LL1AltBlock*/{if (true){
				this.state = 2280
				communicationDescriptionEntry()
				}}
				LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL , EXECSQLLINE  ->  /*LL1AltBlock*/{if (true){
				this.state = 2281
				dataDescriptionEntry()
				}}
				else -> throw NoViableAltException(this)
				}
				}
				this.state = 2286
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CommunicationDescriptionEntryContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_communicationDescriptionEntry.id
	        set(value) { throw RuntimeException() }
		fun findCommunicationDescriptionEntryFormat1() : CommunicationDescriptionEntryFormat1Context? = getRuleContext(solver.getType("CommunicationDescriptionEntryFormat1Context"),0)
		fun findCommunicationDescriptionEntryFormat2() : CommunicationDescriptionEntryFormat2Context? = getRuleContext(solver.getType("CommunicationDescriptionEntryFormat2Context"),0)
		fun findCommunicationDescriptionEntryFormat3() : CommunicationDescriptionEntryFormat3Context? = getRuleContext(solver.getType("CommunicationDescriptionEntryFormat3Context"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCommunicationDescriptionEntry(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCommunicationDescriptionEntry(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCommunicationDescriptionEntry(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  communicationDescriptionEntry() : CommunicationDescriptionEntryContext {
		var _localctx : CommunicationDescriptionEntryContext = CommunicationDescriptionEntryContext(context, state)
		enterRule(_localctx, 218, Rules.RULE_communicationDescriptionEntry.id)
		try {
			this.state = 2290
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,229,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2287
			communicationDescriptionEntryFormat1()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 2288
			communicationDescriptionEntryFormat2()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 2289
			communicationDescriptionEntryFormat3()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CommunicationDescriptionEntryFormat1Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_communicationDescriptionEntryFormat1.id
	        set(value) { throw RuntimeException() }
		fun CD() : TerminalNode? = getToken(Cobol85Parser.Tokens.CD.id, 0)
		fun findCdName() : CdNameContext? = getRuleContext(solver.getType("CdNameContext"),0)
		fun INPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.INPUT.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun INITIAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.INITIAL.id, 0)
		fun findDataDescName() : List<DataDescNameContext> = getRuleContexts(solver.getType("DataDescNameContext"))
		fun findDataDescName(i: Int) : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),i)
		fun findSymbolicQueueClause() : List<SymbolicQueueClauseContext> = getRuleContexts(solver.getType("SymbolicQueueClauseContext"))
		fun findSymbolicQueueClause(i: Int) : SymbolicQueueClauseContext? = getRuleContext(solver.getType("SymbolicQueueClauseContext"),i)
		fun findSymbolicSubQueueClause() : List<SymbolicSubQueueClauseContext> = getRuleContexts(solver.getType("SymbolicSubQueueClauseContext"))
		fun findSymbolicSubQueueClause(i: Int) : SymbolicSubQueueClauseContext? = getRuleContext(solver.getType("SymbolicSubQueueClauseContext"),i)
		fun findMessageDateClause() : List<MessageDateClauseContext> = getRuleContexts(solver.getType("MessageDateClauseContext"))
		fun findMessageDateClause(i: Int) : MessageDateClauseContext? = getRuleContext(solver.getType("MessageDateClauseContext"),i)
		fun findMessageTimeClause() : List<MessageTimeClauseContext> = getRuleContexts(solver.getType("MessageTimeClauseContext"))
		fun findMessageTimeClause(i: Int) : MessageTimeClauseContext? = getRuleContext(solver.getType("MessageTimeClauseContext"),i)
		fun findSymbolicSourceClause() : List<SymbolicSourceClauseContext> = getRuleContexts(solver.getType("SymbolicSourceClauseContext"))
		fun findSymbolicSourceClause(i: Int) : SymbolicSourceClauseContext? = getRuleContext(solver.getType("SymbolicSourceClauseContext"),i)
		fun findTextLengthClause() : List<TextLengthClauseContext> = getRuleContexts(solver.getType("TextLengthClauseContext"))
		fun findTextLengthClause(i: Int) : TextLengthClauseContext? = getRuleContext(solver.getType("TextLengthClauseContext"),i)
		fun findEndKeyClause() : List<EndKeyClauseContext> = getRuleContexts(solver.getType("EndKeyClauseContext"))
		fun findEndKeyClause(i: Int) : EndKeyClauseContext? = getRuleContext(solver.getType("EndKeyClauseContext"),i)
		fun findStatusKeyClause() : List<StatusKeyClauseContext> = getRuleContexts(solver.getType("StatusKeyClauseContext"))
		fun findStatusKeyClause(i: Int) : StatusKeyClauseContext? = getRuleContext(solver.getType("StatusKeyClauseContext"),i)
		fun findMessageCountClause() : List<MessageCountClauseContext> = getRuleContexts(solver.getType("MessageCountClauseContext"))
		fun findMessageCountClause(i: Int) : MessageCountClauseContext? = getRuleContext(solver.getType("MessageCountClauseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCommunicationDescriptionEntryFormat1(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCommunicationDescriptionEntryFormat1(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCommunicationDescriptionEntryFormat1(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  communicationDescriptionEntryFormat1() : CommunicationDescriptionEntryFormat1Context {
		var _localctx : CommunicationDescriptionEntryFormat1Context = CommunicationDescriptionEntryFormat1Context(context, state)
		enterRule(_localctx, 220, Rules.RULE_communicationDescriptionEntryFormat1.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2292
			match(CD) as Token
			this.state = 2293
			cdName()
			this.state = 2295
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 2294
				match(FOR) as Token
				}
			}

			this.state = 2298
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==INITIAL) {
				if (true){
				this.state = 2297
				match(INITIAL) as Token
				}
			}

			this.state = 2300
			match(INPUT) as Token
			this.state = 2315
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (COUNT - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (END - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FILLER - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MESSAGE - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUEUE - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SOURCE - 401)) or (1L shl (STATUS - 401)) or (1L shl (SUB_QUEUE_1 - 401)) or (1L shl (SUB_QUEUE_2 - 401)) or (1L shl (SUB_QUEUE_3 - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (SYMBOLIC - 466)) or (1L shl (TASK - 466)) or (1L shl (TEXT - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER) {
				if (true){
				this.state = 2313
				errorHandler.sync(this)
				when (_input!!.LA(1)) {
				COUNT , END , MESSAGE , QUEUE , SOURCE , STATUS , SUB_QUEUE_1 , SUB_QUEUE_2 , SUB_QUEUE_3 , SYMBOLIC , TEXT  ->  /*LL1AltBlock*/{if (true){
				this.state = 2310
				errorHandler.sync(this)
				when ( interpreter!!.adaptivePredict(_input!!,232,context) ) {
				1 -> {if (true){
				this.state = 2301
				symbolicQueueClause()
				}}
				2 -> {if (true){
				this.state = 2302
				symbolicSubQueueClause()
				}}
				3 -> {if (true){
				this.state = 2303
				messageDateClause()
				}}
				4 -> {if (true){
				this.state = 2304
				messageTimeClause()
				}}
				5 -> {if (true){
				this.state = 2305
				symbolicSourceClause()
				}}
				6 -> {if (true){
				this.state = 2306
				textLengthClause()
				}}
				7 -> {if (true){
				this.state = 2307
				endKeyClause()
				}}
				8 -> {if (true){
				this.state = 2308
				statusKeyClause()
				}}
				9 -> {if (true){
				this.state = 2309
				messageCountClause()
				}}
				}
				}}
				ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FILLER , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
				this.state = 2312
				dataDescName()
				}}
				else -> throw NoViableAltException(this)
				}
				}
				this.state = 2317
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 2318
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CommunicationDescriptionEntryFormat2Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_communicationDescriptionEntryFormat2.id
	        set(value) { throw RuntimeException() }
		fun CD() : TerminalNode? = getToken(Cobol85Parser.Tokens.CD.id, 0)
		fun findCdName() : CdNameContext? = getRuleContext(solver.getType("CdNameContext"),0)
		fun OUTPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.OUTPUT.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun findDestinationCountClause() : List<DestinationCountClauseContext> = getRuleContexts(solver.getType("DestinationCountClauseContext"))
		fun findDestinationCountClause(i: Int) : DestinationCountClauseContext? = getRuleContext(solver.getType("DestinationCountClauseContext"),i)
		fun findTextLengthClause() : List<TextLengthClauseContext> = getRuleContexts(solver.getType("TextLengthClauseContext"))
		fun findTextLengthClause(i: Int) : TextLengthClauseContext? = getRuleContext(solver.getType("TextLengthClauseContext"),i)
		fun findStatusKeyClause() : List<StatusKeyClauseContext> = getRuleContexts(solver.getType("StatusKeyClauseContext"))
		fun findStatusKeyClause(i: Int) : StatusKeyClauseContext? = getRuleContext(solver.getType("StatusKeyClauseContext"),i)
		fun findDestinationTableClause() : List<DestinationTableClauseContext> = getRuleContexts(solver.getType("DestinationTableClauseContext"))
		fun findDestinationTableClause(i: Int) : DestinationTableClauseContext? = getRuleContext(solver.getType("DestinationTableClauseContext"),i)
		fun findErrorKeyClause() : List<ErrorKeyClauseContext> = getRuleContexts(solver.getType("ErrorKeyClauseContext"))
		fun findErrorKeyClause(i: Int) : ErrorKeyClauseContext? = getRuleContext(solver.getType("ErrorKeyClauseContext"),i)
		fun findSymbolicDestinationClause() : List<SymbolicDestinationClauseContext> = getRuleContexts(solver.getType("SymbolicDestinationClauseContext"))
		fun findSymbolicDestinationClause(i: Int) : SymbolicDestinationClauseContext? = getRuleContext(solver.getType("SymbolicDestinationClauseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCommunicationDescriptionEntryFormat2(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCommunicationDescriptionEntryFormat2(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCommunicationDescriptionEntryFormat2(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  communicationDescriptionEntryFormat2() : CommunicationDescriptionEntryFormat2Context {
		var _localctx : CommunicationDescriptionEntryFormat2Context = CommunicationDescriptionEntryFormat2Context(context, state)
		enterRule(_localctx, 222, Rules.RULE_communicationDescriptionEntryFormat2.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2320
			match(CD) as Token
			this.state = 2321
			cdName()
			this.state = 2323
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 2322
				match(FOR) as Token
				}
			}

			this.state = 2325
			match(OUTPUT) as Token
			this.state = 2334
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==DESTINATION || _la==ERROR || ((((_la - 457)) and 0x3f.inv()) == 0 && ((1L shl (_la - 457)) and ((1L shl (STATUS - 457)) or (1L shl (SYMBOLIC - 457)) or (1L shl (TEXT - 457)))) != 0L)) {
				if (true){
				this.state = 2332
				errorHandler.sync(this)
				when ( interpreter!!.adaptivePredict(_input!!,236,context) ) {
				1 -> {if (true){
				this.state = 2326
				destinationCountClause()
				}}
				2 -> {if (true){
				this.state = 2327
				textLengthClause()
				}}
				3 -> {if (true){
				this.state = 2328
				statusKeyClause()
				}}
				4 -> {if (true){
				this.state = 2329
				destinationTableClause()
				}}
				5 -> {if (true){
				this.state = 2330
				errorKeyClause()
				}}
				6 -> {if (true){
				this.state = 2331
				symbolicDestinationClause()
				}}
				}
				}
				this.state = 2336
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 2337
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CommunicationDescriptionEntryFormat3Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_communicationDescriptionEntryFormat3.id
	        set(value) { throw RuntimeException() }
		fun CD() : TerminalNode? = getToken(Cobol85Parser.Tokens.CD.id, 0)
		fun findCdName() : CdNameContext? = getRuleContext(solver.getType("CdNameContext"),0)
		fun INITIAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.INITIAL.id, 0)
		fun I_O() : TerminalNode? = getToken(Cobol85Parser.Tokens.I_O.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun findDataDescName() : List<DataDescNameContext> = getRuleContexts(solver.getType("DataDescNameContext"))
		fun findDataDescName(i: Int) : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),i)
		fun findMessageDateClause() : List<MessageDateClauseContext> = getRuleContexts(solver.getType("MessageDateClauseContext"))
		fun findMessageDateClause(i: Int) : MessageDateClauseContext? = getRuleContext(solver.getType("MessageDateClauseContext"),i)
		fun findMessageTimeClause() : List<MessageTimeClauseContext> = getRuleContexts(solver.getType("MessageTimeClauseContext"))
		fun findMessageTimeClause(i: Int) : MessageTimeClauseContext? = getRuleContext(solver.getType("MessageTimeClauseContext"),i)
		fun findSymbolicTerminalClause() : List<SymbolicTerminalClauseContext> = getRuleContexts(solver.getType("SymbolicTerminalClauseContext"))
		fun findSymbolicTerminalClause(i: Int) : SymbolicTerminalClauseContext? = getRuleContext(solver.getType("SymbolicTerminalClauseContext"),i)
		fun findTextLengthClause() : List<TextLengthClauseContext> = getRuleContexts(solver.getType("TextLengthClauseContext"))
		fun findTextLengthClause(i: Int) : TextLengthClauseContext? = getRuleContext(solver.getType("TextLengthClauseContext"),i)
		fun findEndKeyClause() : List<EndKeyClauseContext> = getRuleContexts(solver.getType("EndKeyClauseContext"))
		fun findEndKeyClause(i: Int) : EndKeyClauseContext? = getRuleContext(solver.getType("EndKeyClauseContext"),i)
		fun findStatusKeyClause() : List<StatusKeyClauseContext> = getRuleContexts(solver.getType("StatusKeyClauseContext"))
		fun findStatusKeyClause(i: Int) : StatusKeyClauseContext? = getRuleContext(solver.getType("StatusKeyClauseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCommunicationDescriptionEntryFormat3(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCommunicationDescriptionEntryFormat3(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCommunicationDescriptionEntryFormat3(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  communicationDescriptionEntryFormat3() : CommunicationDescriptionEntryFormat3Context {
		var _localctx : CommunicationDescriptionEntryFormat3Context = CommunicationDescriptionEntryFormat3Context(context, state)
		enterRule(_localctx, 224, Rules.RULE_communicationDescriptionEntryFormat3.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2339
			match(CD) as Token
			this.state = 2340
			cdName()
			this.state = 2342
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 2341
				match(FOR) as Token
				}
			}

			this.state = 2344
			match(INITIAL) as Token
			this.state = 2345
			match(I_O) as Token
			this.state = 2357
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (END - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FILLER - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MESSAGE - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (STATUS - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (SYMBOLIC - 466)) or (1L shl (TASK - 466)) or (1L shl (TERMINAL - 466)) or (1L shl (TEXT - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER) {
				if (true){
				this.state = 2355
				errorHandler.sync(this)
				when (_input!!.LA(1)) {
				END , MESSAGE , STATUS , SYMBOLIC , TERMINAL , TEXT  ->  /*LL1AltBlock*/{if (true){
				this.state = 2352
				errorHandler.sync(this)
				when ( interpreter!!.adaptivePredict(_input!!,239,context) ) {
				1 -> {if (true){
				this.state = 2346
				messageDateClause()
				}}
				2 -> {if (true){
				this.state = 2347
				messageTimeClause()
				}}
				3 -> {if (true){
				this.state = 2348
				symbolicTerminalClause()
				}}
				4 -> {if (true){
				this.state = 2349
				textLengthClause()
				}}
				5 -> {if (true){
				this.state = 2350
				endKeyClause()
				}}
				6 -> {if (true){
				this.state = 2351
				statusKeyClause()
				}}
				}
				}}
				ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FILLER , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
				this.state = 2354
				dataDescName()
				}}
				else -> throw NoViableAltException(this)
				}
				}
				this.state = 2359
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 2360
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DestinationCountClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_destinationCountClause.id
	        set(value) { throw RuntimeException() }
		fun DESTINATION() : TerminalNode? = getToken(Cobol85Parser.Tokens.DESTINATION.id, 0)
		fun COUNT() : TerminalNode? = getToken(Cobol85Parser.Tokens.COUNT.id, 0)
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDestinationCountClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDestinationCountClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDestinationCountClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  destinationCountClause() : DestinationCountClauseContext {
		var _localctx : DestinationCountClauseContext = DestinationCountClauseContext(context, state)
		enterRule(_localctx, 226, Rules.RULE_destinationCountClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2362
			match(DESTINATION) as Token
			this.state = 2363
			match(COUNT) as Token
			this.state = 2365
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2364
				match(IS) as Token
				}
			}

			this.state = 2367
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DestinationTableClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_destinationTableClause.id
	        set(value) { throw RuntimeException() }
		fun DESTINATION() : TerminalNode? = getToken(Cobol85Parser.Tokens.DESTINATION.id, 0)
		fun TABLE() : TerminalNode? = getToken(Cobol85Parser.Tokens.TABLE.id, 0)
		fun OCCURS() : TerminalNode? = getToken(Cobol85Parser.Tokens.OCCURS.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun TIMES() : TerminalNode? = getToken(Cobol85Parser.Tokens.TIMES.id, 0)
		fun INDEXED() : TerminalNode? = getToken(Cobol85Parser.Tokens.INDEXED.id, 0)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun findIndexName() : List<IndexNameContext> = getRuleContexts(solver.getType("IndexNameContext"))
		fun findIndexName(i: Int) : IndexNameContext? = getRuleContext(solver.getType("IndexNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDestinationTableClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDestinationTableClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDestinationTableClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  destinationTableClause() : DestinationTableClauseContext {
		var _localctx : DestinationTableClauseContext = DestinationTableClauseContext(context, state)
		enterRule(_localctx, 228, Rules.RULE_destinationTableClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2369
			match(DESTINATION) as Token
			this.state = 2370
			match(TABLE) as Token
			this.state = 2371
			match(OCCURS) as Token
			this.state = 2372
			integerLiteral()
			this.state = 2373
			match(TIMES) as Token
			this.state = 2381
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==INDEXED) {
				if (true){
				this.state = 2374
				match(INDEXED) as Token
				this.state = 2375
				match(BY) as Token
				this.state = 2377 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				do {
					if (true){
					if (true){
					this.state = 2376
					indexName()
					}
					}
					this.state = 2379 
					errorHandler.sync(this)
					_la = _input!!.LA(1)
				} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EndKeyClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_endKeyClause.id
	        set(value) { throw RuntimeException() }
		fun END() : TerminalNode? = getToken(Cobol85Parser.Tokens.END.id, 0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEndKeyClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEndKeyClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEndKeyClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  endKeyClause() : EndKeyClauseContext {
		var _localctx : EndKeyClauseContext = EndKeyClauseContext(context, state)
		enterRule(_localctx, 230, Rules.RULE_endKeyClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2383
			match(END) as Token
			this.state = 2384
			match(KEY) as Token
			this.state = 2386
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2385
				match(IS) as Token
				}
			}

			this.state = 2388
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ErrorKeyClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_errorKeyClause.id
	        set(value) { throw RuntimeException() }
		fun ERROR() : TerminalNode? = getToken(Cobol85Parser.Tokens.ERROR.id, 0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterErrorKeyClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitErrorKeyClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitErrorKeyClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  errorKeyClause() : ErrorKeyClauseContext {
		var _localctx : ErrorKeyClauseContext = ErrorKeyClauseContext(context, state)
		enterRule(_localctx, 232, Rules.RULE_errorKeyClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2390
			match(ERROR) as Token
			this.state = 2391
			match(KEY) as Token
			this.state = 2393
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2392
				match(IS) as Token
				}
			}

			this.state = 2395
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MessageCountClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_messageCountClause.id
	        set(value) { throw RuntimeException() }
		fun COUNT() : TerminalNode? = getToken(Cobol85Parser.Tokens.COUNT.id, 0)
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun MESSAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.MESSAGE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMessageCountClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMessageCountClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMessageCountClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  messageCountClause() : MessageCountClauseContext {
		var _localctx : MessageCountClauseContext = MessageCountClauseContext(context, state)
		enterRule(_localctx, 234, Rules.RULE_messageCountClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2398
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==MESSAGE) {
				if (true){
				this.state = 2397
				match(MESSAGE) as Token
				}
			}

			this.state = 2400
			match(COUNT) as Token
			this.state = 2402
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2401
				match(IS) as Token
				}
			}

			this.state = 2404
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MessageDateClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_messageDateClause.id
	        set(value) { throw RuntimeException() }
		fun MESSAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.MESSAGE.id, 0)
		fun DATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DATE.id, 0)
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMessageDateClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMessageDateClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMessageDateClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  messageDateClause() : MessageDateClauseContext {
		var _localctx : MessageDateClauseContext = MessageDateClauseContext(context, state)
		enterRule(_localctx, 236, Rules.RULE_messageDateClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2406
			match(MESSAGE) as Token
			this.state = 2407
			match(DATE) as Token
			this.state = 2409
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2408
				match(IS) as Token
				}
			}

			this.state = 2411
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MessageTimeClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_messageTimeClause.id
	        set(value) { throw RuntimeException() }
		fun MESSAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.MESSAGE.id, 0)
		fun TIME() : TerminalNode? = getToken(Cobol85Parser.Tokens.TIME.id, 0)
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMessageTimeClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMessageTimeClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMessageTimeClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  messageTimeClause() : MessageTimeClauseContext {
		var _localctx : MessageTimeClauseContext = MessageTimeClauseContext(context, state)
		enterRule(_localctx, 238, Rules.RULE_messageTimeClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2413
			match(MESSAGE) as Token
			this.state = 2414
			match(TIME) as Token
			this.state = 2416
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2415
				match(IS) as Token
				}
			}

			this.state = 2418
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class StatusKeyClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_statusKeyClause.id
	        set(value) { throw RuntimeException() }
		fun STATUS() : TerminalNode? = getToken(Cobol85Parser.Tokens.STATUS.id, 0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStatusKeyClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStatusKeyClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStatusKeyClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  statusKeyClause() : StatusKeyClauseContext {
		var _localctx : StatusKeyClauseContext = StatusKeyClauseContext(context, state)
		enterRule(_localctx, 240, Rules.RULE_statusKeyClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2420
			match(STATUS) as Token
			this.state = 2421
			match(KEY) as Token
			this.state = 2423
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2422
				match(IS) as Token
				}
			}

			this.state = 2425
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SymbolicDestinationClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_symbolicDestinationClause.id
	        set(value) { throw RuntimeException() }
		fun DESTINATION() : TerminalNode? = getToken(Cobol85Parser.Tokens.DESTINATION.id, 0)
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun SYMBOLIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.SYMBOLIC.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSymbolicDestinationClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSymbolicDestinationClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSymbolicDestinationClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  symbolicDestinationClause() : SymbolicDestinationClauseContext {
		var _localctx : SymbolicDestinationClauseContext = SymbolicDestinationClauseContext(context, state)
		enterRule(_localctx, 242, Rules.RULE_symbolicDestinationClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2428
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SYMBOLIC) {
				if (true){
				this.state = 2427
				match(SYMBOLIC) as Token
				}
			}

			this.state = 2430
			match(DESTINATION) as Token
			this.state = 2432
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2431
				match(IS) as Token
				}
			}

			this.state = 2434
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SymbolicQueueClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_symbolicQueueClause.id
	        set(value) { throw RuntimeException() }
		fun QUEUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.QUEUE.id, 0)
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun SYMBOLIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.SYMBOLIC.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSymbolicQueueClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSymbolicQueueClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSymbolicQueueClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  symbolicQueueClause() : SymbolicQueueClauseContext {
		var _localctx : SymbolicQueueClauseContext = SymbolicQueueClauseContext(context, state)
		enterRule(_localctx, 244, Rules.RULE_symbolicQueueClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2437
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SYMBOLIC) {
				if (true){
				this.state = 2436
				match(SYMBOLIC) as Token
				}
			}

			this.state = 2439
			match(QUEUE) as Token
			this.state = 2441
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2440
				match(IS) as Token
				}
			}

			this.state = 2443
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SymbolicSourceClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_symbolicSourceClause.id
	        set(value) { throw RuntimeException() }
		fun SOURCE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SOURCE.id, 0)
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun SYMBOLIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.SYMBOLIC.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSymbolicSourceClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSymbolicSourceClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSymbolicSourceClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  symbolicSourceClause() : SymbolicSourceClauseContext {
		var _localctx : SymbolicSourceClauseContext = SymbolicSourceClauseContext(context, state)
		enterRule(_localctx, 246, Rules.RULE_symbolicSourceClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2446
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SYMBOLIC) {
				if (true){
				this.state = 2445
				match(SYMBOLIC) as Token
				}
			}

			this.state = 2448
			match(SOURCE) as Token
			this.state = 2450
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2449
				match(IS) as Token
				}
			}

			this.state = 2452
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SymbolicTerminalClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_symbolicTerminalClause.id
	        set(value) { throw RuntimeException() }
		fun TERMINAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.TERMINAL.id, 0)
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun SYMBOLIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.SYMBOLIC.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSymbolicTerminalClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSymbolicTerminalClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSymbolicTerminalClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  symbolicTerminalClause() : SymbolicTerminalClauseContext {
		var _localctx : SymbolicTerminalClauseContext = SymbolicTerminalClauseContext(context, state)
		enterRule(_localctx, 248, Rules.RULE_symbolicTerminalClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2455
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SYMBOLIC) {
				if (true){
				this.state = 2454
				match(SYMBOLIC) as Token
				}
			}

			this.state = 2457
			match(TERMINAL) as Token
			this.state = 2459
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2458
				match(IS) as Token
				}
			}

			this.state = 2461
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SymbolicSubQueueClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_symbolicSubQueueClause.id
	        set(value) { throw RuntimeException() }
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun SUB_QUEUE_1() : TerminalNode? = getToken(Cobol85Parser.Tokens.SUB_QUEUE_1.id, 0)
		fun SUB_QUEUE_2() : TerminalNode? = getToken(Cobol85Parser.Tokens.SUB_QUEUE_2.id, 0)
		fun SUB_QUEUE_3() : TerminalNode? = getToken(Cobol85Parser.Tokens.SUB_QUEUE_3.id, 0)
		fun SYMBOLIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.SYMBOLIC.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSymbolicSubQueueClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSymbolicSubQueueClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSymbolicSubQueueClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  symbolicSubQueueClause() : SymbolicSubQueueClauseContext {
		var _localctx : SymbolicSubQueueClauseContext = SymbolicSubQueueClauseContext(context, state)
		enterRule(_localctx, 250, Rules.RULE_symbolicSubQueueClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2464
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SYMBOLIC) {
				if (true){
				this.state = 2463
				match(SYMBOLIC) as Token
				}
			}

			this.state = 2466
			_la = _input!!.LA(1)
			if ( !(((((_la - 460)) and 0x3f.inv()) == 0 && ((1L shl (_la - 460)) and ((1L shl (SUB_QUEUE_1 - 460)) or (1L shl (SUB_QUEUE_2 - 460)) or (1L shl (SUB_QUEUE_3 - 460)))) != 0L)) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 2468
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2467
				match(IS) as Token
				}
			}

			this.state = 2470
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class TextLengthClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_textLengthClause.id
	        set(value) { throw RuntimeException() }
		fun TEXT() : TerminalNode? = getToken(Cobol85Parser.Tokens.TEXT.id, 0)
		fun LENGTH() : TerminalNode? = getToken(Cobol85Parser.Tokens.LENGTH.id, 0)
		fun findDataDescName() : DataDescNameContext? = getRuleContext(solver.getType("DataDescNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterTextLengthClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitTextLengthClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitTextLengthClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  textLengthClause() : TextLengthClauseContext {
		var _localctx : TextLengthClauseContext = TextLengthClauseContext(context, state)
		enterRule(_localctx, 252, Rules.RULE_textLengthClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2472
			match(TEXT) as Token
			this.state = 2473
			match(LENGTH) as Token
			this.state = 2475
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2474
				match(IS) as Token
				}
			}

			this.state = 2477
			dataDescName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LocalStorageSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_localStorageSection.id
	        set(value) { throw RuntimeException() }
		fun LOCAL_STORAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOCAL_STORAGE.id, 0)
		fun SECTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECTION.id, 0)
		fun DOT_FS() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.DOT_FS.id)
		fun DOT_FS(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.DOT_FS.id, i) as TerminalNode
		fun LD() : TerminalNode? = getToken(Cobol85Parser.Tokens.LD.id, 0)
		fun findLocalName() : LocalNameContext? = getRuleContext(solver.getType("LocalNameContext"),0)
		fun findDataDescriptionEntry() : List<DataDescriptionEntryContext> = getRuleContexts(solver.getType("DataDescriptionEntryContext"))
		fun findDataDescriptionEntry(i: Int) : DataDescriptionEntryContext? = getRuleContext(solver.getType("DataDescriptionEntryContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLocalStorageSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLocalStorageSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLocalStorageSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  localStorageSection() : LocalStorageSectionContext {
		var _localctx : LocalStorageSectionContext = LocalStorageSectionContext(context, state)
		enterRule(_localctx, 254, Rules.RULE_localStorageSection.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2479
			match(LOCAL_STORAGE) as Token
			this.state = 2480
			match(SECTION) as Token
			this.state = 2481
			match(DOT_FS) as Token
			this.state = 2486
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LD) {
				if (true){
				this.state = 2482
				match(LD) as Token
				this.state = 2483
				localName()
				this.state = 2484
				match(DOT_FS) as Token
				}
			}

			this.state = 2491
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (EXECSQLLINE - 552)))) != 0L)) {
				if (true){
				if (true){
				this.state = 2488
				dataDescriptionEntry()
				}
				}
				this.state = 2493
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenSection.id
	        set(value) { throw RuntimeException() }
		fun SCREEN() : TerminalNode? = getToken(Cobol85Parser.Tokens.SCREEN.id, 0)
		fun SECTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECTION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findScreenDescriptionEntry() : List<ScreenDescriptionEntryContext> = getRuleContexts(solver.getType("ScreenDescriptionEntryContext"))
		fun findScreenDescriptionEntry(i: Int) : ScreenDescriptionEntryContext? = getRuleContext(solver.getType("ScreenDescriptionEntryContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenSection() : ScreenSectionContext {
		var _localctx : ScreenSectionContext = ScreenSectionContext(context, state)
		enterRule(_localctx, 256, Rules.RULE_screenSection.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2494
			match(SCREEN) as Token
			this.state = 2495
			match(SECTION) as Token
			this.state = 2496
			match(DOT_FS) as Token
			this.state = 2500
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==INTEGERLITERAL) {
				if (true){
				if (true){
				this.state = 2497
				screenDescriptionEntry()
				}
				}
				this.state = 2502
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionEntryContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionEntry.id
	        set(value) { throw RuntimeException() }
		fun INTEGERLITERAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTEGERLITERAL.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun FILLER() : TerminalNode? = getToken(Cobol85Parser.Tokens.FILLER.id, 0)
		fun findScreenName() : ScreenNameContext? = getRuleContext(solver.getType("ScreenNameContext"),0)
		fun findScreenDescriptionBlankClause() : List<ScreenDescriptionBlankClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionBlankClauseContext"))
		fun findScreenDescriptionBlankClause(i: Int) : ScreenDescriptionBlankClauseContext? = getRuleContext(solver.getType("ScreenDescriptionBlankClauseContext"),i)
		fun findScreenDescriptionBellClause() : List<ScreenDescriptionBellClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionBellClauseContext"))
		fun findScreenDescriptionBellClause(i: Int) : ScreenDescriptionBellClauseContext? = getRuleContext(solver.getType("ScreenDescriptionBellClauseContext"),i)
		fun findScreenDescriptionBlinkClause() : List<ScreenDescriptionBlinkClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionBlinkClauseContext"))
		fun findScreenDescriptionBlinkClause(i: Int) : ScreenDescriptionBlinkClauseContext? = getRuleContext(solver.getType("ScreenDescriptionBlinkClauseContext"),i)
		fun findScreenDescriptionEraseClause() : List<ScreenDescriptionEraseClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionEraseClauseContext"))
		fun findScreenDescriptionEraseClause(i: Int) : ScreenDescriptionEraseClauseContext? = getRuleContext(solver.getType("ScreenDescriptionEraseClauseContext"),i)
		fun findScreenDescriptionLightClause() : List<ScreenDescriptionLightClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionLightClauseContext"))
		fun findScreenDescriptionLightClause(i: Int) : ScreenDescriptionLightClauseContext? = getRuleContext(solver.getType("ScreenDescriptionLightClauseContext"),i)
		fun findScreenDescriptionGridClause() : List<ScreenDescriptionGridClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionGridClauseContext"))
		fun findScreenDescriptionGridClause(i: Int) : ScreenDescriptionGridClauseContext? = getRuleContext(solver.getType("ScreenDescriptionGridClauseContext"),i)
		fun findScreenDescriptionReverseVideoClause() : List<ScreenDescriptionReverseVideoClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionReverseVideoClauseContext"))
		fun findScreenDescriptionReverseVideoClause(i: Int) : ScreenDescriptionReverseVideoClauseContext? = getRuleContext(solver.getType("ScreenDescriptionReverseVideoClauseContext"),i)
		fun findScreenDescriptionUnderlineClause() : List<ScreenDescriptionUnderlineClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionUnderlineClauseContext"))
		fun findScreenDescriptionUnderlineClause(i: Int) : ScreenDescriptionUnderlineClauseContext? = getRuleContext(solver.getType("ScreenDescriptionUnderlineClauseContext"),i)
		fun findScreenDescriptionSizeClause() : List<ScreenDescriptionSizeClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionSizeClauseContext"))
		fun findScreenDescriptionSizeClause(i: Int) : ScreenDescriptionSizeClauseContext? = getRuleContext(solver.getType("ScreenDescriptionSizeClauseContext"),i)
		fun findScreenDescriptionLineClause() : List<ScreenDescriptionLineClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionLineClauseContext"))
		fun findScreenDescriptionLineClause(i: Int) : ScreenDescriptionLineClauseContext? = getRuleContext(solver.getType("ScreenDescriptionLineClauseContext"),i)
		fun findScreenDescriptionColumnClause() : List<ScreenDescriptionColumnClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionColumnClauseContext"))
		fun findScreenDescriptionColumnClause(i: Int) : ScreenDescriptionColumnClauseContext? = getRuleContext(solver.getType("ScreenDescriptionColumnClauseContext"),i)
		fun findScreenDescriptionForegroundColorClause() : List<ScreenDescriptionForegroundColorClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionForegroundColorClauseContext"))
		fun findScreenDescriptionForegroundColorClause(i: Int) : ScreenDescriptionForegroundColorClauseContext? = getRuleContext(solver.getType("ScreenDescriptionForegroundColorClauseContext"),i)
		fun findScreenDescriptionBackgroundColorClause() : List<ScreenDescriptionBackgroundColorClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionBackgroundColorClauseContext"))
		fun findScreenDescriptionBackgroundColorClause(i: Int) : ScreenDescriptionBackgroundColorClauseContext? = getRuleContext(solver.getType("ScreenDescriptionBackgroundColorClauseContext"),i)
		fun findScreenDescriptionControlClause() : List<ScreenDescriptionControlClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionControlClauseContext"))
		fun findScreenDescriptionControlClause(i: Int) : ScreenDescriptionControlClauseContext? = getRuleContext(solver.getType("ScreenDescriptionControlClauseContext"),i)
		fun findScreenDescriptionValueClause() : List<ScreenDescriptionValueClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionValueClauseContext"))
		fun findScreenDescriptionValueClause(i: Int) : ScreenDescriptionValueClauseContext? = getRuleContext(solver.getType("ScreenDescriptionValueClauseContext"),i)
		fun findScreenDescriptionPictureClause() : List<ScreenDescriptionPictureClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionPictureClauseContext"))
		fun findScreenDescriptionPictureClause(i: Int) : ScreenDescriptionPictureClauseContext? = getRuleContext(solver.getType("ScreenDescriptionPictureClauseContext"),i)
		fun findScreenDescriptionUsageClause() : List<ScreenDescriptionUsageClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionUsageClauseContext"))
		fun findScreenDescriptionUsageClause(i: Int) : ScreenDescriptionUsageClauseContext? = getRuleContext(solver.getType("ScreenDescriptionUsageClauseContext"),i)
		fun findScreenDescriptionBlankWhenZeroClause() : List<ScreenDescriptionBlankWhenZeroClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionBlankWhenZeroClauseContext"))
		fun findScreenDescriptionBlankWhenZeroClause(i: Int) : ScreenDescriptionBlankWhenZeroClauseContext? = getRuleContext(solver.getType("ScreenDescriptionBlankWhenZeroClauseContext"),i)
		fun findScreenDescriptionJustifiedClause() : List<ScreenDescriptionJustifiedClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionJustifiedClauseContext"))
		fun findScreenDescriptionJustifiedClause(i: Int) : ScreenDescriptionJustifiedClauseContext? = getRuleContext(solver.getType("ScreenDescriptionJustifiedClauseContext"),i)
		fun findScreenDescriptionSignClause() : List<ScreenDescriptionSignClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionSignClauseContext"))
		fun findScreenDescriptionSignClause(i: Int) : ScreenDescriptionSignClauseContext? = getRuleContext(solver.getType("ScreenDescriptionSignClauseContext"),i)
		fun findScreenDescriptionAutoClause() : List<ScreenDescriptionAutoClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionAutoClauseContext"))
		fun findScreenDescriptionAutoClause(i: Int) : ScreenDescriptionAutoClauseContext? = getRuleContext(solver.getType("ScreenDescriptionAutoClauseContext"),i)
		fun findScreenDescriptionSecureClause() : List<ScreenDescriptionSecureClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionSecureClauseContext"))
		fun findScreenDescriptionSecureClause(i: Int) : ScreenDescriptionSecureClauseContext? = getRuleContext(solver.getType("ScreenDescriptionSecureClauseContext"),i)
		fun findScreenDescriptionRequiredClause() : List<ScreenDescriptionRequiredClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionRequiredClauseContext"))
		fun findScreenDescriptionRequiredClause(i: Int) : ScreenDescriptionRequiredClauseContext? = getRuleContext(solver.getType("ScreenDescriptionRequiredClauseContext"),i)
		fun findScreenDescriptionPromptClause() : List<ScreenDescriptionPromptClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionPromptClauseContext"))
		fun findScreenDescriptionPromptClause(i: Int) : ScreenDescriptionPromptClauseContext? = getRuleContext(solver.getType("ScreenDescriptionPromptClauseContext"),i)
		fun findScreenDescriptionFullClause() : List<ScreenDescriptionFullClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionFullClauseContext"))
		fun findScreenDescriptionFullClause(i: Int) : ScreenDescriptionFullClauseContext? = getRuleContext(solver.getType("ScreenDescriptionFullClauseContext"),i)
		fun findScreenDescriptionZeroFillClause() : List<ScreenDescriptionZeroFillClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionZeroFillClauseContext"))
		fun findScreenDescriptionZeroFillClause(i: Int) : ScreenDescriptionZeroFillClauseContext? = getRuleContext(solver.getType("ScreenDescriptionZeroFillClauseContext"),i)
		fun findScreenDescriptionFromClause() : List<ScreenDescriptionFromClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionFromClauseContext"))
		fun findScreenDescriptionFromClause(i: Int) : ScreenDescriptionFromClauseContext? = getRuleContext(solver.getType("ScreenDescriptionFromClauseContext"),i)
		fun findScreenDescriptionUsingClause() : List<ScreenDescriptionUsingClauseContext> = getRuleContexts(solver.getType("ScreenDescriptionUsingClauseContext"))
		fun findScreenDescriptionUsingClause(i: Int) : ScreenDescriptionUsingClauseContext? = getRuleContext(solver.getType("ScreenDescriptionUsingClauseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionEntry(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionEntry(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionEntry(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionEntry() : ScreenDescriptionEntryContext {
		var _localctx : ScreenDescriptionEntryContext = ScreenDescriptionEntryContext(context, state)
		enterRule(_localctx, 258, Rules.RULE_screenDescriptionEntry.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2503
			match(INTEGERLITERAL) as Token
			this.state = 2506
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,266,context) ) {
			1   -> if (true){
			this.state = 2504
			match(FILLER) as Token
			}
			2   -> if (true){
			this.state = 2505
			screenName()
			}
			}
			this.state = 2540
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (((((_la - 33)) and 0x3f.inv()) == 0 && ((1L shl (_la - 33)) and ((1L shl (AUTO - 33)) or (1L shl (AUTO_SKIP - 33)) or (1L shl (BACKGROUND_COLOR - 33)) or (1L shl (BACKGROUND_COLOUR - 33)) or (1L shl (BEEP - 33)) or (1L shl (BELL - 33)) or (1L shl (BLANK - 33)) or (1L shl (BLINK - 33)) or (1L shl (COL - 33)) or (1L shl (COLUMN - 33)))) != 0L) || _la==CONTROL || _la==EMPTY_CHECK || ((((_la - 187)) and 0x3f.inv()) == 0 && ((1L shl (_la - 187)) and ((1L shl (ERASE - 187)) or (1L shl (FOREGROUND_COLOR - 187)) or (1L shl (FOREGROUND_COLOUR - 187)) or (1L shl (FROM - 187)) or (1L shl (FULL - 187)) or (1L shl (GRID - 187)) or (1L shl (HIGHLIGHT - 187)))) != 0L) || ((((_la - 255)) and 0x3f.inv()) == 0 && ((1L shl (_la - 255)) and ((1L shl (JUST - 255)) or (1L shl (JUSTIFIED - 255)) or (1L shl (LEADING - 255)) or (1L shl (LEFTLINE - 255)) or (1L shl (LENGTH_CHECK - 255)) or (1L shl (LINE - 255)) or (1L shl (LOWLIGHT - 255)) or (1L shl (NO_ECHO - 255)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (PIC - 336)) or (1L shl (PICTURE - 336)) or (1L shl (PROMPT - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SECURE - 401)) or (1L shl (SIGN - 401)) or (1L shl (SIZE - 401)))) != 0L) || ((((_la - 493)) and 0x3f.inv()) == 0 && ((1L shl (_la - 493)) and ((1L shl (TRAILING - 493)) or (1L shl (UNDERLINE - 493)) or (1L shl (USAGE - 493)) or (1L shl (USING - 493)) or (1L shl (VALUE - 493)) or (1L shl (ZERO_FILL - 493)))) != 0L)) {
				if (true){
				this.state = 2538
				errorHandler.sync(this)
				when ( interpreter!!.adaptivePredict(_input!!,268,context) ) {
				1 -> {if (true){
				this.state = 2508
				screenDescriptionBlankClause()
				}}
				2 -> {if (true){
				this.state = 2509
				screenDescriptionBellClause()
				}}
				3 -> {if (true){
				this.state = 2510
				screenDescriptionBlinkClause()
				}}
				4 -> {if (true){
				this.state = 2511
				screenDescriptionEraseClause()
				}}
				5 -> {if (true){
				this.state = 2512
				screenDescriptionLightClause()
				}}
				6 -> {if (true){
				this.state = 2513
				screenDescriptionGridClause()
				}}
				7 -> {if (true){
				this.state = 2514
				screenDescriptionReverseVideoClause()
				}}
				8 -> {if (true){
				this.state = 2515
				screenDescriptionUnderlineClause()
				}}
				9 -> {if (true){
				this.state = 2516
				screenDescriptionSizeClause()
				}}
				10 -> {if (true){
				this.state = 2517
				screenDescriptionLineClause()
				}}
				11 -> {if (true){
				this.state = 2518
				screenDescriptionColumnClause()
				}}
				12 -> {if (true){
				this.state = 2519
				screenDescriptionForegroundColorClause()
				}}
				13 -> {if (true){
				this.state = 2520
				screenDescriptionBackgroundColorClause()
				}}
				14 -> {if (true){
				this.state = 2521
				screenDescriptionControlClause()
				}}
				15 -> {if (true){
				this.state = 2522
				screenDescriptionValueClause()
				}}
				16 -> {if (true){
				this.state = 2523
				screenDescriptionPictureClause()
				}}
				17 -> {if (true){
				this.state = 2526
				errorHandler.sync(this)
				when (_input!!.LA(1)) {
				FROM  ->  /*LL1AltBlock*/{if (true){
				this.state = 2524
				screenDescriptionFromClause()
				}}
				USING  ->  /*LL1AltBlock*/{if (true){
				this.state = 2525
				screenDescriptionUsingClause()
				}}
				else -> throw NoViableAltException(this)
				}
				}}
				18 -> {if (true){
				this.state = 2528
				screenDescriptionUsageClause()
				}}
				19 -> {if (true){
				this.state = 2529
				screenDescriptionBlankWhenZeroClause()
				}}
				20 -> {if (true){
				this.state = 2530
				screenDescriptionJustifiedClause()
				}}
				21 -> {if (true){
				this.state = 2531
				screenDescriptionSignClause()
				}}
				22 -> {if (true){
				this.state = 2532
				screenDescriptionAutoClause()
				}}
				23 -> {if (true){
				this.state = 2533
				screenDescriptionSecureClause()
				}}
				24 -> {if (true){
				this.state = 2534
				screenDescriptionRequiredClause()
				}}
				25 -> {if (true){
				this.state = 2535
				screenDescriptionPromptClause()
				}}
				26 -> {if (true){
				this.state = 2536
				screenDescriptionFullClause()
				}}
				27 -> {if (true){
				this.state = 2537
				screenDescriptionZeroFillClause()
				}}
				}
				}
				this.state = 2542
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 2543
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionBlankClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionBlankClause.id
	        set(value) { throw RuntimeException() }
		fun BLANK() : TerminalNode? = getToken(Cobol85Parser.Tokens.BLANK.id, 0)
		fun SCREEN() : TerminalNode? = getToken(Cobol85Parser.Tokens.SCREEN.id, 0)
		fun LINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionBlankClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionBlankClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionBlankClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionBlankClause() : ScreenDescriptionBlankClauseContext {
		var _localctx : ScreenDescriptionBlankClauseContext = ScreenDescriptionBlankClauseContext(context, state)
		enterRule(_localctx, 260, Rules.RULE_screenDescriptionBlankClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2545
			match(BLANK) as Token
			this.state = 2546
			_la = _input!!.LA(1)
			if ( !(_la==LINE || _la==SCREEN) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionBellClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionBellClause.id
	        set(value) { throw RuntimeException() }
		fun BELL() : TerminalNode? = getToken(Cobol85Parser.Tokens.BELL.id, 0)
		fun BEEP() : TerminalNode? = getToken(Cobol85Parser.Tokens.BEEP.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionBellClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionBellClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionBellClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionBellClause() : ScreenDescriptionBellClauseContext {
		var _localctx : ScreenDescriptionBellClauseContext = ScreenDescriptionBellClauseContext(context, state)
		enterRule(_localctx, 262, Rules.RULE_screenDescriptionBellClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2548
			_la = _input!!.LA(1)
			if ( !(_la==BEEP || _la==BELL) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionBlinkClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionBlinkClause.id
	        set(value) { throw RuntimeException() }
		fun BLINK() : TerminalNode? = getToken(Cobol85Parser.Tokens.BLINK.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionBlinkClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionBlinkClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionBlinkClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionBlinkClause() : ScreenDescriptionBlinkClauseContext {
		var _localctx : ScreenDescriptionBlinkClauseContext = ScreenDescriptionBlinkClauseContext(context, state)
		enterRule(_localctx, 264, Rules.RULE_screenDescriptionBlinkClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2550
			match(BLINK) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionEraseClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionEraseClause.id
	        set(value) { throw RuntimeException() }
		fun ERASE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ERASE.id, 0)
		fun EOL() : TerminalNode? = getToken(Cobol85Parser.Tokens.EOL.id, 0)
		fun EOS() : TerminalNode? = getToken(Cobol85Parser.Tokens.EOS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionEraseClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionEraseClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionEraseClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionEraseClause() : ScreenDescriptionEraseClauseContext {
		var _localctx : ScreenDescriptionEraseClauseContext = ScreenDescriptionEraseClauseContext(context, state)
		enterRule(_localctx, 266, Rules.RULE_screenDescriptionEraseClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2552
			match(ERASE) as Token
			this.state = 2553
			_la = _input!!.LA(1)
			if ( !(_la==EOL || _la==EOS) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionLightClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionLightClause.id
	        set(value) { throw RuntimeException() }
		fun HIGHLIGHT() : TerminalNode? = getToken(Cobol85Parser.Tokens.HIGHLIGHT.id, 0)
		fun LOWLIGHT() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOWLIGHT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionLightClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionLightClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionLightClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionLightClause() : ScreenDescriptionLightClauseContext {
		var _localctx : ScreenDescriptionLightClauseContext = ScreenDescriptionLightClauseContext(context, state)
		enterRule(_localctx, 268, Rules.RULE_screenDescriptionLightClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2555
			_la = _input!!.LA(1)
			if ( !(_la==HIGHLIGHT || _la==LOWLIGHT) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionGridClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionGridClause.id
	        set(value) { throw RuntimeException() }
		fun GRID() : TerminalNode? = getToken(Cobol85Parser.Tokens.GRID.id, 0)
		fun LEFTLINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEFTLINE.id, 0)
		fun OVERLINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.OVERLINE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionGridClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionGridClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionGridClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionGridClause() : ScreenDescriptionGridClauseContext {
		var _localctx : ScreenDescriptionGridClauseContext = ScreenDescriptionGridClauseContext(context, state)
		enterRule(_localctx, 270, Rules.RULE_screenDescriptionGridClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2557
			_la = _input!!.LA(1)
			if ( !(_la==GRID || _la==LEFTLINE || _la==OVERLINE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionReverseVideoClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionReverseVideoClause.id
	        set(value) { throw RuntimeException() }
		fun REVERSE_VIDEO() : TerminalNode? = getToken(Cobol85Parser.Tokens.REVERSE_VIDEO.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionReverseVideoClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionReverseVideoClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionReverseVideoClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionReverseVideoClause() : ScreenDescriptionReverseVideoClauseContext {
		var _localctx : ScreenDescriptionReverseVideoClauseContext = ScreenDescriptionReverseVideoClauseContext(context, state)
		enterRule(_localctx, 272, Rules.RULE_screenDescriptionReverseVideoClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2559
			match(REVERSE_VIDEO) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionUnderlineClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionUnderlineClause.id
	        set(value) { throw RuntimeException() }
		fun UNDERLINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.UNDERLINE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionUnderlineClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionUnderlineClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionUnderlineClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionUnderlineClause() : ScreenDescriptionUnderlineClauseContext {
		var _localctx : ScreenDescriptionUnderlineClauseContext = ScreenDescriptionUnderlineClauseContext(context, state)
		enterRule(_localctx, 274, Rules.RULE_screenDescriptionUnderlineClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2561
			match(UNDERLINE) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionSizeClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionSizeClause.id
	        set(value) { throw RuntimeException() }
		fun SIZE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIZE.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionSizeClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionSizeClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionSizeClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionSizeClause() : ScreenDescriptionSizeClauseContext {
		var _localctx : ScreenDescriptionSizeClauseContext = ScreenDescriptionSizeClauseContext(context, state)
		enterRule(_localctx, 276, Rules.RULE_screenDescriptionSizeClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2563
			match(SIZE) as Token
			this.state = 2565
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2564
				match(IS) as Token
				}
			}

			this.state = 2569
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,271,context) ) {
			1 -> {if (true){
			this.state = 2567
			identifier()
			}}
			2 -> {if (true){
			this.state = 2568
			integerLiteral()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionLineClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionLineClause.id
	        set(value) { throw RuntimeException() }
		fun LINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINE.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun PLUS() : TerminalNode? = getToken(Cobol85Parser.Tokens.PLUS.id, 0)
		fun PLUSCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.PLUSCHAR.id, 0)
		fun MINUSCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.MINUSCHAR.id, 0)
		fun NUMBER() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMBER.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionLineClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionLineClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionLineClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionLineClause() : ScreenDescriptionLineClauseContext {
		var _localctx : ScreenDescriptionLineClauseContext = ScreenDescriptionLineClauseContext(context, state)
		enterRule(_localctx, 278, Rules.RULE_screenDescriptionLineClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2571
			match(LINE) as Token
			this.state = 2579
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS || _la==NUMBER || _la==PLUS || _la==MINUSCHAR || _la==PLUSCHAR) {
				if (true){
				this.state = 2573
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==NUMBER) {
					if (true){
					this.state = 2572
					match(NUMBER) as Token
					}
				}

				this.state = 2576
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 2575
					match(IS) as Token
					}
				}

				this.state = 2578
				_la = _input!!.LA(1)
				if ( !(_la==PLUS || _la==MINUSCHAR || _la==PLUSCHAR) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			this.state = 2583
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,275,context) ) {
			1 -> {if (true){
			this.state = 2581
			identifier()
			}}
			2 -> {if (true){
			this.state = 2582
			integerLiteral()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionColumnClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionColumnClause.id
	        set(value) { throw RuntimeException() }
		fun COLUMN() : TerminalNode? = getToken(Cobol85Parser.Tokens.COLUMN.id, 0)
		fun COL() : TerminalNode? = getToken(Cobol85Parser.Tokens.COL.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun PLUS() : TerminalNode? = getToken(Cobol85Parser.Tokens.PLUS.id, 0)
		fun PLUSCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.PLUSCHAR.id, 0)
		fun MINUSCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.MINUSCHAR.id, 0)
		fun NUMBER() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMBER.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionColumnClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionColumnClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionColumnClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionColumnClause() : ScreenDescriptionColumnClauseContext {
		var _localctx : ScreenDescriptionColumnClauseContext = ScreenDescriptionColumnClauseContext(context, state)
		enterRule(_localctx, 280, Rules.RULE_screenDescriptionColumnClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2585
			_la = _input!!.LA(1)
			if ( !(_la==COL || _la==COLUMN) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 2593
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS || _la==NUMBER || _la==PLUS || _la==MINUSCHAR || _la==PLUSCHAR) {
				if (true){
				this.state = 2587
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==NUMBER) {
					if (true){
					this.state = 2586
					match(NUMBER) as Token
					}
				}

				this.state = 2590
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 2589
					match(IS) as Token
					}
				}

				this.state = 2592
				_la = _input!!.LA(1)
				if ( !(_la==PLUS || _la==MINUSCHAR || _la==PLUSCHAR) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			this.state = 2597
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,279,context) ) {
			1 -> {if (true){
			this.state = 2595
			identifier()
			}}
			2 -> {if (true){
			this.state = 2596
			integerLiteral()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionForegroundColorClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionForegroundColorClause.id
	        set(value) { throw RuntimeException() }
		fun FOREGROUND_COLOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOREGROUND_COLOR.id, 0)
		fun FOREGROUND_COLOUR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOREGROUND_COLOUR.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionForegroundColorClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionForegroundColorClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionForegroundColorClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionForegroundColorClause() : ScreenDescriptionForegroundColorClauseContext {
		var _localctx : ScreenDescriptionForegroundColorClauseContext = ScreenDescriptionForegroundColorClauseContext(context, state)
		enterRule(_localctx, 282, Rules.RULE_screenDescriptionForegroundColorClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2599
			_la = _input!!.LA(1)
			if ( !(_la==FOREGROUND_COLOR || _la==FOREGROUND_COLOUR) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 2601
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2600
				match(IS) as Token
				}
			}

			this.state = 2605
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,281,context) ) {
			1 -> {if (true){
			this.state = 2603
			identifier()
			}}
			2 -> {if (true){
			this.state = 2604
			integerLiteral()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionBackgroundColorClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionBackgroundColorClause.id
	        set(value) { throw RuntimeException() }
		fun BACKGROUND_COLOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.BACKGROUND_COLOR.id, 0)
		fun BACKGROUND_COLOUR() : TerminalNode? = getToken(Cobol85Parser.Tokens.BACKGROUND_COLOUR.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionBackgroundColorClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionBackgroundColorClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionBackgroundColorClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionBackgroundColorClause() : ScreenDescriptionBackgroundColorClauseContext {
		var _localctx : ScreenDescriptionBackgroundColorClauseContext = ScreenDescriptionBackgroundColorClauseContext(context, state)
		enterRule(_localctx, 284, Rules.RULE_screenDescriptionBackgroundColorClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2607
			_la = _input!!.LA(1)
			if ( !(_la==BACKGROUND_COLOR || _la==BACKGROUND_COLOUR) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 2609
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2608
				match(IS) as Token
				}
			}

			this.state = 2613
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,283,context) ) {
			1 -> {if (true){
			this.state = 2611
			identifier()
			}}
			2 -> {if (true){
			this.state = 2612
			integerLiteral()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionControlClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionControlClause.id
	        set(value) { throw RuntimeException() }
		fun CONTROL() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTROL.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionControlClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionControlClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionControlClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionControlClause() : ScreenDescriptionControlClauseContext {
		var _localctx : ScreenDescriptionControlClauseContext = ScreenDescriptionControlClauseContext(context, state)
		enterRule(_localctx, 286, Rules.RULE_screenDescriptionControlClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2615
			match(CONTROL) as Token
			this.state = 2617
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2616
				match(IS) as Token
				}
			}

			this.state = 2619
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionValueClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionValueClause.id
	        set(value) { throw RuntimeException() }
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun VALUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.VALUE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionValueClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionValueClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionValueClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionValueClause() : ScreenDescriptionValueClauseContext {
		var _localctx : ScreenDescriptionValueClauseContext = ScreenDescriptionValueClauseContext(context, state)
		enterRule(_localctx, 288, Rules.RULE_screenDescriptionValueClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			if (true){
			this.state = 2621
			match(VALUE) as Token
			this.state = 2623
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2622
				match(IS) as Token
				}
			}

			}
			this.state = 2625
			literal()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionPictureClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionPictureClause.id
	        set(value) { throw RuntimeException() }
		fun findPictureString() : PictureStringContext? = getRuleContext(solver.getType("PictureStringContext"),0)
		fun PICTURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PICTURE.id, 0)
		fun PIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.PIC.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionPictureClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionPictureClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionPictureClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionPictureClause() : ScreenDescriptionPictureClauseContext {
		var _localctx : ScreenDescriptionPictureClauseContext = ScreenDescriptionPictureClauseContext(context, state)
		enterRule(_localctx, 290, Rules.RULE_screenDescriptionPictureClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2627
			_la = _input!!.LA(1)
			if ( !(_la==PIC || _la==PICTURE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 2629
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2628
				match(IS) as Token
				}
			}

			this.state = 2631
			pictureString()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionFromClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionFromClause.id
	        set(value) { throw RuntimeException() }
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findScreenDescriptionToClause() : ScreenDescriptionToClauseContext? = getRuleContext(solver.getType("ScreenDescriptionToClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionFromClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionFromClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionFromClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionFromClause() : ScreenDescriptionFromClauseContext {
		var _localctx : ScreenDescriptionFromClauseContext = ScreenDescriptionFromClauseContext(context, state)
		enterRule(_localctx, 292, Rules.RULE_screenDescriptionFromClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2633
			match(FROM) as Token
			this.state = 2636
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,287,context) ) {
			1 -> {if (true){
			this.state = 2634
			identifier()
			}}
			2 -> {if (true){
			this.state = 2635
			literal()
			}}
			}
			this.state = 2639
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TO) {
				if (true){
				this.state = 2638
				screenDescriptionToClause()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionToClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionToClause.id
	        set(value) { throw RuntimeException() }
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionToClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionToClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionToClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionToClause() : ScreenDescriptionToClauseContext {
		var _localctx : ScreenDescriptionToClauseContext = ScreenDescriptionToClauseContext(context, state)
		enterRule(_localctx, 294, Rules.RULE_screenDescriptionToClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2641
			match(TO) as Token
			this.state = 2642
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionUsingClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionUsingClause.id
	        set(value) { throw RuntimeException() }
		fun USING() : TerminalNode? = getToken(Cobol85Parser.Tokens.USING.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionUsingClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionUsingClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionUsingClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionUsingClause() : ScreenDescriptionUsingClauseContext {
		var _localctx : ScreenDescriptionUsingClauseContext = ScreenDescriptionUsingClauseContext(context, state)
		enterRule(_localctx, 296, Rules.RULE_screenDescriptionUsingClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2644
			match(USING) as Token
			this.state = 2645
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionUsageClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionUsageClause.id
	        set(value) { throw RuntimeException() }
		fun DISPLAY() : TerminalNode? = getToken(Cobol85Parser.Tokens.DISPLAY.id, 0)
		fun DISPLAY_1() : TerminalNode? = getToken(Cobol85Parser.Tokens.DISPLAY_1.id, 0)
		fun USAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.USAGE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionUsageClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionUsageClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionUsageClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionUsageClause() : ScreenDescriptionUsageClauseContext {
		var _localctx : ScreenDescriptionUsageClauseContext = ScreenDescriptionUsageClauseContext(context, state)
		enterRule(_localctx, 298, Rules.RULE_screenDescriptionUsageClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			if (true){
			this.state = 2647
			match(USAGE) as Token
			this.state = 2649
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2648
				match(IS) as Token
				}
			}

			}
			this.state = 2651
			_la = _input!!.LA(1)
			if ( !(_la==DISPLAY || _la==DISPLAY_1) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionBlankWhenZeroClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionBlankWhenZeroClause.id
	        set(value) { throw RuntimeException() }
		fun BLANK() : TerminalNode? = getToken(Cobol85Parser.Tokens.BLANK.id, 0)
		fun ZERO() : TerminalNode? = getToken(Cobol85Parser.Tokens.ZERO.id, 0)
		fun WHEN() : TerminalNode? = getToken(Cobol85Parser.Tokens.WHEN.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionBlankWhenZeroClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionBlankWhenZeroClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionBlankWhenZeroClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionBlankWhenZeroClause() : ScreenDescriptionBlankWhenZeroClauseContext {
		var _localctx : ScreenDescriptionBlankWhenZeroClauseContext = ScreenDescriptionBlankWhenZeroClauseContext(context, state)
		enterRule(_localctx, 300, Rules.RULE_screenDescriptionBlankWhenZeroClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2653
			match(BLANK) as Token
			this.state = 2655
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WHEN) {
				if (true){
				this.state = 2654
				match(WHEN) as Token
				}
			}

			this.state = 2657
			match(ZERO) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionJustifiedClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionJustifiedClause.id
	        set(value) { throw RuntimeException() }
		fun JUSTIFIED() : TerminalNode? = getToken(Cobol85Parser.Tokens.JUSTIFIED.id, 0)
		fun JUST() : TerminalNode? = getToken(Cobol85Parser.Tokens.JUST.id, 0)
		fun RIGHT() : TerminalNode? = getToken(Cobol85Parser.Tokens.RIGHT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionJustifiedClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionJustifiedClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionJustifiedClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionJustifiedClause() : ScreenDescriptionJustifiedClauseContext {
		var _localctx : ScreenDescriptionJustifiedClauseContext = ScreenDescriptionJustifiedClauseContext(context, state)
		enterRule(_localctx, 302, Rules.RULE_screenDescriptionJustifiedClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2659
			_la = _input!!.LA(1)
			if ( !(_la==JUST || _la==JUSTIFIED) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 2661
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==RIGHT) {
				if (true){
				this.state = 2660
				match(RIGHT) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionSignClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionSignClause.id
	        set(value) { throw RuntimeException() }
		fun LEADING() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEADING.id, 0)
		fun TRAILING() : TerminalNode? = getToken(Cobol85Parser.Tokens.TRAILING.id, 0)
		fun SIGN() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIGN.id, 0)
		fun SEPARATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEPARATE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun CHARACTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTER.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionSignClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionSignClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionSignClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionSignClause() : ScreenDescriptionSignClauseContext {
		var _localctx : ScreenDescriptionSignClauseContext = ScreenDescriptionSignClauseContext(context, state)
		enterRule(_localctx, 304, Rules.RULE_screenDescriptionSignClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2667
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SIGN) {
				if (true){
				this.state = 2663
				match(SIGN) as Token
				this.state = 2665
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 2664
					match(IS) as Token
					}
				}

				}
			}

			this.state = 2669
			_la = _input!!.LA(1)
			if ( !(_la==LEADING || _la==TRAILING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 2674
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SEPARATE) {
				if (true){
				this.state = 2670
				match(SEPARATE) as Token
				this.state = 2672
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==CHARACTER) {
					if (true){
					this.state = 2671
					match(CHARACTER) as Token
					}
				}

				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionAutoClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionAutoClause.id
	        set(value) { throw RuntimeException() }
		fun AUTO() : TerminalNode? = getToken(Cobol85Parser.Tokens.AUTO.id, 0)
		fun AUTO_SKIP() : TerminalNode? = getToken(Cobol85Parser.Tokens.AUTO_SKIP.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionAutoClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionAutoClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionAutoClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionAutoClause() : ScreenDescriptionAutoClauseContext {
		var _localctx : ScreenDescriptionAutoClauseContext = ScreenDescriptionAutoClauseContext(context, state)
		enterRule(_localctx, 306, Rules.RULE_screenDescriptionAutoClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2676
			_la = _input!!.LA(1)
			if ( !(_la==AUTO || _la==AUTO_SKIP) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionSecureClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionSecureClause.id
	        set(value) { throw RuntimeException() }
		fun SECURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECURE.id, 0)
		fun NO_ECHO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO_ECHO.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionSecureClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionSecureClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionSecureClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionSecureClause() : ScreenDescriptionSecureClauseContext {
		var _localctx : ScreenDescriptionSecureClauseContext = ScreenDescriptionSecureClauseContext(context, state)
		enterRule(_localctx, 308, Rules.RULE_screenDescriptionSecureClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2678
			_la = _input!!.LA(1)
			if ( !(_la==NO_ECHO || _la==SECURE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionRequiredClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionRequiredClause.id
	        set(value) { throw RuntimeException() }
		fun REQUIRED() : TerminalNode? = getToken(Cobol85Parser.Tokens.REQUIRED.id, 0)
		fun EMPTY_CHECK() : TerminalNode? = getToken(Cobol85Parser.Tokens.EMPTY_CHECK.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionRequiredClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionRequiredClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionRequiredClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionRequiredClause() : ScreenDescriptionRequiredClauseContext {
		var _localctx : ScreenDescriptionRequiredClauseContext = ScreenDescriptionRequiredClauseContext(context, state)
		enterRule(_localctx, 310, Rules.RULE_screenDescriptionRequiredClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2680
			_la = _input!!.LA(1)
			if ( !(_la==EMPTY_CHECK || _la==REQUIRED) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionPromptClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionPromptClause.id
	        set(value) { throw RuntimeException() }
		fun PROMPT() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROMPT.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun CHARACTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTER.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findScreenDescriptionPromptOccursClause() : ScreenDescriptionPromptOccursClauseContext? = getRuleContext(solver.getType("ScreenDescriptionPromptOccursClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionPromptClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionPromptClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionPromptClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionPromptClause() : ScreenDescriptionPromptClauseContext {
		var _localctx : ScreenDescriptionPromptClauseContext = ScreenDescriptionPromptClauseContext(context, state)
		enterRule(_localctx, 312, Rules.RULE_screenDescriptionPromptClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2682
			match(PROMPT) as Token
			this.state = 2684
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CHARACTER) {
				if (true){
				this.state = 2683
				match(CHARACTER) as Token
				}
			}

			this.state = 2687
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2686
				match(IS) as Token
				}
			}

			this.state = 2691
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,298,context) ) {
			1 -> {if (true){
			this.state = 2689
			identifier()
			}}
			2 -> {if (true){
			this.state = 2690
			literal()
			}}
			}
			this.state = 2694
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OCCURS) {
				if (true){
				this.state = 2693
				screenDescriptionPromptOccursClause()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionPromptOccursClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionPromptOccursClause.id
	        set(value) { throw RuntimeException() }
		fun OCCURS() : TerminalNode? = getToken(Cobol85Parser.Tokens.OCCURS.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun TIMES() : TerminalNode? = getToken(Cobol85Parser.Tokens.TIMES.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionPromptOccursClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionPromptOccursClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionPromptOccursClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionPromptOccursClause() : ScreenDescriptionPromptOccursClauseContext {
		var _localctx : ScreenDescriptionPromptOccursClauseContext = ScreenDescriptionPromptOccursClauseContext(context, state)
		enterRule(_localctx, 314, Rules.RULE_screenDescriptionPromptOccursClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2696
			match(OCCURS) as Token
			this.state = 2697
			integerLiteral()
			this.state = 2699
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TIMES) {
				if (true){
				this.state = 2698
				match(TIMES) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionFullClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionFullClause.id
	        set(value) { throw RuntimeException() }
		fun FULL() : TerminalNode? = getToken(Cobol85Parser.Tokens.FULL.id, 0)
		fun LENGTH_CHECK() : TerminalNode? = getToken(Cobol85Parser.Tokens.LENGTH_CHECK.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionFullClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionFullClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionFullClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionFullClause() : ScreenDescriptionFullClauseContext {
		var _localctx : ScreenDescriptionFullClauseContext = ScreenDescriptionFullClauseContext(context, state)
		enterRule(_localctx, 316, Rules.RULE_screenDescriptionFullClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2701
			_la = _input!!.LA(1)
			if ( !(_la==FULL || _la==LENGTH_CHECK) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenDescriptionZeroFillClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenDescriptionZeroFillClause.id
	        set(value) { throw RuntimeException() }
		fun ZERO_FILL() : TerminalNode? = getToken(Cobol85Parser.Tokens.ZERO_FILL.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenDescriptionZeroFillClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenDescriptionZeroFillClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenDescriptionZeroFillClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenDescriptionZeroFillClause() : ScreenDescriptionZeroFillClauseContext {
		var _localctx : ScreenDescriptionZeroFillClauseContext = ScreenDescriptionZeroFillClauseContext(context, state)
		enterRule(_localctx, 318, Rules.RULE_screenDescriptionZeroFillClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2703
			match(ZERO_FILL) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportSection.id
	        set(value) { throw RuntimeException() }
		fun REPORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.REPORT.id, 0)
		fun SECTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECTION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findReportDescription() : List<ReportDescriptionContext> = getRuleContexts(solver.getType("ReportDescriptionContext"))
		fun findReportDescription(i: Int) : ReportDescriptionContext? = getRuleContext(solver.getType("ReportDescriptionContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportSection() : ReportSectionContext {
		var _localctx : ReportSectionContext = ReportSectionContext(context, state)
		enterRule(_localctx, 320, Rules.RULE_reportSection.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2705
			match(REPORT) as Token
			this.state = 2706
			match(SECTION) as Token
			this.state = 2707
			match(DOT_FS) as Token
			this.state = 2711
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==RD) {
				if (true){
				if (true){
				this.state = 2708
				reportDescription()
				}
				}
				this.state = 2713
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportDescriptionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportDescription.id
	        set(value) { throw RuntimeException() }
		fun findReportDescriptionEntry() : ReportDescriptionEntryContext? = getRuleContext(solver.getType("ReportDescriptionEntryContext"),0)
		fun findReportGroupDescriptionEntry() : List<ReportGroupDescriptionEntryContext> = getRuleContexts(solver.getType("ReportGroupDescriptionEntryContext"))
		fun findReportGroupDescriptionEntry(i: Int) : ReportGroupDescriptionEntryContext? = getRuleContext(solver.getType("ReportGroupDescriptionEntryContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportDescription(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportDescription(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportDescription(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportDescription() : ReportDescriptionContext {
		var _localctx : ReportDescriptionContext = ReportDescriptionContext(context, state)
		enterRule(_localctx, 322, Rules.RULE_reportDescription.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2714
			reportDescriptionEntry()
			this.state = 2716 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 2715
				reportGroupDescriptionEntry()
				}
				}
				this.state = 2718 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportDescriptionEntryContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportDescriptionEntry.id
	        set(value) { throw RuntimeException() }
		fun RD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RD.id, 0)
		fun findReportName() : ReportNameContext? = getRuleContext(solver.getType("ReportNameContext"),0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findReportDescriptionGlobalClause() : ReportDescriptionGlobalClauseContext? = getRuleContext(solver.getType("ReportDescriptionGlobalClauseContext"),0)
		fun findReportDescriptionPageLimitClause() : ReportDescriptionPageLimitClauseContext? = getRuleContext(solver.getType("ReportDescriptionPageLimitClauseContext"),0)
		fun findReportDescriptionHeadingClause() : ReportDescriptionHeadingClauseContext? = getRuleContext(solver.getType("ReportDescriptionHeadingClauseContext"),0)
		fun findReportDescriptionFirstDetailClause() : ReportDescriptionFirstDetailClauseContext? = getRuleContext(solver.getType("ReportDescriptionFirstDetailClauseContext"),0)
		fun findReportDescriptionLastDetailClause() : ReportDescriptionLastDetailClauseContext? = getRuleContext(solver.getType("ReportDescriptionLastDetailClauseContext"),0)
		fun findReportDescriptionFootingClause() : ReportDescriptionFootingClauseContext? = getRuleContext(solver.getType("ReportDescriptionFootingClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportDescriptionEntry(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportDescriptionEntry(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportDescriptionEntry(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportDescriptionEntry() : ReportDescriptionEntryContext {
		var _localctx : ReportDescriptionEntryContext = ReportDescriptionEntryContext(context, state)
		enterRule(_localctx, 324, Rules.RULE_reportDescriptionEntry.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2720
			match(RD) as Token
			this.state = 2721
			reportName()
			this.state = 2723
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==GLOBAL || _la==IS) {
				if (true){
				this.state = 2722
				reportDescriptionGlobalClause()
				}
			}

			this.state = 2738
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==PAGE) {
				if (true){
				this.state = 2725
				reportDescriptionPageLimitClause()
				this.state = 2727
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==HEADING) {
					if (true){
					this.state = 2726
					reportDescriptionHeadingClause()
					}
				}

				this.state = 2730
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==FIRST) {
					if (true){
					this.state = 2729
					reportDescriptionFirstDetailClause()
					}
				}

				this.state = 2733
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==LAST) {
					if (true){
					this.state = 2732
					reportDescriptionLastDetailClause()
					}
				}

				this.state = 2736
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==FOOTING) {
					if (true){
					this.state = 2735
					reportDescriptionFootingClause()
					}
				}

				}
			}

			this.state = 2740
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportDescriptionGlobalClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportDescriptionGlobalClause.id
	        set(value) { throw RuntimeException() }
		fun GLOBAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.GLOBAL.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportDescriptionGlobalClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportDescriptionGlobalClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportDescriptionGlobalClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportDescriptionGlobalClause() : ReportDescriptionGlobalClauseContext {
		var _localctx : ReportDescriptionGlobalClauseContext = ReportDescriptionGlobalClauseContext(context, state)
		enterRule(_localctx, 326, Rules.RULE_reportDescriptionGlobalClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2743
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2742
				match(IS) as Token
				}
			}

			this.state = 2745
			match(GLOBAL) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportDescriptionPageLimitClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportDescriptionPageLimitClause.id
	        set(value) { throw RuntimeException() }
		fun PAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PAGE.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun LIMIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.LIMIT.id, 0)
		fun LIMITS() : TerminalNode? = getToken(Cobol85Parser.Tokens.LIMITS.id, 0)
		fun LINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINE.id, 0)
		fun LINES() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINES.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun ARE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ARE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportDescriptionPageLimitClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportDescriptionPageLimitClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportDescriptionPageLimitClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportDescriptionPageLimitClause() : ReportDescriptionPageLimitClauseContext {
		var _localctx : ReportDescriptionPageLimitClauseContext = ReportDescriptionPageLimitClauseContext(context, state)
		enterRule(_localctx, 328, Rules.RULE_reportDescriptionPageLimitClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2747
			match(PAGE) as Token
			this.state = 2756
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			LIMIT  -> 
				if (true){
				this.state = 2748
				match(LIMIT) as Token
				this.state = 2750
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 2749
					match(IS) as Token
					}
				}

				}
			LIMITS  -> 
				if (true){
				this.state = 2752
				match(LIMITS) as Token
				this.state = 2754
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==ARE) {
					if (true){
					this.state = 2753
					match(ARE) as Token
					}
				}

				}
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  -> 
				Unit
			else -> Unit
			}
			this.state = 2758
			integerLiteral()
			this.state = 2760
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LINE || _la==LINES) {
				if (true){
				this.state = 2759
				_la = _input!!.LA(1)
				if ( !(_la==LINE || _la==LINES) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportDescriptionHeadingClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportDescriptionHeadingClause.id
	        set(value) { throw RuntimeException() }
		fun HEADING() : TerminalNode? = getToken(Cobol85Parser.Tokens.HEADING.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportDescriptionHeadingClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportDescriptionHeadingClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportDescriptionHeadingClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportDescriptionHeadingClause() : ReportDescriptionHeadingClauseContext {
		var _localctx : ReportDescriptionHeadingClauseContext = ReportDescriptionHeadingClauseContext(context, state)
		enterRule(_localctx, 330, Rules.RULE_reportDescriptionHeadingClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2762
			match(HEADING) as Token
			this.state = 2763
			integerLiteral()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportDescriptionFirstDetailClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportDescriptionFirstDetailClause.id
	        set(value) { throw RuntimeException() }
		fun FIRST() : TerminalNode? = getToken(Cobol85Parser.Tokens.FIRST.id, 0)
		fun DETAIL() : TerminalNode? = getToken(Cobol85Parser.Tokens.DETAIL.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportDescriptionFirstDetailClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportDescriptionFirstDetailClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportDescriptionFirstDetailClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportDescriptionFirstDetailClause() : ReportDescriptionFirstDetailClauseContext {
		var _localctx : ReportDescriptionFirstDetailClauseContext = ReportDescriptionFirstDetailClauseContext(context, state)
		enterRule(_localctx, 332, Rules.RULE_reportDescriptionFirstDetailClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2765
			match(FIRST) as Token
			this.state = 2766
			match(DETAIL) as Token
			this.state = 2767
			integerLiteral()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportDescriptionLastDetailClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportDescriptionLastDetailClause.id
	        set(value) { throw RuntimeException() }
		fun LAST() : TerminalNode? = getToken(Cobol85Parser.Tokens.LAST.id, 0)
		fun DETAIL() : TerminalNode? = getToken(Cobol85Parser.Tokens.DETAIL.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportDescriptionLastDetailClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportDescriptionLastDetailClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportDescriptionLastDetailClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportDescriptionLastDetailClause() : ReportDescriptionLastDetailClauseContext {
		var _localctx : ReportDescriptionLastDetailClauseContext = ReportDescriptionLastDetailClauseContext(context, state)
		enterRule(_localctx, 334, Rules.RULE_reportDescriptionLastDetailClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2769
			match(LAST) as Token
			this.state = 2770
			match(DETAIL) as Token
			this.state = 2771
			integerLiteral()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportDescriptionFootingClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportDescriptionFootingClause.id
	        set(value) { throw RuntimeException() }
		fun FOOTING() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOOTING.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportDescriptionFootingClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportDescriptionFootingClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportDescriptionFootingClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportDescriptionFootingClause() : ReportDescriptionFootingClauseContext {
		var _localctx : ReportDescriptionFootingClauseContext = ReportDescriptionFootingClauseContext(context, state)
		enterRule(_localctx, 336, Rules.RULE_reportDescriptionFootingClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2773
			match(FOOTING) as Token
			this.state = 2774
			integerLiteral()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupDescriptionEntryContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupDescriptionEntry.id
	        set(value) { throw RuntimeException() }
		fun findReportGroupDescriptionEntryFormat1() : ReportGroupDescriptionEntryFormat1Context? = getRuleContext(solver.getType("ReportGroupDescriptionEntryFormat1Context"),0)
		fun findReportGroupDescriptionEntryFormat2() : ReportGroupDescriptionEntryFormat2Context? = getRuleContext(solver.getType("ReportGroupDescriptionEntryFormat2Context"),0)
		fun findReportGroupDescriptionEntryFormat3() : ReportGroupDescriptionEntryFormat3Context? = getRuleContext(solver.getType("ReportGroupDescriptionEntryFormat3Context"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupDescriptionEntry(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupDescriptionEntry(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupDescriptionEntry(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupDescriptionEntry() : ReportGroupDescriptionEntryContext {
		var _localctx : ReportGroupDescriptionEntryContext = ReportGroupDescriptionEntryContext(context, state)
		enterRule(_localctx, 338, Rules.RULE_reportGroupDescriptionEntry.id)
		try {
			this.state = 2779
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,314,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2776
			reportGroupDescriptionEntryFormat1()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 2777
			reportGroupDescriptionEntryFormat2()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 2778
			reportGroupDescriptionEntryFormat3()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupDescriptionEntryFormat1Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupDescriptionEntryFormat1.id
	        set(value) { throw RuntimeException() }
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun findReportGroupTypeClause() : ReportGroupTypeClauseContext? = getRuleContext(solver.getType("ReportGroupTypeClauseContext"),0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findReportGroupLineNumberClause() : ReportGroupLineNumberClauseContext? = getRuleContext(solver.getType("ReportGroupLineNumberClauseContext"),0)
		fun findReportGroupNextGroupClause() : ReportGroupNextGroupClauseContext? = getRuleContext(solver.getType("ReportGroupNextGroupClauseContext"),0)
		fun findReportGroupUsageClause() : ReportGroupUsageClauseContext? = getRuleContext(solver.getType("ReportGroupUsageClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupDescriptionEntryFormat1(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupDescriptionEntryFormat1(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupDescriptionEntryFormat1(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupDescriptionEntryFormat1() : ReportGroupDescriptionEntryFormat1Context {
		var _localctx : ReportGroupDescriptionEntryFormat1Context = ReportGroupDescriptionEntryFormat1Context(context, state)
		enterRule(_localctx, 340, Rules.RULE_reportGroupDescriptionEntryFormat1.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2781
			integerLiteral()
			this.state = 2782
			dataName()
			this.state = 2784
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (((((_la - 254)) and 0x3f.inv()) == 0 && ((1L shl (_la - 254)) and ((1L shl (IS - 254)) or (1L shl (LINE - 254)) or (1L shl (NUMBER - 254)))) != 0L) || _la==PLUS || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)))) != 0L)) {
				if (true){
				this.state = 2783
				reportGroupLineNumberClause()
				}
			}

			this.state = 2787
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==NEXT) {
				if (true){
				this.state = 2786
				reportGroupNextGroupClause()
				}
			}

			this.state = 2789
			reportGroupTypeClause()
			this.state = 2791
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DISPLAY || _la==DISPLAY_1 || _la==USAGE) {
				if (true){
				this.state = 2790
				reportGroupUsageClause()
				}
			}

			this.state = 2793
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupDescriptionEntryFormat2Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupDescriptionEntryFormat2.id
	        set(value) { throw RuntimeException() }
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun findReportGroupUsageClause() : ReportGroupUsageClauseContext? = getRuleContext(solver.getType("ReportGroupUsageClauseContext"),0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun findReportGroupLineNumberClause() : ReportGroupLineNumberClauseContext? = getRuleContext(solver.getType("ReportGroupLineNumberClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupDescriptionEntryFormat2(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupDescriptionEntryFormat2(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupDescriptionEntryFormat2(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupDescriptionEntryFormat2() : ReportGroupDescriptionEntryFormat2Context {
		var _localctx : ReportGroupDescriptionEntryFormat2Context = ReportGroupDescriptionEntryFormat2Context(context, state)
		enterRule(_localctx, 342, Rules.RULE_reportGroupDescriptionEntryFormat2.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2795
			integerLiteral()
			this.state = 2797
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER) {
				if (true){
				this.state = 2796
				dataName()
				}
			}

			this.state = 2800
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (((((_la - 254)) and 0x3f.inv()) == 0 && ((1L shl (_la - 254)) and ((1L shl (IS - 254)) or (1L shl (LINE - 254)) or (1L shl (NUMBER - 254)))) != 0L) || _la==PLUS || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)))) != 0L)) {
				if (true){
				this.state = 2799
				reportGroupLineNumberClause()
				}
			}

			this.state = 2802
			reportGroupUsageClause()
			this.state = 2803
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupDescriptionEntryFormat3Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupDescriptionEntryFormat3.id
	        set(value) { throw RuntimeException() }
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun findReportGroupPictureClause() : List<ReportGroupPictureClauseContext> = getRuleContexts(solver.getType("ReportGroupPictureClauseContext"))
		fun findReportGroupPictureClause(i: Int) : ReportGroupPictureClauseContext? = getRuleContext(solver.getType("ReportGroupPictureClauseContext"),i)
		fun findReportGroupUsageClause() : List<ReportGroupUsageClauseContext> = getRuleContexts(solver.getType("ReportGroupUsageClauseContext"))
		fun findReportGroupUsageClause(i: Int) : ReportGroupUsageClauseContext? = getRuleContext(solver.getType("ReportGroupUsageClauseContext"),i)
		fun findReportGroupSignClause() : List<ReportGroupSignClauseContext> = getRuleContexts(solver.getType("ReportGroupSignClauseContext"))
		fun findReportGroupSignClause(i: Int) : ReportGroupSignClauseContext? = getRuleContext(solver.getType("ReportGroupSignClauseContext"),i)
		fun findReportGroupJustifiedClause() : List<ReportGroupJustifiedClauseContext> = getRuleContexts(solver.getType("ReportGroupJustifiedClauseContext"))
		fun findReportGroupJustifiedClause(i: Int) : ReportGroupJustifiedClauseContext? = getRuleContext(solver.getType("ReportGroupJustifiedClauseContext"),i)
		fun findReportGroupBlankWhenZeroClause() : List<ReportGroupBlankWhenZeroClauseContext> = getRuleContexts(solver.getType("ReportGroupBlankWhenZeroClauseContext"))
		fun findReportGroupBlankWhenZeroClause(i: Int) : ReportGroupBlankWhenZeroClauseContext? = getRuleContext(solver.getType("ReportGroupBlankWhenZeroClauseContext"),i)
		fun findReportGroupLineNumberClause() : List<ReportGroupLineNumberClauseContext> = getRuleContexts(solver.getType("ReportGroupLineNumberClauseContext"))
		fun findReportGroupLineNumberClause(i: Int) : ReportGroupLineNumberClauseContext? = getRuleContext(solver.getType("ReportGroupLineNumberClauseContext"),i)
		fun findReportGroupColumnNumberClause() : List<ReportGroupColumnNumberClauseContext> = getRuleContexts(solver.getType("ReportGroupColumnNumberClauseContext"))
		fun findReportGroupColumnNumberClause(i: Int) : ReportGroupColumnNumberClauseContext? = getRuleContext(solver.getType("ReportGroupColumnNumberClauseContext"),i)
		fun findReportGroupIndicateClause() : List<ReportGroupIndicateClauseContext> = getRuleContexts(solver.getType("ReportGroupIndicateClauseContext"))
		fun findReportGroupIndicateClause(i: Int) : ReportGroupIndicateClauseContext? = getRuleContext(solver.getType("ReportGroupIndicateClauseContext"),i)
		fun findReportGroupSourceClause() : List<ReportGroupSourceClauseContext> = getRuleContexts(solver.getType("ReportGroupSourceClauseContext"))
		fun findReportGroupSourceClause(i: Int) : ReportGroupSourceClauseContext? = getRuleContext(solver.getType("ReportGroupSourceClauseContext"),i)
		fun findReportGroupValueClause() : List<ReportGroupValueClauseContext> = getRuleContexts(solver.getType("ReportGroupValueClauseContext"))
		fun findReportGroupValueClause(i: Int) : ReportGroupValueClauseContext? = getRuleContext(solver.getType("ReportGroupValueClauseContext"),i)
		fun findReportGroupSumClause() : List<ReportGroupSumClauseContext> = getRuleContexts(solver.getType("ReportGroupSumClauseContext"))
		fun findReportGroupSumClause(i: Int) : ReportGroupSumClauseContext? = getRuleContext(solver.getType("ReportGroupSumClauseContext"),i)
		fun findReportGroupResetClause() : List<ReportGroupResetClauseContext> = getRuleContexts(solver.getType("ReportGroupResetClauseContext"))
		fun findReportGroupResetClause(i: Int) : ReportGroupResetClauseContext? = getRuleContext(solver.getType("ReportGroupResetClauseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupDescriptionEntryFormat3(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupDescriptionEntryFormat3(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupDescriptionEntryFormat3(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupDescriptionEntryFormat3() : ReportGroupDescriptionEntryFormat3Context {
		var _localctx : ReportGroupDescriptionEntryFormat3Context = ReportGroupDescriptionEntryFormat3Context(context, state)
		enterRule(_localctx, 344, Rules.RULE_reportGroupDescriptionEntryFormat3.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2805
			integerLiteral()
			this.state = 2807
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER) {
				if (true){
				this.state = 2806
				dataName()
				}
			}

			this.state = 2825
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==BLANK || _la==COLUMN || _la==DISPLAY || _la==DISPLAY_1 || ((((_la - 227)) and 0x3f.inv()) == 0 && ((1L shl (_la - 227)) and ((1L shl (GROUP - 227)) or (1L shl (IS - 227)) or (1L shl (JUST - 227)) or (1L shl (JUSTIFIED - 227)) or (1L shl (LINE - 227)))) != 0L) || ((((_la - 315)) and 0x3f.inv()) == 0 && ((1L shl (_la - 315)) and ((1L shl (NUMBER - 315)) or (1L shl (PIC - 315)) or (1L shl (PICTURE - 315)) or (1L shl (PLUS - 315)))) != 0L) || ((((_la - 402)) and 0x3f.inv()) == 0 && ((1L shl (_la - 402)) and ((1L shl (RESET - 402)) or (1L shl (SIGN - 402)) or (1L shl (SOURCE - 402)) or (1L shl (SUM - 402)))) != 0L) || ((((_la - 504)) and 0x3f.inv()) == 0 && ((1L shl (_la - 504)) and ((1L shl (USAGE - 504)) or (1L shl (VALUE - 504)) or (1L shl (LEVEL_NUMBER_66 - 504)) or (1L shl (LEVEL_NUMBER_77 - 504)) or (1L shl (LEVEL_NUMBER_88 - 504)) or (1L shl (INTEGERLITERAL - 504)))) != 0L)) {
				if (true){
				this.state = 2823
				errorHandler.sync(this)
				when (_input!!.LA(1)) {
				PIC , PICTURE  ->  /*LL1AltBlock*/{if (true){
				this.state = 2809
				reportGroupPictureClause()
				}}
				DISPLAY , DISPLAY_1 , USAGE  ->  /*LL1AltBlock*/{if (true){
				this.state = 2810
				reportGroupUsageClause()
				}}
				SIGN  ->  /*LL1AltBlock*/{if (true){
				this.state = 2811
				reportGroupSignClause()
				}}
				JUST , JUSTIFIED  ->  /*LL1AltBlock*/{if (true){
				this.state = 2812
				reportGroupJustifiedClause()
				}}
				BLANK  ->  /*LL1AltBlock*/{if (true){
				this.state = 2813
				reportGroupBlankWhenZeroClause()
				}}
				IS , LINE , NUMBER , PLUS , LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{if (true){
				this.state = 2814
				reportGroupLineNumberClause()
				}}
				COLUMN  ->  /*LL1AltBlock*/{if (true){
				this.state = 2815
				reportGroupColumnNumberClause()
				}}
				RESET , SOURCE , SUM , VALUE  ->  /*LL1AltBlock*/{if (true){
				this.state = 2820
				errorHandler.sync(this)
				when (_input!!.LA(1)) {
				SOURCE  ->  /*LL1AltBlock*/{if (true){
				this.state = 2816
				reportGroupSourceClause()
				}}
				VALUE  ->  /*LL1AltBlock*/{if (true){
				this.state = 2817
				reportGroupValueClause()
				}}
				SUM  ->  /*LL1AltBlock*/{if (true){
				this.state = 2818
				reportGroupSumClause()
				}}
				RESET  ->  /*LL1AltBlock*/{if (true){
				this.state = 2819
				reportGroupResetClause()
				}}
				else -> throw NoViableAltException(this)
				}
				}}
				GROUP  ->  /*LL1AltBlock*/{if (true){
				this.state = 2822
				reportGroupIndicateClause()
				}}
				else -> throw NoViableAltException(this)
				}
				}
				this.state = 2827
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 2828
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupBlankWhenZeroClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupBlankWhenZeroClause.id
	        set(value) { throw RuntimeException() }
		fun BLANK() : TerminalNode? = getToken(Cobol85Parser.Tokens.BLANK.id, 0)
		fun ZERO() : TerminalNode? = getToken(Cobol85Parser.Tokens.ZERO.id, 0)
		fun WHEN() : TerminalNode? = getToken(Cobol85Parser.Tokens.WHEN.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupBlankWhenZeroClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupBlankWhenZeroClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupBlankWhenZeroClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupBlankWhenZeroClause() : ReportGroupBlankWhenZeroClauseContext {
		var _localctx : ReportGroupBlankWhenZeroClauseContext = ReportGroupBlankWhenZeroClauseContext(context, state)
		enterRule(_localctx, 346, Rules.RULE_reportGroupBlankWhenZeroClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2830
			match(BLANK) as Token
			this.state = 2832
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WHEN) {
				if (true){
				this.state = 2831
				match(WHEN) as Token
				}
			}

			this.state = 2834
			match(ZERO) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupColumnNumberClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupColumnNumberClause.id
	        set(value) { throw RuntimeException() }
		fun COLUMN() : TerminalNode? = getToken(Cobol85Parser.Tokens.COLUMN.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun NUMBER() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMBER.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupColumnNumberClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupColumnNumberClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupColumnNumberClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupColumnNumberClause() : ReportGroupColumnNumberClauseContext {
		var _localctx : ReportGroupColumnNumberClauseContext = ReportGroupColumnNumberClauseContext(context, state)
		enterRule(_localctx, 348, Rules.RULE_reportGroupColumnNumberClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2836
			match(COLUMN) as Token
			this.state = 2838
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==NUMBER) {
				if (true){
				this.state = 2837
				match(NUMBER) as Token
				}
			}

			this.state = 2841
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2840
				match(IS) as Token
				}
			}

			this.state = 2843
			integerLiteral()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupIndicateClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupIndicateClause.id
	        set(value) { throw RuntimeException() }
		fun GROUP() : TerminalNode? = getToken(Cobol85Parser.Tokens.GROUP.id, 0)
		fun INDICATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.INDICATE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupIndicateClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupIndicateClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupIndicateClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupIndicateClause() : ReportGroupIndicateClauseContext {
		var _localctx : ReportGroupIndicateClauseContext = ReportGroupIndicateClauseContext(context, state)
		enterRule(_localctx, 350, Rules.RULE_reportGroupIndicateClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2845
			match(GROUP) as Token
			this.state = 2847
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==INDICATE) {
				if (true){
				this.state = 2846
				match(INDICATE) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupJustifiedClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupJustifiedClause.id
	        set(value) { throw RuntimeException() }
		fun JUSTIFIED() : TerminalNode? = getToken(Cobol85Parser.Tokens.JUSTIFIED.id, 0)
		fun JUST() : TerminalNode? = getToken(Cobol85Parser.Tokens.JUST.id, 0)
		fun RIGHT() : TerminalNode? = getToken(Cobol85Parser.Tokens.RIGHT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupJustifiedClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupJustifiedClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupJustifiedClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupJustifiedClause() : ReportGroupJustifiedClauseContext {
		var _localctx : ReportGroupJustifiedClauseContext = ReportGroupJustifiedClauseContext(context, state)
		enterRule(_localctx, 352, Rules.RULE_reportGroupJustifiedClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2849
			_la = _input!!.LA(1)
			if ( !(_la==JUST || _la==JUSTIFIED) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 2851
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==RIGHT) {
				if (true){
				this.state = 2850
				match(RIGHT) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupLineNumberClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupLineNumberClause.id
	        set(value) { throw RuntimeException() }
		fun findReportGroupLineNumberNextPage() : ReportGroupLineNumberNextPageContext? = getRuleContext(solver.getType("ReportGroupLineNumberNextPageContext"),0)
		fun findReportGroupLineNumberPlus() : ReportGroupLineNumberPlusContext? = getRuleContext(solver.getType("ReportGroupLineNumberPlusContext"),0)
		fun LINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINE.id, 0)
		fun NUMBER() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMBER.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupLineNumberClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupLineNumberClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupLineNumberClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupLineNumberClause() : ReportGroupLineNumberClauseContext {
		var _localctx : ReportGroupLineNumberClauseContext = ReportGroupLineNumberClauseContext(context, state)
		enterRule(_localctx, 354, Rules.RULE_reportGroupLineNumberClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2854
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LINE) {
				if (true){
				this.state = 2853
				match(LINE) as Token
				}
			}

			this.state = 2857
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==NUMBER) {
				if (true){
				this.state = 2856
				match(NUMBER) as Token
				}
			}

			this.state = 2860
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2859
				match(IS) as Token
				}
			}

			this.state = 2864
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 2862
			reportGroupLineNumberNextPage()
			}}
			PLUS  ->  /*LL1AltBlock*/{if (true){
			this.state = 2863
			reportGroupLineNumberPlus()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupLineNumberNextPageContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupLineNumberNextPage.id
	        set(value) { throw RuntimeException() }
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun NEXT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NEXT.id, 0)
		fun PAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PAGE.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupLineNumberNextPage(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupLineNumberNextPage(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupLineNumberNextPage(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupLineNumberNextPage() : ReportGroupLineNumberNextPageContext {
		var _localctx : ReportGroupLineNumberNextPageContext = ReportGroupLineNumberNextPageContext(context, state)
		enterRule(_localctx, 356, Rules.RULE_reportGroupLineNumberNextPage.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2866
			integerLiteral()
			this.state = 2872
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,334,context) ) {
			1   -> if (true){
			this.state = 2868
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 2867
				match(ON) as Token
				}
			}

			this.state = 2870
			match(NEXT) as Token
			this.state = 2871
			match(PAGE) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupLineNumberPlusContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupLineNumberPlus.id
	        set(value) { throw RuntimeException() }
		fun PLUS() : TerminalNode? = getToken(Cobol85Parser.Tokens.PLUS.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupLineNumberPlus(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupLineNumberPlus(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupLineNumberPlus(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupLineNumberPlus() : ReportGroupLineNumberPlusContext {
		var _localctx : ReportGroupLineNumberPlusContext = ReportGroupLineNumberPlusContext(context, state)
		enterRule(_localctx, 358, Rules.RULE_reportGroupLineNumberPlus.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2874
			match(PLUS) as Token
			this.state = 2875
			integerLiteral()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupNextGroupClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupNextGroupClause.id
	        set(value) { throw RuntimeException() }
		fun NEXT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NEXT.id, 0)
		fun GROUP() : TerminalNode? = getToken(Cobol85Parser.Tokens.GROUP.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun findReportGroupNextGroupNextPage() : ReportGroupNextGroupNextPageContext? = getRuleContext(solver.getType("ReportGroupNextGroupNextPageContext"),0)
		fun findReportGroupNextGroupPlus() : ReportGroupNextGroupPlusContext? = getRuleContext(solver.getType("ReportGroupNextGroupPlusContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupNextGroupClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupNextGroupClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupNextGroupClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupNextGroupClause() : ReportGroupNextGroupClauseContext {
		var _localctx : ReportGroupNextGroupClauseContext = ReportGroupNextGroupClauseContext(context, state)
		enterRule(_localctx, 360, Rules.RULE_reportGroupNextGroupClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2877
			match(NEXT) as Token
			this.state = 2878
			match(GROUP) as Token
			this.state = 2880
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2879
				match(IS) as Token
				}
			}

			this.state = 2885
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 2882
			integerLiteral()
			}}
			NEXT  ->  /*LL1AltBlock*/{if (true){
			this.state = 2883
			reportGroupNextGroupNextPage()
			}}
			PLUS  ->  /*LL1AltBlock*/{if (true){
			this.state = 2884
			reportGroupNextGroupPlus()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupNextGroupPlusContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupNextGroupPlus.id
	        set(value) { throw RuntimeException() }
		fun PLUS() : TerminalNode? = getToken(Cobol85Parser.Tokens.PLUS.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupNextGroupPlus(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupNextGroupPlus(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupNextGroupPlus(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupNextGroupPlus() : ReportGroupNextGroupPlusContext {
		var _localctx : ReportGroupNextGroupPlusContext = ReportGroupNextGroupPlusContext(context, state)
		enterRule(_localctx, 362, Rules.RULE_reportGroupNextGroupPlus.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2887
			match(PLUS) as Token
			this.state = 2888
			integerLiteral()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupNextGroupNextPageContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupNextGroupNextPage.id
	        set(value) { throw RuntimeException() }
		fun NEXT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NEXT.id, 0)
		fun PAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PAGE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupNextGroupNextPage(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupNextGroupNextPage(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupNextGroupNextPage(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupNextGroupNextPage() : ReportGroupNextGroupNextPageContext {
		var _localctx : ReportGroupNextGroupNextPageContext = ReportGroupNextGroupNextPageContext(context, state)
		enterRule(_localctx, 364, Rules.RULE_reportGroupNextGroupNextPage.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2890
			match(NEXT) as Token
			this.state = 2891
			match(PAGE) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupPictureClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupPictureClause.id
	        set(value) { throw RuntimeException() }
		fun findPictureString() : PictureStringContext? = getRuleContext(solver.getType("PictureStringContext"),0)
		fun PICTURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PICTURE.id, 0)
		fun PIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.PIC.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupPictureClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupPictureClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupPictureClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupPictureClause() : ReportGroupPictureClauseContext {
		var _localctx : ReportGroupPictureClauseContext = ReportGroupPictureClauseContext(context, state)
		enterRule(_localctx, 366, Rules.RULE_reportGroupPictureClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2893
			_la = _input!!.LA(1)
			if ( !(_la==PIC || _la==PICTURE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 2895
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2894
				match(IS) as Token
				}
			}

			this.state = 2897
			pictureString()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupResetClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupResetClause.id
	        set(value) { throw RuntimeException() }
		fun RESET() : TerminalNode? = getToken(Cobol85Parser.Tokens.RESET.id, 0)
		fun FINAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.FINAL.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupResetClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupResetClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupResetClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupResetClause() : ReportGroupResetClauseContext {
		var _localctx : ReportGroupResetClauseContext = ReportGroupResetClauseContext(context, state)
		enterRule(_localctx, 368, Rules.RULE_reportGroupResetClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2899
			match(RESET) as Token
			this.state = 2901
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 2900
				match(ON) as Token
				}
			}

			this.state = 2905
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			FINAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 2903
			match(FINAL) as Token
			}}
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 2904
			dataName()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupSignClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupSignClause.id
	        set(value) { throw RuntimeException() }
		fun SIGN() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIGN.id, 0)
		fun SEPARATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEPARATE.id, 0)
		fun LEADING() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEADING.id, 0)
		fun TRAILING() : TerminalNode? = getToken(Cobol85Parser.Tokens.TRAILING.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun CHARACTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTER.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupSignClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupSignClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupSignClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupSignClause() : ReportGroupSignClauseContext {
		var _localctx : ReportGroupSignClauseContext = ReportGroupSignClauseContext(context, state)
		enterRule(_localctx, 370, Rules.RULE_reportGroupSignClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2907
			match(SIGN) as Token
			this.state = 2909
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2908
				match(IS) as Token
				}
			}

			this.state = 2911
			_la = _input!!.LA(1)
			if ( !(_la==LEADING || _la==TRAILING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 2912
			match(SEPARATE) as Token
			this.state = 2914
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CHARACTER) {
				if (true){
				this.state = 2913
				match(CHARACTER) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupSourceClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupSourceClause.id
	        set(value) { throw RuntimeException() }
		fun SOURCE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SOURCE.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupSourceClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupSourceClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupSourceClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupSourceClause() : ReportGroupSourceClauseContext {
		var _localctx : ReportGroupSourceClauseContext = ReportGroupSourceClauseContext(context, state)
		enterRule(_localctx, 372, Rules.RULE_reportGroupSourceClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2916
			match(SOURCE) as Token
			this.state = 2918
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2917
				match(IS) as Token
				}
			}

			this.state = 2920
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupSumClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupSumClause.id
	        set(value) { throw RuntimeException() }
		fun SUM() : TerminalNode? = getToken(Cobol85Parser.Tokens.SUM.id, 0)
		fun findIdentifier() : List<IdentifierContext> = getRuleContexts(solver.getType("IdentifierContext"))
		fun findIdentifier(i: Int) : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),i)
		fun UPON() : TerminalNode? = getToken(Cobol85Parser.Tokens.UPON.id, 0)
		fun findDataName() : List<DataNameContext> = getRuleContexts(solver.getType("DataNameContext"))
		fun findDataName(i: Int) : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),i)
		fun COMMACHAR() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.COMMACHAR.id)
		fun COMMACHAR(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.COMMACHAR.id, i) as TerminalNode
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupSumClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupSumClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupSumClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupSumClause() : ReportGroupSumClauseContext {
		var _localctx : ReportGroupSumClauseContext = ReportGroupSumClauseContext(context, state)
		enterRule(_localctx, 374, Rules.RULE_reportGroupSumClause.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2922
			match(SUM) as Token
			this.state = 2923
			identifier()
			this.state = 2930
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,344,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 2925
					errorHandler.sync(this)
					_la = _input!!.LA(1)
					if (_la==COMMACHAR) {
						if (true){
						this.state = 2924
						match(COMMACHAR) as Token
						}
					}

					this.state = 2927
					identifier()
					}
					} 
				}
				this.state = 2932
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,344,context)
			}
			this.state = 2944
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==UPON) {
				if (true){
				this.state = 2933
				match(UPON) as Token
				this.state = 2934
				dataName()
				this.state = 2941
				errorHandler.sync(this);
				_la = _input!!.LA(1)
				while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (COMMACHAR - 466)))) != 0L) || _la==IDENTIFIER) {
					if (true){
					if (true){
					this.state = 2936
					errorHandler.sync(this)
					_la = _input!!.LA(1)
					if (_la==COMMACHAR) {
						if (true){
						this.state = 2935
						match(COMMACHAR) as Token
						}
					}

					this.state = 2938
					dataName()
					}
					}
					this.state = 2943
					errorHandler.sync(this)
					_la = _input!!.LA(1)
				}
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupTypeClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupTypeClause.id
	        set(value) { throw RuntimeException() }
		fun TYPE() : TerminalNode? = getToken(Cobol85Parser.Tokens.TYPE.id, 0)
		fun findReportGroupTypeReportHeading() : ReportGroupTypeReportHeadingContext? = getRuleContext(solver.getType("ReportGroupTypeReportHeadingContext"),0)
		fun findReportGroupTypePageHeading() : ReportGroupTypePageHeadingContext? = getRuleContext(solver.getType("ReportGroupTypePageHeadingContext"),0)
		fun findReportGroupTypeControlHeading() : ReportGroupTypeControlHeadingContext? = getRuleContext(solver.getType("ReportGroupTypeControlHeadingContext"),0)
		fun findReportGroupTypeDetail() : ReportGroupTypeDetailContext? = getRuleContext(solver.getType("ReportGroupTypeDetailContext"),0)
		fun findReportGroupTypeControlFooting() : ReportGroupTypeControlFootingContext? = getRuleContext(solver.getType("ReportGroupTypeControlFootingContext"),0)
		fun findReportGroupTypePageFooting() : ReportGroupTypePageFootingContext? = getRuleContext(solver.getType("ReportGroupTypePageFootingContext"),0)
		fun findReportGroupTypeReportFooting() : ReportGroupTypeReportFootingContext? = getRuleContext(solver.getType("ReportGroupTypeReportFootingContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupTypeClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupTypeClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupTypeClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupTypeClause() : ReportGroupTypeClauseContext {
		var _localctx : ReportGroupTypeClauseContext = ReportGroupTypeClauseContext(context, state)
		enterRule(_localctx, 376, Rules.RULE_reportGroupTypeClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2946
			match(TYPE) as Token
			this.state = 2948
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 2947
				match(IS) as Token
				}
			}

			this.state = 2957
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,349,context) ) {
			1 -> {if (true){
			this.state = 2950
			reportGroupTypeReportHeading()
			}}
			2 -> {if (true){
			this.state = 2951
			reportGroupTypePageHeading()
			}}
			3 -> {if (true){
			this.state = 2952
			reportGroupTypeControlHeading()
			}}
			4 -> {if (true){
			this.state = 2953
			reportGroupTypeDetail()
			}}
			5 -> {if (true){
			this.state = 2954
			reportGroupTypeControlFooting()
			}}
			6 -> {if (true){
			this.state = 2955
			reportGroupTypePageFooting()
			}}
			7 -> {if (true){
			this.state = 2956
			reportGroupTypeReportFooting()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupTypeReportHeadingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupTypeReportHeading.id
	        set(value) { throw RuntimeException() }
		fun REPORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.REPORT.id, 0)
		fun HEADING() : TerminalNode? = getToken(Cobol85Parser.Tokens.HEADING.id, 0)
		fun RH() : TerminalNode? = getToken(Cobol85Parser.Tokens.RH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupTypeReportHeading(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupTypeReportHeading(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupTypeReportHeading(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupTypeReportHeading() : ReportGroupTypeReportHeadingContext {
		var _localctx : ReportGroupTypeReportHeadingContext = ReportGroupTypeReportHeadingContext(context, state)
		enterRule(_localctx, 378, Rules.RULE_reportGroupTypeReportHeading.id)
		try {
			this.state = 2962
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			REPORT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2959
			match(REPORT) as Token
			this.state = 2960
			match(HEADING) as Token
			}}
			RH  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 2961
			match(RH) as Token
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupTypePageHeadingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupTypePageHeading.id
	        set(value) { throw RuntimeException() }
		fun PAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PAGE.id, 0)
		fun HEADING() : TerminalNode? = getToken(Cobol85Parser.Tokens.HEADING.id, 0)
		fun PH() : TerminalNode? = getToken(Cobol85Parser.Tokens.PH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupTypePageHeading(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupTypePageHeading(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupTypePageHeading(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupTypePageHeading() : ReportGroupTypePageHeadingContext {
		var _localctx : ReportGroupTypePageHeadingContext = ReportGroupTypePageHeadingContext(context, state)
		enterRule(_localctx, 380, Rules.RULE_reportGroupTypePageHeading.id)
		try {
			this.state = 2967
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			PAGE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2964
			match(PAGE) as Token
			this.state = 2965
			match(HEADING) as Token
			}}
			PH  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 2966
			match(PH) as Token
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupTypeControlHeadingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupTypeControlHeading.id
	        set(value) { throw RuntimeException() }
		fun CONTROL() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTROL.id, 0)
		fun HEADING() : TerminalNode? = getToken(Cobol85Parser.Tokens.HEADING.id, 0)
		fun CH() : TerminalNode? = getToken(Cobol85Parser.Tokens.CH.id, 0)
		fun FINAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.FINAL.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupTypeControlHeading(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupTypeControlHeading(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupTypeControlHeading(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupTypeControlHeading() : ReportGroupTypeControlHeadingContext {
		var _localctx : ReportGroupTypeControlHeadingContext = ReportGroupTypeControlHeadingContext(context, state)
		enterRule(_localctx, 382, Rules.RULE_reportGroupTypeControlHeading.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2972
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			CONTROL  ->  /*LL1AltBlock*/{if (true){
			this.state = 2969
			match(CONTROL) as Token
			this.state = 2970
			match(HEADING) as Token
			}}
			CH  ->  /*LL1AltBlock*/{if (true){
			this.state = 2971
			match(CH) as Token
			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 2976
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			FINAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 2974
			match(FINAL) as Token
			}}
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 2975
			dataName()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupTypeDetailContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupTypeDetail.id
	        set(value) { throw RuntimeException() }
		fun DETAIL() : TerminalNode? = getToken(Cobol85Parser.Tokens.DETAIL.id, 0)
		fun DE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupTypeDetail(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupTypeDetail(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupTypeDetail(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupTypeDetail() : ReportGroupTypeDetailContext {
		var _localctx : ReportGroupTypeDetailContext = ReportGroupTypeDetailContext(context, state)
		enterRule(_localctx, 384, Rules.RULE_reportGroupTypeDetail.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2978
			_la = _input!!.LA(1)
			if ( !(_la==DE || _la==DETAIL) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupTypeControlFootingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupTypeControlFooting.id
	        set(value) { throw RuntimeException() }
		fun CONTROL() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTROL.id, 0)
		fun FOOTING() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOOTING.id, 0)
		fun CF() : TerminalNode? = getToken(Cobol85Parser.Tokens.CF.id, 0)
		fun FINAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.FINAL.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupTypeControlFooting(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupTypeControlFooting(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupTypeControlFooting(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupTypeControlFooting() : ReportGroupTypeControlFootingContext {
		var _localctx : ReportGroupTypeControlFootingContext = ReportGroupTypeControlFootingContext(context, state)
		enterRule(_localctx, 386, Rules.RULE_reportGroupTypeControlFooting.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2983
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			CONTROL  ->  /*LL1AltBlock*/{if (true){
			this.state = 2980
			match(CONTROL) as Token
			this.state = 2981
			match(FOOTING) as Token
			}}
			CF  ->  /*LL1AltBlock*/{if (true){
			this.state = 2982
			match(CF) as Token
			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 2987
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			FINAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 2985
			match(FINAL) as Token
			}}
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 2986
			dataName()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupUsageClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupUsageClause.id
	        set(value) { throw RuntimeException() }
		fun DISPLAY() : TerminalNode? = getToken(Cobol85Parser.Tokens.DISPLAY.id, 0)
		fun DISPLAY_1() : TerminalNode? = getToken(Cobol85Parser.Tokens.DISPLAY_1.id, 0)
		fun USAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.USAGE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupUsageClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupUsageClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupUsageClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupUsageClause() : ReportGroupUsageClauseContext {
		var _localctx : ReportGroupUsageClauseContext = ReportGroupUsageClauseContext(context, state)
		enterRule(_localctx, 388, Rules.RULE_reportGroupUsageClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2993
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==USAGE) {
				if (true){
				this.state = 2989
				match(USAGE) as Token
				this.state = 2991
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 2990
					match(IS) as Token
					}
				}

				}
			}

			this.state = 2995
			_la = _input!!.LA(1)
			if ( !(_la==DISPLAY || _la==DISPLAY_1) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupTypePageFootingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupTypePageFooting.id
	        set(value) { throw RuntimeException() }
		fun PAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PAGE.id, 0)
		fun FOOTING() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOOTING.id, 0)
		fun PF() : TerminalNode? = getToken(Cobol85Parser.Tokens.PF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupTypePageFooting(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupTypePageFooting(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupTypePageFooting(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupTypePageFooting() : ReportGroupTypePageFootingContext {
		var _localctx : ReportGroupTypePageFootingContext = ReportGroupTypePageFootingContext(context, state)
		enterRule(_localctx, 390, Rules.RULE_reportGroupTypePageFooting.id)
		try {
			this.state = 3000
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			PAGE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 2997
			match(PAGE) as Token
			this.state = 2998
			match(FOOTING) as Token
			}}
			PF  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 2999
			match(PF) as Token
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupTypeReportFootingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupTypeReportFooting.id
	        set(value) { throw RuntimeException() }
		fun REPORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.REPORT.id, 0)
		fun FOOTING() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOOTING.id, 0)
		fun RF() : TerminalNode? = getToken(Cobol85Parser.Tokens.RF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupTypeReportFooting(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupTypeReportFooting(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupTypeReportFooting(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupTypeReportFooting() : ReportGroupTypeReportFootingContext {
		var _localctx : ReportGroupTypeReportFootingContext = ReportGroupTypeReportFootingContext(context, state)
		enterRule(_localctx, 392, Rules.RULE_reportGroupTypeReportFooting.id)
		try {
			this.state = 3005
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			REPORT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3002
			match(REPORT) as Token
			this.state = 3003
			match(FOOTING) as Token
			}}
			RF  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3004
			match(RF) as Token
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportGroupValueClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportGroupValueClause.id
	        set(value) { throw RuntimeException() }
		fun VALUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.VALUE.id, 0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportGroupValueClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportGroupValueClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportGroupValueClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportGroupValueClause() : ReportGroupValueClauseContext {
		var _localctx : ReportGroupValueClauseContext = ReportGroupValueClauseContext(context, state)
		enterRule(_localctx, 394, Rules.RULE_reportGroupValueClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3007
			match(VALUE) as Token
			this.state = 3009
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 3008
				match(IS) as Token
				}
			}

			this.state = 3011
			literal()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProgramLibrarySectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_programLibrarySection.id
	        set(value) { throw RuntimeException() }
		fun PROGRAM_LIBRARY() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROGRAM_LIBRARY.id, 0)
		fun SECTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECTION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findLibraryDescriptionEntry() : List<LibraryDescriptionEntryContext> = getRuleContexts(solver.getType("LibraryDescriptionEntryContext"))
		fun findLibraryDescriptionEntry(i: Int) : LibraryDescriptionEntryContext? = getRuleContext(solver.getType("LibraryDescriptionEntryContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProgramLibrarySection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProgramLibrarySection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProgramLibrarySection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  programLibrarySection() : ProgramLibrarySectionContext {
		var _localctx : ProgramLibrarySectionContext = ProgramLibrarySectionContext(context, state)
		enterRule(_localctx, 396, Rules.RULE_programLibrarySection.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3013
			match(PROGRAM_LIBRARY) as Token
			this.state = 3014
			match(SECTION) as Token
			this.state = 3015
			match(DOT_FS) as Token
			this.state = 3019
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==LB || _la==LD) {
				if (true){
				if (true){
				this.state = 3016
				libraryDescriptionEntry()
				}
				}
				this.state = 3021
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryDescriptionEntryContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryDescriptionEntry.id
	        set(value) { throw RuntimeException() }
		fun findLibraryDescriptionEntryFormat1() : LibraryDescriptionEntryFormat1Context? = getRuleContext(solver.getType("LibraryDescriptionEntryFormat1Context"),0)
		fun findLibraryDescriptionEntryFormat2() : LibraryDescriptionEntryFormat2Context? = getRuleContext(solver.getType("LibraryDescriptionEntryFormat2Context"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryDescriptionEntry(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryDescriptionEntry(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryDescriptionEntry(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryDescriptionEntry() : LibraryDescriptionEntryContext {
		var _localctx : LibraryDescriptionEntryContext = LibraryDescriptionEntryContext(context, state)
		enterRule(_localctx, 398, Rules.RULE_libraryDescriptionEntry.id)
		try {
			this.state = 3024
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			LD  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3022
			libraryDescriptionEntryFormat1()
			}}
			LB  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3023
			libraryDescriptionEntryFormat2()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryDescriptionEntryFormat1Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryDescriptionEntryFormat1.id
	        set(value) { throw RuntimeException() }
		fun LD() : TerminalNode? = getToken(Cobol85Parser.Tokens.LD.id, 0)
		fun findLibraryName() : LibraryNameContext? = getRuleContext(solver.getType("LibraryNameContext"),0)
		fun EXPORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXPORT.id, 0)
		fun findLibraryAttributeClauseFormat1() : LibraryAttributeClauseFormat1Context? = getRuleContext(solver.getType("LibraryAttributeClauseFormat1Context"),0)
		fun findLibraryEntryProcedureClauseFormat1() : LibraryEntryProcedureClauseFormat1Context? = getRuleContext(solver.getType("LibraryEntryProcedureClauseFormat1Context"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryDescriptionEntryFormat1(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryDescriptionEntryFormat1(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryDescriptionEntryFormat1(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryDescriptionEntryFormat1() : LibraryDescriptionEntryFormat1Context {
		var _localctx : LibraryDescriptionEntryFormat1Context = LibraryDescriptionEntryFormat1Context(context, state)
		enterRule(_localctx, 400, Rules.RULE_libraryDescriptionEntryFormat1.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3026
			match(LD) as Token
			this.state = 3027
			libraryName()
			this.state = 3028
			match(EXPORT) as Token
			this.state = 3030
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ATTRIBUTE) {
				if (true){
				this.state = 3029
				libraryAttributeClauseFormat1()
				}
			}

			this.state = 3033
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ENTRY_PROCEDURE) {
				if (true){
				this.state = 3032
				libraryEntryProcedureClauseFormat1()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryDescriptionEntryFormat2Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryDescriptionEntryFormat2.id
	        set(value) { throw RuntimeException() }
		fun LB() : TerminalNode? = getToken(Cobol85Parser.Tokens.LB.id, 0)
		fun findLibraryName() : LibraryNameContext? = getRuleContext(solver.getType("LibraryNameContext"),0)
		fun IMPORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.IMPORT.id, 0)
		fun findLibraryIsGlobalClause() : LibraryIsGlobalClauseContext? = getRuleContext(solver.getType("LibraryIsGlobalClauseContext"),0)
		fun findLibraryIsCommonClause() : LibraryIsCommonClauseContext? = getRuleContext(solver.getType("LibraryIsCommonClauseContext"),0)
		fun findLibraryAttributeClauseFormat2() : List<LibraryAttributeClauseFormat2Context> = getRuleContexts(solver.getType("LibraryAttributeClauseFormat2Context"))
		fun findLibraryAttributeClauseFormat2(i: Int) : LibraryAttributeClauseFormat2Context? = getRuleContext(solver.getType("LibraryAttributeClauseFormat2Context"),i)
		fun findLibraryEntryProcedureClauseFormat2() : List<LibraryEntryProcedureClauseFormat2Context> = getRuleContexts(solver.getType("LibraryEntryProcedureClauseFormat2Context"))
		fun findLibraryEntryProcedureClauseFormat2(i: Int) : LibraryEntryProcedureClauseFormat2Context? = getRuleContext(solver.getType("LibraryEntryProcedureClauseFormat2Context"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryDescriptionEntryFormat2(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryDescriptionEntryFormat2(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryDescriptionEntryFormat2(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryDescriptionEntryFormat2() : LibraryDescriptionEntryFormat2Context {
		var _localctx : LibraryDescriptionEntryFormat2Context = LibraryDescriptionEntryFormat2Context(context, state)
		enterRule(_localctx, 402, Rules.RULE_libraryDescriptionEntryFormat2.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3035
			match(LB) as Token
			this.state = 3036
			libraryName()
			this.state = 3037
			match(IMPORT) as Token
			this.state = 3039
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,365,context) ) {
			1   -> if (true){
			this.state = 3038
			libraryIsGlobalClause()
			}
			}
			this.state = 3042
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COMMON || _la==IS) {
				if (true){
				this.state = 3041
				libraryIsCommonClause()
				}
			}

			this.state = 3048
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==ATTRIBUTE || _la==ENTRY_PROCEDURE) {
				if (true){
				this.state = 3046
				errorHandler.sync(this)
				when (_input!!.LA(1)) {
				ATTRIBUTE  ->  /*LL1AltBlock*/{if (true){
				this.state = 3044
				libraryAttributeClauseFormat2()
				}}
				ENTRY_PROCEDURE  ->  /*LL1AltBlock*/{if (true){
				this.state = 3045
				libraryEntryProcedureClauseFormat2()
				}}
				else -> throw NoViableAltException(this)
				}
				}
				this.state = 3050
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryAttributeClauseFormat1Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryAttributeClauseFormat1.id
	        set(value) { throw RuntimeException() }
		fun ATTRIBUTE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ATTRIBUTE.id, 0)
		fun SHARING() : TerminalNode? = getToken(Cobol85Parser.Tokens.SHARING.id, 0)
		fun DONTCARE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DONTCARE.id, 0)
		fun PRIVATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PRIVATE.id, 0)
		fun SHAREDBYRUNUNIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.SHAREDBYRUNUNIT.id, 0)
		fun SHAREDBYALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.SHAREDBYALL.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryAttributeClauseFormat1(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryAttributeClauseFormat1(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryAttributeClauseFormat1(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryAttributeClauseFormat1() : LibraryAttributeClauseFormat1Context {
		var _localctx : LibraryAttributeClauseFormat1Context = LibraryAttributeClauseFormat1Context(context, state)
		enterRule(_localctx, 404, Rules.RULE_libraryAttributeClauseFormat1.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3051
			match(ATTRIBUTE) as Token
			this.state = 3057
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SHARING) {
				if (true){
				this.state = 3052
				match(SHARING) as Token
				this.state = 3054
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 3053
					match(IS) as Token
					}
				}

				this.state = 3056
				_la = _input!!.LA(1)
				if ( !(_la==DONTCARE || _la==PRIVATE || _la==SHAREDBYALL || _la==SHAREDBYRUNUNIT) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryAttributeClauseFormat2Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryAttributeClauseFormat2.id
	        set(value) { throw RuntimeException() }
		fun ATTRIBUTE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ATTRIBUTE.id, 0)
		fun findLibraryAttributeFunction() : LibraryAttributeFunctionContext? = getRuleContext(solver.getType("LibraryAttributeFunctionContext"),0)
		fun LIBACCESS() : TerminalNode? = getToken(Cobol85Parser.Tokens.LIBACCESS.id, 0)
		fun findLibraryAttributeParameter() : LibraryAttributeParameterContext? = getRuleContext(solver.getType("LibraryAttributeParameterContext"),0)
		fun findLibraryAttributeTitle() : LibraryAttributeTitleContext? = getRuleContext(solver.getType("LibraryAttributeTitleContext"),0)
		fun BYFUNCTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.BYFUNCTION.id, 0)
		fun BYTITLE() : TerminalNode? = getToken(Cobol85Parser.Tokens.BYTITLE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryAttributeClauseFormat2(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryAttributeClauseFormat2(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryAttributeClauseFormat2(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryAttributeClauseFormat2() : LibraryAttributeClauseFormat2Context {
		var _localctx : LibraryAttributeClauseFormat2Context = LibraryAttributeClauseFormat2Context(context, state)
		enterRule(_localctx, 406, Rules.RULE_libraryAttributeClauseFormat2.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3059
			match(ATTRIBUTE) as Token
			this.state = 3061
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FUNCTIONNAME) {
				if (true){
				this.state = 3060
				libraryAttributeFunction()
				}
			}

			this.state = 3068
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LIBACCESS) {
				if (true){
				this.state = 3063
				match(LIBACCESS) as Token
				this.state = 3065
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 3064
					match(IS) as Token
					}
				}

				this.state = 3067
				_la = _input!!.LA(1)
				if ( !(_la==BYFUNCTION || _la==BYTITLE) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			this.state = 3071
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LIBPARAMETER) {
				if (true){
				this.state = 3070
				libraryAttributeParameter()
				}
			}

			this.state = 3074
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TITLE) {
				if (true){
				this.state = 3073
				libraryAttributeTitle()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryAttributeFunctionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryAttributeFunction.id
	        set(value) { throw RuntimeException() }
		fun FUNCTIONNAME() : TerminalNode? = getToken(Cobol85Parser.Tokens.FUNCTIONNAME.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryAttributeFunction(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryAttributeFunction(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryAttributeFunction(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryAttributeFunction() : LibraryAttributeFunctionContext {
		var _localctx : LibraryAttributeFunctionContext = LibraryAttributeFunctionContext(context, state)
		enterRule(_localctx, 408, Rules.RULE_libraryAttributeFunction.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3076
			match(FUNCTIONNAME) as Token
			this.state = 3077
			match(IS) as Token
			this.state = 3078
			literal()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryAttributeParameterContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryAttributeParameter.id
	        set(value) { throw RuntimeException() }
		fun LIBPARAMETER() : TerminalNode? = getToken(Cobol85Parser.Tokens.LIBPARAMETER.id, 0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryAttributeParameter(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryAttributeParameter(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryAttributeParameter(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryAttributeParameter() : LibraryAttributeParameterContext {
		var _localctx : LibraryAttributeParameterContext = LibraryAttributeParameterContext(context, state)
		enterRule(_localctx, 410, Rules.RULE_libraryAttributeParameter.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3080
			match(LIBPARAMETER) as Token
			this.state = 3082
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 3081
				match(IS) as Token
				}
			}

			this.state = 3084
			literal()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryAttributeTitleContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryAttributeTitle.id
	        set(value) { throw RuntimeException() }
		fun TITLE() : TerminalNode? = getToken(Cobol85Parser.Tokens.TITLE.id, 0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryAttributeTitle(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryAttributeTitle(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryAttributeTitle(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryAttributeTitle() : LibraryAttributeTitleContext {
		var _localctx : LibraryAttributeTitleContext = LibraryAttributeTitleContext(context, state)
		enterRule(_localctx, 412, Rules.RULE_libraryAttributeTitle.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3086
			match(TITLE) as Token
			this.state = 3088
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 3087
				match(IS) as Token
				}
			}

			this.state = 3090
			literal()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryEntryProcedureClauseFormat1Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryEntryProcedureClauseFormat1.id
	        set(value) { throw RuntimeException() }
		fun ENTRY_PROCEDURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ENTRY_PROCEDURE.id, 0)
		fun findProgramName() : ProgramNameContext? = getRuleContext(solver.getType("ProgramNameContext"),0)
		fun findLibraryEntryProcedureForClause() : LibraryEntryProcedureForClauseContext? = getRuleContext(solver.getType("LibraryEntryProcedureForClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryEntryProcedureClauseFormat1(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryEntryProcedureClauseFormat1(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryEntryProcedureClauseFormat1(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryEntryProcedureClauseFormat1() : LibraryEntryProcedureClauseFormat1Context {
		var _localctx : LibraryEntryProcedureClauseFormat1Context = LibraryEntryProcedureClauseFormat1Context(context, state)
		enterRule(_localctx, 414, Rules.RULE_libraryEntryProcedureClauseFormat1.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3092
			match(ENTRY_PROCEDURE) as Token
			this.state = 3093
			programName()
			this.state = 3095
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 3094
				libraryEntryProcedureForClause()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryEntryProcedureClauseFormat2Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryEntryProcedureClauseFormat2.id
	        set(value) { throw RuntimeException() }
		fun ENTRY_PROCEDURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ENTRY_PROCEDURE.id, 0)
		fun findProgramName() : ProgramNameContext? = getRuleContext(solver.getType("ProgramNameContext"),0)
		fun findLibraryEntryProcedureForClause() : LibraryEntryProcedureForClauseContext? = getRuleContext(solver.getType("LibraryEntryProcedureForClauseContext"),0)
		fun findLibraryEntryProcedureWithClause() : LibraryEntryProcedureWithClauseContext? = getRuleContext(solver.getType("LibraryEntryProcedureWithClauseContext"),0)
		fun findLibraryEntryProcedureUsingClause() : LibraryEntryProcedureUsingClauseContext? = getRuleContext(solver.getType("LibraryEntryProcedureUsingClauseContext"),0)
		fun findLibraryEntryProcedureGivingClause() : LibraryEntryProcedureGivingClauseContext? = getRuleContext(solver.getType("LibraryEntryProcedureGivingClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryEntryProcedureClauseFormat2(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryEntryProcedureClauseFormat2(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryEntryProcedureClauseFormat2(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryEntryProcedureClauseFormat2() : LibraryEntryProcedureClauseFormat2Context {
		var _localctx : LibraryEntryProcedureClauseFormat2Context = LibraryEntryProcedureClauseFormat2Context(context, state)
		enterRule(_localctx, 416, Rules.RULE_libraryEntryProcedureClauseFormat2.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3097
			match(ENTRY_PROCEDURE) as Token
			this.state = 3098
			programName()
			this.state = 3100
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 3099
				libraryEntryProcedureForClause()
				}
			}

			this.state = 3103
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 3102
				libraryEntryProcedureWithClause()
				}
			}

			this.state = 3106
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==USING) {
				if (true){
				this.state = 3105
				libraryEntryProcedureUsingClause()
				}
			}

			this.state = 3109
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==GIVING) {
				if (true){
				this.state = 3108
				libraryEntryProcedureGivingClause()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryEntryProcedureForClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryEntryProcedureForClause.id
	        set(value) { throw RuntimeException() }
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryEntryProcedureForClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryEntryProcedureForClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryEntryProcedureForClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryEntryProcedureForClause() : LibraryEntryProcedureForClauseContext {
		var _localctx : LibraryEntryProcedureForClauseContext = LibraryEntryProcedureForClauseContext(context, state)
		enterRule(_localctx, 418, Rules.RULE_libraryEntryProcedureForClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3111
			match(FOR) as Token
			this.state = 3112
			literal()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryEntryProcedureGivingClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryEntryProcedureGivingClause.id
	        set(value) { throw RuntimeException() }
		fun GIVING() : TerminalNode? = getToken(Cobol85Parser.Tokens.GIVING.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryEntryProcedureGivingClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryEntryProcedureGivingClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryEntryProcedureGivingClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryEntryProcedureGivingClause() : LibraryEntryProcedureGivingClauseContext {
		var _localctx : LibraryEntryProcedureGivingClauseContext = LibraryEntryProcedureGivingClauseContext(context, state)
		enterRule(_localctx, 420, Rules.RULE_libraryEntryProcedureGivingClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3114
			match(GIVING) as Token
			this.state = 3115
			dataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryEntryProcedureUsingClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryEntryProcedureUsingClause.id
	        set(value) { throw RuntimeException() }
		fun USING() : TerminalNode? = getToken(Cobol85Parser.Tokens.USING.id, 0)
		fun findLibraryEntryProcedureUsingName() : List<LibraryEntryProcedureUsingNameContext> = getRuleContexts(solver.getType("LibraryEntryProcedureUsingNameContext"))
		fun findLibraryEntryProcedureUsingName(i: Int) : LibraryEntryProcedureUsingNameContext? = getRuleContext(solver.getType("LibraryEntryProcedureUsingNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryEntryProcedureUsingClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryEntryProcedureUsingClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryEntryProcedureUsingClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryEntryProcedureUsingClause() : LibraryEntryProcedureUsingClauseContext {
		var _localctx : LibraryEntryProcedureUsingClauseContext = LibraryEntryProcedureUsingClauseContext(context, state)
		enterRule(_localctx, 422, Rules.RULE_libraryEntryProcedureUsingClause.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3117
			match(USING) as Token
			this.state = 3119 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 3118
				libraryEntryProcedureUsingName()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 3121 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,383,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryEntryProcedureUsingNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryEntryProcedureUsingName.id
	        set(value) { throw RuntimeException() }
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryEntryProcedureUsingName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryEntryProcedureUsingName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryEntryProcedureUsingName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryEntryProcedureUsingName() : LibraryEntryProcedureUsingNameContext {
		var _localctx : LibraryEntryProcedureUsingNameContext = LibraryEntryProcedureUsingNameContext(context, state)
		enterRule(_localctx, 424, Rules.RULE_libraryEntryProcedureUsingName.id)
		try {
			this.state = 3125
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,384,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3123
			dataName()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3124
			fileName()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryEntryProcedureWithClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryEntryProcedureWithClause.id
	        set(value) { throw RuntimeException() }
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		fun findLibraryEntryProcedureWithName() : List<LibraryEntryProcedureWithNameContext> = getRuleContexts(solver.getType("LibraryEntryProcedureWithNameContext"))
		fun findLibraryEntryProcedureWithName(i: Int) : LibraryEntryProcedureWithNameContext? = getRuleContext(solver.getType("LibraryEntryProcedureWithNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryEntryProcedureWithClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryEntryProcedureWithClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryEntryProcedureWithClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryEntryProcedureWithClause() : LibraryEntryProcedureWithClauseContext {
		var _localctx : LibraryEntryProcedureWithClauseContext = LibraryEntryProcedureWithClauseContext(context, state)
		enterRule(_localctx, 426, Rules.RULE_libraryEntryProcedureWithClause.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3127
			match(WITH) as Token
			this.state = 3129 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 3128
				libraryEntryProcedureWithName()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 3131 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,385,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryEntryProcedureWithNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryEntryProcedureWithName.id
	        set(value) { throw RuntimeException() }
		fun findLocalName() : LocalNameContext? = getRuleContext(solver.getType("LocalNameContext"),0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryEntryProcedureWithName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryEntryProcedureWithName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryEntryProcedureWithName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryEntryProcedureWithName() : LibraryEntryProcedureWithNameContext {
		var _localctx : LibraryEntryProcedureWithNameContext = LibraryEntryProcedureWithNameContext(context, state)
		enterRule(_localctx, 428, Rules.RULE_libraryEntryProcedureWithName.id)
		try {
			this.state = 3135
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,386,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3133
			localName()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3134
			fileName()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryIsCommonClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryIsCommonClause.id
	        set(value) { throw RuntimeException() }
		fun COMMON() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMMON.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryIsCommonClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryIsCommonClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryIsCommonClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryIsCommonClause() : LibraryIsCommonClauseContext {
		var _localctx : LibraryIsCommonClauseContext = LibraryIsCommonClauseContext(context, state)
		enterRule(_localctx, 430, Rules.RULE_libraryIsCommonClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3138
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 3137
				match(IS) as Token
				}
			}

			this.state = 3140
			match(COMMON) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryIsGlobalClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryIsGlobalClause.id
	        set(value) { throw RuntimeException() }
		fun GLOBAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.GLOBAL.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryIsGlobalClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryIsGlobalClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryIsGlobalClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryIsGlobalClause() : LibraryIsGlobalClauseContext {
		var _localctx : LibraryIsGlobalClauseContext = LibraryIsGlobalClauseContext(context, state)
		enterRule(_localctx, 432, Rules.RULE_libraryIsGlobalClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3143
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 3142
				match(IS) as Token
				}
			}

			this.state = 3145
			match(GLOBAL) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataDescriptionEntryContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataDescriptionEntry.id
	        set(value) { throw RuntimeException() }
		fun findDataDescriptionEntryFormat1() : DataDescriptionEntryFormat1Context? = getRuleContext(solver.getType("DataDescriptionEntryFormat1Context"),0)
		fun findDataDescriptionEntryFormat2() : DataDescriptionEntryFormat2Context? = getRuleContext(solver.getType("DataDescriptionEntryFormat2Context"),0)
		fun findDataDescriptionEntryFormat3() : DataDescriptionEntryFormat3Context? = getRuleContext(solver.getType("DataDescriptionEntryFormat3Context"),0)
		fun findDataDescriptionEntryExecSql() : DataDescriptionEntryExecSqlContext? = getRuleContext(solver.getType("DataDescriptionEntryExecSqlContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataDescriptionEntry(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataDescriptionEntry(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataDescriptionEntry(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataDescriptionEntry() : DataDescriptionEntryContext {
		var _localctx : DataDescriptionEntryContext = DataDescriptionEntryContext(context, state)
		enterRule(_localctx, 434, Rules.RULE_dataDescriptionEntry.id)
		try {
			this.state = 3151
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			LEVEL_NUMBER_77 , INTEGERLITERAL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3147
			dataDescriptionEntryFormat1()
			}}
			LEVEL_NUMBER_66  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3148
			dataDescriptionEntryFormat2()
			}}
			LEVEL_NUMBER_88  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 3149
			dataDescriptionEntryFormat3()
			}}
			EXECSQLLINE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 3150
			dataDescriptionEntryExecSql()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataDescriptionEntryFormat1Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataDescriptionEntryFormat1.id
	        set(value) { throw RuntimeException() }
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun INTEGERLITERAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTEGERLITERAL.id, 0)
		fun LEVEL_NUMBER_77() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEVEL_NUMBER_77.id, 0)
		fun FILLER() : TerminalNode? = getToken(Cobol85Parser.Tokens.FILLER.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun findDataRedefinesClause() : List<DataRedefinesClauseContext> = getRuleContexts(solver.getType("DataRedefinesClauseContext"))
		fun findDataRedefinesClause(i: Int) : DataRedefinesClauseContext? = getRuleContext(solver.getType("DataRedefinesClauseContext"),i)
		fun findDataIntegerStringClause() : List<DataIntegerStringClauseContext> = getRuleContexts(solver.getType("DataIntegerStringClauseContext"))
		fun findDataIntegerStringClause(i: Int) : DataIntegerStringClauseContext? = getRuleContext(solver.getType("DataIntegerStringClauseContext"),i)
		fun findDataExternalClause() : List<DataExternalClauseContext> = getRuleContexts(solver.getType("DataExternalClauseContext"))
		fun findDataExternalClause(i: Int) : DataExternalClauseContext? = getRuleContext(solver.getType("DataExternalClauseContext"),i)
		fun findDataGlobalClause() : List<DataGlobalClauseContext> = getRuleContexts(solver.getType("DataGlobalClauseContext"))
		fun findDataGlobalClause(i: Int) : DataGlobalClauseContext? = getRuleContext(solver.getType("DataGlobalClauseContext"),i)
		fun findDataTypeDefClause() : List<DataTypeDefClauseContext> = getRuleContexts(solver.getType("DataTypeDefClauseContext"))
		fun findDataTypeDefClause(i: Int) : DataTypeDefClauseContext? = getRuleContext(solver.getType("DataTypeDefClauseContext"),i)
		fun findDataThreadLocalClause() : List<DataThreadLocalClauseContext> = getRuleContexts(solver.getType("DataThreadLocalClauseContext"))
		fun findDataThreadLocalClause(i: Int) : DataThreadLocalClauseContext? = getRuleContext(solver.getType("DataThreadLocalClauseContext"),i)
		fun findDataPictureClause() : List<DataPictureClauseContext> = getRuleContexts(solver.getType("DataPictureClauseContext"))
		fun findDataPictureClause(i: Int) : DataPictureClauseContext? = getRuleContext(solver.getType("DataPictureClauseContext"),i)
		fun findDataCommonOwnLocalClause() : List<DataCommonOwnLocalClauseContext> = getRuleContexts(solver.getType("DataCommonOwnLocalClauseContext"))
		fun findDataCommonOwnLocalClause(i: Int) : DataCommonOwnLocalClauseContext? = getRuleContext(solver.getType("DataCommonOwnLocalClauseContext"),i)
		fun findDataTypeClause() : List<DataTypeClauseContext> = getRuleContexts(solver.getType("DataTypeClauseContext"))
		fun findDataTypeClause(i: Int) : DataTypeClauseContext? = getRuleContext(solver.getType("DataTypeClauseContext"),i)
		fun findDataUsingClause() : List<DataUsingClauseContext> = getRuleContexts(solver.getType("DataUsingClauseContext"))
		fun findDataUsingClause(i: Int) : DataUsingClauseContext? = getRuleContext(solver.getType("DataUsingClauseContext"),i)
		fun findDataUsageClause() : List<DataUsageClauseContext> = getRuleContexts(solver.getType("DataUsageClauseContext"))
		fun findDataUsageClause(i: Int) : DataUsageClauseContext? = getRuleContext(solver.getType("DataUsageClauseContext"),i)
		fun findDataValueClause() : List<DataValueClauseContext> = getRuleContexts(solver.getType("DataValueClauseContext"))
		fun findDataValueClause(i: Int) : DataValueClauseContext? = getRuleContext(solver.getType("DataValueClauseContext"),i)
		fun findDataReceivedByClause() : List<DataReceivedByClauseContext> = getRuleContexts(solver.getType("DataReceivedByClauseContext"))
		fun findDataReceivedByClause(i: Int) : DataReceivedByClauseContext? = getRuleContext(solver.getType("DataReceivedByClauseContext"),i)
		fun findDataOccursClause() : List<DataOccursClauseContext> = getRuleContexts(solver.getType("DataOccursClauseContext"))
		fun findDataOccursClause(i: Int) : DataOccursClauseContext? = getRuleContext(solver.getType("DataOccursClauseContext"),i)
		fun findDataSignClause() : List<DataSignClauseContext> = getRuleContexts(solver.getType("DataSignClauseContext"))
		fun findDataSignClause(i: Int) : DataSignClauseContext? = getRuleContext(solver.getType("DataSignClauseContext"),i)
		fun findDataSynchronizedClause() : List<DataSynchronizedClauseContext> = getRuleContexts(solver.getType("DataSynchronizedClauseContext"))
		fun findDataSynchronizedClause(i: Int) : DataSynchronizedClauseContext? = getRuleContext(solver.getType("DataSynchronizedClauseContext"),i)
		fun findDataJustifiedClause() : List<DataJustifiedClauseContext> = getRuleContexts(solver.getType("DataJustifiedClauseContext"))
		fun findDataJustifiedClause(i: Int) : DataJustifiedClauseContext? = getRuleContext(solver.getType("DataJustifiedClauseContext"),i)
		fun findDataBlankWhenZeroClause() : List<DataBlankWhenZeroClauseContext> = getRuleContexts(solver.getType("DataBlankWhenZeroClauseContext"))
		fun findDataBlankWhenZeroClause(i: Int) : DataBlankWhenZeroClauseContext? = getRuleContext(solver.getType("DataBlankWhenZeroClauseContext"),i)
		fun findDataWithLowerBoundsClause() : List<DataWithLowerBoundsClauseContext> = getRuleContexts(solver.getType("DataWithLowerBoundsClauseContext"))
		fun findDataWithLowerBoundsClause(i: Int) : DataWithLowerBoundsClauseContext? = getRuleContext(solver.getType("DataWithLowerBoundsClauseContext"),i)
		fun findDataAlignedClause() : List<DataAlignedClauseContext> = getRuleContexts(solver.getType("DataAlignedClauseContext"))
		fun findDataAlignedClause(i: Int) : DataAlignedClauseContext? = getRuleContext(solver.getType("DataAlignedClauseContext"),i)
		fun findDataRecordAreaClause() : List<DataRecordAreaClauseContext> = getRuleContexts(solver.getType("DataRecordAreaClauseContext"))
		fun findDataRecordAreaClause(i: Int) : DataRecordAreaClauseContext? = getRuleContext(solver.getType("DataRecordAreaClauseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataDescriptionEntryFormat1(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataDescriptionEntryFormat1(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataDescriptionEntryFormat1(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataDescriptionEntryFormat1() : DataDescriptionEntryFormat1Context {
		var _localctx : DataDescriptionEntryFormat1Context = DataDescriptionEntryFormat1Context(context, state)
		enterRule(_localctx, 436, Rules.RULE_dataDescriptionEntryFormat1.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3153
			_la = _input!!.LA(1)
			if ( !(_la==LEVEL_NUMBER_77 || _la==INTEGERLITERAL) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3156
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,390,context) ) {
			1   -> if (true){
			this.state = 3154
			match(FILLER) as Token
			}
			2   -> if (true){
			this.state = 3155
			dataName()
			}
			}
			this.state = 3181
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ALIGNED) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLANK) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl BY) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (COMMON - 68)) or (1L shl (COMP - 68)) or (1L shl (COMP_1 - 68)) or (1L shl (COMP_2 - 68)) or (1L shl (COMP_3 - 68)) or (1L shl (COMP_4 - 68)) or (1L shl (COMP_5 - 68)) or (1L shl (COMPUTATIONAL - 68)) or (1L shl (COMPUTATIONAL_1 - 68)) or (1L shl (COMPUTATIONAL_2 - 68)) or (1L shl (COMPUTATIONAL_3 - 68)) or (1L shl (COMPUTATIONAL_4 - 68)) or (1L shl (COMPUTATIONAL_5 - 68)) or (1L shl (CONTENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DISPLAY - 138)) or (1L shl (DISPLAY_1 - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (EXTERNAL - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GLOBAL - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INDEX - 202)) or (1L shl (INTEGER - 202)) or (1L shl (IS - 202)) or (1L shl (JUST - 202)) or (1L shl (JUSTIFIED - 202)) or (1L shl (KANJI - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 266)) and 0x3f.inv()) == 0 && ((1L shl (_la - 266)) and ((1L shl (LEADING - 266)) or (1L shl (LEFTLINE - 266)) or (1L shl (LENGTH_CHECK - 266)) or (1L shl (LIBACCESS - 266)) or (1L shl (LIBPARAMETER - 266)) or (1L shl (LIBRARY - 266)) or (1L shl (LIST - 266)) or (1L shl (LOCAL - 266)) or (1L shl (LOCK - 266)) or (1L shl (LONG_DATE - 266)) or (1L shl (LONG_TIME - 266)) or (1L shl (LOWER - 266)) or (1L shl (LOWLIGHT - 266)) or (1L shl (LOW_VALUE - 266)) or (1L shl (LOW_VALUES - 266)) or (1L shl (MMDDYYYY - 266)) or (1L shl (NAMED - 266)) or (1L shl (NATIONAL - 266)) or (1L shl (NATIONAL_EDITED - 266)) or (1L shl (NETWORK - 266)) or (1L shl (NO_ECHO - 266)) or (1L shl (NULL - 266)) or (1L shl (NULLS - 266)) or (1L shl (NUMERIC_DATE - 266)) or (1L shl (NUMERIC_TIME - 266)) or (1L shl (OCCURS - 266)) or (1L shl (ODT - 266)))) != 0L) || ((((_la - 331)) and 0x3f.inv()) == 0 && ((1L shl (_la - 331)) and ((1L shl (ORDERLY - 331)) or (1L shl (OVERLINE - 331)) or (1L shl (OWN - 331)) or (1L shl (PACKED_DECIMAL - 331)) or (1L shl (PASSWORD - 331)) or (1L shl (PIC - 331)) or (1L shl (PICTURE - 331)) or (1L shl (POINTER - 331)) or (1L shl (PORT - 331)) or (1L shl (PRINTER - 331)) or (1L shl (PRIVATE - 331)) or (1L shl (PROCEDURE_POINTER - 331)) or (1L shl (PROCESS - 331)) or (1L shl (PROGRAM - 331)) or (1L shl (PROMPT - 331)) or (1L shl (QUOTE - 331)) or (1L shl (QUOTES - 331)) or (1L shl (READER - 331)) or (1L shl (REMOTE - 331)) or (1L shl (REAL - 331)) or (1L shl (RECEIVED - 331)) or (1L shl (RECORD - 331)) or (1L shl (RECURSIVE - 331)) or (1L shl (REDEFINES - 331)) or (1L shl (REF - 331)) or (1L shl (REFERENCE - 331)) or (1L shl (REMOVE - 331)))) != 0L) || ((((_la - 398)) and 0x3f.inv()) == 0 && ((1L shl (_la - 398)) and ((1L shl (REQUIRED - 398)) or (1L shl (REVERSE_VIDEO - 398)) or (1L shl (SAVE - 398)) or (1L shl (SECURE - 398)) or (1L shl (SHARED - 398)) or (1L shl (SHAREDBYALL - 398)) or (1L shl (SHAREDBYRUNUNIT - 398)) or (1L shl (SHARING - 398)) or (1L shl (SHORT_DATE - 398)) or (1L shl (SIGN - 398)) or (1L shl (SPACE - 398)) or (1L shl (SPACES - 398)) or (1L shl (STRING - 398)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (SYNC - 466)) or (1L shl (SYNCHRONIZED - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRAILING - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPE - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (USAGE - 466)) or (1L shl (USING - 466)) or (1L shl (VALUE - 466)) or (1L shl (VALUES - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WITH - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)))) != 0L) || ((((_la - 551)) and 0x3f.inv()) == 0 && ((1L shl (_la - 551)) and ((1L shl (NONNUMERICLITERAL - 551)) or (1L shl (LEVEL_NUMBER_66 - 551)) or (1L shl (LEVEL_NUMBER_77 - 551)) or (1L shl (LEVEL_NUMBER_88 - 551)) or (1L shl (INTEGERLITERAL - 551)) or (1L shl (NUMERICLITERAL - 551)) or (1L shl (IDENTIFIER - 551)))) != 0L)) {
				if (true){
				this.state = 3179
				errorHandler.sync(this)
				when ( interpreter!!.adaptivePredict(_input!!,391,context) ) {
				1 -> {if (true){
				this.state = 3158
				dataRedefinesClause()
				}}
				2 -> {if (true){
				this.state = 3159
				dataIntegerStringClause()
				}}
				3 -> {if (true){
				this.state = 3160
				dataExternalClause()
				}}
				4 -> {if (true){
				this.state = 3161
				dataGlobalClause()
				}}
				5 -> {if (true){
				this.state = 3162
				dataTypeDefClause()
				}}
				6 -> {if (true){
				this.state = 3163
				dataThreadLocalClause()
				}}
				7 -> {if (true){
				this.state = 3164
				dataPictureClause()
				}}
				8 -> {if (true){
				this.state = 3165
				dataCommonOwnLocalClause()
				}}
				9 -> {if (true){
				this.state = 3166
				dataTypeClause()
				}}
				10 -> {if (true){
				this.state = 3167
				dataUsingClause()
				}}
				11 -> {if (true){
				this.state = 3168
				dataUsageClause()
				}}
				12 -> {if (true){
				this.state = 3169
				dataValueClause()
				}}
				13 -> {if (true){
				this.state = 3170
				dataReceivedByClause()
				}}
				14 -> {if (true){
				this.state = 3171
				dataOccursClause()
				}}
				15 -> {if (true){
				this.state = 3172
				dataSignClause()
				}}
				16 -> {if (true){
				this.state = 3173
				dataSynchronizedClause()
				}}
				17 -> {if (true){
				this.state = 3174
				dataJustifiedClause()
				}}
				18 -> {if (true){
				this.state = 3175
				dataBlankWhenZeroClause()
				}}
				19 -> {if (true){
				this.state = 3176
				dataWithLowerBoundsClause()
				}}
				20 -> {if (true){
				this.state = 3177
				dataAlignedClause()
				}}
				21 -> {if (true){
				this.state = 3178
				dataRecordAreaClause()
				}}
				}
				}
				this.state = 3183
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 3184
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataDescriptionEntryFormat2Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataDescriptionEntryFormat2.id
	        set(value) { throw RuntimeException() }
		fun LEVEL_NUMBER_66() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEVEL_NUMBER_66.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun findDataRenamesClause() : DataRenamesClauseContext? = getRuleContext(solver.getType("DataRenamesClauseContext"),0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataDescriptionEntryFormat2(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataDescriptionEntryFormat2(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataDescriptionEntryFormat2(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataDescriptionEntryFormat2() : DataDescriptionEntryFormat2Context {
		var _localctx : DataDescriptionEntryFormat2Context = DataDescriptionEntryFormat2Context(context, state)
		enterRule(_localctx, 438, Rules.RULE_dataDescriptionEntryFormat2.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3186
			match(LEVEL_NUMBER_66) as Token
			this.state = 3187
			dataName()
			this.state = 3188
			dataRenamesClause()
			this.state = 3189
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataDescriptionEntryFormat3Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataDescriptionEntryFormat3.id
	        set(value) { throw RuntimeException() }
		fun LEVEL_NUMBER_88() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEVEL_NUMBER_88.id, 0)
		fun findConditionName() : ConditionNameContext? = getRuleContext(solver.getType("ConditionNameContext"),0)
		fun findDataValueClause() : DataValueClauseContext? = getRuleContext(solver.getType("DataValueClauseContext"),0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataDescriptionEntryFormat3(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataDescriptionEntryFormat3(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataDescriptionEntryFormat3(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataDescriptionEntryFormat3() : DataDescriptionEntryFormat3Context {
		var _localctx : DataDescriptionEntryFormat3Context = DataDescriptionEntryFormat3Context(context, state)
		enterRule(_localctx, 440, Rules.RULE_dataDescriptionEntryFormat3.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3191
			match(LEVEL_NUMBER_88) as Token
			this.state = 3192
			conditionName()
			this.state = 3193
			dataValueClause()
			this.state = 3194
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataDescriptionEntryExecSqlContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataDescriptionEntryExecSql.id
	        set(value) { throw RuntimeException() }
		fun EXECSQLLINE() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.EXECSQLLINE.id)
		fun EXECSQLLINE(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.EXECSQLLINE.id, i) as TerminalNode
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataDescriptionEntryExecSql(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataDescriptionEntryExecSql(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataDescriptionEntryExecSql(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataDescriptionEntryExecSql() : DataDescriptionEntryExecSqlContext {
		var _localctx : DataDescriptionEntryExecSqlContext = DataDescriptionEntryExecSqlContext(context, state)
		enterRule(_localctx, 442, Rules.RULE_dataDescriptionEntryExecSql.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3197 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 3196
				match(EXECSQLLINE) as Token
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 3199 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,393,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			this.state = 3202
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DOT_FS) {
				if (true){
				this.state = 3201
				match(DOT_FS) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataAlignedClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataAlignedClause.id
	        set(value) { throw RuntimeException() }
		fun ALIGNED() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALIGNED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataAlignedClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataAlignedClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataAlignedClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataAlignedClause() : DataAlignedClauseContext {
		var _localctx : DataAlignedClauseContext = DataAlignedClauseContext(context, state)
		enterRule(_localctx, 444, Rules.RULE_dataAlignedClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3204
			match(ALIGNED) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataBlankWhenZeroClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataBlankWhenZeroClause.id
	        set(value) { throw RuntimeException() }
		fun BLANK() : TerminalNode? = getToken(Cobol85Parser.Tokens.BLANK.id, 0)
		fun ZERO() : TerminalNode? = getToken(Cobol85Parser.Tokens.ZERO.id, 0)
		fun ZEROS() : TerminalNode? = getToken(Cobol85Parser.Tokens.ZEROS.id, 0)
		fun ZEROES() : TerminalNode? = getToken(Cobol85Parser.Tokens.ZEROES.id, 0)
		fun WHEN() : TerminalNode? = getToken(Cobol85Parser.Tokens.WHEN.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataBlankWhenZeroClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataBlankWhenZeroClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataBlankWhenZeroClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataBlankWhenZeroClause() : DataBlankWhenZeroClauseContext {
		var _localctx : DataBlankWhenZeroClauseContext = DataBlankWhenZeroClauseContext(context, state)
		enterRule(_localctx, 446, Rules.RULE_dataBlankWhenZeroClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3206
			match(BLANK) as Token
			this.state = 3208
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WHEN) {
				if (true){
				this.state = 3207
				match(WHEN) as Token
				}
			}

			this.state = 3210
			_la = _input!!.LA(1)
			if ( !(((((_la - 521)) and 0x3f.inv()) == 0 && ((1L shl (_la - 521)) and ((1L shl (ZERO - 521)) or (1L shl (ZEROS - 521)) or (1L shl (ZEROES - 521)))) != 0L)) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataCommonOwnLocalClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataCommonOwnLocalClause.id
	        set(value) { throw RuntimeException() }
		fun COMMON() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMMON.id, 0)
		fun OWN() : TerminalNode? = getToken(Cobol85Parser.Tokens.OWN.id, 0)
		fun LOCAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOCAL.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataCommonOwnLocalClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataCommonOwnLocalClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataCommonOwnLocalClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataCommonOwnLocalClause() : DataCommonOwnLocalClauseContext {
		var _localctx : DataCommonOwnLocalClauseContext = DataCommonOwnLocalClauseContext(context, state)
		enterRule(_localctx, 448, Rules.RULE_dataCommonOwnLocalClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3212
			_la = _input!!.LA(1)
			if ( !(_la==COMMON || _la==LOCAL || _la==OWN) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataExternalClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataExternalClause.id
	        set(value) { throw RuntimeException() }
		fun EXTERNAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXTERNAL.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataExternalClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataExternalClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataExternalClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataExternalClause() : DataExternalClauseContext {
		var _localctx : DataExternalClauseContext = DataExternalClauseContext(context, state)
		enterRule(_localctx, 450, Rules.RULE_dataExternalClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3215
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 3214
				match(IS) as Token
				}
			}

			this.state = 3217
			match(EXTERNAL) as Token
			this.state = 3220
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,397,context) ) {
			1   -> if (true){
			this.state = 3218
			match(BY) as Token
			this.state = 3219
			literal()
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataGlobalClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataGlobalClause.id
	        set(value) { throw RuntimeException() }
		fun GLOBAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.GLOBAL.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataGlobalClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataGlobalClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataGlobalClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataGlobalClause() : DataGlobalClauseContext {
		var _localctx : DataGlobalClauseContext = DataGlobalClauseContext(context, state)
		enterRule(_localctx, 452, Rules.RULE_dataGlobalClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3223
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 3222
				match(IS) as Token
				}
			}

			this.state = 3225
			match(GLOBAL) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataIntegerStringClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataIntegerStringClause.id
	        set(value) { throw RuntimeException() }
		fun INTEGER() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTEGER.id, 0)
		fun STRING() : TerminalNode? = getToken(Cobol85Parser.Tokens.STRING.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataIntegerStringClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataIntegerStringClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataIntegerStringClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataIntegerStringClause() : DataIntegerStringClauseContext {
		var _localctx : DataIntegerStringClauseContext = DataIntegerStringClauseContext(context, state)
		enterRule(_localctx, 454, Rules.RULE_dataIntegerStringClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3227
			_la = _input!!.LA(1)
			if ( !(_la==INTEGER || _la==STRING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataJustifiedClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataJustifiedClause.id
	        set(value) { throw RuntimeException() }
		fun JUSTIFIED() : TerminalNode? = getToken(Cobol85Parser.Tokens.JUSTIFIED.id, 0)
		fun JUST() : TerminalNode? = getToken(Cobol85Parser.Tokens.JUST.id, 0)
		fun RIGHT() : TerminalNode? = getToken(Cobol85Parser.Tokens.RIGHT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataJustifiedClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataJustifiedClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataJustifiedClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataJustifiedClause() : DataJustifiedClauseContext {
		var _localctx : DataJustifiedClauseContext = DataJustifiedClauseContext(context, state)
		enterRule(_localctx, 456, Rules.RULE_dataJustifiedClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3229
			_la = _input!!.LA(1)
			if ( !(_la==JUST || _la==JUSTIFIED) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3231
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==RIGHT) {
				if (true){
				this.state = 3230
				match(RIGHT) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataOccursClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataOccursClause.id
	        set(value) { throw RuntimeException() }
		fun OCCURS() : TerminalNode? = getToken(Cobol85Parser.Tokens.OCCURS.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun findDataOccursTo() : DataOccursToContext? = getRuleContext(solver.getType("DataOccursToContext"),0)
		fun TIMES() : TerminalNode? = getToken(Cobol85Parser.Tokens.TIMES.id, 0)
		fun DEPENDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEPENDING.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun findDataOccursSort() : List<DataOccursSortContext> = getRuleContexts(solver.getType("DataOccursSortContext"))
		fun findDataOccursSort(i: Int) : DataOccursSortContext? = getRuleContext(solver.getType("DataOccursSortContext"),i)
		fun INDEXED() : TerminalNode? = getToken(Cobol85Parser.Tokens.INDEXED.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun LOCAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOCAL.id, 0)
		fun findIndexName() : List<IndexNameContext> = getRuleContexts(solver.getType("IndexNameContext"))
		fun findIndexName(i: Int) : IndexNameContext? = getRuleContext(solver.getType("IndexNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataOccursClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataOccursClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataOccursClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataOccursClause() : DataOccursClauseContext {
		var _localctx : DataOccursClauseContext = DataOccursClauseContext(context, state)
		enterRule(_localctx, 458, Rules.RULE_dataOccursClause.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3233
			match(OCCURS) as Token
			this.state = 3234
			integerLiteral()
			this.state = 3236
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TO) {
				if (true){
				this.state = 3235
				dataOccursTo()
				}
			}

			this.state = 3239
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TIMES) {
				if (true){
				this.state = 3238
				match(TIMES) as Token
				}
			}

			this.state = 3246
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DEPENDING) {
				if (true){
				this.state = 3241
				match(DEPENDING) as Token
				this.state = 3243
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==ON) {
					if (true){
					this.state = 3242
					match(ON) as Token
					}
				}

				this.state = 3245
				qualifiedDataName()
				}
			}

			this.state = 3251
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==ASCENDING || _la==DESCENDING) {
				if (true){
				if (true){
				this.state = 3248
				dataOccursSort()
				}
				}
				this.state = 3253
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 3266
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==INDEXED) {
				if (true){
				this.state = 3254
				match(INDEXED) as Token
				this.state = 3256
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==BY) {
					if (true){
					this.state = 3255
					match(BY) as Token
					}
				}

				this.state = 3259
				errorHandler.sync(this)
				when ( interpreter!!.adaptivePredict(_input!!,406,context) ) {
				1   -> if (true){
				this.state = 3258
				match(LOCAL) as Token
				}
				}
				this.state = 3262 
				errorHandler.sync(this)
				_alt = 1
				do {
					when (_alt) {
					    1 -> if (true){
					if (true){
					this.state = 3261
					indexName()
					}
					}
					else -> throw NoViableAltException(this)
					}
					this.state = 3264 
					errorHandler.sync(this)
					_alt = interpreter!!.adaptivePredict(_input!!,407,context)
				} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataOccursToContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataOccursTo.id
	        set(value) { throw RuntimeException() }
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataOccursTo(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataOccursTo(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataOccursTo(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataOccursTo() : DataOccursToContext {
		var _localctx : DataOccursToContext = DataOccursToContext(context, state)
		enterRule(_localctx, 460, Rules.RULE_dataOccursTo.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3268
			match(TO) as Token
			this.state = 3269
			integerLiteral()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataOccursSortContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataOccursSort.id
	        set(value) { throw RuntimeException() }
		fun ASCENDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.ASCENDING.id, 0)
		fun DESCENDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.DESCENDING.id, 0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findQualifiedDataName() : List<QualifiedDataNameContext> = getRuleContexts(solver.getType("QualifiedDataNameContext"))
		fun findQualifiedDataName(i: Int) : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataOccursSort(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataOccursSort(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataOccursSort(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataOccursSort() : DataOccursSortContext {
		var _localctx : DataOccursSortContext = DataOccursSortContext(context, state)
		enterRule(_localctx, 462, Rules.RULE_dataOccursSort.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3271
			_la = _input!!.LA(1)
			if ( !(_la==ASCENDING || _la==DESCENDING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3273
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==KEY) {
				if (true){
				this.state = 3272
				match(KEY) as Token
				}
			}

			this.state = 3276
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 3275
				match(IS) as Token
				}
			}

			this.state = 3279 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 3278
				qualifiedDataName()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 3281 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,411,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataPictureClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataPictureClause.id
	        set(value) { throw RuntimeException() }
		fun findPictureString() : PictureStringContext? = getRuleContext(solver.getType("PictureStringContext"),0)
		fun PICTURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PICTURE.id, 0)
		fun PIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.PIC.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataPictureClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataPictureClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataPictureClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataPictureClause() : DataPictureClauseContext {
		var _localctx : DataPictureClauseContext = DataPictureClauseContext(context, state)
		enterRule(_localctx, 464, Rules.RULE_dataPictureClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3283
			_la = _input!!.LA(1)
			if ( !(_la==PIC || _la==PICTURE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3285
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 3284
				match(IS) as Token
				}
			}

			this.state = 3287
			pictureString()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PictureStringContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_pictureString.id
	        set(value) { throw RuntimeException() }
		fun findPictureChars() : List<PictureCharsContext> = getRuleContexts(solver.getType("PictureCharsContext"))
		fun findPictureChars(i: Int) : PictureCharsContext? = getRuleContext(solver.getType("PictureCharsContext"),i)
		fun findPictureCardinality() : List<PictureCardinalityContext> = getRuleContexts(solver.getType("PictureCardinalityContext"))
		fun findPictureCardinality(i: Int) : PictureCardinalityContext? = getRuleContext(solver.getType("PictureCardinalityContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPictureString(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPictureString(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPictureString(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  pictureString() : PictureStringContext {
		var _localctx : PictureStringContext = PictureStringContext(context, state)
		enterRule(_localctx, 466, Rules.RULE_pictureString.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3297 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 3290 
				errorHandler.sync(this)
				_alt = 1
				do {
					when (_alt) {
					    1 -> if (true){
					if (true){
					this.state = 3289
					pictureChars()
					}
					}
					else -> throw NoViableAltException(this)
					}
					this.state = 3292 
					errorHandler.sync(this)
					_alt = interpreter!!.adaptivePredict(_input!!,413,context)
				} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
				this.state = 3295
				errorHandler.sync(this)
				when ( interpreter!!.adaptivePredict(_input!!,414,context) ) {
				1   -> if (true){
				this.state = 3294
				pictureCardinality()
				}
				}
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 3299 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,415,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PictureCharsContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_pictureChars.id
	        set(value) { throw RuntimeException() }
		fun DOLLARCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOLLARCHAR.id, 0)
		fun IDENTIFIER() : TerminalNode? = getToken(Cobol85Parser.Tokens.IDENTIFIER.id, 0)
		fun NUMERICLITERAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMERICLITERAL.id, 0)
		fun SLASHCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.SLASHCHAR.id, 0)
		fun COMMACHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMMACHAR.id, 0)
		fun DOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT.id, 0)
		fun COLONCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.COLONCHAR.id, 0)
		fun ASTERISKCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.ASTERISKCHAR.id, 0)
		fun DOUBLEASTERISKCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOUBLEASTERISKCHAR.id, 0)
		fun LPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LPARENCHAR.id, 0)
		fun RPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.RPARENCHAR.id, 0)
		fun PLUSCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.PLUSCHAR.id, 0)
		fun MINUSCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.MINUSCHAR.id, 0)
		fun LESSTHANCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LESSTHANCHAR.id, 0)
		fun MORETHANCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.MORETHANCHAR.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPictureChars(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPictureChars(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPictureChars(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  pictureChars() : PictureCharsContext {
		var _localctx : PictureCharsContext = PictureCharsContext(context, state)
		enterRule(_localctx, 468, Rules.RULE_pictureChars.id)
		try {
			this.state = 3317
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			DOLLARCHAR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3301
			match(DOLLARCHAR) as Token
			}}
			IDENTIFIER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3302
			match(IDENTIFIER) as Token
			}}
			NUMERICLITERAL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 3303
			match(NUMERICLITERAL) as Token
			}}
			SLASHCHAR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 3304
			match(SLASHCHAR) as Token
			}}
			COMMACHAR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 3305
			match(COMMACHAR) as Token
			}}
			DOT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 6)
			if (true){
			this.state = 3306
			match(DOT) as Token
			}}
			COLONCHAR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 7)
			if (true){
			this.state = 3307
			match(COLONCHAR) as Token
			}}
			ASTERISKCHAR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 8)
			if (true){
			this.state = 3308
			match(ASTERISKCHAR) as Token
			}}
			DOUBLEASTERISKCHAR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 9)
			if (true){
			this.state = 3309
			match(DOUBLEASTERISKCHAR) as Token
			}}
			LPARENCHAR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 10)
			if (true){
			this.state = 3310
			match(LPARENCHAR) as Token
			}}
			RPARENCHAR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 11)
			if (true){
			this.state = 3311
			match(RPARENCHAR) as Token
			}}
			PLUSCHAR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 12)
			if (true){
			this.state = 3312
			match(PLUSCHAR) as Token
			}}
			MINUSCHAR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 13)
			if (true){
			this.state = 3313
			match(MINUSCHAR) as Token
			}}
			LESSTHANCHAR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 14)
			if (true){
			this.state = 3314
			match(LESSTHANCHAR) as Token
			}}
			MORETHANCHAR  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 15)
			if (true){
			this.state = 3315
			match(MORETHANCHAR) as Token
			}}
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 16)
			if (true){
			this.state = 3316
			integerLiteral()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PictureCardinalityContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_pictureCardinality.id
	        set(value) { throw RuntimeException() }
		fun LPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LPARENCHAR.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun RPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.RPARENCHAR.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPictureCardinality(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPictureCardinality(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPictureCardinality(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  pictureCardinality() : PictureCardinalityContext {
		var _localctx : PictureCardinalityContext = PictureCardinalityContext(context, state)
		enterRule(_localctx, 470, Rules.RULE_pictureCardinality.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3319
			match(LPARENCHAR) as Token
			this.state = 3320
			integerLiteral()
			this.state = 3321
			match(RPARENCHAR) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataReceivedByClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataReceivedByClause.id
	        set(value) { throw RuntimeException() }
		fun CONTENT() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTENT.id, 0)
		fun REFERENCE() : TerminalNode? = getToken(Cobol85Parser.Tokens.REFERENCE.id, 0)
		fun REF() : TerminalNode? = getToken(Cobol85Parser.Tokens.REF.id, 0)
		fun RECEIVED() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECEIVED.id, 0)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataReceivedByClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataReceivedByClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataReceivedByClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataReceivedByClause() : DataReceivedByClauseContext {
		var _localctx : DataReceivedByClauseContext = DataReceivedByClauseContext(context, state)
		enterRule(_localctx, 472, Rules.RULE_dataReceivedByClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3324
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==RECEIVED) {
				if (true){
				this.state = 3323
				match(RECEIVED) as Token
				}
			}

			this.state = 3327
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==BY) {
				if (true){
				this.state = 3326
				match(BY) as Token
				}
			}

			this.state = 3329
			_la = _input!!.LA(1)
			if ( !(_la==CONTENT || _la==REF || _la==REFERENCE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataRecordAreaClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataRecordAreaClause.id
	        set(value) { throw RuntimeException() }
		fun RECORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORD.id, 0)
		fun AREA() : TerminalNode? = getToken(Cobol85Parser.Tokens.AREA.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataRecordAreaClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataRecordAreaClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataRecordAreaClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataRecordAreaClause() : DataRecordAreaClauseContext {
		var _localctx : DataRecordAreaClauseContext = DataRecordAreaClauseContext(context, state)
		enterRule(_localctx, 474, Rules.RULE_dataRecordAreaClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3331
			match(RECORD) as Token
			this.state = 3332
			match(AREA) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataRedefinesClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataRedefinesClause.id
	        set(value) { throw RuntimeException() }
		fun REDEFINES() : TerminalNode? = getToken(Cobol85Parser.Tokens.REDEFINES.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataRedefinesClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataRedefinesClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataRedefinesClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataRedefinesClause() : DataRedefinesClauseContext {
		var _localctx : DataRedefinesClauseContext = DataRedefinesClauseContext(context, state)
		enterRule(_localctx, 476, Rules.RULE_dataRedefinesClause.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3334
			match(REDEFINES) as Token
			this.state = 3335
			dataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataRenamesClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataRenamesClause.id
	        set(value) { throw RuntimeException() }
		fun RENAMES() : TerminalNode? = getToken(Cobol85Parser.Tokens.RENAMES.id, 0)
		fun findQualifiedDataName() : List<QualifiedDataNameContext> = getRuleContexts(solver.getType("QualifiedDataNameContext"))
		fun findQualifiedDataName(i: Int) : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),i)
		fun THROUGH() : TerminalNode? = getToken(Cobol85Parser.Tokens.THROUGH.id, 0)
		fun THRU() : TerminalNode? = getToken(Cobol85Parser.Tokens.THRU.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataRenamesClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataRenamesClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataRenamesClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataRenamesClause() : DataRenamesClauseContext {
		var _localctx : DataRenamesClauseContext = DataRenamesClauseContext(context, state)
		enterRule(_localctx, 478, Rules.RULE_dataRenamesClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3337
			match(RENAMES) as Token
			this.state = 3338
			qualifiedDataName()
			this.state = 3341
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THROUGH || _la==THRU) {
				if (true){
				this.state = 3339
				_la = _input!!.LA(1)
				if ( !(_la==THROUGH || _la==THRU) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				this.state = 3340
				qualifiedDataName()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataSignClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataSignClause.id
	        set(value) { throw RuntimeException() }
		fun LEADING() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEADING.id, 0)
		fun TRAILING() : TerminalNode? = getToken(Cobol85Parser.Tokens.TRAILING.id, 0)
		fun SIGN() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIGN.id, 0)
		fun SEPARATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEPARATE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun CHARACTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTER.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataSignClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataSignClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataSignClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataSignClause() : DataSignClauseContext {
		var _localctx : DataSignClauseContext = DataSignClauseContext(context, state)
		enterRule(_localctx, 480, Rules.RULE_dataSignClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3347
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SIGN) {
				if (true){
				this.state = 3343
				match(SIGN) as Token
				this.state = 3345
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 3344
					match(IS) as Token
					}
				}

				}
			}

			this.state = 3349
			_la = _input!!.LA(1)
			if ( !(_la==LEADING || _la==TRAILING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3354
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==SEPARATE) {
				if (true){
				this.state = 3350
				match(SEPARATE) as Token
				this.state = 3352
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==CHARACTER) {
					if (true){
					this.state = 3351
					match(CHARACTER) as Token
					}
				}

				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataSynchronizedClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataSynchronizedClause.id
	        set(value) { throw RuntimeException() }
		fun SYNCHRONIZED() : TerminalNode? = getToken(Cobol85Parser.Tokens.SYNCHRONIZED.id, 0)
		fun SYNC() : TerminalNode? = getToken(Cobol85Parser.Tokens.SYNC.id, 0)
		fun LEFT() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEFT.id, 0)
		fun RIGHT() : TerminalNode? = getToken(Cobol85Parser.Tokens.RIGHT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataSynchronizedClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataSynchronizedClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataSynchronizedClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataSynchronizedClause() : DataSynchronizedClauseContext {
		var _localctx : DataSynchronizedClauseContext = DataSynchronizedClauseContext(context, state)
		enterRule(_localctx, 482, Rules.RULE_dataSynchronizedClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3356
			_la = _input!!.LA(1)
			if ( !(_la==SYNC || _la==SYNCHRONIZED) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3358
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LEFT || _la==RIGHT) {
				if (true){
				this.state = 3357
				_la = _input!!.LA(1)
				if ( !(_la==LEFT || _la==RIGHT) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataThreadLocalClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataThreadLocalClause.id
	        set(value) { throw RuntimeException() }
		fun THREAD_LOCAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.THREAD_LOCAL.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataThreadLocalClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataThreadLocalClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataThreadLocalClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataThreadLocalClause() : DataThreadLocalClauseContext {
		var _localctx : DataThreadLocalClauseContext = DataThreadLocalClauseContext(context, state)
		enterRule(_localctx, 484, Rules.RULE_dataThreadLocalClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3361
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 3360
				match(IS) as Token
				}
			}

			this.state = 3363
			match(THREAD_LOCAL) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataTypeClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataTypeClause.id
	        set(value) { throw RuntimeException() }
		fun TYPE() : TerminalNode? = getToken(Cobol85Parser.Tokens.TYPE.id, 0)
		fun SHORT_DATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SHORT_DATE.id, 0)
		fun LONG_DATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LONG_DATE.id, 0)
		fun NUMERIC_DATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMERIC_DATE.id, 0)
		fun NUMERIC_TIME() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMERIC_TIME.id, 0)
		fun LONG_TIME() : TerminalNode? = getToken(Cobol85Parser.Tokens.LONG_TIME.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataTypeClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataTypeClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataTypeClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataTypeClause() : DataTypeClauseContext {
		var _localctx : DataTypeClauseContext = DataTypeClauseContext(context, state)
		enterRule(_localctx, 486, Rules.RULE_dataTypeClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3365
			match(TYPE) as Token
			this.state = 3367
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 3366
				match(IS) as Token
				}
			}

			this.state = 3369
			_la = _input!!.LA(1)
			if ( !(((((_la - 287)) and 0x3f.inv()) == 0 && ((1L shl (_la - 287)) and ((1L shl (LONG_DATE - 287)) or (1L shl (LONG_TIME - 287)) or (1L shl (NUMERIC_DATE - 287)) or (1L shl (NUMERIC_TIME - 287)))) != 0L) || _la==SHORT_DATE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataTypeDefClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataTypeDefClause.id
	        set(value) { throw RuntimeException() }
		fun TYPEDEF() : TerminalNode? = getToken(Cobol85Parser.Tokens.TYPEDEF.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataTypeDefClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataTypeDefClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataTypeDefClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataTypeDefClause() : DataTypeDefClauseContext {
		var _localctx : DataTypeDefClauseContext = DataTypeDefClauseContext(context, state)
		enterRule(_localctx, 488, Rules.RULE_dataTypeDefClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3372
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 3371
				match(IS) as Token
				}
			}

			this.state = 3374
			match(TYPEDEF) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataUsageClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataUsageClause.id
	        set(value) { throw RuntimeException() }
		fun BINARY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BINARY.id, 0)
		fun BIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.BIT.id, 0)
		fun COMP() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMP.id, 0)
		fun COMP_1() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMP_1.id, 0)
		fun COMP_2() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMP_2.id, 0)
		fun COMP_3() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMP_3.id, 0)
		fun COMP_4() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMP_4.id, 0)
		fun COMP_5() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMP_5.id, 0)
		fun COMPUTATIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMPUTATIONAL.id, 0)
		fun COMPUTATIONAL_1() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMPUTATIONAL_1.id, 0)
		fun COMPUTATIONAL_2() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMPUTATIONAL_2.id, 0)
		fun COMPUTATIONAL_3() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMPUTATIONAL_3.id, 0)
		fun COMPUTATIONAL_4() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMPUTATIONAL_4.id, 0)
		fun COMPUTATIONAL_5() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMPUTATIONAL_5.id, 0)
		fun CONTROL_POINT() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTROL_POINT.id, 0)
		fun DATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DATE.id, 0)
		fun DISPLAY() : TerminalNode? = getToken(Cobol85Parser.Tokens.DISPLAY.id, 0)
		fun DISPLAY_1() : TerminalNode? = getToken(Cobol85Parser.Tokens.DISPLAY_1.id, 0)
		fun DOUBLE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOUBLE.id, 0)
		fun EVENT() : TerminalNode? = getToken(Cobol85Parser.Tokens.EVENT.id, 0)
		fun FUNCTION_POINTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.FUNCTION_POINTER.id, 0)
		fun INDEX() : TerminalNode? = getToken(Cobol85Parser.Tokens.INDEX.id, 0)
		fun KANJI() : TerminalNode? = getToken(Cobol85Parser.Tokens.KANJI.id, 0)
		fun LOCK() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOCK.id, 0)
		fun NATIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIONAL.id, 0)
		fun PACKED_DECIMAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.PACKED_DECIMAL.id, 0)
		fun POINTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.POINTER.id, 0)
		fun PROCEDURE_POINTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROCEDURE_POINTER.id, 0)
		fun REAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.REAL.id, 0)
		fun TASK() : TerminalNode? = getToken(Cobol85Parser.Tokens.TASK.id, 0)
		fun USAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.USAGE.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun TRUNCATED() : TerminalNode? = getToken(Cobol85Parser.Tokens.TRUNCATED.id, 0)
		fun EXTENDED() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXTENDED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataUsageClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataUsageClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataUsageClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataUsageClause() : DataUsageClauseContext {
		var _localctx : DataUsageClauseContext = DataUsageClauseContext(context, state)
		enterRule(_localctx, 490, Rules.RULE_dataUsageClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3380
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==USAGE) {
				if (true){
				this.state = 3376
				match(USAGE) as Token
				this.state = 3378
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 3377
					match(IS) as Token
					}
				}

				}
			}

			this.state = 3415
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			BINARY  ->  /*LL1AltBlock*/{if (true){
			this.state = 3382
			match(BINARY) as Token
			this.state = 3384
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,430,context) ) {
			1   -> if (true){
			this.state = 3383
			_la = _input!!.LA(1)
			if ( !(_la==EXTENDED || _la==TRUNCATED) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
			}
			}}
			BIT  ->  /*LL1AltBlock*/{if (true){
			this.state = 3386
			match(BIT) as Token
			}}
			COMP  ->  /*LL1AltBlock*/{if (true){
			this.state = 3387
			match(COMP) as Token
			}}
			COMP_1  ->  /*LL1AltBlock*/{if (true){
			this.state = 3388
			match(COMP_1) as Token
			}}
			COMP_2  ->  /*LL1AltBlock*/{if (true){
			this.state = 3389
			match(COMP_2) as Token
			}}
			COMP_3  ->  /*LL1AltBlock*/{if (true){
			this.state = 3390
			match(COMP_3) as Token
			}}
			COMP_4  ->  /*LL1AltBlock*/{if (true){
			this.state = 3391
			match(COMP_4) as Token
			}}
			COMP_5  ->  /*LL1AltBlock*/{if (true){
			this.state = 3392
			match(COMP_5) as Token
			}}
			COMPUTATIONAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 3393
			match(COMPUTATIONAL) as Token
			}}
			COMPUTATIONAL_1  ->  /*LL1AltBlock*/{if (true){
			this.state = 3394
			match(COMPUTATIONAL_1) as Token
			}}
			COMPUTATIONAL_2  ->  /*LL1AltBlock*/{if (true){
			this.state = 3395
			match(COMPUTATIONAL_2) as Token
			}}
			COMPUTATIONAL_3  ->  /*LL1AltBlock*/{if (true){
			this.state = 3396
			match(COMPUTATIONAL_3) as Token
			}}
			COMPUTATIONAL_4  ->  /*LL1AltBlock*/{if (true){
			this.state = 3397
			match(COMPUTATIONAL_4) as Token
			}}
			COMPUTATIONAL_5  ->  /*LL1AltBlock*/{if (true){
			this.state = 3398
			match(COMPUTATIONAL_5) as Token
			}}
			CONTROL_POINT  ->  /*LL1AltBlock*/{if (true){
			this.state = 3399
			match(CONTROL_POINT) as Token
			}}
			DATE  ->  /*LL1AltBlock*/{if (true){
			this.state = 3400
			match(DATE) as Token
			}}
			DISPLAY  ->  /*LL1AltBlock*/{if (true){
			this.state = 3401
			match(DISPLAY) as Token
			}}
			DISPLAY_1  ->  /*LL1AltBlock*/{if (true){
			this.state = 3402
			match(DISPLAY_1) as Token
			}}
			DOUBLE  ->  /*LL1AltBlock*/{if (true){
			this.state = 3403
			match(DOUBLE) as Token
			}}
			EVENT  ->  /*LL1AltBlock*/{if (true){
			this.state = 3404
			match(EVENT) as Token
			}}
			FUNCTION_POINTER  ->  /*LL1AltBlock*/{if (true){
			this.state = 3405
			match(FUNCTION_POINTER) as Token
			}}
			INDEX  ->  /*LL1AltBlock*/{if (true){
			this.state = 3406
			match(INDEX) as Token
			}}
			KANJI  ->  /*LL1AltBlock*/{if (true){
			this.state = 3407
			match(KANJI) as Token
			}}
			LOCK  ->  /*LL1AltBlock*/{if (true){
			this.state = 3408
			match(LOCK) as Token
			}}
			NATIONAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 3409
			match(NATIONAL) as Token
			}}
			PACKED_DECIMAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 3410
			match(PACKED_DECIMAL) as Token
			}}
			POINTER  ->  /*LL1AltBlock*/{if (true){
			this.state = 3411
			match(POINTER) as Token
			}}
			PROCEDURE_POINTER  ->  /*LL1AltBlock*/{if (true){
			this.state = 3412
			match(PROCEDURE_POINTER) as Token
			}}
			REAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 3413
			match(REAL) as Token
			}}
			TASK  ->  /*LL1AltBlock*/{if (true){
			this.state = 3414
			match(TASK) as Token
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataUsingClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataUsingClause.id
	        set(value) { throw RuntimeException() }
		fun USING() : TerminalNode? = getToken(Cobol85Parser.Tokens.USING.id, 0)
		fun LANGUAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LANGUAGE.id, 0)
		fun CONVENTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONVENTION.id, 0)
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataUsingClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataUsingClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataUsingClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataUsingClause() : DataUsingClauseContext {
		var _localctx : DataUsingClauseContext = DataUsingClauseContext(context, state)
		enterRule(_localctx, 492, Rules.RULE_dataUsingClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3417
			match(USING) as Token
			this.state = 3418
			_la = _input!!.LA(1)
			if ( !(_la==CONVENTION || _la==LANGUAGE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3420
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OF) {
				if (true){
				this.state = 3419
				match(OF) as Token
				}
			}

			this.state = 3424
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,433,context) ) {
			1 -> {if (true){
			this.state = 3422
			cobolWord()
			}}
			2 -> {if (true){
			this.state = 3423
			dataName()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataValueClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataValueClause.id
	        set(value) { throw RuntimeException() }
		fun findDataValueInterval() : List<DataValueIntervalContext> = getRuleContexts(solver.getType("DataValueIntervalContext"))
		fun findDataValueInterval(i: Int) : DataValueIntervalContext? = getRuleContext(solver.getType("DataValueIntervalContext"),i)
		fun VALUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.VALUE.id, 0)
		fun VALUES() : TerminalNode? = getToken(Cobol85Parser.Tokens.VALUES.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun ARE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ARE.id, 0)
		fun COMMACHAR() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.COMMACHAR.id)
		fun COMMACHAR(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.COMMACHAR.id, i) as TerminalNode
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataValueClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataValueClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataValueClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataValueClause() : DataValueClauseContext {
		var _localctx : DataValueClauseContext = DataValueClauseContext(context, state)
		enterRule(_localctx, 494, Rules.RULE_dataValueClause.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3434
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			VALUE  -> 
				if (true){
				this.state = 3426
				match(VALUE) as Token
				this.state = 3428
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==IS) {
					if (true){
					this.state = 3427
					match(IS) as Token
					}
				}

				}
			VALUES  -> 
				if (true){
				this.state = 3430
				match(VALUES) as Token
				this.state = 3432
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==ARE) {
					if (true){
					this.state = 3431
					match(ARE) as Token
					}
				}

				}
			ABORT , ALL , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FALSE , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , HIGH_VALUE , HIGH_VALUES , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , LOW_VALUE , LOW_VALUES , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NULL , NULLS , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , QUOTE , QUOTES , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SPACE , SPACES , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUE , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO , ZERO_FILL , ZEROS , ZEROES , NONNUMERICLITERAL , LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL , NUMERICLITERAL , IDENTIFIER  -> 
				Unit
			else -> Unit
			}
			this.state = 3436
			dataValueInterval()
			this.state = 3443
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,438,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 3438
					errorHandler.sync(this)
					_la = _input!!.LA(1)
					if (_la==COMMACHAR) {
						if (true){
						this.state = 3437
						match(COMMACHAR) as Token
						}
					}

					this.state = 3440
					dataValueInterval()
					}
					} 
				}
				this.state = 3445
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,438,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataValueIntervalContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataValueInterval.id
	        set(value) { throw RuntimeException() }
		fun findDataValueIntervalFrom() : DataValueIntervalFromContext? = getRuleContext(solver.getType("DataValueIntervalFromContext"),0)
		fun findDataValueIntervalTo() : DataValueIntervalToContext? = getRuleContext(solver.getType("DataValueIntervalToContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataValueInterval(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataValueInterval(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataValueInterval(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataValueInterval() : DataValueIntervalContext {
		var _localctx : DataValueIntervalContext = DataValueIntervalContext(context, state)
		enterRule(_localctx, 496, Rules.RULE_dataValueInterval.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3446
			dataValueIntervalFrom()
			this.state = 3448
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THROUGH || _la==THRU) {
				if (true){
				this.state = 3447
				dataValueIntervalTo()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataValueIntervalFromContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataValueIntervalFrom.id
	        set(value) { throw RuntimeException() }
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataValueIntervalFrom(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataValueIntervalFrom(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataValueIntervalFrom(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataValueIntervalFrom() : DataValueIntervalFromContext {
		var _localctx : DataValueIntervalFromContext = DataValueIntervalFromContext(context, state)
		enterRule(_localctx, 498, Rules.RULE_dataValueIntervalFrom.id)
		try {
			this.state = 3452
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,440,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3450
			literal()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3451
			cobolWord()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataValueIntervalToContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataValueIntervalTo.id
	        set(value) { throw RuntimeException() }
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun THROUGH() : TerminalNode? = getToken(Cobol85Parser.Tokens.THROUGH.id, 0)
		fun THRU() : TerminalNode? = getToken(Cobol85Parser.Tokens.THRU.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataValueIntervalTo(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataValueIntervalTo(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataValueIntervalTo(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataValueIntervalTo() : DataValueIntervalToContext {
		var _localctx : DataValueIntervalToContext = DataValueIntervalToContext(context, state)
		enterRule(_localctx, 500, Rules.RULE_dataValueIntervalTo.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3454
			_la = _input!!.LA(1)
			if ( !(_la==THROUGH || _la==THRU) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3455
			literal()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataWithLowerBoundsClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataWithLowerBoundsClause.id
	        set(value) { throw RuntimeException() }
		fun LOWER() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOWER.id, 0)
		fun BOUNDS() : TerminalNode? = getToken(Cobol85Parser.Tokens.BOUNDS.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataWithLowerBoundsClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataWithLowerBoundsClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataWithLowerBoundsClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataWithLowerBoundsClause() : DataWithLowerBoundsClauseContext {
		var _localctx : DataWithLowerBoundsClauseContext = DataWithLowerBoundsClauseContext(context, state)
		enterRule(_localctx, 502, Rules.RULE_dataWithLowerBoundsClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3458
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 3457
				match(WITH) as Token
				}
			}

			this.state = 3460
			match(LOWER) as Token
			this.state = 3461
			match(BOUNDS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureDivisionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureDivision.id
	        set(value) { throw RuntimeException() }
		fun PROCEDURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROCEDURE.id, 0)
		fun DIVISION() : TerminalNode? = getToken(Cobol85Parser.Tokens.DIVISION.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findProcedureDivisionBody() : ProcedureDivisionBodyContext? = getRuleContext(solver.getType("ProcedureDivisionBodyContext"),0)
		fun findProcedureDivisionUsingClause() : ProcedureDivisionUsingClauseContext? = getRuleContext(solver.getType("ProcedureDivisionUsingClauseContext"),0)
		fun findProcedureDivisionGivingClause() : ProcedureDivisionGivingClauseContext? = getRuleContext(solver.getType("ProcedureDivisionGivingClauseContext"),0)
		fun findProcedureDeclaratives() : ProcedureDeclarativesContext? = getRuleContext(solver.getType("ProcedureDeclarativesContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureDivision(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureDivision(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureDivision(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureDivision() : ProcedureDivisionContext {
		var _localctx : ProcedureDivisionContext = ProcedureDivisionContext(context, state)
		enterRule(_localctx, 504, Rules.RULE_procedureDivision.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3463
			match(PROCEDURE) as Token
			this.state = 3464
			match(DIVISION) as Token
			this.state = 3466
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==CHAINING || _la==USING) {
				if (true){
				this.state = 3465
				procedureDivisionUsingClause()
				}
			}

			this.state = 3469
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==GIVING || _la==RETURNING) {
				if (true){
				this.state = 3468
				procedureDivisionGivingClause()
				}
			}

			this.state = 3471
			match(DOT_FS) as Token
			this.state = 3473
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DECLARATIVES) {
				if (true){
				this.state = 3472
				procedureDeclaratives()
				}
			}

			this.state = 3475
			procedureDivisionBody()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureDivisionUsingClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureDivisionUsingClause.id
	        set(value) { throw RuntimeException() }
		fun USING() : TerminalNode? = getToken(Cobol85Parser.Tokens.USING.id, 0)
		fun CHAINING() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHAINING.id, 0)
		fun findProcedureDivisionUsingParameter() : List<ProcedureDivisionUsingParameterContext> = getRuleContexts(solver.getType("ProcedureDivisionUsingParameterContext"))
		fun findProcedureDivisionUsingParameter(i: Int) : ProcedureDivisionUsingParameterContext? = getRuleContext(solver.getType("ProcedureDivisionUsingParameterContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureDivisionUsingClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureDivisionUsingClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureDivisionUsingClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureDivisionUsingClause() : ProcedureDivisionUsingClauseContext {
		var _localctx : ProcedureDivisionUsingClauseContext = ProcedureDivisionUsingClauseContext(context, state)
		enterRule(_localctx, 506, Rules.RULE_procedureDivisionUsingClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3477
			_la = _input!!.LA(1)
			if ( !(_la==CHAINING || _la==USING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3479 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 3478
				procedureDivisionUsingParameter()
				}
				}
				this.state = 3481 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ANY) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl BY) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (OPTIONAL - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REFERENCE - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VALUE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureDivisionGivingClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureDivisionGivingClause.id
	        set(value) { throw RuntimeException() }
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun GIVING() : TerminalNode? = getToken(Cobol85Parser.Tokens.GIVING.id, 0)
		fun RETURNING() : TerminalNode? = getToken(Cobol85Parser.Tokens.RETURNING.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureDivisionGivingClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureDivisionGivingClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureDivisionGivingClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureDivisionGivingClause() : ProcedureDivisionGivingClauseContext {
		var _localctx : ProcedureDivisionGivingClauseContext = ProcedureDivisionGivingClauseContext(context, state)
		enterRule(_localctx, 508, Rules.RULE_procedureDivisionGivingClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3483
			_la = _input!!.LA(1)
			if ( !(_la==GIVING || _la==RETURNING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3484
			dataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureDivisionUsingParameterContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureDivisionUsingParameter.id
	        set(value) { throw RuntimeException() }
		fun findProcedureDivisionByReferencePhrase() : ProcedureDivisionByReferencePhraseContext? = getRuleContext(solver.getType("ProcedureDivisionByReferencePhraseContext"),0)
		fun findProcedureDivisionByValuePhrase() : ProcedureDivisionByValuePhraseContext? = getRuleContext(solver.getType("ProcedureDivisionByValuePhraseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureDivisionUsingParameter(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureDivisionUsingParameter(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureDivisionUsingParameter(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureDivisionUsingParameter() : ProcedureDivisionUsingParameterContext {
		var _localctx : ProcedureDivisionUsingParameterContext = ProcedureDivisionUsingParameterContext(context, state)
		enterRule(_localctx, 510, Rules.RULE_procedureDivisionUsingParameter.id)
		try {
			this.state = 3488
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,446,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3486
			procedureDivisionByReferencePhrase()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3487
			procedureDivisionByValuePhrase()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureDivisionByReferencePhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureDivisionByReferencePhrase.id
	        set(value) { throw RuntimeException() }
		fun REFERENCE() : TerminalNode? = getToken(Cobol85Parser.Tokens.REFERENCE.id, 0)
		fun findProcedureDivisionByReference() : List<ProcedureDivisionByReferenceContext> = getRuleContexts(solver.getType("ProcedureDivisionByReferenceContext"))
		fun findProcedureDivisionByReference(i: Int) : ProcedureDivisionByReferenceContext? = getRuleContext(solver.getType("ProcedureDivisionByReferenceContext"),i)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureDivisionByReferencePhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureDivisionByReferencePhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureDivisionByReferencePhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureDivisionByReferencePhrase() : ProcedureDivisionByReferencePhraseContext {
		var _localctx : ProcedureDivisionByReferencePhraseContext = ProcedureDivisionByReferencePhraseContext(context, state)
		enterRule(_localctx, 512, Rules.RULE_procedureDivisionByReferencePhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3494
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==BY || _la==REFERENCE) {
				if (true){
				this.state = 3491
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==BY) {
					if (true){
					this.state = 3490
					match(BY) as Token
					}
				}

				this.state = 3493
				match(REFERENCE) as Token
				}
			}

			this.state = 3497 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 3496
				procedureDivisionByReference()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 3499 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,449,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureDivisionByReferenceContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureDivisionByReference.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun OPTIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.OPTIONAL.id, 0)
		fun ANY() : TerminalNode? = getToken(Cobol85Parser.Tokens.ANY.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureDivisionByReference(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureDivisionByReference(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureDivisionByReference(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureDivisionByReference() : ProcedureDivisionByReferenceContext {
		var _localctx : ProcedureDivisionByReferenceContext = ProcedureDivisionByReferenceContext(context, state)
		enterRule(_localctx, 514, Rules.RULE_procedureDivisionByReference.id)
		var _la: Int
		try {
			this.state = 3509
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ABORT , ADDRESS , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DATE , DAY , DAY_OF_WEEK , DEBUG_CONTENTS , DEBUG_ITEM , DEBUG_LINE , DEBUG_NAME , DEBUG_SUB_1 , DEBUG_SUB_2 , DEBUG_SUB_3 , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTION , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LINAGE_COUNTER , LINE_COUNTER , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , OPTIONAL , ORDERLY , OVERLINE , OWN , PAGE_COUNTER , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , RETURN_CODE , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHIFT_IN , SHIFT_OUT , SHORT_DATE , SORT_CONTROL , SORT_CORE_SIZE , SORT_FILE_SIZE , SORT_MESSAGE , SORT_MODE_SIZE , SORT_RETURN , SYMBOL , TALLY , TASK , THREAD , THREAD_LOCAL , TIME , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , WHEN_COMPILED , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL , IDENTIFIER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			if (true){
			this.state = 3502
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OPTIONAL) {
				if (true){
				this.state = 3501
				match(OPTIONAL) as Token
				}
			}

			this.state = 3506
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,451,context) ) {
			1 -> {if (true){
			this.state = 3504
			identifier()
			}}
			2 -> {if (true){
			this.state = 3505
			fileName()
			}}
			}
			}
			}}
			ANY  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3508
			match(ANY) as Token
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureDivisionByValuePhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureDivisionByValuePhrase.id
	        set(value) { throw RuntimeException() }
		fun VALUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.VALUE.id, 0)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun findProcedureDivisionByValue() : List<ProcedureDivisionByValueContext> = getRuleContexts(solver.getType("ProcedureDivisionByValueContext"))
		fun findProcedureDivisionByValue(i: Int) : ProcedureDivisionByValueContext? = getRuleContext(solver.getType("ProcedureDivisionByValueContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureDivisionByValuePhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureDivisionByValuePhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureDivisionByValuePhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureDivisionByValuePhrase() : ProcedureDivisionByValuePhraseContext {
		var _localctx : ProcedureDivisionByValuePhraseContext = ProcedureDivisionByValuePhraseContext(context, state)
		enterRule(_localctx, 516, Rules.RULE_procedureDivisionByValuePhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3512
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==BY) {
				if (true){
				this.state = 3511
				match(BY) as Token
				}
			}

			this.state = 3514
			match(VALUE) as Token
			this.state = 3516 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 3515
				procedureDivisionByValue()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 3518 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,454,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureDivisionByValueContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureDivisionByValue.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun ANY() : TerminalNode? = getToken(Cobol85Parser.Tokens.ANY.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureDivisionByValue(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureDivisionByValue(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureDivisionByValue(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureDivisionByValue() : ProcedureDivisionByValueContext {
		var _localctx : ProcedureDivisionByValueContext = ProcedureDivisionByValueContext(context, state)
		enterRule(_localctx, 518, Rules.RULE_procedureDivisionByValue.id)
		try {
			this.state = 3523
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,455,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3520
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3521
			literal()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 3522
			match(ANY) as Token
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureDeclarativesContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureDeclaratives.id
	        set(value) { throw RuntimeException() }
		fun DECLARATIVES() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.DECLARATIVES.id)
		fun DECLARATIVES(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.DECLARATIVES.id, i) as TerminalNode
		fun DOT_FS() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.DOT_FS.id)
		fun DOT_FS(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.DOT_FS.id, i) as TerminalNode
		fun END() : TerminalNode? = getToken(Cobol85Parser.Tokens.END.id, 0)
		fun findProcedureDeclarative() : List<ProcedureDeclarativeContext> = getRuleContexts(solver.getType("ProcedureDeclarativeContext"))
		fun findProcedureDeclarative(i: Int) : ProcedureDeclarativeContext? = getRuleContext(solver.getType("ProcedureDeclarativeContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureDeclaratives(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureDeclaratives(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureDeclaratives(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureDeclaratives() : ProcedureDeclarativesContext {
		var _localctx : ProcedureDeclarativesContext = ProcedureDeclarativesContext(context, state)
		enterRule(_localctx, 520, Rules.RULE_procedureDeclaratives.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3525
			match(DECLARATIVES) as Token
			this.state = 3526
			match(DOT_FS) as Token
			this.state = 3528 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 3527
				procedureDeclarative()
				}
				}
				this.state = 3530 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			this.state = 3532
			match(END) as Token
			this.state = 3533
			match(DECLARATIVES) as Token
			this.state = 3534
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureDeclarativeContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureDeclarative.id
	        set(value) { throw RuntimeException() }
		fun findProcedureSectionHeader() : ProcedureSectionHeaderContext? = getRuleContext(solver.getType("ProcedureSectionHeaderContext"),0)
		fun DOT_FS() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.DOT_FS.id)
		fun DOT_FS(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.DOT_FS.id, i) as TerminalNode
		fun findUseStatement() : UseStatementContext? = getRuleContext(solver.getType("UseStatementContext"),0)
		fun findParagraphs() : ParagraphsContext? = getRuleContext(solver.getType("ParagraphsContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureDeclarative(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureDeclarative(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureDeclarative(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureDeclarative() : ProcedureDeclarativeContext {
		var _localctx : ProcedureDeclarativeContext = ProcedureDeclarativeContext(context, state)
		enterRule(_localctx, 522, Rules.RULE_procedureDeclarative.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3536
			procedureSectionHeader()
			this.state = 3537
			match(DOT_FS) as Token
			this.state = 3538
			useStatement()
			this.state = 3539
			match(DOT_FS) as Token
			this.state = 3540
			paragraphs()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureSectionHeaderContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureSectionHeader.id
	        set(value) { throw RuntimeException() }
		fun findSectionName() : SectionNameContext? = getRuleContext(solver.getType("SectionNameContext"),0)
		fun SECTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECTION.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureSectionHeader(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureSectionHeader(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureSectionHeader(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureSectionHeader() : ProcedureSectionHeaderContext {
		var _localctx : ProcedureSectionHeaderContext = ProcedureSectionHeaderContext(context, state)
		enterRule(_localctx, 524, Rules.RULE_procedureSectionHeader.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3542
			sectionName()
			this.state = 3543
			match(SECTION) as Token
			this.state = 3545
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)))) != 0L)) {
				if (true){
				this.state = 3544
				integerLiteral()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureDivisionBodyContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureDivisionBody.id
	        set(value) { throw RuntimeException() }
		fun findParagraphs() : ParagraphsContext? = getRuleContext(solver.getType("ParagraphsContext"),0)
		fun findProcedureSection() : List<ProcedureSectionContext> = getRuleContexts(solver.getType("ProcedureSectionContext"))
		fun findProcedureSection(i: Int) : ProcedureSectionContext? = getRuleContext(solver.getType("ProcedureSectionContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureDivisionBody(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureDivisionBody(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureDivisionBody(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureDivisionBody() : ProcedureDivisionBodyContext {
		var _localctx : ProcedureDivisionBodyContext = ProcedureDivisionBodyContext(context, state)
		enterRule(_localctx, 526, Rules.RULE_procedureDivisionBody.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3547
			paragraphs()
			this.state = 3551
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L)) {
				if (true){
				if (true){
				this.state = 3548
				procedureSection()
				}
				}
				this.state = 3553
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureSection.id
	        set(value) { throw RuntimeException() }
		fun findProcedureSectionHeader() : ProcedureSectionHeaderContext? = getRuleContext(solver.getType("ProcedureSectionHeaderContext"),0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findParagraphs() : ParagraphsContext? = getRuleContext(solver.getType("ParagraphsContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureSection() : ProcedureSectionContext {
		var _localctx : ProcedureSectionContext = ProcedureSectionContext(context, state)
		enterRule(_localctx, 528, Rules.RULE_procedureSection.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3554
			procedureSectionHeader()
			this.state = 3555
			match(DOT_FS) as Token
			this.state = 3556
			paragraphs()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ParagraphsContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_paragraphs.id
	        set(value) { throw RuntimeException() }
		fun findSentence() : List<SentenceContext> = getRuleContexts(solver.getType("SentenceContext"))
		fun findSentence(i: Int) : SentenceContext? = getRuleContext(solver.getType("SentenceContext"),i)
		fun findParagraph() : List<ParagraphContext> = getRuleContexts(solver.getType("ParagraphContext"))
		fun findParagraph(i: Int) : ParagraphContext? = getRuleContext(solver.getType("ParagraphContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterParagraphs(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitParagraphs(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitParagraphs(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  paragraphs() : ParagraphsContext {
		var _localctx : ParagraphsContext = ParagraphsContext(context, state)
		enterRule(_localctx, 530, Rules.RULE_paragraphs.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3561
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ACCEPT) or (1L shl ADD) or (1L shl ALTER) or (1L shl CALL) or (1L shl CANCEL))) != 0L) || ((((_la - 67)) and 0x3f.inv()) == 0 && ((1L shl (_la - 67)) and ((1L shl (CLOSE - 67)) or (1L shl (COMPUTE - 67)) or (1L shl (CONTINUE - 67)))) != 0L) || ((((_la - 131)) and 0x3f.inv()) == 0 && ((1L shl (_la - 131)) and ((1L shl (DELETE - 131)) or (1L shl (DISABLE - 131)) or (1L shl (DISPLAY - 131)) or (1L shl (DIVIDE - 131)) or (1L shl (ENABLE - 131)) or (1L shl (ENTRY - 131)) or (1L shl (EVALUATE - 131)))) != 0L) || ((((_la - 198)) and 0x3f.inv()) == 0 && ((1L shl (_la - 198)) and ((1L shl (EXHIBIT - 198)) or (1L shl (EXIT - 198)) or (1L shl (GENERATE - 198)) or (1L shl (GOBACK - 198)) or (1L shl (GO - 198)) or (1L shl (IF - 198)) or (1L shl (INITIALIZE - 198)) or (1L shl (INITIATE - 198)) or (1L shl (INSPECT - 198)))) != 0L) || ((((_la - 294)) and 0x3f.inv()) == 0 && ((1L shl (_la - 294)) and ((1L shl (MERGE - 294)) or (1L shl (MOVE - 294)) or (1L shl (MULTIPLY - 294)) or (1L shl (OPEN - 294)) or (1L shl (PERFORM - 294)))) != 0L) || ((((_la - 365)) and 0x3f.inv()) == 0 && ((1L shl (_la - 365)) and ((1L shl (PURGE - 365)) or (1L shl (READ - 365)) or (1L shl (RECEIVE - 365)) or (1L shl (RELEASE - 365)) or (1L shl (RETURN - 365)) or (1L shl (REWRITE - 365)) or (1L shl (SEARCH - 365)) or (1L shl (SEND - 365)))) != 0L) || ((((_la - 430)) and 0x3f.inv()) == 0 && ((1L shl (_la - 430)) and ((1L shl (SET - 430)) or (1L shl (SORT - 430)) or (1L shl (START - 430)) or (1L shl (STOP - 430)) or (1L shl (STRING - 430)) or (1L shl (SUBTRACT - 430)) or (1L shl (TERMINATE - 430)))) != 0L) || ((((_la - 500)) and 0x3f.inv()) == 0 && ((1L shl (_la - 500)) and ((1L shl (UNSTRING - 500)) or (1L shl (WRITE - 500)) or (1L shl (DOT_FS - 500)) or (1L shl (EXECCICSLINE - 500)) or (1L shl (EXECSQLIMSLINE - 500)) or (1L shl (EXECSQLLINE - 500)))) != 0L)) {
				if (true){
				if (true){
				this.state = 3558
				sentence()
				}
				}
				this.state = 3563
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 3567
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,460,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 3564
					paragraph()
					}
					} 
				}
				this.state = 3569
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,460,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ParagraphContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_paragraph.id
	        set(value) { throw RuntimeException() }
		fun findParagraphName() : ParagraphNameContext? = getRuleContext(solver.getType("ParagraphNameContext"),0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findAlteredGoTo() : AlteredGoToContext? = getRuleContext(solver.getType("AlteredGoToContext"),0)
		fun findSentence() : List<SentenceContext> = getRuleContexts(solver.getType("SentenceContext"))
		fun findSentence(i: Int) : SentenceContext? = getRuleContext(solver.getType("SentenceContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterParagraph(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitParagraph(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitParagraph(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  paragraph() : ParagraphContext {
		var _localctx : ParagraphContext = ParagraphContext(context, state)
		enterRule(_localctx, 532, Rules.RULE_paragraph.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3570
			paragraphName()
			this.state = 3571
			match(DOT_FS) as Token
			this.state = 3579
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,462,context) ) {
			1 -> {if (true){
			this.state = 3572
			alteredGoTo()
			}}
			2 -> {if (true){
			this.state = 3576
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ACCEPT) or (1L shl ADD) or (1L shl ALTER) or (1L shl CALL) or (1L shl CANCEL))) != 0L) || ((((_la - 67)) and 0x3f.inv()) == 0 && ((1L shl (_la - 67)) and ((1L shl (CLOSE - 67)) or (1L shl (COMPUTE - 67)) or (1L shl (CONTINUE - 67)))) != 0L) || ((((_la - 131)) and 0x3f.inv()) == 0 && ((1L shl (_la - 131)) and ((1L shl (DELETE - 131)) or (1L shl (DISABLE - 131)) or (1L shl (DISPLAY - 131)) or (1L shl (DIVIDE - 131)) or (1L shl (ENABLE - 131)) or (1L shl (ENTRY - 131)) or (1L shl (EVALUATE - 131)))) != 0L) || ((((_la - 198)) and 0x3f.inv()) == 0 && ((1L shl (_la - 198)) and ((1L shl (EXHIBIT - 198)) or (1L shl (EXIT - 198)) or (1L shl (GENERATE - 198)) or (1L shl (GOBACK - 198)) or (1L shl (GO - 198)) or (1L shl (IF - 198)) or (1L shl (INITIALIZE - 198)) or (1L shl (INITIATE - 198)) or (1L shl (INSPECT - 198)))) != 0L) || ((((_la - 294)) and 0x3f.inv()) == 0 && ((1L shl (_la - 294)) and ((1L shl (MERGE - 294)) or (1L shl (MOVE - 294)) or (1L shl (MULTIPLY - 294)) or (1L shl (OPEN - 294)) or (1L shl (PERFORM - 294)))) != 0L) || ((((_la - 365)) and 0x3f.inv()) == 0 && ((1L shl (_la - 365)) and ((1L shl (PURGE - 365)) or (1L shl (READ - 365)) or (1L shl (RECEIVE - 365)) or (1L shl (RELEASE - 365)) or (1L shl (RETURN - 365)) or (1L shl (REWRITE - 365)) or (1L shl (SEARCH - 365)) or (1L shl (SEND - 365)))) != 0L) || ((((_la - 430)) and 0x3f.inv()) == 0 && ((1L shl (_la - 430)) and ((1L shl (SET - 430)) or (1L shl (SORT - 430)) or (1L shl (START - 430)) or (1L shl (STOP - 430)) or (1L shl (STRING - 430)) or (1L shl (SUBTRACT - 430)) or (1L shl (TERMINATE - 430)))) != 0L) || ((((_la - 500)) and 0x3f.inv()) == 0 && ((1L shl (_la - 500)) and ((1L shl (UNSTRING - 500)) or (1L shl (WRITE - 500)) or (1L shl (DOT_FS - 500)) or (1L shl (EXECCICSLINE - 500)) or (1L shl (EXECSQLIMSLINE - 500)) or (1L shl (EXECSQLLINE - 500)))) != 0L)) {
				if (true){
				if (true){
				this.state = 3573
				sentence()
				}
				}
				this.state = 3578
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SentenceContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sentence.id
	        set(value) { throw RuntimeException() }
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSentence(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSentence(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSentence(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sentence() : SentenceContext {
		var _localctx : SentenceContext = SentenceContext(context, state)
		enterRule(_localctx, 534, Rules.RULE_sentence.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3584
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ACCEPT) or (1L shl ADD) or (1L shl ALTER) or (1L shl CALL) or (1L shl CANCEL))) != 0L) || ((((_la - 67)) and 0x3f.inv()) == 0 && ((1L shl (_la - 67)) and ((1L shl (CLOSE - 67)) or (1L shl (COMPUTE - 67)) or (1L shl (CONTINUE - 67)))) != 0L) || ((((_la - 131)) and 0x3f.inv()) == 0 && ((1L shl (_la - 131)) and ((1L shl (DELETE - 131)) or (1L shl (DISABLE - 131)) or (1L shl (DISPLAY - 131)) or (1L shl (DIVIDE - 131)) or (1L shl (ENABLE - 131)) or (1L shl (ENTRY - 131)) or (1L shl (EVALUATE - 131)))) != 0L) || ((((_la - 198)) and 0x3f.inv()) == 0 && ((1L shl (_la - 198)) and ((1L shl (EXHIBIT - 198)) or (1L shl (EXIT - 198)) or (1L shl (GENERATE - 198)) or (1L shl (GOBACK - 198)) or (1L shl (GO - 198)) or (1L shl (IF - 198)) or (1L shl (INITIALIZE - 198)) or (1L shl (INITIATE - 198)) or (1L shl (INSPECT - 198)))) != 0L) || ((((_la - 294)) and 0x3f.inv()) == 0 && ((1L shl (_la - 294)) and ((1L shl (MERGE - 294)) or (1L shl (MOVE - 294)) or (1L shl (MULTIPLY - 294)) or (1L shl (OPEN - 294)) or (1L shl (PERFORM - 294)))) != 0L) || ((((_la - 365)) and 0x3f.inv()) == 0 && ((1L shl (_la - 365)) and ((1L shl (PURGE - 365)) or (1L shl (READ - 365)) or (1L shl (RECEIVE - 365)) or (1L shl (RELEASE - 365)) or (1L shl (RETURN - 365)) or (1L shl (REWRITE - 365)) or (1L shl (SEARCH - 365)) or (1L shl (SEND - 365)))) != 0L) || ((((_la - 430)) and 0x3f.inv()) == 0 && ((1L shl (_la - 430)) and ((1L shl (SET - 430)) or (1L shl (SORT - 430)) or (1L shl (START - 430)) or (1L shl (STOP - 430)) or (1L shl (STRING - 430)) or (1L shl (SUBTRACT - 430)) or (1L shl (TERMINATE - 430)))) != 0L) || ((((_la - 500)) and 0x3f.inv()) == 0 && ((1L shl (_la - 500)) and ((1L shl (UNSTRING - 500)) or (1L shl (WRITE - 500)) or (1L shl (EXECCICSLINE - 500)) or (1L shl (EXECSQLIMSLINE - 500)) or (1L shl (EXECSQLLINE - 500)))) != 0L)) {
				if (true){
				if (true){
				this.state = 3581
				statement()
				}
				}
				this.state = 3586
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 3587
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class StatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_statement.id
	        set(value) { throw RuntimeException() }
		fun findAcceptStatement() : AcceptStatementContext? = getRuleContext(solver.getType("AcceptStatementContext"),0)
		fun findAddStatement() : AddStatementContext? = getRuleContext(solver.getType("AddStatementContext"),0)
		fun findAlterStatement() : AlterStatementContext? = getRuleContext(solver.getType("AlterStatementContext"),0)
		fun findCallStatement() : CallStatementContext? = getRuleContext(solver.getType("CallStatementContext"),0)
		fun findCancelStatement() : CancelStatementContext? = getRuleContext(solver.getType("CancelStatementContext"),0)
		fun findCloseStatement() : CloseStatementContext? = getRuleContext(solver.getType("CloseStatementContext"),0)
		fun findComputeStatement() : ComputeStatementContext? = getRuleContext(solver.getType("ComputeStatementContext"),0)
		fun findContinueStatement() : ContinueStatementContext? = getRuleContext(solver.getType("ContinueStatementContext"),0)
		fun findDeleteStatement() : DeleteStatementContext? = getRuleContext(solver.getType("DeleteStatementContext"),0)
		fun findDisableStatement() : DisableStatementContext? = getRuleContext(solver.getType("DisableStatementContext"),0)
		fun findDisplayStatement() : DisplayStatementContext? = getRuleContext(solver.getType("DisplayStatementContext"),0)
		fun findDivideStatement() : DivideStatementContext? = getRuleContext(solver.getType("DivideStatementContext"),0)
		fun findEnableStatement() : EnableStatementContext? = getRuleContext(solver.getType("EnableStatementContext"),0)
		fun findEntryStatement() : EntryStatementContext? = getRuleContext(solver.getType("EntryStatementContext"),0)
		fun findEvaluateStatement() : EvaluateStatementContext? = getRuleContext(solver.getType("EvaluateStatementContext"),0)
		fun findExhibitStatement() : ExhibitStatementContext? = getRuleContext(solver.getType("ExhibitStatementContext"),0)
		fun findExecCicsStatement() : ExecCicsStatementContext? = getRuleContext(solver.getType("ExecCicsStatementContext"),0)
		fun findExecSqlStatement() : ExecSqlStatementContext? = getRuleContext(solver.getType("ExecSqlStatementContext"),0)
		fun findExecSqlImsStatement() : ExecSqlImsStatementContext? = getRuleContext(solver.getType("ExecSqlImsStatementContext"),0)
		fun findExitStatement() : ExitStatementContext? = getRuleContext(solver.getType("ExitStatementContext"),0)
		fun findGenerateStatement() : GenerateStatementContext? = getRuleContext(solver.getType("GenerateStatementContext"),0)
		fun findGobackStatement() : GobackStatementContext? = getRuleContext(solver.getType("GobackStatementContext"),0)
		fun findGoToStatement() : GoToStatementContext? = getRuleContext(solver.getType("GoToStatementContext"),0)
		fun findIfStatement() : IfStatementContext? = getRuleContext(solver.getType("IfStatementContext"),0)
		fun findInitializeStatement() : InitializeStatementContext? = getRuleContext(solver.getType("InitializeStatementContext"),0)
		fun findInitiateStatement() : InitiateStatementContext? = getRuleContext(solver.getType("InitiateStatementContext"),0)
		fun findInspectStatement() : InspectStatementContext? = getRuleContext(solver.getType("InspectStatementContext"),0)
		fun findMergeStatement() : MergeStatementContext? = getRuleContext(solver.getType("MergeStatementContext"),0)
		fun findMoveStatement() : MoveStatementContext? = getRuleContext(solver.getType("MoveStatementContext"),0)
		fun findMultiplyStatement() : MultiplyStatementContext? = getRuleContext(solver.getType("MultiplyStatementContext"),0)
		fun findOpenStatement() : OpenStatementContext? = getRuleContext(solver.getType("OpenStatementContext"),0)
		fun findPerformStatement() : PerformStatementContext? = getRuleContext(solver.getType("PerformStatementContext"),0)
		fun findPurgeStatement() : PurgeStatementContext? = getRuleContext(solver.getType("PurgeStatementContext"),0)
		fun findReadStatement() : ReadStatementContext? = getRuleContext(solver.getType("ReadStatementContext"),0)
		fun findReceiveStatement() : ReceiveStatementContext? = getRuleContext(solver.getType("ReceiveStatementContext"),0)
		fun findReleaseStatement() : ReleaseStatementContext? = getRuleContext(solver.getType("ReleaseStatementContext"),0)
		fun findReturnStatement() : ReturnStatementContext? = getRuleContext(solver.getType("ReturnStatementContext"),0)
		fun findRewriteStatement() : RewriteStatementContext? = getRuleContext(solver.getType("RewriteStatementContext"),0)
		fun findSearchStatement() : SearchStatementContext? = getRuleContext(solver.getType("SearchStatementContext"),0)
		fun findSendStatement() : SendStatementContext? = getRuleContext(solver.getType("SendStatementContext"),0)
		fun findSetStatement() : SetStatementContext? = getRuleContext(solver.getType("SetStatementContext"),0)
		fun findSortStatement() : SortStatementContext? = getRuleContext(solver.getType("SortStatementContext"),0)
		fun findStartStatement() : StartStatementContext? = getRuleContext(solver.getType("StartStatementContext"),0)
		fun findStopStatement() : StopStatementContext? = getRuleContext(solver.getType("StopStatementContext"),0)
		fun findStringStatement() : StringStatementContext? = getRuleContext(solver.getType("StringStatementContext"),0)
		fun findSubtractStatement() : SubtractStatementContext? = getRuleContext(solver.getType("SubtractStatementContext"),0)
		fun findTerminateStatement() : TerminateStatementContext? = getRuleContext(solver.getType("TerminateStatementContext"),0)
		fun findUnstringStatement() : UnstringStatementContext? = getRuleContext(solver.getType("UnstringStatementContext"),0)
		fun findWriteStatement() : WriteStatementContext? = getRuleContext(solver.getType("WriteStatementContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  statement() : StatementContext {
		var _localctx : StatementContext = StatementContext(context, state)
		enterRule(_localctx, 536, Rules.RULE_statement.id)
		try {
			this.state = 3638
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ACCEPT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3589
			acceptStatement()
			}}
			ADD  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3590
			addStatement()
			}}
			ALTER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 3591
			alterStatement()
			}}
			CALL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 3592
			callStatement()
			}}
			CANCEL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 3593
			cancelStatement()
			}}
			CLOSE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 6)
			if (true){
			this.state = 3594
			closeStatement()
			}}
			COMPUTE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 7)
			if (true){
			this.state = 3595
			computeStatement()
			}}
			CONTINUE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 8)
			if (true){
			this.state = 3596
			continueStatement()
			}}
			DELETE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 9)
			if (true){
			this.state = 3597
			deleteStatement()
			}}
			DISABLE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 10)
			if (true){
			this.state = 3598
			disableStatement()
			}}
			DISPLAY  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 11)
			if (true){
			this.state = 3599
			displayStatement()
			}}
			DIVIDE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 12)
			if (true){
			this.state = 3600
			divideStatement()
			}}
			ENABLE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 13)
			if (true){
			this.state = 3601
			enableStatement()
			}}
			ENTRY  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 14)
			if (true){
			this.state = 3602
			entryStatement()
			}}
			EVALUATE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 15)
			if (true){
			this.state = 3603
			evaluateStatement()
			}}
			EXHIBIT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 16)
			if (true){
			this.state = 3604
			exhibitStatement()
			}}
			EXECCICSLINE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 17)
			if (true){
			this.state = 3605
			execCicsStatement()
			}}
			EXECSQLLINE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 18)
			if (true){
			this.state = 3606
			execSqlStatement()
			}}
			EXECSQLIMSLINE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 19)
			if (true){
			this.state = 3607
			execSqlImsStatement()
			}}
			EXIT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 20)
			if (true){
			this.state = 3608
			exitStatement()
			}}
			GENERATE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 21)
			if (true){
			this.state = 3609
			generateStatement()
			}}
			GOBACK  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 22)
			if (true){
			this.state = 3610
			gobackStatement()
			}}
			GO  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 23)
			if (true){
			this.state = 3611
			goToStatement()
			}}
			IF  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 24)
			if (true){
			this.state = 3612
			ifStatement()
			}}
			INITIALIZE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 25)
			if (true){
			this.state = 3613
			initializeStatement()
			}}
			INITIATE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 26)
			if (true){
			this.state = 3614
			initiateStatement()
			}}
			INSPECT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 27)
			if (true){
			this.state = 3615
			inspectStatement()
			}}
			MERGE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 28)
			if (true){
			this.state = 3616
			mergeStatement()
			}}
			MOVE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 29)
			if (true){
			this.state = 3617
			moveStatement()
			}}
			MULTIPLY  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 30)
			if (true){
			this.state = 3618
			multiplyStatement()
			}}
			OPEN  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 31)
			if (true){
			this.state = 3619
			openStatement()
			}}
			PERFORM  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 32)
			if (true){
			this.state = 3620
			performStatement()
			}}
			PURGE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 33)
			if (true){
			this.state = 3621
			purgeStatement()
			}}
			READ  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 34)
			if (true){
			this.state = 3622
			readStatement()
			}}
			RECEIVE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 35)
			if (true){
			this.state = 3623
			receiveStatement()
			}}
			RELEASE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 36)
			if (true){
			this.state = 3624
			releaseStatement()
			}}
			RETURN  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 37)
			if (true){
			this.state = 3625
			returnStatement()
			}}
			REWRITE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 38)
			if (true){
			this.state = 3626
			rewriteStatement()
			}}
			SEARCH  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 39)
			if (true){
			this.state = 3627
			searchStatement()
			}}
			SEND  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 40)
			if (true){
			this.state = 3628
			sendStatement()
			}}
			SET  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 41)
			if (true){
			this.state = 3629
			setStatement()
			}}
			SORT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 42)
			if (true){
			this.state = 3630
			sortStatement()
			}}
			START  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 43)
			if (true){
			this.state = 3631
			startStatement()
			}}
			STOP  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 44)
			if (true){
			this.state = 3632
			stopStatement()
			}}
			STRING  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 45)
			if (true){
			this.state = 3633
			stringStatement()
			}}
			SUBTRACT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 46)
			if (true){
			this.state = 3634
			subtractStatement()
			}}
			TERMINATE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 47)
			if (true){
			this.state = 3635
			terminateStatement()
			}}
			UNSTRING  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 48)
			if (true){
			this.state = 3636
			unstringStatement()
			}}
			WRITE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 49)
			if (true){
			this.state = 3637
			writeStatement()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AcceptStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_acceptStatement.id
	        set(value) { throw RuntimeException() }
		fun ACCEPT() : TerminalNode? = getToken(Cobol85Parser.Tokens.ACCEPT.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findAcceptFromDateStatement() : AcceptFromDateStatementContext? = getRuleContext(solver.getType("AcceptFromDateStatementContext"),0)
		fun findAcceptFromEscapeKeyStatement() : AcceptFromEscapeKeyStatementContext? = getRuleContext(solver.getType("AcceptFromEscapeKeyStatementContext"),0)
		fun findAcceptFromMnemonicStatement() : AcceptFromMnemonicStatementContext? = getRuleContext(solver.getType("AcceptFromMnemonicStatementContext"),0)
		fun findAcceptMessageCountStatement() : AcceptMessageCountStatementContext? = getRuleContext(solver.getType("AcceptMessageCountStatementContext"),0)
		fun findOnExceptionClause() : OnExceptionClauseContext? = getRuleContext(solver.getType("OnExceptionClauseContext"),0)
		fun findNotOnExceptionClause() : NotOnExceptionClauseContext? = getRuleContext(solver.getType("NotOnExceptionClauseContext"),0)
		fun END_ACCEPT() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_ACCEPT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAcceptStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAcceptStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAcceptStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  acceptStatement() : AcceptStatementContext {
		var _localctx : AcceptStatementContext = AcceptStatementContext(context, state)
		enterRule(_localctx, 538, Rules.RULE_acceptStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3640
			match(ACCEPT) as Token
			this.state = 3641
			identifier()
			this.state = 3646
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,465,context) ) {
			1   -> if (true){
			this.state = 3642
			acceptFromDateStatement()
			}
			2   -> if (true){
			this.state = 3643
			acceptFromEscapeKeyStatement()
			}
			3   -> if (true){
			this.state = 3644
			acceptFromMnemonicStatement()
			}
			4   -> if (true){
			this.state = 3645
			acceptMessageCountStatement()
			}
			}
			this.state = 3649
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,466,context) ) {
			1   -> if (true){
			this.state = 3648
			onExceptionClause()
			}
			}
			this.state = 3652
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,467,context) ) {
			1   -> if (true){
			this.state = 3651
			notOnExceptionClause()
			}
			}
			this.state = 3655
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,468,context) ) {
			1   -> if (true){
			this.state = 3654
			match(END_ACCEPT) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AcceptFromDateStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_acceptFromDateStatement.id
	        set(value) { throw RuntimeException() }
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun DATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DATE.id, 0)
		fun DAY() : TerminalNode? = getToken(Cobol85Parser.Tokens.DAY.id, 0)
		fun DAY_OF_WEEK() : TerminalNode? = getToken(Cobol85Parser.Tokens.DAY_OF_WEEK.id, 0)
		fun TIME() : TerminalNode? = getToken(Cobol85Parser.Tokens.TIME.id, 0)
		fun TIMER() : TerminalNode? = getToken(Cobol85Parser.Tokens.TIMER.id, 0)
		fun TODAYS_DATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.TODAYS_DATE.id, 0)
		fun TODAYS_NAME() : TerminalNode? = getToken(Cobol85Parser.Tokens.TODAYS_NAME.id, 0)
		fun YEAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.YEAR.id, 0)
		fun YYYYMMDD() : TerminalNode? = getToken(Cobol85Parser.Tokens.YYYYMMDD.id, 0)
		fun YYYYDDD() : TerminalNode? = getToken(Cobol85Parser.Tokens.YYYYDDD.id, 0)
		fun MMDDYYYY() : TerminalNode? = getToken(Cobol85Parser.Tokens.MMDDYYYY.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAcceptFromDateStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAcceptFromDateStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAcceptFromDateStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  acceptFromDateStatement() : AcceptFromDateStatementContext {
		var _localctx : AcceptFromDateStatementContext = AcceptFromDateStatementContext(context, state)
		enterRule(_localctx, 540, Rules.RULE_acceptFromDateStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3657
			match(FROM) as Token
			this.state = 3677
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			DATE  ->  /*LL1AltBlock*/{if (true){
			this.state = 3658
			match(DATE) as Token
			this.state = 3660
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==YYYYMMDD) {
				if (true){
				this.state = 3659
				match(YYYYMMDD) as Token
				}
			}

			}}
			DAY  ->  /*LL1AltBlock*/{if (true){
			this.state = 3662
			match(DAY) as Token
			this.state = 3664
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==YYYYDDD) {
				if (true){
				this.state = 3663
				match(YYYYDDD) as Token
				}
			}

			}}
			DAY_OF_WEEK  ->  /*LL1AltBlock*/{if (true){
			this.state = 3666
			match(DAY_OF_WEEK) as Token
			}}
			TIME  ->  /*LL1AltBlock*/{if (true){
			this.state = 3667
			match(TIME) as Token
			}}
			TIMER  ->  /*LL1AltBlock*/{if (true){
			this.state = 3668
			match(TIMER) as Token
			}}
			TODAYS_DATE  ->  /*LL1AltBlock*/{if (true){
			this.state = 3669
			match(TODAYS_DATE) as Token
			this.state = 3671
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==MMDDYYYY) {
				if (true){
				this.state = 3670
				match(MMDDYYYY) as Token
				}
			}

			}}
			TODAYS_NAME  ->  /*LL1AltBlock*/{if (true){
			this.state = 3673
			match(TODAYS_NAME) as Token
			}}
			YEAR  ->  /*LL1AltBlock*/{if (true){
			this.state = 3674
			match(YEAR) as Token
			}}
			YYYYMMDD  ->  /*LL1AltBlock*/{if (true){
			this.state = 3675
			match(YYYYMMDD) as Token
			}}
			YYYYDDD  ->  /*LL1AltBlock*/{if (true){
			this.state = 3676
			match(YYYYDDD) as Token
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AcceptFromMnemonicStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_acceptFromMnemonicStatement.id
	        set(value) { throw RuntimeException() }
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun findMnemonicName() : MnemonicNameContext? = getRuleContext(solver.getType("MnemonicNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAcceptFromMnemonicStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAcceptFromMnemonicStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAcceptFromMnemonicStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  acceptFromMnemonicStatement() : AcceptFromMnemonicStatementContext {
		var _localctx : AcceptFromMnemonicStatementContext = AcceptFromMnemonicStatementContext(context, state)
		enterRule(_localctx, 542, Rules.RULE_acceptFromMnemonicStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3679
			match(FROM) as Token
			this.state = 3680
			mnemonicName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AcceptFromEscapeKeyStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_acceptFromEscapeKeyStatement.id
	        set(value) { throw RuntimeException() }
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun ESCAPE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ESCAPE.id, 0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAcceptFromEscapeKeyStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAcceptFromEscapeKeyStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAcceptFromEscapeKeyStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  acceptFromEscapeKeyStatement() : AcceptFromEscapeKeyStatementContext {
		var _localctx : AcceptFromEscapeKeyStatementContext = AcceptFromEscapeKeyStatementContext(context, state)
		enterRule(_localctx, 544, Rules.RULE_acceptFromEscapeKeyStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3682
			match(FROM) as Token
			this.state = 3683
			match(ESCAPE) as Token
			this.state = 3684
			match(KEY) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AcceptMessageCountStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_acceptMessageCountStatement.id
	        set(value) { throw RuntimeException() }
		fun COUNT() : TerminalNode? = getToken(Cobol85Parser.Tokens.COUNT.id, 0)
		fun MESSAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.MESSAGE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAcceptMessageCountStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAcceptMessageCountStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAcceptMessageCountStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  acceptMessageCountStatement() : AcceptMessageCountStatementContext {
		var _localctx : AcceptMessageCountStatementContext = AcceptMessageCountStatementContext(context, state)
		enterRule(_localctx, 546, Rules.RULE_acceptMessageCountStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3687
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==MESSAGE) {
				if (true){
				this.state = 3686
				match(MESSAGE) as Token
				}
			}

			this.state = 3689
			match(COUNT) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AddStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_addStatement.id
	        set(value) { throw RuntimeException() }
		fun ADD() : TerminalNode? = getToken(Cobol85Parser.Tokens.ADD.id, 0)
		fun findAddToStatement() : AddToStatementContext? = getRuleContext(solver.getType("AddToStatementContext"),0)
		fun findAddToGivingStatement() : AddToGivingStatementContext? = getRuleContext(solver.getType("AddToGivingStatementContext"),0)
		fun findAddCorrespondingStatement() : AddCorrespondingStatementContext? = getRuleContext(solver.getType("AddCorrespondingStatementContext"),0)
		fun findOnSizeErrorPhrase() : OnSizeErrorPhraseContext? = getRuleContext(solver.getType("OnSizeErrorPhraseContext"),0)
		fun findNotOnSizeErrorPhrase() : NotOnSizeErrorPhraseContext? = getRuleContext(solver.getType("NotOnSizeErrorPhraseContext"),0)
		fun END_ADD() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_ADD.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAddStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAddStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAddStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  addStatement() : AddStatementContext {
		var _localctx : AddStatementContext = AddStatementContext(context, state)
		enterRule(_localctx, 548, Rules.RULE_addStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3691
			match(ADD) as Token
			this.state = 3695
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,474,context) ) {
			1 -> {if (true){
			this.state = 3692
			addToStatement()
			}}
			2 -> {if (true){
			this.state = 3693
			addToGivingStatement()
			}}
			3 -> {if (true){
			this.state = 3694
			addCorrespondingStatement()
			}}
			}
			this.state = 3698
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,475,context) ) {
			1   -> if (true){
			this.state = 3697
			onSizeErrorPhrase()
			}
			}
			this.state = 3701
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,476,context) ) {
			1   -> if (true){
			this.state = 3700
			notOnSizeErrorPhrase()
			}
			}
			this.state = 3704
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,477,context) ) {
			1   -> if (true){
			this.state = 3703
			match(END_ADD) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AddToStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_addToStatement.id
	        set(value) { throw RuntimeException() }
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun findAddFrom() : List<AddFromContext> = getRuleContexts(solver.getType("AddFromContext"))
		fun findAddFrom(i: Int) : AddFromContext? = getRuleContext(solver.getType("AddFromContext"),i)
		fun findAddTo() : List<AddToContext> = getRuleContexts(solver.getType("AddToContext"))
		fun findAddTo(i: Int) : AddToContext? = getRuleContext(solver.getType("AddToContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAddToStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAddToStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAddToStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  addToStatement() : AddToStatementContext {
		var _localctx : AddToStatementContext = AddToStatementContext(context, state)
		enterRule(_localctx, 550, Rules.RULE_addToStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3707 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 3706
				addFrom()
				}
				}
				this.state = 3709 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)))) != 0L) || ((((_la - 551)) and 0x3f.inv()) == 0 && ((1L shl (_la - 551)) and ((1L shl (NONNUMERICLITERAL - 551)) or (1L shl (LEVEL_NUMBER_66 - 551)) or (1L shl (LEVEL_NUMBER_77 - 551)) or (1L shl (LEVEL_NUMBER_88 - 551)) or (1L shl (INTEGERLITERAL - 551)) or (1L shl (NUMERICLITERAL - 551)) or (1L shl (IDENTIFIER - 551)))) != 0L) )
			this.state = 3711
			match(TO) as Token
			this.state = 3713 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 3712
				addTo()
				}
				}
				this.state = 3715 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AddToGivingStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_addToGivingStatement.id
	        set(value) { throw RuntimeException() }
		fun GIVING() : TerminalNode? = getToken(Cobol85Parser.Tokens.GIVING.id, 0)
		fun findAddFrom() : List<AddFromContext> = getRuleContexts(solver.getType("AddFromContext"))
		fun findAddFrom(i: Int) : AddFromContext? = getRuleContext(solver.getType("AddFromContext"),i)
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun findAddGiving() : List<AddGivingContext> = getRuleContexts(solver.getType("AddGivingContext"))
		fun findAddGiving(i: Int) : AddGivingContext? = getRuleContext(solver.getType("AddGivingContext"),i)
		fun findAddToGiving() : List<AddToGivingContext> = getRuleContexts(solver.getType("AddToGivingContext"))
		fun findAddToGiving(i: Int) : AddToGivingContext? = getRuleContext(solver.getType("AddToGivingContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAddToGivingStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAddToGivingStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAddToGivingStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  addToGivingStatement() : AddToGivingStatementContext {
		var _localctx : AddToGivingStatementContext = AddToGivingStatementContext(context, state)
		enterRule(_localctx, 552, Rules.RULE_addToGivingStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3718 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 3717
				addFrom()
				}
				}
				this.state = 3720 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)))) != 0L) || ((((_la - 551)) and 0x3f.inv()) == 0 && ((1L shl (_la - 551)) and ((1L shl (NONNUMERICLITERAL - 551)) or (1L shl (LEVEL_NUMBER_66 - 551)) or (1L shl (LEVEL_NUMBER_77 - 551)) or (1L shl (LEVEL_NUMBER_88 - 551)) or (1L shl (INTEGERLITERAL - 551)) or (1L shl (NUMERICLITERAL - 551)) or (1L shl (IDENTIFIER - 551)))) != 0L) )
			this.state = 3728
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TO) {
				if (true){
				this.state = 3722
				match(TO) as Token
				this.state = 3724 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				do {
					if (true){
					if (true){
					this.state = 3723
					addToGiving()
					}
					}
					this.state = 3726 
					errorHandler.sync(this)
					_la = _input!!.LA(1)
				} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)))) != 0L) || ((((_la - 551)) and 0x3f.inv()) == 0 && ((1L shl (_la - 551)) and ((1L shl (NONNUMERICLITERAL - 551)) or (1L shl (LEVEL_NUMBER_66 - 551)) or (1L shl (LEVEL_NUMBER_77 - 551)) or (1L shl (LEVEL_NUMBER_88 - 551)) or (1L shl (INTEGERLITERAL - 551)) or (1L shl (NUMERICLITERAL - 551)) or (1L shl (IDENTIFIER - 551)))) != 0L) )
				}
			}

			this.state = 3730
			match(GIVING) as Token
			this.state = 3732 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 3731
				addGiving()
				}
				}
				this.state = 3734 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AddCorrespondingStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_addCorrespondingStatement.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun findAddTo() : AddToContext? = getRuleContext(solver.getType("AddToContext"),0)
		fun CORRESPONDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.CORRESPONDING.id, 0)
		fun CORR() : TerminalNode? = getToken(Cobol85Parser.Tokens.CORR.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAddCorrespondingStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAddCorrespondingStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAddCorrespondingStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  addCorrespondingStatement() : AddCorrespondingStatementContext {
		var _localctx : AddCorrespondingStatementContext = AddCorrespondingStatementContext(context, state)
		enterRule(_localctx, 554, Rules.RULE_addCorrespondingStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3736
			_la = _input!!.LA(1)
			if ( !(_la==CORR || _la==CORRESPONDING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3737
			identifier()
			this.state = 3738
			match(TO) as Token
			this.state = 3739
			addTo()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AddFromContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_addFrom.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAddFrom(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAddFrom(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAddFrom(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  addFrom() : AddFromContext {
		var _localctx : AddFromContext = AddFromContext(context, state)
		enterRule(_localctx, 556, Rules.RULE_addFrom.id)
		try {
			this.state = 3743
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,484,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3741
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3742
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AddToContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_addTo.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun ROUNDED() : TerminalNode? = getToken(Cobol85Parser.Tokens.ROUNDED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAddTo(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAddTo(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAddTo(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  addTo() : AddToContext {
		var _localctx : AddToContext = AddToContext(context, state)
		enterRule(_localctx, 558, Rules.RULE_addTo.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3745
			identifier()
			this.state = 3747
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ROUNDED) {
				if (true){
				this.state = 3746
				match(ROUNDED) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AddToGivingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_addToGiving.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAddToGiving(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAddToGiving(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAddToGiving(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  addToGiving() : AddToGivingContext {
		var _localctx : AddToGivingContext = AddToGivingContext(context, state)
		enterRule(_localctx, 560, Rules.RULE_addToGiving.id)
		try {
			this.state = 3751
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,486,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3749
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3750
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AddGivingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_addGiving.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun ROUNDED() : TerminalNode? = getToken(Cobol85Parser.Tokens.ROUNDED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAddGiving(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAddGiving(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAddGiving(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  addGiving() : AddGivingContext {
		var _localctx : AddGivingContext = AddGivingContext(context, state)
		enterRule(_localctx, 562, Rules.RULE_addGiving.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3753
			identifier()
			this.state = 3755
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ROUNDED) {
				if (true){
				this.state = 3754
				match(ROUNDED) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AlteredGoToContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_alteredGoTo.id
	        set(value) { throw RuntimeException() }
		fun GO() : TerminalNode? = getToken(Cobol85Parser.Tokens.GO.id, 0)
		fun DOT_FS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOT_FS.id, 0)
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAlteredGoTo(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAlteredGoTo(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAlteredGoTo(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  alteredGoTo() : AlteredGoToContext {
		var _localctx : AlteredGoToContext = AlteredGoToContext(context, state)
		enterRule(_localctx, 564, Rules.RULE_alteredGoTo.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3757
			match(GO) as Token
			this.state = 3759
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TO) {
				if (true){
				this.state = 3758
				match(TO) as Token
				}
			}

			this.state = 3761
			match(DOT_FS) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AlterStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_alterStatement.id
	        set(value) { throw RuntimeException() }
		fun ALTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALTER.id, 0)
		fun findAlterProceedTo() : List<AlterProceedToContext> = getRuleContexts(solver.getType("AlterProceedToContext"))
		fun findAlterProceedTo(i: Int) : AlterProceedToContext? = getRuleContext(solver.getType("AlterProceedToContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAlterStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAlterStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAlterStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  alterStatement() : AlterStatementContext {
		var _localctx : AlterStatementContext = AlterStatementContext(context, state)
		enterRule(_localctx, 566, Rules.RULE_alterStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3763
			match(ALTER) as Token
			this.state = 3765 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 3764
				alterProceedTo()
				}
				}
				this.state = 3767 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AlterProceedToContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_alterProceedTo.id
	        set(value) { throw RuntimeException() }
		fun findProcedureName() : List<ProcedureNameContext> = getRuleContexts(solver.getType("ProcedureNameContext"))
		fun findProcedureName(i: Int) : ProcedureNameContext? = getRuleContext(solver.getType("ProcedureNameContext"),i)
		fun TO() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.TO.id)
		fun TO(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.TO.id, i) as TerminalNode
		fun PROCEED() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROCEED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAlterProceedTo(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAlterProceedTo(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAlterProceedTo(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  alterProceedTo() : AlterProceedToContext {
		var _localctx : AlterProceedToContext = AlterProceedToContext(context, state)
		enterRule(_localctx, 568, Rules.RULE_alterProceedTo.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3769
			procedureName()
			this.state = 3770
			match(TO) as Token
			this.state = 3773
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==PROCEED) {
				if (true){
				this.state = 3771
				match(PROCEED) as Token
				this.state = 3772
				match(TO) as Token
				}
			}

			this.state = 3775
			procedureName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CallStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_callStatement.id
	        set(value) { throw RuntimeException() }
		fun CALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.CALL.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findCallUsingPhrase() : CallUsingPhraseContext? = getRuleContext(solver.getType("CallUsingPhraseContext"),0)
		fun findCallGivingPhrase() : CallGivingPhraseContext? = getRuleContext(solver.getType("CallGivingPhraseContext"),0)
		fun findOnOverflowPhrase() : OnOverflowPhraseContext? = getRuleContext(solver.getType("OnOverflowPhraseContext"),0)
		fun findOnExceptionClause() : OnExceptionClauseContext? = getRuleContext(solver.getType("OnExceptionClauseContext"),0)
		fun findNotOnExceptionClause() : NotOnExceptionClauseContext? = getRuleContext(solver.getType("NotOnExceptionClauseContext"),0)
		fun END_CALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_CALL.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCallStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCallStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCallStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  callStatement() : CallStatementContext {
		var _localctx : CallStatementContext = CallStatementContext(context, state)
		enterRule(_localctx, 570, Rules.RULE_callStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3777
			match(CALL) as Token
			this.state = 3780
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,491,context) ) {
			1 -> {if (true){
			this.state = 3778
			identifier()
			}}
			2 -> {if (true){
			this.state = 3779
			literal()
			}}
			}
			this.state = 3783
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==USING) {
				if (true){
				this.state = 3782
				callUsingPhrase()
				}
			}

			this.state = 3786
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==GIVING || _la==RETURNING) {
				if (true){
				this.state = 3785
				callGivingPhrase()
				}
			}

			this.state = 3789
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,494,context) ) {
			1   -> if (true){
			this.state = 3788
			onOverflowPhrase()
			}
			}
			this.state = 3792
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,495,context) ) {
			1   -> if (true){
			this.state = 3791
			onExceptionClause()
			}
			}
			this.state = 3795
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,496,context) ) {
			1   -> if (true){
			this.state = 3794
			notOnExceptionClause()
			}
			}
			this.state = 3798
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,497,context) ) {
			1   -> if (true){
			this.state = 3797
			match(END_CALL) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CallUsingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_callUsingPhrase.id
	        set(value) { throw RuntimeException() }
		fun USING() : TerminalNode? = getToken(Cobol85Parser.Tokens.USING.id, 0)
		fun findCallUsingParameter() : List<CallUsingParameterContext> = getRuleContexts(solver.getType("CallUsingParameterContext"))
		fun findCallUsingParameter(i: Int) : CallUsingParameterContext? = getRuleContext(solver.getType("CallUsingParameterContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCallUsingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCallUsingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCallUsingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  callUsingPhrase() : CallUsingPhraseContext {
		var _localctx : CallUsingPhraseContext = CallUsingPhraseContext(context, state)
		enterRule(_localctx, 572, Rules.RULE_callUsingPhrase.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3800
			match(USING) as Token
			this.state = 3802 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 3801
				callUsingParameter()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 3804 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,498,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CallUsingParameterContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_callUsingParameter.id
	        set(value) { throw RuntimeException() }
		fun findCallByReferencePhrase() : CallByReferencePhraseContext? = getRuleContext(solver.getType("CallByReferencePhraseContext"),0)
		fun findCallByValuePhrase() : CallByValuePhraseContext? = getRuleContext(solver.getType("CallByValuePhraseContext"),0)
		fun findCallByContentPhrase() : CallByContentPhraseContext? = getRuleContext(solver.getType("CallByContentPhraseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCallUsingParameter(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCallUsingParameter(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCallUsingParameter(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  callUsingParameter() : CallUsingParameterContext {
		var _localctx : CallUsingParameterContext = CallUsingParameterContext(context, state)
		enterRule(_localctx, 574, Rules.RULE_callUsingParameter.id)
		try {
			this.state = 3809
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,499,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3806
			callByReferencePhrase()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3807
			callByValuePhrase()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 3808
			callByContentPhrase()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CallByReferencePhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_callByReferencePhrase.id
	        set(value) { throw RuntimeException() }
		fun REFERENCE() : TerminalNode? = getToken(Cobol85Parser.Tokens.REFERENCE.id, 0)
		fun findCallByReference() : List<CallByReferenceContext> = getRuleContexts(solver.getType("CallByReferenceContext"))
		fun findCallByReference(i: Int) : CallByReferenceContext? = getRuleContext(solver.getType("CallByReferenceContext"),i)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCallByReferencePhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCallByReferencePhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCallByReferencePhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  callByReferencePhrase() : CallByReferencePhraseContext {
		var _localctx : CallByReferencePhraseContext = CallByReferencePhraseContext(context, state)
		enterRule(_localctx, 576, Rules.RULE_callByReferencePhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3815
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==BY || _la==REFERENCE) {
				if (true){
				this.state = 3812
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==BY) {
					if (true){
					this.state = 3811
					match(BY) as Token
					}
				}

				this.state = 3814
				match(REFERENCE) as Token
				}
			}

			this.state = 3818 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 3817
				callByReference()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 3820 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,502,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CallByReferenceContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_callByReference.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun ADDRESS() : TerminalNode? = getToken(Cobol85Parser.Tokens.ADDRESS.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		fun INTEGER() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTEGER.id, 0)
		fun STRING() : TerminalNode? = getToken(Cobol85Parser.Tokens.STRING.id, 0)
		fun OMITTED() : TerminalNode? = getToken(Cobol85Parser.Tokens.OMITTED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCallByReference(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCallByReference(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCallByReference(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  callByReference() : CallByReferenceContext {
		var _localctx : CallByReferenceContext = CallByReferenceContext(context, state)
		enterRule(_localctx, 578, Rules.RULE_callByReference.id)
		try {
			this.state = 3834
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ABORT , ADDRESS , ALL , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DATE , DAY , DAY_OF_WEEK , DEBUG_CONTENTS , DEBUG_ITEM , DEBUG_LINE , DEBUG_NAME , DEBUG_SUB_1 , DEBUG_SUB_2 , DEBUG_SUB_3 , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FALSE , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTION , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , HIGH_VALUE , HIGH_VALUES , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LINAGE_COUNTER , LINE_COUNTER , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , LOW_VALUE , LOW_VALUES , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NULL , NULLS , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PAGE_COUNTER , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , QUOTE , QUOTES , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , RETURN_CODE , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHIFT_IN , SHIFT_OUT , SHORT_DATE , SORT_CONTROL , SORT_CORE_SIZE , SORT_FILE_SIZE , SORT_MESSAGE , SORT_MODE_SIZE , SORT_RETURN , SPACE , SPACES , STRING , SYMBOL , TALLY , TASK , THREAD , THREAD_LOCAL , TIME , TIMER , TODAYS_DATE , TODAYS_NAME , TRUE , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , WHEN_COMPILED , YEAR , YYYYMMDD , YYYYDDD , ZERO , ZERO_FILL , ZEROS , ZEROES , NONNUMERICLITERAL , LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL , NUMERICLITERAL , IDENTIFIER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3831
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,504,context) ) {
			1 -> {if (true){
			this.state = 3826
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,503,context) ) {
			1   -> if (true){
			this.state = 3822
			match(ADDRESS) as Token
			this.state = 3823
			match(OF) as Token
			}
			2   -> if (true){
			this.state = 3824
			match(INTEGER) as Token
			}
			3   -> if (true){
			this.state = 3825
			match(STRING) as Token
			}
			}
			this.state = 3828
			identifier()
			}}
			2 -> {if (true){
			this.state = 3829
			literal()
			}}
			3 -> {if (true){
			this.state = 3830
			fileName()
			}}
			}
			}}
			OMITTED  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3833
			match(OMITTED) as Token
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CallByValuePhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_callByValuePhrase.id
	        set(value) { throw RuntimeException() }
		fun VALUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.VALUE.id, 0)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun findCallByValue() : List<CallByValueContext> = getRuleContexts(solver.getType("CallByValueContext"))
		fun findCallByValue(i: Int) : CallByValueContext? = getRuleContext(solver.getType("CallByValueContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCallByValuePhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCallByValuePhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCallByValuePhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  callByValuePhrase() : CallByValuePhraseContext {
		var _localctx : CallByValuePhraseContext = CallByValuePhraseContext(context, state)
		enterRule(_localctx, 580, Rules.RULE_callByValuePhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3837
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==BY) {
				if (true){
				this.state = 3836
				match(BY) as Token
				}
			}

			this.state = 3839
			match(VALUE) as Token
			this.state = 3841 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 3840
				callByValue()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 3843 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,507,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CallByValueContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_callByValue.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun ADDRESS() : TerminalNode? = getToken(Cobol85Parser.Tokens.ADDRESS.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		fun LENGTH() : TerminalNode? = getToken(Cobol85Parser.Tokens.LENGTH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCallByValue(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCallByValue(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCallByValue(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  callByValue() : CallByValueContext {
		var _localctx : CallByValueContext = CallByValueContext(context, state)
		enterRule(_localctx, 582, Rules.RULE_callByValue.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3851
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,509,context) ) {
			1   -> if (true){
			this.state = 3845
			match(ADDRESS) as Token
			this.state = 3846
			match(OF) as Token
			}
			2   -> if (true){
			this.state = 3847
			match(LENGTH) as Token
			this.state = 3849
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OF) {
				if (true){
				this.state = 3848
				match(OF) as Token
				}
			}

			}
			}
			this.state = 3855
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,510,context) ) {
			1 -> {if (true){
			this.state = 3853
			identifier()
			}}
			2 -> {if (true){
			this.state = 3854
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CallByContentPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_callByContentPhrase.id
	        set(value) { throw RuntimeException() }
		fun CONTENT() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTENT.id, 0)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun findCallByContent() : List<CallByContentContext> = getRuleContexts(solver.getType("CallByContentContext"))
		fun findCallByContent(i: Int) : CallByContentContext? = getRuleContext(solver.getType("CallByContentContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCallByContentPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCallByContentPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCallByContentPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  callByContentPhrase() : CallByContentPhraseContext {
		var _localctx : CallByContentPhraseContext = CallByContentPhraseContext(context, state)
		enterRule(_localctx, 584, Rules.RULE_callByContentPhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3858
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==BY) {
				if (true){
				this.state = 3857
				match(BY) as Token
				}
			}

			this.state = 3860
			match(CONTENT) as Token
			this.state = 3862 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 3861
				callByContent()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 3864 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,512,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CallByContentContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_callByContent.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun ADDRESS() : TerminalNode? = getToken(Cobol85Parser.Tokens.ADDRESS.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		fun LENGTH() : TerminalNode? = getToken(Cobol85Parser.Tokens.LENGTH.id, 0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun OMITTED() : TerminalNode? = getToken(Cobol85Parser.Tokens.OMITTED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCallByContent(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCallByContent(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCallByContent(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  callByContent() : CallByContentContext {
		var _localctx : CallByContentContext = CallByContentContext(context, state)
		enterRule(_localctx, 586, Rules.RULE_callByContent.id)
		var _la: Int
		try {
			this.state = 3877
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,515,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3872
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,514,context) ) {
			1   -> if (true){
			this.state = 3866
			match(ADDRESS) as Token
			this.state = 3867
			match(OF) as Token
			}
			2   -> if (true){
			this.state = 3868
			match(LENGTH) as Token
			this.state = 3870
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OF) {
				if (true){
				this.state = 3869
				match(OF) as Token
				}
			}

			}
			}
			this.state = 3874
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3875
			literal()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 3876
			match(OMITTED) as Token
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CallGivingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_callGivingPhrase.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun GIVING() : TerminalNode? = getToken(Cobol85Parser.Tokens.GIVING.id, 0)
		fun RETURNING() : TerminalNode? = getToken(Cobol85Parser.Tokens.RETURNING.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCallGivingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCallGivingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCallGivingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  callGivingPhrase() : CallGivingPhraseContext {
		var _localctx : CallGivingPhraseContext = CallGivingPhraseContext(context, state)
		enterRule(_localctx, 588, Rules.RULE_callGivingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3879
			_la = _input!!.LA(1)
			if ( !(_la==GIVING || _la==RETURNING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3880
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CancelStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_cancelStatement.id
	        set(value) { throw RuntimeException() }
		fun CANCEL() : TerminalNode? = getToken(Cobol85Parser.Tokens.CANCEL.id, 0)
		fun findCancelCall() : List<CancelCallContext> = getRuleContexts(solver.getType("CancelCallContext"))
		fun findCancelCall(i: Int) : CancelCallContext? = getRuleContext(solver.getType("CancelCallContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCancelStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCancelStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCancelStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  cancelStatement() : CancelStatementContext {
		var _localctx : CancelStatementContext = CancelStatementContext(context, state)
		enterRule(_localctx, 590, Rules.RULE_cancelStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3882
			match(CANCEL) as Token
			this.state = 3884 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 3883
				cancelCall()
				}
				}
				this.state = 3886 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)))) != 0L) || ((((_la - 551)) and 0x3f.inv()) == 0 && ((1L shl (_la - 551)) and ((1L shl (NONNUMERICLITERAL - 551)) or (1L shl (LEVEL_NUMBER_66 - 551)) or (1L shl (LEVEL_NUMBER_77 - 551)) or (1L shl (LEVEL_NUMBER_88 - 551)) or (1L shl (INTEGERLITERAL - 551)) or (1L shl (NUMERICLITERAL - 551)) or (1L shl (IDENTIFIER - 551)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CancelCallContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_cancelCall.id
	        set(value) { throw RuntimeException() }
		fun findLibraryName() : LibraryNameContext? = getRuleContext(solver.getType("LibraryNameContext"),0)
		fun BYTITLE() : TerminalNode? = getToken(Cobol85Parser.Tokens.BYTITLE.id, 0)
		fun BYFUNCTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.BYFUNCTION.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCancelCall(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCancelCall(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCancelCall(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  cancelCall() : CancelCallContext {
		var _localctx : CancelCallContext = CancelCallContext(context, state)
		enterRule(_localctx, 592, Rules.RULE_cancelCall.id)
		var _la: Int
		try {
			this.state = 3893
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,517,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3888
			libraryName()
			this.state = 3889
			_la = _input!!.LA(1)
			if ( !(_la==BYFUNCTION || _la==BYTITLE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3891
			identifier()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 3892
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CloseStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_closeStatement.id
	        set(value) { throw RuntimeException() }
		fun CLOSE() : TerminalNode? = getToken(Cobol85Parser.Tokens.CLOSE.id, 0)
		fun findCloseFile() : List<CloseFileContext> = getRuleContexts(solver.getType("CloseFileContext"))
		fun findCloseFile(i: Int) : CloseFileContext? = getRuleContext(solver.getType("CloseFileContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCloseStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCloseStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCloseStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  closeStatement() : CloseStatementContext {
		var _localctx : CloseStatementContext = CloseStatementContext(context, state)
		enterRule(_localctx, 594, Rules.RULE_closeStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3895
			match(CLOSE) as Token
			this.state = 3897 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 3896
				closeFile()
				}
				}
				this.state = 3899 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CloseFileContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_closeFile.id
	        set(value) { throw RuntimeException() }
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun findCloseReelUnitStatement() : CloseReelUnitStatementContext? = getRuleContext(solver.getType("CloseReelUnitStatementContext"),0)
		fun findCloseRelativeStatement() : CloseRelativeStatementContext? = getRuleContext(solver.getType("CloseRelativeStatementContext"),0)
		fun findClosePortFileIOStatement() : ClosePortFileIOStatementContext? = getRuleContext(solver.getType("ClosePortFileIOStatementContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCloseFile(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCloseFile(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCloseFile(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  closeFile() : CloseFileContext {
		var _localctx : CloseFileContext = CloseFileContext(context, state)
		enterRule(_localctx, 596, Rules.RULE_closeFile.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3901
			fileName()
			this.state = 3905
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,519,context) ) {
			1   -> if (true){
			this.state = 3902
			closeReelUnitStatement()
			}
			2   -> if (true){
			this.state = 3903
			closeRelativeStatement()
			}
			3   -> if (true){
			this.state = 3904
			closePortFileIOStatement()
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CloseReelUnitStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_closeReelUnitStatement.id
	        set(value) { throw RuntimeException() }
		fun REEL() : TerminalNode? = getToken(Cobol85Parser.Tokens.REEL.id, 0)
		fun UNIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.UNIT.id, 0)
		fun REMOVAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.REMOVAL.id, 0)
		fun NO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO.id, 0)
		fun REWIND() : TerminalNode? = getToken(Cobol85Parser.Tokens.REWIND.id, 0)
		fun LOCK() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOCK.id, 0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCloseReelUnitStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCloseReelUnitStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCloseReelUnitStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  closeReelUnitStatement() : CloseReelUnitStatementContext {
		var _localctx : CloseReelUnitStatementContext = CloseReelUnitStatementContext(context, state)
		enterRule(_localctx, 598, Rules.RULE_closeReelUnitStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3907
			_la = _input!!.LA(1)
			if ( !(_la==REEL || _la==UNIT) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3912
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR || _la==REMOVAL) {
				if (true){
				this.state = 3909
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==FOR) {
					if (true){
					this.state = 3908
					match(FOR) as Token
					}
				}

				this.state = 3911
				match(REMOVAL) as Token
				}
			}

			this.state = 3922
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,524,context) ) {
			1   -> if (true){
			this.state = 3915
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 3914
				match(WITH) as Token
				}
			}

			this.state = 3920
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			NO  ->  /*LL1AltBlock*/{if (true){
			this.state = 3917
			match(NO) as Token
			this.state = 3918
			match(REWIND) as Token
			}}
			LOCK  ->  /*LL1AltBlock*/{if (true){
			this.state = 3919
			match(LOCK) as Token
			}}
			else -> throw NoViableAltException(this)
			}
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CloseRelativeStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_closeRelativeStatement.id
	        set(value) { throw RuntimeException() }
		fun NO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO.id, 0)
		fun REWIND() : TerminalNode? = getToken(Cobol85Parser.Tokens.REWIND.id, 0)
		fun LOCK() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOCK.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCloseRelativeStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCloseRelativeStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCloseRelativeStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  closeRelativeStatement() : CloseRelativeStatementContext {
		var _localctx : CloseRelativeStatementContext = CloseRelativeStatementContext(context, state)
		enterRule(_localctx, 600, Rules.RULE_closeRelativeStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3925
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 3924
				match(WITH) as Token
				}
			}

			this.state = 3930
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			NO  ->  /*LL1AltBlock*/{if (true){
			this.state = 3927
			match(NO) as Token
			this.state = 3928
			match(REWIND) as Token
			}}
			LOCK  ->  /*LL1AltBlock*/{if (true){
			this.state = 3929
			match(LOCK) as Token
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ClosePortFileIOStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_closePortFileIOStatement.id
	        set(value) { throw RuntimeException() }
		fun NO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO.id, 0)
		fun WAIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.WAIT.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		fun USING() : TerminalNode? = getToken(Cobol85Parser.Tokens.USING.id, 0)
		fun findClosePortFileIOUsing() : List<ClosePortFileIOUsingContext> = getRuleContexts(solver.getType("ClosePortFileIOUsingContext"))
		fun findClosePortFileIOUsing(i: Int) : ClosePortFileIOUsingContext? = getRuleContext(solver.getType("ClosePortFileIOUsingContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterClosePortFileIOStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitClosePortFileIOStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitClosePortFileIOStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  closePortFileIOStatement() : ClosePortFileIOStatementContext {
		var _localctx : ClosePortFileIOStatementContext = ClosePortFileIOStatementContext(context, state)
		enterRule(_localctx, 602, Rules.RULE_closePortFileIOStatement.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3939
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,528,context) ) {
			1 -> {if (true){
			this.state = 3933
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 3932
				match(WITH) as Token
				}
			}

			this.state = 3935
			match(NO) as Token
			this.state = 3936
			match(WAIT) as Token
			}}
			2 -> {if (true){
			this.state = 3937
			match(WITH) as Token
			this.state = 3938
			match(WAIT) as Token
			}}
			}
			this.state = 3947
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==USING) {
				if (true){
				this.state = 3941
				match(USING) as Token
				this.state = 3943 
				errorHandler.sync(this)
				_alt = 1
				do {
					when (_alt) {
					    1 -> if (true){
					if (true){
					this.state = 3942
					closePortFileIOUsing()
					}
					}
					else -> throw NoViableAltException(this)
					}
					this.state = 3945 
					errorHandler.sync(this)
					_alt = interpreter!!.adaptivePredict(_input!!,529,context)
				} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ClosePortFileIOUsingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_closePortFileIOUsing.id
	        set(value) { throw RuntimeException() }
		fun findClosePortFileIOUsingCloseDisposition() : ClosePortFileIOUsingCloseDispositionContext? = getRuleContext(solver.getType("ClosePortFileIOUsingCloseDispositionContext"),0)
		fun findClosePortFileIOUsingAssociatedData() : ClosePortFileIOUsingAssociatedDataContext? = getRuleContext(solver.getType("ClosePortFileIOUsingAssociatedDataContext"),0)
		fun findClosePortFileIOUsingAssociatedDataLength() : ClosePortFileIOUsingAssociatedDataLengthContext? = getRuleContext(solver.getType("ClosePortFileIOUsingAssociatedDataLengthContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterClosePortFileIOUsing(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitClosePortFileIOUsing(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitClosePortFileIOUsing(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  closePortFileIOUsing() : ClosePortFileIOUsingContext {
		var _localctx : ClosePortFileIOUsingContext = ClosePortFileIOUsingContext(context, state)
		enterRule(_localctx, 604, Rules.RULE_closePortFileIOUsing.id)
		try {
			this.state = 3952
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			CLOSE_DISPOSITION  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3949
			closePortFileIOUsingCloseDisposition()
			}}
			ASSOCIATED_DATA  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 3950
			closePortFileIOUsingAssociatedData()
			}}
			ASSOCIATED_DATA_LENGTH  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 3951
			closePortFileIOUsingAssociatedDataLength()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ClosePortFileIOUsingCloseDispositionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_closePortFileIOUsingCloseDisposition.id
	        set(value) { throw RuntimeException() }
		fun CLOSE_DISPOSITION() : TerminalNode? = getToken(Cobol85Parser.Tokens.CLOSE_DISPOSITION.id, 0)
		fun ABORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.ABORT.id, 0)
		fun ORDERLY() : TerminalNode? = getToken(Cobol85Parser.Tokens.ORDERLY.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterClosePortFileIOUsingCloseDisposition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitClosePortFileIOUsingCloseDisposition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitClosePortFileIOUsingCloseDisposition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  closePortFileIOUsingCloseDisposition() : ClosePortFileIOUsingCloseDispositionContext {
		var _localctx : ClosePortFileIOUsingCloseDispositionContext = ClosePortFileIOUsingCloseDispositionContext(context, state)
		enterRule(_localctx, 606, Rules.RULE_closePortFileIOUsingCloseDisposition.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3954
			match(CLOSE_DISPOSITION) as Token
			this.state = 3956
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OF) {
				if (true){
				this.state = 3955
				match(OF) as Token
				}
			}

			this.state = 3958
			_la = _input!!.LA(1)
			if ( !(_la==ABORT || _la==ORDERLY) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ClosePortFileIOUsingAssociatedDataContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_closePortFileIOUsingAssociatedData.id
	        set(value) { throw RuntimeException() }
		fun ASSOCIATED_DATA() : TerminalNode? = getToken(Cobol85Parser.Tokens.ASSOCIATED_DATA.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterClosePortFileIOUsingAssociatedData(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitClosePortFileIOUsingAssociatedData(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitClosePortFileIOUsingAssociatedData(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  closePortFileIOUsingAssociatedData() : ClosePortFileIOUsingAssociatedDataContext {
		var _localctx : ClosePortFileIOUsingAssociatedDataContext = ClosePortFileIOUsingAssociatedDataContext(context, state)
		enterRule(_localctx, 608, Rules.RULE_closePortFileIOUsingAssociatedData.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3960
			match(ASSOCIATED_DATA) as Token
			this.state = 3963
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,533,context) ) {
			1 -> {if (true){
			this.state = 3961
			identifier()
			}}
			2 -> {if (true){
			this.state = 3962
			integerLiteral()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ClosePortFileIOUsingAssociatedDataLengthContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_closePortFileIOUsingAssociatedDataLength.id
	        set(value) { throw RuntimeException() }
		fun ASSOCIATED_DATA_LENGTH() : TerminalNode? = getToken(Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterClosePortFileIOUsingAssociatedDataLength(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitClosePortFileIOUsingAssociatedDataLength(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitClosePortFileIOUsingAssociatedDataLength(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  closePortFileIOUsingAssociatedDataLength() : ClosePortFileIOUsingAssociatedDataLengthContext {
		var _localctx : ClosePortFileIOUsingAssociatedDataLengthContext = ClosePortFileIOUsingAssociatedDataLengthContext(context, state)
		enterRule(_localctx, 610, Rules.RULE_closePortFileIOUsingAssociatedDataLength.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3965
			match(ASSOCIATED_DATA_LENGTH) as Token
			this.state = 3967
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OF) {
				if (true){
				this.state = 3966
				match(OF) as Token
				}
			}

			this.state = 3971
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,535,context) ) {
			1 -> {if (true){
			this.state = 3969
			identifier()
			}}
			2 -> {if (true){
			this.state = 3970
			integerLiteral()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ComputeStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_computeStatement.id
	        set(value) { throw RuntimeException() }
		fun COMPUTE() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMPUTE.id, 0)
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		fun EQUALCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.EQUALCHAR.id, 0)
		fun EQUAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.EQUAL.id, 0)
		fun findComputeStore() : List<ComputeStoreContext> = getRuleContexts(solver.getType("ComputeStoreContext"))
		fun findComputeStore(i: Int) : ComputeStoreContext? = getRuleContext(solver.getType("ComputeStoreContext"),i)
		fun findOnSizeErrorPhrase() : OnSizeErrorPhraseContext? = getRuleContext(solver.getType("OnSizeErrorPhraseContext"),0)
		fun findNotOnSizeErrorPhrase() : NotOnSizeErrorPhraseContext? = getRuleContext(solver.getType("NotOnSizeErrorPhraseContext"),0)
		fun END_COMPUTE() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_COMPUTE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterComputeStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitComputeStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitComputeStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  computeStatement() : ComputeStatementContext {
		var _localctx : ComputeStatementContext = ComputeStatementContext(context, state)
		enterRule(_localctx, 612, Rules.RULE_computeStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3973
			match(COMPUTE) as Token
			this.state = 3975 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 3974
				computeStore()
				}
				}
				this.state = 3977 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			this.state = 3979
			_la = _input!!.LA(1)
			if ( !(_la==EQUAL || _la==EQUALCHAR) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 3980
			arithmeticExpression()
			this.state = 3982
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,537,context) ) {
			1   -> if (true){
			this.state = 3981
			onSizeErrorPhrase()
			}
			}
			this.state = 3985
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,538,context) ) {
			1   -> if (true){
			this.state = 3984
			notOnSizeErrorPhrase()
			}
			}
			this.state = 3988
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,539,context) ) {
			1   -> if (true){
			this.state = 3987
			match(END_COMPUTE) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ComputeStoreContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_computeStore.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun ROUNDED() : TerminalNode? = getToken(Cobol85Parser.Tokens.ROUNDED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterComputeStore(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitComputeStore(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitComputeStore(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  computeStore() : ComputeStoreContext {
		var _localctx : ComputeStoreContext = ComputeStoreContext(context, state)
		enterRule(_localctx, 614, Rules.RULE_computeStore.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3990
			identifier()
			this.state = 3992
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ROUNDED) {
				if (true){
				this.state = 3991
				match(ROUNDED) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ContinueStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_continueStatement.id
	        set(value) { throw RuntimeException() }
		fun CONTINUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTINUE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterContinueStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitContinueStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitContinueStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  continueStatement() : ContinueStatementContext {
		var _localctx : ContinueStatementContext = ContinueStatementContext(context, state)
		enterRule(_localctx, 616, Rules.RULE_continueStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3994
			match(CONTINUE) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DeleteStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_deleteStatement.id
	        set(value) { throw RuntimeException() }
		fun DELETE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DELETE.id, 0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun RECORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORD.id, 0)
		fun findInvalidKeyPhrase() : InvalidKeyPhraseContext? = getRuleContext(solver.getType("InvalidKeyPhraseContext"),0)
		fun findNotInvalidKeyPhrase() : NotInvalidKeyPhraseContext? = getRuleContext(solver.getType("NotInvalidKeyPhraseContext"),0)
		fun END_DELETE() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_DELETE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDeleteStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDeleteStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDeleteStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  deleteStatement() : DeleteStatementContext {
		var _localctx : DeleteStatementContext = DeleteStatementContext(context, state)
		enterRule(_localctx, 618, Rules.RULE_deleteStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 3996
			match(DELETE) as Token
			this.state = 3997
			fileName()
			this.state = 3999
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==RECORD) {
				if (true){
				this.state = 3998
				match(RECORD) as Token
				}
			}

			this.state = 4002
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,542,context) ) {
			1   -> if (true){
			this.state = 4001
			invalidKeyPhrase()
			}
			}
			this.state = 4005
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,543,context) ) {
			1   -> if (true){
			this.state = 4004
			notInvalidKeyPhrase()
			}
			}
			this.state = 4008
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,544,context) ) {
			1   -> if (true){
			this.state = 4007
			match(END_DELETE) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DisableStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_disableStatement.id
	        set(value) { throw RuntimeException() }
		fun DISABLE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DISABLE.id, 0)
		fun findCdName() : CdNameContext? = getRuleContext(solver.getType("CdNameContext"),0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun INPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.INPUT.id, 0)
		fun I_O() : TerminalNode? = getToken(Cobol85Parser.Tokens.I_O.id, 0)
		fun TERMINAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.TERMINAL.id, 0)
		fun OUTPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.OUTPUT.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDisableStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDisableStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDisableStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  disableStatement() : DisableStatementContext {
		var _localctx : DisableStatementContext = DisableStatementContext(context, state)
		enterRule(_localctx, 620, Rules.RULE_disableStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4010
			match(DISABLE) as Token
			this.state = 4018
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			INPUT  ->  /*LL1AltBlock*/{if (true){
			this.state = 4011
			match(INPUT) as Token
			this.state = 4013
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TERMINAL) {
				if (true){
				this.state = 4012
				match(TERMINAL) as Token
				}
			}

			}}
			I_O  ->  /*LL1AltBlock*/{if (true){
			this.state = 4015
			match(I_O) as Token
			this.state = 4016
			match(TERMINAL) as Token
			}}
			OUTPUT  ->  /*LL1AltBlock*/{if (true){
			this.state = 4017
			match(OUTPUT) as Token
			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 4020
			cdName()
			this.state = 4022
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 4021
				match(WITH) as Token
				}
			}

			this.state = 4024
			match(KEY) as Token
			this.state = 4027
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,548,context) ) {
			1 -> {if (true){
			this.state = 4025
			identifier()
			}}
			2 -> {if (true){
			this.state = 4026
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DisplayStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_displayStatement.id
	        set(value) { throw RuntimeException() }
		fun DISPLAY() : TerminalNode? = getToken(Cobol85Parser.Tokens.DISPLAY.id, 0)
		fun findDisplayOperand() : List<DisplayOperandContext> = getRuleContexts(solver.getType("DisplayOperandContext"))
		fun findDisplayOperand(i: Int) : DisplayOperandContext? = getRuleContext(solver.getType("DisplayOperandContext"),i)
		fun findDisplayAt() : DisplayAtContext? = getRuleContext(solver.getType("DisplayAtContext"),0)
		fun findDisplayUpon() : DisplayUponContext? = getRuleContext(solver.getType("DisplayUponContext"),0)
		fun findDisplayWith() : DisplayWithContext? = getRuleContext(solver.getType("DisplayWithContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDisplayStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDisplayStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDisplayStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  displayStatement() : DisplayStatementContext {
		var _localctx : DisplayStatementContext = DisplayStatementContext(context, state)
		enterRule(_localctx, 622, Rules.RULE_displayStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4029
			match(DISPLAY) as Token
			this.state = 4031 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4030
				displayOperand()
				}
				}
				this.state = 4033 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)))) != 0L) || ((((_la - 551)) and 0x3f.inv()) == 0 && ((1L shl (_la - 551)) and ((1L shl (NONNUMERICLITERAL - 551)) or (1L shl (LEVEL_NUMBER_66 - 551)) or (1L shl (LEVEL_NUMBER_77 - 551)) or (1L shl (LEVEL_NUMBER_88 - 551)) or (1L shl (INTEGERLITERAL - 551)) or (1L shl (NUMERICLITERAL - 551)) or (1L shl (IDENTIFIER - 551)))) != 0L) )
			this.state = 4036
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,550,context) ) {
			1   -> if (true){
			this.state = 4035
			displayAt()
			}
			}
			this.state = 4039
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==UPON) {
				if (true){
				this.state = 4038
				displayUpon()
				}
			}

			this.state = 4042
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,552,context) ) {
			1   -> if (true){
			this.state = 4041
			displayWith()
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DisplayOperandContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_displayOperand.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDisplayOperand(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDisplayOperand(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDisplayOperand(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  displayOperand() : DisplayOperandContext {
		var _localctx : DisplayOperandContext = DisplayOperandContext(context, state)
		enterRule(_localctx, 624, Rules.RULE_displayOperand.id)
		try {
			this.state = 4046
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,553,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4044
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 4045
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DisplayAtContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_displayAt.id
	        set(value) { throw RuntimeException() }
		fun AT() : TerminalNode? = getToken(Cobol85Parser.Tokens.AT.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDisplayAt(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDisplayAt(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDisplayAt(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  displayAt() : DisplayAtContext {
		var _localctx : DisplayAtContext = DisplayAtContext(context, state)
		enterRule(_localctx, 626, Rules.RULE_displayAt.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4048
			match(AT) as Token
			this.state = 4051
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,554,context) ) {
			1 -> {if (true){
			this.state = 4049
			identifier()
			}}
			2 -> {if (true){
			this.state = 4050
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DisplayUponContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_displayUpon.id
	        set(value) { throw RuntimeException() }
		fun UPON() : TerminalNode? = getToken(Cobol85Parser.Tokens.UPON.id, 0)
		fun findMnemonicName() : MnemonicNameContext? = getRuleContext(solver.getType("MnemonicNameContext"),0)
		fun findEnvironmentName() : EnvironmentNameContext? = getRuleContext(solver.getType("EnvironmentNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDisplayUpon(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDisplayUpon(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDisplayUpon(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  displayUpon() : DisplayUponContext {
		var _localctx : DisplayUponContext = DisplayUponContext(context, state)
		enterRule(_localctx, 628, Rules.RULE_displayUpon.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4053
			match(UPON) as Token
			this.state = 4056
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,555,context) ) {
			1 -> {if (true){
			this.state = 4054
			mnemonicName()
			}}
			2 -> {if (true){
			this.state = 4055
			environmentName()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DisplayWithContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_displayWith.id
	        set(value) { throw RuntimeException() }
		fun NO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO.id, 0)
		fun ADVANCING() : TerminalNode? = getToken(Cobol85Parser.Tokens.ADVANCING.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDisplayWith(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDisplayWith(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDisplayWith(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  displayWith() : DisplayWithContext {
		var _localctx : DisplayWithContext = DisplayWithContext(context, state)
		enterRule(_localctx, 630, Rules.RULE_displayWith.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4059
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 4058
				match(WITH) as Token
				}
			}

			this.state = 4061
			match(NO) as Token
			this.state = 4062
			match(ADVANCING) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DivideStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_divideStatement.id
	        set(value) { throw RuntimeException() }
		fun DIVIDE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DIVIDE.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findDivideIntoStatement() : DivideIntoStatementContext? = getRuleContext(solver.getType("DivideIntoStatementContext"),0)
		fun findDivideIntoGivingStatement() : DivideIntoGivingStatementContext? = getRuleContext(solver.getType("DivideIntoGivingStatementContext"),0)
		fun findDivideByGivingStatement() : DivideByGivingStatementContext? = getRuleContext(solver.getType("DivideByGivingStatementContext"),0)
		fun findDivideRemainder() : DivideRemainderContext? = getRuleContext(solver.getType("DivideRemainderContext"),0)
		fun findOnSizeErrorPhrase() : OnSizeErrorPhraseContext? = getRuleContext(solver.getType("OnSizeErrorPhraseContext"),0)
		fun findNotOnSizeErrorPhrase() : NotOnSizeErrorPhraseContext? = getRuleContext(solver.getType("NotOnSizeErrorPhraseContext"),0)
		fun END_DIVIDE() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_DIVIDE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDivideStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDivideStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDivideStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  divideStatement() : DivideStatementContext {
		var _localctx : DivideStatementContext = DivideStatementContext(context, state)
		enterRule(_localctx, 632, Rules.RULE_divideStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4064
			match(DIVIDE) as Token
			this.state = 4067
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,557,context) ) {
			1 -> {if (true){
			this.state = 4065
			identifier()
			}}
			2 -> {if (true){
			this.state = 4066
			literal()
			}}
			}
			this.state = 4072
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,558,context) ) {
			1 -> {if (true){
			this.state = 4069
			divideIntoStatement()
			}}
			2 -> {if (true){
			this.state = 4070
			divideIntoGivingStatement()
			}}
			3 -> {if (true){
			this.state = 4071
			divideByGivingStatement()
			}}
			}
			this.state = 4075
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==REMAINDER) {
				if (true){
				this.state = 4074
				divideRemainder()
				}
			}

			this.state = 4078
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,560,context) ) {
			1   -> if (true){
			this.state = 4077
			onSizeErrorPhrase()
			}
			}
			this.state = 4081
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,561,context) ) {
			1   -> if (true){
			this.state = 4080
			notOnSizeErrorPhrase()
			}
			}
			this.state = 4084
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,562,context) ) {
			1   -> if (true){
			this.state = 4083
			match(END_DIVIDE) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DivideIntoStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_divideIntoStatement.id
	        set(value) { throw RuntimeException() }
		fun INTO() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTO.id, 0)
		fun findDivideInto() : List<DivideIntoContext> = getRuleContexts(solver.getType("DivideIntoContext"))
		fun findDivideInto(i: Int) : DivideIntoContext? = getRuleContext(solver.getType("DivideIntoContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDivideIntoStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDivideIntoStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDivideIntoStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  divideIntoStatement() : DivideIntoStatementContext {
		var _localctx : DivideIntoStatementContext = DivideIntoStatementContext(context, state)
		enterRule(_localctx, 634, Rules.RULE_divideIntoStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4086
			match(INTO) as Token
			this.state = 4088 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4087
				divideInto()
				}
				}
				this.state = 4090 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DivideIntoGivingStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_divideIntoGivingStatement.id
	        set(value) { throw RuntimeException() }
		fun INTO() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTO.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findDivideGivingPhrase() : DivideGivingPhraseContext? = getRuleContext(solver.getType("DivideGivingPhraseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDivideIntoGivingStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDivideIntoGivingStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDivideIntoGivingStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  divideIntoGivingStatement() : DivideIntoGivingStatementContext {
		var _localctx : DivideIntoGivingStatementContext = DivideIntoGivingStatementContext(context, state)
		enterRule(_localctx, 636, Rules.RULE_divideIntoGivingStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4092
			match(INTO) as Token
			this.state = 4095
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,564,context) ) {
			1 -> {if (true){
			this.state = 4093
			identifier()
			}}
			2 -> {if (true){
			this.state = 4094
			literal()
			}}
			}
			this.state = 4098
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==GIVING) {
				if (true){
				this.state = 4097
				divideGivingPhrase()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DivideByGivingStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_divideByGivingStatement.id
	        set(value) { throw RuntimeException() }
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findDivideGivingPhrase() : DivideGivingPhraseContext? = getRuleContext(solver.getType("DivideGivingPhraseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDivideByGivingStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDivideByGivingStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDivideByGivingStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  divideByGivingStatement() : DivideByGivingStatementContext {
		var _localctx : DivideByGivingStatementContext = DivideByGivingStatementContext(context, state)
		enterRule(_localctx, 638, Rules.RULE_divideByGivingStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4100
			match(BY) as Token
			this.state = 4103
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,566,context) ) {
			1 -> {if (true){
			this.state = 4101
			identifier()
			}}
			2 -> {if (true){
			this.state = 4102
			literal()
			}}
			}
			this.state = 4106
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==GIVING) {
				if (true){
				this.state = 4105
				divideGivingPhrase()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DivideGivingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_divideGivingPhrase.id
	        set(value) { throw RuntimeException() }
		fun GIVING() : TerminalNode? = getToken(Cobol85Parser.Tokens.GIVING.id, 0)
		fun findDivideGiving() : List<DivideGivingContext> = getRuleContexts(solver.getType("DivideGivingContext"))
		fun findDivideGiving(i: Int) : DivideGivingContext? = getRuleContext(solver.getType("DivideGivingContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDivideGivingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDivideGivingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDivideGivingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  divideGivingPhrase() : DivideGivingPhraseContext {
		var _localctx : DivideGivingPhraseContext = DivideGivingPhraseContext(context, state)
		enterRule(_localctx, 640, Rules.RULE_divideGivingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4108
			match(GIVING) as Token
			this.state = 4110 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4109
				divideGiving()
				}
				}
				this.state = 4112 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DivideIntoContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_divideInto.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun ROUNDED() : TerminalNode? = getToken(Cobol85Parser.Tokens.ROUNDED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDivideInto(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDivideInto(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDivideInto(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  divideInto() : DivideIntoContext {
		var _localctx : DivideIntoContext = DivideIntoContext(context, state)
		enterRule(_localctx, 642, Rules.RULE_divideInto.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4114
			identifier()
			this.state = 4116
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ROUNDED) {
				if (true){
				this.state = 4115
				match(ROUNDED) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DivideGivingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_divideGiving.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun ROUNDED() : TerminalNode? = getToken(Cobol85Parser.Tokens.ROUNDED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDivideGiving(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDivideGiving(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDivideGiving(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  divideGiving() : DivideGivingContext {
		var _localctx : DivideGivingContext = DivideGivingContext(context, state)
		enterRule(_localctx, 644, Rules.RULE_divideGiving.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4118
			identifier()
			this.state = 4120
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ROUNDED) {
				if (true){
				this.state = 4119
				match(ROUNDED) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DivideRemainderContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_divideRemainder.id
	        set(value) { throw RuntimeException() }
		fun REMAINDER() : TerminalNode? = getToken(Cobol85Parser.Tokens.REMAINDER.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDivideRemainder(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDivideRemainder(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDivideRemainder(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  divideRemainder() : DivideRemainderContext {
		var _localctx : DivideRemainderContext = DivideRemainderContext(context, state)
		enterRule(_localctx, 646, Rules.RULE_divideRemainder.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4122
			match(REMAINDER) as Token
			this.state = 4123
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EnableStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_enableStatement.id
	        set(value) { throw RuntimeException() }
		fun ENABLE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ENABLE.id, 0)
		fun findCdName() : CdNameContext? = getRuleContext(solver.getType("CdNameContext"),0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun INPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.INPUT.id, 0)
		fun I_O() : TerminalNode? = getToken(Cobol85Parser.Tokens.I_O.id, 0)
		fun TERMINAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.TERMINAL.id, 0)
		fun OUTPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.OUTPUT.id, 0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEnableStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEnableStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEnableStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  enableStatement() : EnableStatementContext {
		var _localctx : EnableStatementContext = EnableStatementContext(context, state)
		enterRule(_localctx, 648, Rules.RULE_enableStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4125
			match(ENABLE) as Token
			this.state = 4133
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			INPUT  ->  /*LL1AltBlock*/{if (true){
			this.state = 4126
			match(INPUT) as Token
			this.state = 4128
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TERMINAL) {
				if (true){
				this.state = 4127
				match(TERMINAL) as Token
				}
			}

			}}
			I_O  ->  /*LL1AltBlock*/{if (true){
			this.state = 4130
			match(I_O) as Token
			this.state = 4131
			match(TERMINAL) as Token
			}}
			OUTPUT  ->  /*LL1AltBlock*/{if (true){
			this.state = 4132
			match(OUTPUT) as Token
			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 4135
			cdName()
			this.state = 4137
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 4136
				match(WITH) as Token
				}
			}

			this.state = 4139
			match(KEY) as Token
			this.state = 4142
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,574,context) ) {
			1 -> {if (true){
			this.state = 4140
			literal()
			}}
			2 -> {if (true){
			this.state = 4141
			identifier()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EntryStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_entryStatement.id
	        set(value) { throw RuntimeException() }
		fun ENTRY() : TerminalNode? = getToken(Cobol85Parser.Tokens.ENTRY.id, 0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun USING() : TerminalNode? = getToken(Cobol85Parser.Tokens.USING.id, 0)
		fun findIdentifier() : List<IdentifierContext> = getRuleContexts(solver.getType("IdentifierContext"))
		fun findIdentifier(i: Int) : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEntryStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEntryStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEntryStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  entryStatement() : EntryStatementContext {
		var _localctx : EntryStatementContext = EntryStatementContext(context, state)
		enterRule(_localctx, 650, Rules.RULE_entryStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4144
			match(ENTRY) as Token
			this.state = 4145
			literal()
			this.state = 4152
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==USING) {
				if (true){
				this.state = 4146
				match(USING) as Token
				this.state = 4148 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				do {
					if (true){
					if (true){
					this.state = 4147
					identifier()
					}
					}
					this.state = 4150 
					errorHandler.sync(this)
					_la = _input!!.LA(1)
				} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EvaluateStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_evaluateStatement.id
	        set(value) { throw RuntimeException() }
		fun EVALUATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.EVALUATE.id, 0)
		fun findEvaluateSelect() : EvaluateSelectContext? = getRuleContext(solver.getType("EvaluateSelectContext"),0)
		fun findEvaluateAlsoSelect() : List<EvaluateAlsoSelectContext> = getRuleContexts(solver.getType("EvaluateAlsoSelectContext"))
		fun findEvaluateAlsoSelect(i: Int) : EvaluateAlsoSelectContext? = getRuleContext(solver.getType("EvaluateAlsoSelectContext"),i)
		fun findEvaluateWhenPhrase() : List<EvaluateWhenPhraseContext> = getRuleContexts(solver.getType("EvaluateWhenPhraseContext"))
		fun findEvaluateWhenPhrase(i: Int) : EvaluateWhenPhraseContext? = getRuleContext(solver.getType("EvaluateWhenPhraseContext"),i)
		fun findEvaluateWhenOther() : EvaluateWhenOtherContext? = getRuleContext(solver.getType("EvaluateWhenOtherContext"),0)
		fun END_EVALUATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_EVALUATE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEvaluateStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEvaluateStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEvaluateStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  evaluateStatement() : EvaluateStatementContext {
		var _localctx : EvaluateStatementContext = EvaluateStatementContext(context, state)
		enterRule(_localctx, 652, Rules.RULE_evaluateStatement.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4154
			match(EVALUATE) as Token
			this.state = 4155
			evaluateSelect()
			this.state = 4159
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==ALSO) {
				if (true){
				if (true){
				this.state = 4156
				evaluateAlsoSelect()
				}
				}
				this.state = 4161
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 4163 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 4162
				evaluateWhenPhrase()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 4165 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,578,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			this.state = 4168
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,579,context) ) {
			1   -> if (true){
			this.state = 4167
			evaluateWhenOther()
			}
			}
			this.state = 4171
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,580,context) ) {
			1   -> if (true){
			this.state = 4170
			match(END_EVALUATE) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EvaluateSelectContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_evaluateSelect.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		fun findCondition() : ConditionContext? = getRuleContext(solver.getType("ConditionContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEvaluateSelect(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEvaluateSelect(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEvaluateSelect(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  evaluateSelect() : EvaluateSelectContext {
		var _localctx : EvaluateSelectContext = EvaluateSelectContext(context, state)
		enterRule(_localctx, 654, Rules.RULE_evaluateSelect.id)
		try {
			this.state = 4177
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,581,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4173
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 4174
			literal()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 4175
			arithmeticExpression()
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 4176
			condition()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EvaluateAlsoSelectContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_evaluateAlsoSelect.id
	        set(value) { throw RuntimeException() }
		fun ALSO() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALSO.id, 0)
		fun findEvaluateSelect() : EvaluateSelectContext? = getRuleContext(solver.getType("EvaluateSelectContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEvaluateAlsoSelect(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEvaluateAlsoSelect(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEvaluateAlsoSelect(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  evaluateAlsoSelect() : EvaluateAlsoSelectContext {
		var _localctx : EvaluateAlsoSelectContext = EvaluateAlsoSelectContext(context, state)
		enterRule(_localctx, 656, Rules.RULE_evaluateAlsoSelect.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4179
			match(ALSO) as Token
			this.state = 4180
			evaluateSelect()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EvaluateWhenPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_evaluateWhenPhrase.id
	        set(value) { throw RuntimeException() }
		fun findEvaluateWhen() : List<EvaluateWhenContext> = getRuleContexts(solver.getType("EvaluateWhenContext"))
		fun findEvaluateWhen(i: Int) : EvaluateWhenContext? = getRuleContext(solver.getType("EvaluateWhenContext"),i)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEvaluateWhenPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEvaluateWhenPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEvaluateWhenPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  evaluateWhenPhrase() : EvaluateWhenPhraseContext {
		var _localctx : EvaluateWhenPhraseContext = EvaluateWhenPhraseContext(context, state)
		enterRule(_localctx, 658, Rules.RULE_evaluateWhenPhrase.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4183 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 4182
				evaluateWhen()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 4185 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,582,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			this.state = 4190
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,583,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 4187
					statement()
					}
					} 
				}
				this.state = 4192
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,583,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EvaluateWhenContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_evaluateWhen.id
	        set(value) { throw RuntimeException() }
		fun WHEN() : TerminalNode? = getToken(Cobol85Parser.Tokens.WHEN.id, 0)
		fun findEvaluateCondition() : EvaluateConditionContext? = getRuleContext(solver.getType("EvaluateConditionContext"),0)
		fun findEvaluateAlsoCondition() : List<EvaluateAlsoConditionContext> = getRuleContexts(solver.getType("EvaluateAlsoConditionContext"))
		fun findEvaluateAlsoCondition(i: Int) : EvaluateAlsoConditionContext? = getRuleContext(solver.getType("EvaluateAlsoConditionContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEvaluateWhen(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEvaluateWhen(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEvaluateWhen(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  evaluateWhen() : EvaluateWhenContext {
		var _localctx : EvaluateWhenContext = EvaluateWhenContext(context, state)
		enterRule(_localctx, 660, Rules.RULE_evaluateWhen.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4193
			match(WHEN) as Token
			this.state = 4194
			evaluateCondition()
			this.state = 4198
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==ALSO) {
				if (true){
				if (true){
				this.state = 4195
				evaluateAlsoCondition()
				}
				}
				this.state = 4200
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EvaluateConditionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_evaluateCondition.id
	        set(value) { throw RuntimeException() }
		fun ANY() : TerminalNode? = getToken(Cobol85Parser.Tokens.ANY.id, 0)
		fun findEvaluateValue() : EvaluateValueContext? = getRuleContext(solver.getType("EvaluateValueContext"),0)
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		fun findEvaluateThrough() : EvaluateThroughContext? = getRuleContext(solver.getType("EvaluateThroughContext"),0)
		fun findCondition() : ConditionContext? = getRuleContext(solver.getType("ConditionContext"),0)
		fun findBooleanLiteral() : BooleanLiteralContext? = getRuleContext(solver.getType("BooleanLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEvaluateCondition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEvaluateCondition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEvaluateCondition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  evaluateCondition() : EvaluateConditionContext {
		var _localctx : EvaluateConditionContext = EvaluateConditionContext(context, state)
		enterRule(_localctx, 662, Rules.RULE_evaluateCondition.id)
		var _la: Int
		try {
			this.state = 4211
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,587,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4201
			match(ANY) as Token
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 4203
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==NOT) {
				if (true){
				this.state = 4202
				match(NOT) as Token
				}
			}

			this.state = 4205
			evaluateValue()
			this.state = 4207
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THROUGH || _la==THRU) {
				if (true){
				this.state = 4206
				evaluateThrough()
				}
			}

			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 4209
			condition()
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 4210
			booleanLiteral()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EvaluateThroughContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_evaluateThrough.id
	        set(value) { throw RuntimeException() }
		fun findEvaluateValue() : EvaluateValueContext? = getRuleContext(solver.getType("EvaluateValueContext"),0)
		fun THROUGH() : TerminalNode? = getToken(Cobol85Parser.Tokens.THROUGH.id, 0)
		fun THRU() : TerminalNode? = getToken(Cobol85Parser.Tokens.THRU.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEvaluateThrough(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEvaluateThrough(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEvaluateThrough(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  evaluateThrough() : EvaluateThroughContext {
		var _localctx : EvaluateThroughContext = EvaluateThroughContext(context, state)
		enterRule(_localctx, 664, Rules.RULE_evaluateThrough.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4213
			_la = _input!!.LA(1)
			if ( !(_la==THROUGH || _la==THRU) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 4214
			evaluateValue()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EvaluateAlsoConditionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_evaluateAlsoCondition.id
	        set(value) { throw RuntimeException() }
		fun ALSO() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALSO.id, 0)
		fun findEvaluateCondition() : EvaluateConditionContext? = getRuleContext(solver.getType("EvaluateConditionContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEvaluateAlsoCondition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEvaluateAlsoCondition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEvaluateAlsoCondition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  evaluateAlsoCondition() : EvaluateAlsoConditionContext {
		var _localctx : EvaluateAlsoConditionContext = EvaluateAlsoConditionContext(context, state)
		enterRule(_localctx, 666, Rules.RULE_evaluateAlsoCondition.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4216
			match(ALSO) as Token
			this.state = 4217
			evaluateCondition()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EvaluateWhenOtherContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_evaluateWhenOther.id
	        set(value) { throw RuntimeException() }
		fun WHEN() : TerminalNode? = getToken(Cobol85Parser.Tokens.WHEN.id, 0)
		fun OTHER() : TerminalNode? = getToken(Cobol85Parser.Tokens.OTHER.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEvaluateWhenOther(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEvaluateWhenOther(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEvaluateWhenOther(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  evaluateWhenOther() : EvaluateWhenOtherContext {
		var _localctx : EvaluateWhenOtherContext = EvaluateWhenOtherContext(context, state)
		enterRule(_localctx, 668, Rules.RULE_evaluateWhenOther.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4219
			match(WHEN) as Token
			this.state = 4220
			match(OTHER) as Token
			this.state = 4224
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,588,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 4221
					statement()
					}
					} 
				}
				this.state = 4226
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,588,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EvaluateValueContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_evaluateValue.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEvaluateValue(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEvaluateValue(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEvaluateValue(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  evaluateValue() : EvaluateValueContext {
		var _localctx : EvaluateValueContext = EvaluateValueContext(context, state)
		enterRule(_localctx, 670, Rules.RULE_evaluateValue.id)
		try {
			this.state = 4230
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,589,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4227
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 4228
			literal()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 4229
			arithmeticExpression()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ExecCicsStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_execCicsStatement.id
	        set(value) { throw RuntimeException() }
		fun EXECCICSLINE() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.EXECCICSLINE.id)
		fun EXECCICSLINE(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.EXECCICSLINE.id, i) as TerminalNode
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterExecCicsStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitExecCicsStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitExecCicsStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  execCicsStatement() : ExecCicsStatementContext {
		var _localctx : ExecCicsStatementContext = ExecCicsStatementContext(context, state)
		enterRule(_localctx, 672, Rules.RULE_execCicsStatement.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4233 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 4232
				match(EXECCICSLINE) as Token
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 4235 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,590,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ExecSqlStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_execSqlStatement.id
	        set(value) { throw RuntimeException() }
		fun EXECSQLLINE() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.EXECSQLLINE.id)
		fun EXECSQLLINE(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.EXECSQLLINE.id, i) as TerminalNode
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterExecSqlStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitExecSqlStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitExecSqlStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  execSqlStatement() : ExecSqlStatementContext {
		var _localctx : ExecSqlStatementContext = ExecSqlStatementContext(context, state)
		enterRule(_localctx, 674, Rules.RULE_execSqlStatement.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4238 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 4237
				match(EXECSQLLINE) as Token
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 4240 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,591,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ExecSqlImsStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_execSqlImsStatement.id
	        set(value) { throw RuntimeException() }
		fun EXECSQLIMSLINE() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.EXECSQLIMSLINE.id)
		fun EXECSQLIMSLINE(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.EXECSQLIMSLINE.id, i) as TerminalNode
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterExecSqlImsStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitExecSqlImsStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitExecSqlImsStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  execSqlImsStatement() : ExecSqlImsStatementContext {
		var _localctx : ExecSqlImsStatementContext = ExecSqlImsStatementContext(context, state)
		enterRule(_localctx, 676, Rules.RULE_execSqlImsStatement.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4243 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 4242
				match(EXECSQLIMSLINE) as Token
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 4245 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,592,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ExhibitStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_exhibitStatement.id
	        set(value) { throw RuntimeException() }
		fun EXHIBIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXHIBIT.id, 0)
		fun NAMED() : TerminalNode? = getToken(Cobol85Parser.Tokens.NAMED.id, 0)
		fun CHANGED() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHANGED.id, 0)
		fun findExhibitOperand() : List<ExhibitOperandContext> = getRuleContexts(solver.getType("ExhibitOperandContext"))
		fun findExhibitOperand(i: Int) : ExhibitOperandContext? = getRuleContext(solver.getType("ExhibitOperandContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterExhibitStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitExhibitStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitExhibitStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  exhibitStatement() : ExhibitStatementContext {
		var _localctx : ExhibitStatementContext = ExhibitStatementContext(context, state)
		enterRule(_localctx, 678, Rules.RULE_exhibitStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4247
			match(EXHIBIT) as Token
			this.state = 4249
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,593,context) ) {
			1   -> if (true){
			this.state = 4248
			match(NAMED) as Token
			}
			}
			this.state = 4252
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,594,context) ) {
			1   -> if (true){
			this.state = 4251
			match(CHANGED) as Token
			}
			}
			this.state = 4255 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4254
				exhibitOperand()
				}
				}
				this.state = 4257 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)))) != 0L) || ((((_la - 551)) and 0x3f.inv()) == 0 && ((1L shl (_la - 551)) and ((1L shl (NONNUMERICLITERAL - 551)) or (1L shl (LEVEL_NUMBER_66 - 551)) or (1L shl (LEVEL_NUMBER_77 - 551)) or (1L shl (LEVEL_NUMBER_88 - 551)) or (1L shl (INTEGERLITERAL - 551)) or (1L shl (NUMERICLITERAL - 551)) or (1L shl (IDENTIFIER - 551)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ExhibitOperandContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_exhibitOperand.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterExhibitOperand(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitExhibitOperand(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitExhibitOperand(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  exhibitOperand() : ExhibitOperandContext {
		var _localctx : ExhibitOperandContext = ExhibitOperandContext(context, state)
		enterRule(_localctx, 680, Rules.RULE_exhibitOperand.id)
		try {
			this.state = 4261
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,596,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4259
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 4260
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ExitStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_exitStatement.id
	        set(value) { throw RuntimeException() }
		fun EXIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXIT.id, 0)
		fun PROGRAM() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROGRAM.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterExitStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitExitStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitExitStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  exitStatement() : ExitStatementContext {
		var _localctx : ExitStatementContext = ExitStatementContext(context, state)
		enterRule(_localctx, 682, Rules.RULE_exitStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4263
			match(EXIT) as Token
			this.state = 4265
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==PROGRAM) {
				if (true){
				this.state = 4264
				match(PROGRAM) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class GenerateStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_generateStatement.id
	        set(value) { throw RuntimeException() }
		fun GENERATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.GENERATE.id, 0)
		fun findReportName() : ReportNameContext? = getRuleContext(solver.getType("ReportNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterGenerateStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitGenerateStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitGenerateStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  generateStatement() : GenerateStatementContext {
		var _localctx : GenerateStatementContext = GenerateStatementContext(context, state)
		enterRule(_localctx, 684, Rules.RULE_generateStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4267
			match(GENERATE) as Token
			this.state = 4268
			reportName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class GobackStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_gobackStatement.id
	        set(value) { throw RuntimeException() }
		fun GOBACK() : TerminalNode? = getToken(Cobol85Parser.Tokens.GOBACK.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterGobackStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitGobackStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitGobackStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  gobackStatement() : GobackStatementContext {
		var _localctx : GobackStatementContext = GobackStatementContext(context, state)
		enterRule(_localctx, 686, Rules.RULE_gobackStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4270
			match(GOBACK) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class GoToStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_goToStatement.id
	        set(value) { throw RuntimeException() }
		fun GO() : TerminalNode? = getToken(Cobol85Parser.Tokens.GO.id, 0)
		fun findGoToStatementSimple() : GoToStatementSimpleContext? = getRuleContext(solver.getType("GoToStatementSimpleContext"),0)
		fun findGoToDependingOnStatement() : GoToDependingOnStatementContext? = getRuleContext(solver.getType("GoToDependingOnStatementContext"),0)
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterGoToStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitGoToStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitGoToStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  goToStatement() : GoToStatementContext {
		var _localctx : GoToStatementContext = GoToStatementContext(context, state)
		enterRule(_localctx, 688, Rules.RULE_goToStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4272
			match(GO) as Token
			this.state = 4274
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TO) {
				if (true){
				this.state = 4273
				match(TO) as Token
				}
			}

			this.state = 4278
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,599,context) ) {
			1 -> {if (true){
			this.state = 4276
			goToStatementSimple()
			}}
			2 -> {if (true){
			this.state = 4277
			goToDependingOnStatement()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class GoToStatementSimpleContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_goToStatementSimple.id
	        set(value) { throw RuntimeException() }
		fun findProcedureName() : ProcedureNameContext? = getRuleContext(solver.getType("ProcedureNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterGoToStatementSimple(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitGoToStatementSimple(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitGoToStatementSimple(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  goToStatementSimple() : GoToStatementSimpleContext {
		var _localctx : GoToStatementSimpleContext = GoToStatementSimpleContext(context, state)
		enterRule(_localctx, 690, Rules.RULE_goToStatementSimple.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4280
			procedureName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class GoToDependingOnStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_goToDependingOnStatement.id
	        set(value) { throw RuntimeException() }
		fun MORE_LABELS() : TerminalNode? = getToken(Cobol85Parser.Tokens.MORE_LABELS.id, 0)
		fun findProcedureName() : List<ProcedureNameContext> = getRuleContexts(solver.getType("ProcedureNameContext"))
		fun findProcedureName(i: Int) : ProcedureNameContext? = getRuleContext(solver.getType("ProcedureNameContext"),i)
		fun DEPENDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEPENDING.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterGoToDependingOnStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitGoToDependingOnStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitGoToDependingOnStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  goToDependingOnStatement() : GoToDependingOnStatementContext {
		var _localctx : GoToDependingOnStatementContext = GoToDependingOnStatementContext(context, state)
		enterRule(_localctx, 692, Rules.RULE_goToDependingOnStatement.id)
		var _la: Int
		try {
			this.state = 4295
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			MORE_LABELS  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4282
			match(MORE_LABELS) as Token
			}}
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL , IDENTIFIER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 4284 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4283
				procedureName()
				}
				}
				this.state = 4286 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			this.state = 4293
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DEPENDING) {
				if (true){
				this.state = 4288
				match(DEPENDING) as Token
				this.state = 4290
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==ON) {
					if (true){
					this.state = 4289
					match(ON) as Token
					}
				}

				this.state = 4292
				identifier()
				}
			}

			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class IfStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_ifStatement.id
	        set(value) { throw RuntimeException() }
		fun IF() : TerminalNode? = getToken(Cobol85Parser.Tokens.IF.id, 0)
		fun findCondition() : ConditionContext? = getRuleContext(solver.getType("ConditionContext"),0)
		fun findIfThen() : IfThenContext? = getRuleContext(solver.getType("IfThenContext"),0)
		fun findIfElse() : IfElseContext? = getRuleContext(solver.getType("IfElseContext"),0)
		fun END_IF() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_IF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterIfStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitIfStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitIfStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  ifStatement() : IfStatementContext {
		var _localctx : IfStatementContext = IfStatementContext(context, state)
		enterRule(_localctx, 694, Rules.RULE_ifStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4297
			match(IF) as Token
			this.state = 4298
			condition()
			this.state = 4299
			ifThen()
			this.state = 4301
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,604,context) ) {
			1   -> if (true){
			this.state = 4300
			ifElse()
			}
			}
			this.state = 4304
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,605,context) ) {
			1   -> if (true){
			this.state = 4303
			match(END_IF) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class IfThenContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_ifThen.id
	        set(value) { throw RuntimeException() }
		fun NEXT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NEXT.id, 0)
		fun SENTENCE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SENTENCE.id, 0)
		fun THEN() : TerminalNode? = getToken(Cobol85Parser.Tokens.THEN.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterIfThen(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitIfThen(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitIfThen(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  ifThen() : IfThenContext {
		var _localctx : IfThenContext = IfThenContext(context, state)
		enterRule(_localctx, 696, Rules.RULE_ifThen.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4307
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THEN) {
				if (true){
				this.state = 4306
				match(THEN) as Token
				}
			}

			this.state = 4317
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			NEXT  ->  /*LL1AltBlock*/{if (true){
			this.state = 4309
			match(NEXT) as Token
			this.state = 4310
			match(SENTENCE) as Token
			}}
			ACCEPT , ADD , ALTER , AT , CALL , CANCEL , CLOSE , COMPUTE , CONTINUE , DELETE , DISABLE , DISPLAY , DIVIDE , ELSE , ENABLE , END , END_ACCEPT , END_ADD , END_CALL , END_COMPUTE , END_DELETE , END_DIVIDE , END_EVALUATE , END_IF , END_MULTIPLY , END_PERFORM , END_READ , END_RECEIVE , END_RETURN , END_REWRITE , END_SEARCH , END_START , END_STRING , END_SUBTRACT , END_UNSTRING , END_WRITE , ENTRY , EVALUATE , EXCEPTION , EXHIBIT , EXIT , GENERATE , GOBACK , GO , IF , INITIALIZE , INITIATE , INSPECT , INVALID , MERGE , MOVE , MULTIPLY , NOT , ON , OPEN , PERFORM , PURGE , READ , RECEIVE , RELEASE , RETURN , REWRITE , SEARCH , SEND , SET , SORT , START , STOP , STRING , SUBTRACT , TERMINATE , UNSTRING , WHEN , WITH , WRITE , DOT_FS , EXECCICSLINE , EXECSQLIMSLINE , EXECSQLLINE  ->  /*LL1AltBlock*/{if (true){
			this.state = 4314
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,607,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 4311
					statement()
					}
					} 
				}
				this.state = 4316
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,607,context)
			}
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class IfElseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_ifElse.id
	        set(value) { throw RuntimeException() }
		fun ELSE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ELSE.id, 0)
		fun NEXT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NEXT.id, 0)
		fun SENTENCE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SENTENCE.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterIfElse(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitIfElse(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitIfElse(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  ifElse() : IfElseContext {
		var _localctx : IfElseContext = IfElseContext(context, state)
		enterRule(_localctx, 698, Rules.RULE_ifElse.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4319
			match(ELSE) as Token
			this.state = 4328
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			NEXT  ->  /*LL1AltBlock*/{if (true){
			this.state = 4320
			match(NEXT) as Token
			this.state = 4321
			match(SENTENCE) as Token
			}}
			ACCEPT , ADD , ALTER , AT , CALL , CANCEL , CLOSE , COMPUTE , CONTINUE , DELETE , DISABLE , DISPLAY , DIVIDE , ELSE , ENABLE , END , END_ACCEPT , END_ADD , END_CALL , END_COMPUTE , END_DELETE , END_DIVIDE , END_EVALUATE , END_IF , END_MULTIPLY , END_PERFORM , END_READ , END_RECEIVE , END_RETURN , END_REWRITE , END_SEARCH , END_START , END_STRING , END_SUBTRACT , END_UNSTRING , END_WRITE , ENTRY , EVALUATE , EXCEPTION , EXHIBIT , EXIT , GENERATE , GOBACK , GO , IF , INITIALIZE , INITIATE , INSPECT , INVALID , MERGE , MOVE , MULTIPLY , NOT , ON , OPEN , PERFORM , PURGE , READ , RECEIVE , RELEASE , RETURN , REWRITE , SEARCH , SEND , SET , SORT , START , STOP , STRING , SUBTRACT , TERMINATE , UNSTRING , WHEN , WITH , WRITE , DOT_FS , EXECCICSLINE , EXECSQLIMSLINE , EXECSQLLINE  ->  /*LL1AltBlock*/{if (true){
			this.state = 4325
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,609,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 4322
					statement()
					}
					} 
				}
				this.state = 4327
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,609,context)
			}
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InitializeStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_initializeStatement.id
	        set(value) { throw RuntimeException() }
		fun INITIALIZE() : TerminalNode? = getToken(Cobol85Parser.Tokens.INITIALIZE.id, 0)
		fun findIdentifier() : List<IdentifierContext> = getRuleContexts(solver.getType("IdentifierContext"))
		fun findIdentifier(i: Int) : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),i)
		fun findInitializeReplacingPhrase() : InitializeReplacingPhraseContext? = getRuleContext(solver.getType("InitializeReplacingPhraseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInitializeStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInitializeStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInitializeStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  initializeStatement() : InitializeStatementContext {
		var _localctx : InitializeStatementContext = InitializeStatementContext(context, state)
		enterRule(_localctx, 700, Rules.RULE_initializeStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4330
			match(INITIALIZE) as Token
			this.state = 4332 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4331
				identifier()
				}
				}
				this.state = 4334 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			this.state = 4337
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==REPLACING) {
				if (true){
				this.state = 4336
				initializeReplacingPhrase()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InitializeReplacingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_initializeReplacingPhrase.id
	        set(value) { throw RuntimeException() }
		fun REPLACING() : TerminalNode? = getToken(Cobol85Parser.Tokens.REPLACING.id, 0)
		fun findInitializeReplacingBy() : List<InitializeReplacingByContext> = getRuleContexts(solver.getType("InitializeReplacingByContext"))
		fun findInitializeReplacingBy(i: Int) : InitializeReplacingByContext? = getRuleContext(solver.getType("InitializeReplacingByContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInitializeReplacingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInitializeReplacingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInitializeReplacingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  initializeReplacingPhrase() : InitializeReplacingPhraseContext {
		var _localctx : InitializeReplacingPhraseContext = InitializeReplacingPhraseContext(context, state)
		enterRule(_localctx, 702, Rules.RULE_initializeReplacingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4339
			match(REPLACING) as Token
			this.state = 4341 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4340
				initializeReplacingBy()
				}
				}
				this.state = 4343 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ALPHABETIC) or (1L shl ALPHANUMERIC) or (1L shl ALPHANUMERIC_EDITED))) != 0L) || _la==DBCS || _la==EGCS || ((((_la - 304)) and 0x3f.inv()) == 0 && ((1L shl (_la - 304)) and ((1L shl (NATIONAL - 304)) or (1L shl (NATIONAL_EDITED - 304)) or (1L shl (NUMERIC - 304)) or (1L shl (NUMERIC_EDITED - 304)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InitializeReplacingByContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_initializeReplacingBy.id
	        set(value) { throw RuntimeException() }
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun ALPHABETIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHABETIC.id, 0)
		fun ALPHANUMERIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHANUMERIC.id, 0)
		fun ALPHANUMERIC_EDITED() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHANUMERIC_EDITED.id, 0)
		fun NATIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIONAL.id, 0)
		fun NATIONAL_EDITED() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIONAL_EDITED.id, 0)
		fun NUMERIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMERIC.id, 0)
		fun NUMERIC_EDITED() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMERIC_EDITED.id, 0)
		fun DBCS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DBCS.id, 0)
		fun EGCS() : TerminalNode? = getToken(Cobol85Parser.Tokens.EGCS.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun DATA() : TerminalNode? = getToken(Cobol85Parser.Tokens.DATA.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInitializeReplacingBy(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInitializeReplacingBy(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInitializeReplacingBy(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  initializeReplacingBy() : InitializeReplacingByContext {
		var _localctx : InitializeReplacingByContext = InitializeReplacingByContext(context, state)
		enterRule(_localctx, 704, Rules.RULE_initializeReplacingBy.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4345
			_la = _input!!.LA(1)
			if ( !((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ALPHABETIC) or (1L shl ALPHANUMERIC) or (1L shl ALPHANUMERIC_EDITED))) != 0L) || _la==DBCS || _la==EGCS || ((((_la - 304)) and 0x3f.inv()) == 0 && ((1L shl (_la - 304)) and ((1L shl (NATIONAL - 304)) or (1L shl (NATIONAL_EDITED - 304)) or (1L shl (NUMERIC - 304)) or (1L shl (NUMERIC_EDITED - 304)))) != 0L)) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 4347
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DATA) {
				if (true){
				this.state = 4346
				match(DATA) as Token
				}
			}

			this.state = 4349
			match(BY) as Token
			this.state = 4352
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,615,context) ) {
			1 -> {if (true){
			this.state = 4350
			identifier()
			}}
			2 -> {if (true){
			this.state = 4351
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InitiateStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_initiateStatement.id
	        set(value) { throw RuntimeException() }
		fun INITIATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.INITIATE.id, 0)
		fun findReportName() : List<ReportNameContext> = getRuleContexts(solver.getType("ReportNameContext"))
		fun findReportName(i: Int) : ReportNameContext? = getRuleContext(solver.getType("ReportNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInitiateStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInitiateStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInitiateStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  initiateStatement() : InitiateStatementContext {
		var _localctx : InitiateStatementContext = InitiateStatementContext(context, state)
		enterRule(_localctx, 706, Rules.RULE_initiateStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4354
			match(INITIATE) as Token
			this.state = 4356 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4355
				reportName()
				}
				}
				this.state = 4358 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectStatement.id
	        set(value) { throw RuntimeException() }
		fun INSPECT() : TerminalNode? = getToken(Cobol85Parser.Tokens.INSPECT.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findInspectTallyingPhrase() : InspectTallyingPhraseContext? = getRuleContext(solver.getType("InspectTallyingPhraseContext"),0)
		fun findInspectReplacingPhrase() : InspectReplacingPhraseContext? = getRuleContext(solver.getType("InspectReplacingPhraseContext"),0)
		fun findInspectTallyingReplacingPhrase() : InspectTallyingReplacingPhraseContext? = getRuleContext(solver.getType("InspectTallyingReplacingPhraseContext"),0)
		fun findInspectConvertingPhrase() : InspectConvertingPhraseContext? = getRuleContext(solver.getType("InspectConvertingPhraseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectStatement() : InspectStatementContext {
		var _localctx : InspectStatementContext = InspectStatementContext(context, state)
		enterRule(_localctx, 708, Rules.RULE_inspectStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4360
			match(INSPECT) as Token
			this.state = 4361
			identifier()
			this.state = 4366
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,617,context) ) {
			1 -> {if (true){
			this.state = 4362
			inspectTallyingPhrase()
			}}
			2 -> {if (true){
			this.state = 4363
			inspectReplacingPhrase()
			}}
			3 -> {if (true){
			this.state = 4364
			inspectTallyingReplacingPhrase()
			}}
			4 -> {if (true){
			this.state = 4365
			inspectConvertingPhrase()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectTallyingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectTallyingPhrase.id
	        set(value) { throw RuntimeException() }
		fun TALLYING() : TerminalNode? = getToken(Cobol85Parser.Tokens.TALLYING.id, 0)
		fun findInspectFor() : List<InspectForContext> = getRuleContexts(solver.getType("InspectForContext"))
		fun findInspectFor(i: Int) : InspectForContext? = getRuleContext(solver.getType("InspectForContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectTallyingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectTallyingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectTallyingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectTallyingPhrase() : InspectTallyingPhraseContext {
		var _localctx : InspectTallyingPhraseContext = InspectTallyingPhraseContext(context, state)
		enterRule(_localctx, 710, Rules.RULE_inspectTallyingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4368
			match(TALLYING) as Token
			this.state = 4370 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4369
				inspectFor()
				}
				}
				this.state = 4372 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectReplacingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectReplacingPhrase.id
	        set(value) { throw RuntimeException() }
		fun REPLACING() : TerminalNode? = getToken(Cobol85Parser.Tokens.REPLACING.id, 0)
		fun findInspectReplacingCharacters() : List<InspectReplacingCharactersContext> = getRuleContexts(solver.getType("InspectReplacingCharactersContext"))
		fun findInspectReplacingCharacters(i: Int) : InspectReplacingCharactersContext? = getRuleContext(solver.getType("InspectReplacingCharactersContext"),i)
		fun findInspectReplacingAllLeadings() : List<InspectReplacingAllLeadingsContext> = getRuleContexts(solver.getType("InspectReplacingAllLeadingsContext"))
		fun findInspectReplacingAllLeadings(i: Int) : InspectReplacingAllLeadingsContext? = getRuleContext(solver.getType("InspectReplacingAllLeadingsContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectReplacingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectReplacingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectReplacingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectReplacingPhrase() : InspectReplacingPhraseContext {
		var _localctx : InspectReplacingPhraseContext = InspectReplacingPhraseContext(context, state)
		enterRule(_localctx, 712, Rules.RULE_inspectReplacingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4374
			match(REPLACING) as Token
			this.state = 4377 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				this.state = 4377
				errorHandler.sync(this)
				when (_input!!.LA(1)) {
				CHARACTERS  ->  /*LL1AltBlock*/{if (true){
				this.state = 4375
				inspectReplacingCharacters()
				}}
				ALL , FIRST , LEADING  ->  /*LL1AltBlock*/{if (true){
				this.state = 4376
				inspectReplacingAllLeadings()
				}}
				else -> throw NoViableAltException(this)
				}
				}
				this.state = 4379 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( _la==ALL || _la==CHARACTERS || _la==FIRST || _la==LEADING )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectTallyingReplacingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectTallyingReplacingPhrase.id
	        set(value) { throw RuntimeException() }
		fun TALLYING() : TerminalNode? = getToken(Cobol85Parser.Tokens.TALLYING.id, 0)
		fun findInspectFor() : List<InspectForContext> = getRuleContexts(solver.getType("InspectForContext"))
		fun findInspectFor(i: Int) : InspectForContext? = getRuleContext(solver.getType("InspectForContext"),i)
		fun findInspectReplacingPhrase() : List<InspectReplacingPhraseContext> = getRuleContexts(solver.getType("InspectReplacingPhraseContext"))
		fun findInspectReplacingPhrase(i: Int) : InspectReplacingPhraseContext? = getRuleContext(solver.getType("InspectReplacingPhraseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectTallyingReplacingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectTallyingReplacingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectTallyingReplacingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectTallyingReplacingPhrase() : InspectTallyingReplacingPhraseContext {
		var _localctx : InspectTallyingReplacingPhraseContext = InspectTallyingReplacingPhraseContext(context, state)
		enterRule(_localctx, 714, Rules.RULE_inspectTallyingReplacingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4381
			match(TALLYING) as Token
			this.state = 4383 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4382
				inspectFor()
				}
				}
				this.state = 4385 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			this.state = 4388 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4387
				inspectReplacingPhrase()
				}
				}
				this.state = 4390 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( _la==REPLACING )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectConvertingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectConvertingPhrase.id
	        set(value) { throw RuntimeException() }
		fun CONVERTING() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONVERTING.id, 0)
		fun findInspectTo() : InspectToContext? = getRuleContext(solver.getType("InspectToContext"),0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findInspectBeforeAfter() : List<InspectBeforeAfterContext> = getRuleContexts(solver.getType("InspectBeforeAfterContext"))
		fun findInspectBeforeAfter(i: Int) : InspectBeforeAfterContext? = getRuleContext(solver.getType("InspectBeforeAfterContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectConvertingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectConvertingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectConvertingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectConvertingPhrase() : InspectConvertingPhraseContext {
		var _localctx : InspectConvertingPhraseContext = InspectConvertingPhraseContext(context, state)
		enterRule(_localctx, 716, Rules.RULE_inspectConvertingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4392
			match(CONVERTING) as Token
			this.state = 4395
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,623,context) ) {
			1 -> {if (true){
			this.state = 4393
			identifier()
			}}
			2 -> {if (true){
			this.state = 4394
			literal()
			}}
			}
			this.state = 4397
			inspectTo()
			this.state = 4401
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==AFTER || _la==BEFORE) {
				if (true){
				if (true){
				this.state = 4398
				inspectBeforeAfter()
				}
				}
				this.state = 4403
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectForContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectFor.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun findInspectCharacters() : List<InspectCharactersContext> = getRuleContexts(solver.getType("InspectCharactersContext"))
		fun findInspectCharacters(i: Int) : InspectCharactersContext? = getRuleContext(solver.getType("InspectCharactersContext"),i)
		fun findInspectAllLeadings() : List<InspectAllLeadingsContext> = getRuleContexts(solver.getType("InspectAllLeadingsContext"))
		fun findInspectAllLeadings(i: Int) : InspectAllLeadingsContext? = getRuleContext(solver.getType("InspectAllLeadingsContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectFor(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectFor(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectFor(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectFor() : InspectForContext {
		var _localctx : InspectForContext = InspectForContext(context, state)
		enterRule(_localctx, 718, Rules.RULE_inspectFor.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4404
			identifier()
			this.state = 4405
			match(FOR) as Token
			this.state = 4408 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				this.state = 4408
				errorHandler.sync(this)
				when (_input!!.LA(1)) {
				CHARACTERS  ->  /*LL1AltBlock*/{if (true){
				this.state = 4406
				inspectCharacters()
				}}
				ALL , LEADING  ->  /*LL1AltBlock*/{if (true){
				this.state = 4407
				inspectAllLeadings()
				}}
				else -> throw NoViableAltException(this)
				}
				}
				this.state = 4410 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( _la==ALL || _la==CHARACTERS || _la==LEADING )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectCharactersContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectCharacters.id
	        set(value) { throw RuntimeException() }
		fun CHARACTERS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTERS.id, 0)
		fun findInspectBeforeAfter() : List<InspectBeforeAfterContext> = getRuleContexts(solver.getType("InspectBeforeAfterContext"))
		fun findInspectBeforeAfter(i: Int) : InspectBeforeAfterContext? = getRuleContext(solver.getType("InspectBeforeAfterContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectCharacters(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectCharacters(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectCharacters(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectCharacters() : InspectCharactersContext {
		var _localctx : InspectCharactersContext = InspectCharactersContext(context, state)
		enterRule(_localctx, 720, Rules.RULE_inspectCharacters.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4412
			match(CHARACTERS) as Token
			this.state = 4416
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==AFTER || _la==BEFORE) {
				if (true){
				if (true){
				this.state = 4413
				inspectBeforeAfter()
				}
				}
				this.state = 4418
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectReplacingCharactersContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectReplacingCharacters.id
	        set(value) { throw RuntimeException() }
		fun CHARACTERS() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHARACTERS.id, 0)
		fun findInspectBy() : InspectByContext? = getRuleContext(solver.getType("InspectByContext"),0)
		fun findInspectBeforeAfter() : List<InspectBeforeAfterContext> = getRuleContexts(solver.getType("InspectBeforeAfterContext"))
		fun findInspectBeforeAfter(i: Int) : InspectBeforeAfterContext? = getRuleContext(solver.getType("InspectBeforeAfterContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectReplacingCharacters(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectReplacingCharacters(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectReplacingCharacters(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectReplacingCharacters() : InspectReplacingCharactersContext {
		var _localctx : InspectReplacingCharactersContext = InspectReplacingCharactersContext(context, state)
		enterRule(_localctx, 722, Rules.RULE_inspectReplacingCharacters.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4419
			match(CHARACTERS) as Token
			this.state = 4420
			inspectBy()
			this.state = 4424
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==AFTER || _la==BEFORE) {
				if (true){
				if (true){
				this.state = 4421
				inspectBeforeAfter()
				}
				}
				this.state = 4426
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectAllLeadingsContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectAllLeadings.id
	        set(value) { throw RuntimeException() }
		fun ALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALL.id, 0)
		fun LEADING() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEADING.id, 0)
		fun findInspectAllLeading() : List<InspectAllLeadingContext> = getRuleContexts(solver.getType("InspectAllLeadingContext"))
		fun findInspectAllLeading(i: Int) : InspectAllLeadingContext? = getRuleContext(solver.getType("InspectAllLeadingContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectAllLeadings(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectAllLeadings(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectAllLeadings(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectAllLeadings() : InspectAllLeadingsContext {
		var _localctx : InspectAllLeadingsContext = InspectAllLeadingsContext(context, state)
		enterRule(_localctx, 724, Rules.RULE_inspectAllLeadings.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4427
			_la = _input!!.LA(1)
			if ( !(_la==ALL || _la==LEADING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 4429 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 4428
				inspectAllLeading()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 4431 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,629,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectReplacingAllLeadingsContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectReplacingAllLeadings.id
	        set(value) { throw RuntimeException() }
		fun ALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALL.id, 0)
		fun LEADING() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEADING.id, 0)
		fun FIRST() : TerminalNode? = getToken(Cobol85Parser.Tokens.FIRST.id, 0)
		fun findInspectReplacingAllLeading() : List<InspectReplacingAllLeadingContext> = getRuleContexts(solver.getType("InspectReplacingAllLeadingContext"))
		fun findInspectReplacingAllLeading(i: Int) : InspectReplacingAllLeadingContext? = getRuleContext(solver.getType("InspectReplacingAllLeadingContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectReplacingAllLeadings(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectReplacingAllLeadings(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectReplacingAllLeadings(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectReplacingAllLeadings() : InspectReplacingAllLeadingsContext {
		var _localctx : InspectReplacingAllLeadingsContext = InspectReplacingAllLeadingsContext(context, state)
		enterRule(_localctx, 726, Rules.RULE_inspectReplacingAllLeadings.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4433
			_la = _input!!.LA(1)
			if ( !(_la==ALL || _la==FIRST || _la==LEADING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 4435 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 4434
				inspectReplacingAllLeading()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 4437 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,630,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectAllLeadingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectAllLeading.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findInspectBeforeAfter() : List<InspectBeforeAfterContext> = getRuleContexts(solver.getType("InspectBeforeAfterContext"))
		fun findInspectBeforeAfter(i: Int) : InspectBeforeAfterContext? = getRuleContext(solver.getType("InspectBeforeAfterContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectAllLeading(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectAllLeading(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectAllLeading(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectAllLeading() : InspectAllLeadingContext {
		var _localctx : InspectAllLeadingContext = InspectAllLeadingContext(context, state)
		enterRule(_localctx, 728, Rules.RULE_inspectAllLeading.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4441
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,631,context) ) {
			1 -> {if (true){
			this.state = 4439
			identifier()
			}}
			2 -> {if (true){
			this.state = 4440
			literal()
			}}
			}
			this.state = 4446
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==AFTER || _la==BEFORE) {
				if (true){
				if (true){
				this.state = 4443
				inspectBeforeAfter()
				}
				}
				this.state = 4448
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectReplacingAllLeadingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectReplacingAllLeading.id
	        set(value) { throw RuntimeException() }
		fun findInspectBy() : InspectByContext? = getRuleContext(solver.getType("InspectByContext"),0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findInspectBeforeAfter() : List<InspectBeforeAfterContext> = getRuleContexts(solver.getType("InspectBeforeAfterContext"))
		fun findInspectBeforeAfter(i: Int) : InspectBeforeAfterContext? = getRuleContext(solver.getType("InspectBeforeAfterContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectReplacingAllLeading(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectReplacingAllLeading(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectReplacingAllLeading(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectReplacingAllLeading() : InspectReplacingAllLeadingContext {
		var _localctx : InspectReplacingAllLeadingContext = InspectReplacingAllLeadingContext(context, state)
		enterRule(_localctx, 730, Rules.RULE_inspectReplacingAllLeading.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4451
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,633,context) ) {
			1 -> {if (true){
			this.state = 4449
			identifier()
			}}
			2 -> {if (true){
			this.state = 4450
			literal()
			}}
			}
			this.state = 4453
			inspectBy()
			this.state = 4457
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==AFTER || _la==BEFORE) {
				if (true){
				if (true){
				this.state = 4454
				inspectBeforeAfter()
				}
				}
				this.state = 4459
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectByContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectBy.id
	        set(value) { throw RuntimeException() }
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectBy(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectBy(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectBy(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectBy() : InspectByContext {
		var _localctx : InspectByContext = InspectByContext(context, state)
		enterRule(_localctx, 732, Rules.RULE_inspectBy.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4460
			match(BY) as Token
			this.state = 4463
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,635,context) ) {
			1 -> {if (true){
			this.state = 4461
			identifier()
			}}
			2 -> {if (true){
			this.state = 4462
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectToContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectTo.id
	        set(value) { throw RuntimeException() }
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectTo(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectTo(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectTo(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectTo() : InspectToContext {
		var _localctx : InspectToContext = InspectToContext(context, state)
		enterRule(_localctx, 734, Rules.RULE_inspectTo.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4465
			match(TO) as Token
			this.state = 4468
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,636,context) ) {
			1 -> {if (true){
			this.state = 4466
			identifier()
			}}
			2 -> {if (true){
			this.state = 4467
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InspectBeforeAfterContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inspectBeforeAfter.id
	        set(value) { throw RuntimeException() }
		fun BEFORE() : TerminalNode? = getToken(Cobol85Parser.Tokens.BEFORE.id, 0)
		fun AFTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.AFTER.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun INITIAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.INITIAL.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInspectBeforeAfter(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInspectBeforeAfter(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInspectBeforeAfter(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inspectBeforeAfter() : InspectBeforeAfterContext {
		var _localctx : InspectBeforeAfterContext = InspectBeforeAfterContext(context, state)
		enterRule(_localctx, 736, Rules.RULE_inspectBeforeAfter.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4470
			_la = _input!!.LA(1)
			if ( !(_la==AFTER || _la==BEFORE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 4472
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==INITIAL) {
				if (true){
				this.state = 4471
				match(INITIAL) as Token
				}
			}

			this.state = 4476
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,638,context) ) {
			1 -> {if (true){
			this.state = 4474
			identifier()
			}}
			2 -> {if (true){
			this.state = 4475
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MergeStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_mergeStatement.id
	        set(value) { throw RuntimeException() }
		fun MERGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.MERGE.id, 0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun findMergeOnKeyClause() : List<MergeOnKeyClauseContext> = getRuleContexts(solver.getType("MergeOnKeyClauseContext"))
		fun findMergeOnKeyClause(i: Int) : MergeOnKeyClauseContext? = getRuleContext(solver.getType("MergeOnKeyClauseContext"),i)
		fun findMergeCollatingSequencePhrase() : MergeCollatingSequencePhraseContext? = getRuleContext(solver.getType("MergeCollatingSequencePhraseContext"),0)
		fun findMergeUsing() : List<MergeUsingContext> = getRuleContexts(solver.getType("MergeUsingContext"))
		fun findMergeUsing(i: Int) : MergeUsingContext? = getRuleContext(solver.getType("MergeUsingContext"),i)
		fun findMergeOutputProcedurePhrase() : MergeOutputProcedurePhraseContext? = getRuleContext(solver.getType("MergeOutputProcedurePhraseContext"),0)
		fun findMergeGivingPhrase() : List<MergeGivingPhraseContext> = getRuleContexts(solver.getType("MergeGivingPhraseContext"))
		fun findMergeGivingPhrase(i: Int) : MergeGivingPhraseContext? = getRuleContext(solver.getType("MergeGivingPhraseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMergeStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMergeStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMergeStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  mergeStatement() : MergeStatementContext {
		var _localctx : MergeStatementContext = MergeStatementContext(context, state)
		enterRule(_localctx, 738, Rules.RULE_mergeStatement.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4478
			match(MERGE) as Token
			this.state = 4479
			fileName()
			this.state = 4481 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 4480
				mergeOnKeyClause()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 4483 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,639,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			this.state = 4486
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COLLATING || _la==SEQUENCE) {
				if (true){
				this.state = 4485
				mergeCollatingSequencePhrase()
				}
			}

			this.state = 4491
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==USING) {
				if (true){
				if (true){
				this.state = 4488
				mergeUsing()
				}
				}
				this.state = 4493
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 4495
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OUTPUT) {
				if (true){
				this.state = 4494
				mergeOutputProcedurePhrase()
				}
			}

			this.state = 4500
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==GIVING) {
				if (true){
				if (true){
				this.state = 4497
				mergeGivingPhrase()
				}
				}
				this.state = 4502
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MergeOnKeyClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_mergeOnKeyClause.id
	        set(value) { throw RuntimeException() }
		fun ASCENDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.ASCENDING.id, 0)
		fun DESCENDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.DESCENDING.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun findQualifiedDataName() : List<QualifiedDataNameContext> = getRuleContexts(solver.getType("QualifiedDataNameContext"))
		fun findQualifiedDataName(i: Int) : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMergeOnKeyClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMergeOnKeyClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMergeOnKeyClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  mergeOnKeyClause() : MergeOnKeyClauseContext {
		var _localctx : MergeOnKeyClauseContext = MergeOnKeyClauseContext(context, state)
		enterRule(_localctx, 740, Rules.RULE_mergeOnKeyClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4504
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 4503
				match(ON) as Token
				}
			}

			this.state = 4506
			_la = _input!!.LA(1)
			if ( !(_la==ASCENDING || _la==DESCENDING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 4508
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==KEY) {
				if (true){
				this.state = 4507
				match(KEY) as Token
				}
			}

			this.state = 4511 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4510
				qualifiedDataName()
				}
				}
				this.state = 4513 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MergeCollatingSequencePhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_mergeCollatingSequencePhrase.id
	        set(value) { throw RuntimeException() }
		fun SEQUENCE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEQUENCE.id, 0)
		fun COLLATING() : TerminalNode? = getToken(Cobol85Parser.Tokens.COLLATING.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findAlphabetName() : List<AlphabetNameContext> = getRuleContexts(solver.getType("AlphabetNameContext"))
		fun findAlphabetName(i: Int) : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),i)
		fun findMergeCollatingAlphanumeric() : MergeCollatingAlphanumericContext? = getRuleContext(solver.getType("MergeCollatingAlphanumericContext"),0)
		fun findMergeCollatingNational() : MergeCollatingNationalContext? = getRuleContext(solver.getType("MergeCollatingNationalContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMergeCollatingSequencePhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMergeCollatingSequencePhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMergeCollatingSequencePhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  mergeCollatingSequencePhrase() : MergeCollatingSequencePhraseContext {
		var _localctx : MergeCollatingSequencePhraseContext = MergeCollatingSequencePhraseContext(context, state)
		enterRule(_localctx, 742, Rules.RULE_mergeCollatingSequencePhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4516
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COLLATING) {
				if (true){
				this.state = 4515
				match(COLLATING) as Token
				}
			}

			this.state = 4518
			match(SEQUENCE) as Token
			this.state = 4520
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 4519
				match(IS) as Token
				}
			}

			this.state = 4523 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 4522
				alphabetName()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 4525 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,649,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			this.state = 4528
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,650,context) ) {
			1   -> if (true){
			this.state = 4527
			mergeCollatingAlphanumeric()
			}
			}
			this.state = 4531
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR || _la==NATIONAL) {
				if (true){
				this.state = 4530
				mergeCollatingNational()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MergeCollatingAlphanumericContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_mergeCollatingAlphanumeric.id
	        set(value) { throw RuntimeException() }
		fun ALPHANUMERIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHANUMERIC.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findAlphabetName() : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMergeCollatingAlphanumeric(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMergeCollatingAlphanumeric(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMergeCollatingAlphanumeric(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  mergeCollatingAlphanumeric() : MergeCollatingAlphanumericContext {
		var _localctx : MergeCollatingAlphanumericContext = MergeCollatingAlphanumericContext(context, state)
		enterRule(_localctx, 744, Rules.RULE_mergeCollatingAlphanumeric.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4534
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 4533
				match(FOR) as Token
				}
			}

			this.state = 4536
			match(ALPHANUMERIC) as Token
			this.state = 4537
			match(IS) as Token
			this.state = 4538
			alphabetName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MergeCollatingNationalContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_mergeCollatingNational.id
	        set(value) { throw RuntimeException() }
		fun NATIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIONAL.id, 0)
		fun findAlphabetName() : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMergeCollatingNational(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMergeCollatingNational(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMergeCollatingNational(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  mergeCollatingNational() : MergeCollatingNationalContext {
		var _localctx : MergeCollatingNationalContext = MergeCollatingNationalContext(context, state)
		enterRule(_localctx, 746, Rules.RULE_mergeCollatingNational.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4541
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 4540
				match(FOR) as Token
				}
			}

			this.state = 4543
			match(NATIONAL) as Token
			this.state = 4545
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 4544
				match(IS) as Token
				}
			}

			this.state = 4547
			alphabetName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MergeUsingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_mergeUsing.id
	        set(value) { throw RuntimeException() }
		fun USING() : TerminalNode? = getToken(Cobol85Parser.Tokens.USING.id, 0)
		fun findFileName() : List<FileNameContext> = getRuleContexts(solver.getType("FileNameContext"))
		fun findFileName(i: Int) : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMergeUsing(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMergeUsing(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMergeUsing(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  mergeUsing() : MergeUsingContext {
		var _localctx : MergeUsingContext = MergeUsingContext(context, state)
		enterRule(_localctx, 748, Rules.RULE_mergeUsing.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4549
			match(USING) as Token
			this.state = 4551 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4550
				fileName()
				}
				}
				this.state = 4553 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MergeOutputProcedurePhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_mergeOutputProcedurePhrase.id
	        set(value) { throw RuntimeException() }
		fun OUTPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.OUTPUT.id, 0)
		fun PROCEDURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROCEDURE.id, 0)
		fun findProcedureName() : ProcedureNameContext? = getRuleContext(solver.getType("ProcedureNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findMergeOutputThrough() : MergeOutputThroughContext? = getRuleContext(solver.getType("MergeOutputThroughContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMergeOutputProcedurePhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMergeOutputProcedurePhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMergeOutputProcedurePhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  mergeOutputProcedurePhrase() : MergeOutputProcedurePhraseContext {
		var _localctx : MergeOutputProcedurePhraseContext = MergeOutputProcedurePhraseContext(context, state)
		enterRule(_localctx, 750, Rules.RULE_mergeOutputProcedurePhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4555
			match(OUTPUT) as Token
			this.state = 4556
			match(PROCEDURE) as Token
			this.state = 4558
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 4557
				match(IS) as Token
				}
			}

			this.state = 4560
			procedureName()
			this.state = 4562
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THROUGH || _la==THRU) {
				if (true){
				this.state = 4561
				mergeOutputThrough()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MergeOutputThroughContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_mergeOutputThrough.id
	        set(value) { throw RuntimeException() }
		fun findProcedureName() : ProcedureNameContext? = getRuleContext(solver.getType("ProcedureNameContext"),0)
		fun THROUGH() : TerminalNode? = getToken(Cobol85Parser.Tokens.THROUGH.id, 0)
		fun THRU() : TerminalNode? = getToken(Cobol85Parser.Tokens.THRU.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMergeOutputThrough(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMergeOutputThrough(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMergeOutputThrough(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  mergeOutputThrough() : MergeOutputThroughContext {
		var _localctx : MergeOutputThroughContext = MergeOutputThroughContext(context, state)
		enterRule(_localctx, 752, Rules.RULE_mergeOutputThrough.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4564
			_la = _input!!.LA(1)
			if ( !(_la==THROUGH || _la==THRU) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 4565
			procedureName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MergeGivingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_mergeGivingPhrase.id
	        set(value) { throw RuntimeException() }
		fun GIVING() : TerminalNode? = getToken(Cobol85Parser.Tokens.GIVING.id, 0)
		fun findMergeGiving() : List<MergeGivingContext> = getRuleContexts(solver.getType("MergeGivingContext"))
		fun findMergeGiving(i: Int) : MergeGivingContext? = getRuleContext(solver.getType("MergeGivingContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMergeGivingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMergeGivingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMergeGivingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  mergeGivingPhrase() : MergeGivingPhraseContext {
		var _localctx : MergeGivingPhraseContext = MergeGivingPhraseContext(context, state)
		enterRule(_localctx, 754, Rules.RULE_mergeGivingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4567
			match(GIVING) as Token
			this.state = 4569 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4568
				mergeGiving()
				}
				}
				this.state = 4571 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MergeGivingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_mergeGiving.id
	        set(value) { throw RuntimeException() }
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun LOCK() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOCK.id, 0)
		fun SAVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SAVE.id, 0)
		fun NO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO.id, 0)
		fun REWIND() : TerminalNode? = getToken(Cobol85Parser.Tokens.REWIND.id, 0)
		fun CRUNCH() : TerminalNode? = getToken(Cobol85Parser.Tokens.CRUNCH.id, 0)
		fun RELEASE() : TerminalNode? = getToken(Cobol85Parser.Tokens.RELEASE.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		fun REMOVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.REMOVE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMergeGiving(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMergeGiving(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMergeGiving(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  mergeGiving() : MergeGivingContext {
		var _localctx : MergeGivingContext = MergeGivingContext(context, state)
		enterRule(_localctx, 756, Rules.RULE_mergeGiving.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4573
			fileName()
			this.state = 4583
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,659,context) ) {
			1   -> if (true){
			this.state = 4574
			match(LOCK) as Token
			}
			2   -> if (true){
			this.state = 4575
			match(SAVE) as Token
			}
			3   -> if (true){
			this.state = 4576
			match(NO) as Token
			this.state = 4577
			match(REWIND) as Token
			}
			4   -> if (true){
			this.state = 4578
			match(CRUNCH) as Token
			}
			5   -> if (true){
			this.state = 4579
			match(RELEASE) as Token
			}
			6   -> if (true){
			this.state = 4580
			match(WITH) as Token
			this.state = 4581
			match(REMOVE) as Token
			this.state = 4582
			match(CRUNCH) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MoveStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_moveStatement.id
	        set(value) { throw RuntimeException() }
		fun MOVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.MOVE.id, 0)
		fun findMoveToStatement() : MoveToStatementContext? = getRuleContext(solver.getType("MoveToStatementContext"),0)
		fun findMoveCorrespondingToStatement() : MoveCorrespondingToStatementContext? = getRuleContext(solver.getType("MoveCorrespondingToStatementContext"),0)
		fun ALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALL.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMoveStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMoveStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMoveStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  moveStatement() : MoveStatementContext {
		var _localctx : MoveStatementContext = MoveStatementContext(context, state)
		enterRule(_localctx, 758, Rules.RULE_moveStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4585
			match(MOVE) as Token
			this.state = 4587
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,660,context) ) {
			1   -> if (true){
			this.state = 4586
			match(ALL) as Token
			}
			}
			this.state = 4591
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ABORT , ADDRESS , ALL , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DATE , DAY , DAY_OF_WEEK , DEBUG_CONTENTS , DEBUG_ITEM , DEBUG_LINE , DEBUG_NAME , DEBUG_SUB_1 , DEBUG_SUB_2 , DEBUG_SUB_3 , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FALSE , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTION , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , HIGH_VALUE , HIGH_VALUES , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LINAGE_COUNTER , LINE_COUNTER , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , LOW_VALUE , LOW_VALUES , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NULL , NULLS , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PAGE_COUNTER , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , QUOTE , QUOTES , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , RETURN_CODE , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHIFT_IN , SHIFT_OUT , SHORT_DATE , SORT_CONTROL , SORT_CORE_SIZE , SORT_FILE_SIZE , SORT_MESSAGE , SORT_MODE_SIZE , SORT_RETURN , SPACE , SPACES , SYMBOL , TALLY , TASK , THREAD , THREAD_LOCAL , TIME , TIMER , TODAYS_DATE , TODAYS_NAME , TRUE , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , WHEN_COMPILED , YEAR , YYYYMMDD , YYYYDDD , ZERO , ZERO_FILL , ZEROS , ZEROES , NONNUMERICLITERAL , LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL , NUMERICLITERAL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 4589
			moveToStatement()
			}}
			CORR , CORRESPONDING  ->  /*LL1AltBlock*/{if (true){
			this.state = 4590
			moveCorrespondingToStatement()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MoveToStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_moveToStatement.id
	        set(value) { throw RuntimeException() }
		fun findMoveToSendingArea() : MoveToSendingAreaContext? = getRuleContext(solver.getType("MoveToSendingAreaContext"),0)
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun findIdentifier() : List<IdentifierContext> = getRuleContexts(solver.getType("IdentifierContext"))
		fun findIdentifier(i: Int) : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMoveToStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMoveToStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMoveToStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  moveToStatement() : MoveToStatementContext {
		var _localctx : MoveToStatementContext = MoveToStatementContext(context, state)
		enterRule(_localctx, 760, Rules.RULE_moveToStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4593
			moveToSendingArea()
			this.state = 4594
			match(TO) as Token
			this.state = 4596 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4595
				identifier()
				}
				}
				this.state = 4598 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MoveToSendingAreaContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_moveToSendingArea.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMoveToSendingArea(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMoveToSendingArea(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMoveToSendingArea(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  moveToSendingArea() : MoveToSendingAreaContext {
		var _localctx : MoveToSendingAreaContext = MoveToSendingAreaContext(context, state)
		enterRule(_localctx, 762, Rules.RULE_moveToSendingArea.id)
		try {
			this.state = 4602
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,663,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4600
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 4601
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MoveCorrespondingToStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_moveCorrespondingToStatement.id
	        set(value) { throw RuntimeException() }
		fun findMoveCorrespondingToSendingArea() : MoveCorrespondingToSendingAreaContext? = getRuleContext(solver.getType("MoveCorrespondingToSendingAreaContext"),0)
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun CORRESPONDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.CORRESPONDING.id, 0)
		fun CORR() : TerminalNode? = getToken(Cobol85Parser.Tokens.CORR.id, 0)
		fun findIdentifier() : List<IdentifierContext> = getRuleContexts(solver.getType("IdentifierContext"))
		fun findIdentifier(i: Int) : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMoveCorrespondingToStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMoveCorrespondingToStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMoveCorrespondingToStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  moveCorrespondingToStatement() : MoveCorrespondingToStatementContext {
		var _localctx : MoveCorrespondingToStatementContext = MoveCorrespondingToStatementContext(context, state)
		enterRule(_localctx, 764, Rules.RULE_moveCorrespondingToStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4604
			_la = _input!!.LA(1)
			if ( !(_la==CORR || _la==CORRESPONDING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 4605
			moveCorrespondingToSendingArea()
			this.state = 4606
			match(TO) as Token
			this.state = 4608 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4607
				identifier()
				}
				}
				this.state = 4610 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MoveCorrespondingToSendingAreaContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_moveCorrespondingToSendingArea.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMoveCorrespondingToSendingArea(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMoveCorrespondingToSendingArea(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMoveCorrespondingToSendingArea(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  moveCorrespondingToSendingArea() : MoveCorrespondingToSendingAreaContext {
		var _localctx : MoveCorrespondingToSendingAreaContext = MoveCorrespondingToSendingAreaContext(context, state)
		enterRule(_localctx, 766, Rules.RULE_moveCorrespondingToSendingArea.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4612
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MultiplyStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_multiplyStatement.id
	        set(value) { throw RuntimeException() }
		fun MULTIPLY() : TerminalNode? = getToken(Cobol85Parser.Tokens.MULTIPLY.id, 0)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findMultiplyRegular() : MultiplyRegularContext? = getRuleContext(solver.getType("MultiplyRegularContext"),0)
		fun findMultiplyGiving() : MultiplyGivingContext? = getRuleContext(solver.getType("MultiplyGivingContext"),0)
		fun findOnSizeErrorPhrase() : OnSizeErrorPhraseContext? = getRuleContext(solver.getType("OnSizeErrorPhraseContext"),0)
		fun findNotOnSizeErrorPhrase() : NotOnSizeErrorPhraseContext? = getRuleContext(solver.getType("NotOnSizeErrorPhraseContext"),0)
		fun END_MULTIPLY() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_MULTIPLY.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMultiplyStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMultiplyStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMultiplyStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  multiplyStatement() : MultiplyStatementContext {
		var _localctx : MultiplyStatementContext = MultiplyStatementContext(context, state)
		enterRule(_localctx, 768, Rules.RULE_multiplyStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4614
			match(MULTIPLY) as Token
			this.state = 4617
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,665,context) ) {
			1 -> {if (true){
			this.state = 4615
			identifier()
			}}
			2 -> {if (true){
			this.state = 4616
			literal()
			}}
			}
			this.state = 4619
			match(BY) as Token
			this.state = 4622
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,666,context) ) {
			1 -> {if (true){
			this.state = 4620
			multiplyRegular()
			}}
			2 -> {if (true){
			this.state = 4621
			multiplyGiving()
			}}
			}
			this.state = 4625
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,667,context) ) {
			1   -> if (true){
			this.state = 4624
			onSizeErrorPhrase()
			}
			}
			this.state = 4628
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,668,context) ) {
			1   -> if (true){
			this.state = 4627
			notOnSizeErrorPhrase()
			}
			}
			this.state = 4631
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,669,context) ) {
			1   -> if (true){
			this.state = 4630
			match(END_MULTIPLY) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MultiplyRegularContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_multiplyRegular.id
	        set(value) { throw RuntimeException() }
		fun findMultiplyRegularOperand() : List<MultiplyRegularOperandContext> = getRuleContexts(solver.getType("MultiplyRegularOperandContext"))
		fun findMultiplyRegularOperand(i: Int) : MultiplyRegularOperandContext? = getRuleContext(solver.getType("MultiplyRegularOperandContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMultiplyRegular(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMultiplyRegular(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMultiplyRegular(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  multiplyRegular() : MultiplyRegularContext {
		var _localctx : MultiplyRegularContext = MultiplyRegularContext(context, state)
		enterRule(_localctx, 770, Rules.RULE_multiplyRegular.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4634 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4633
				multiplyRegularOperand()
				}
				}
				this.state = 4636 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MultiplyRegularOperandContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_multiplyRegularOperand.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun ROUNDED() : TerminalNode? = getToken(Cobol85Parser.Tokens.ROUNDED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMultiplyRegularOperand(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMultiplyRegularOperand(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMultiplyRegularOperand(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  multiplyRegularOperand() : MultiplyRegularOperandContext {
		var _localctx : MultiplyRegularOperandContext = MultiplyRegularOperandContext(context, state)
		enterRule(_localctx, 772, Rules.RULE_multiplyRegularOperand.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4638
			identifier()
			this.state = 4640
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ROUNDED) {
				if (true){
				this.state = 4639
				match(ROUNDED) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MultiplyGivingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_multiplyGiving.id
	        set(value) { throw RuntimeException() }
		fun findMultiplyGivingOperand() : MultiplyGivingOperandContext? = getRuleContext(solver.getType("MultiplyGivingOperandContext"),0)
		fun GIVING() : TerminalNode? = getToken(Cobol85Parser.Tokens.GIVING.id, 0)
		fun findMultiplyGivingResult() : List<MultiplyGivingResultContext> = getRuleContexts(solver.getType("MultiplyGivingResultContext"))
		fun findMultiplyGivingResult(i: Int) : MultiplyGivingResultContext? = getRuleContext(solver.getType("MultiplyGivingResultContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMultiplyGiving(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMultiplyGiving(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMultiplyGiving(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  multiplyGiving() : MultiplyGivingContext {
		var _localctx : MultiplyGivingContext = MultiplyGivingContext(context, state)
		enterRule(_localctx, 774, Rules.RULE_multiplyGiving.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4642
			multiplyGivingOperand()
			this.state = 4643
			match(GIVING) as Token
			this.state = 4645 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4644
				multiplyGivingResult()
				}
				}
				this.state = 4647 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MultiplyGivingOperandContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_multiplyGivingOperand.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMultiplyGivingOperand(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMultiplyGivingOperand(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMultiplyGivingOperand(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  multiplyGivingOperand() : MultiplyGivingOperandContext {
		var _localctx : MultiplyGivingOperandContext = MultiplyGivingOperandContext(context, state)
		enterRule(_localctx, 776, Rules.RULE_multiplyGivingOperand.id)
		try {
			this.state = 4651
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,673,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4649
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 4650
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MultiplyGivingResultContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_multiplyGivingResult.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun ROUNDED() : TerminalNode? = getToken(Cobol85Parser.Tokens.ROUNDED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMultiplyGivingResult(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMultiplyGivingResult(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMultiplyGivingResult(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  multiplyGivingResult() : MultiplyGivingResultContext {
		var _localctx : MultiplyGivingResultContext = MultiplyGivingResultContext(context, state)
		enterRule(_localctx, 778, Rules.RULE_multiplyGivingResult.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4653
			identifier()
			this.state = 4655
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ROUNDED) {
				if (true){
				this.state = 4654
				match(ROUNDED) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class OpenStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_openStatement.id
	        set(value) { throw RuntimeException() }
		fun OPEN() : TerminalNode? = getToken(Cobol85Parser.Tokens.OPEN.id, 0)
		fun findOpenInputStatement() : List<OpenInputStatementContext> = getRuleContexts(solver.getType("OpenInputStatementContext"))
		fun findOpenInputStatement(i: Int) : OpenInputStatementContext? = getRuleContext(solver.getType("OpenInputStatementContext"),i)
		fun findOpenOutputStatement() : List<OpenOutputStatementContext> = getRuleContexts(solver.getType("OpenOutputStatementContext"))
		fun findOpenOutputStatement(i: Int) : OpenOutputStatementContext? = getRuleContext(solver.getType("OpenOutputStatementContext"),i)
		fun findOpenIOStatement() : List<OpenIOStatementContext> = getRuleContexts(solver.getType("OpenIOStatementContext"))
		fun findOpenIOStatement(i: Int) : OpenIOStatementContext? = getRuleContext(solver.getType("OpenIOStatementContext"),i)
		fun findOpenExtendStatement() : List<OpenExtendStatementContext> = getRuleContexts(solver.getType("OpenExtendStatementContext"))
		fun findOpenExtendStatement(i: Int) : OpenExtendStatementContext? = getRuleContext(solver.getType("OpenExtendStatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterOpenStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitOpenStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitOpenStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  openStatement() : OpenStatementContext {
		var _localctx : OpenStatementContext = OpenStatementContext(context, state)
		enterRule(_localctx, 780, Rules.RULE_openStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4657
			match(OPEN) as Token
			this.state = 4662 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				this.state = 4662
				errorHandler.sync(this)
				when (_input!!.LA(1)) {
				INPUT  ->  /*LL1AltBlock*/{if (true){
				this.state = 4658
				openInputStatement()
				}}
				OUTPUT  ->  /*LL1AltBlock*/{if (true){
				this.state = 4659
				openOutputStatement()
				}}
				I_O  ->  /*LL1AltBlock*/{if (true){
				this.state = 4660
				openIOStatement()
				}}
				EXTEND  ->  /*LL1AltBlock*/{if (true){
				this.state = 4661
				openExtendStatement()
				}}
				else -> throw NoViableAltException(this)
				}
				}
				this.state = 4664 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( ((((_la - 201)) and 0x3f.inv()) == 0 && ((1L shl (_la - 201)) and ((1L shl (EXTEND - 201)) or (1L shl (I_O - 201)) or (1L shl (INPUT - 201)))) != 0L) || _la==OUTPUT )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class OpenInputStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_openInputStatement.id
	        set(value) { throw RuntimeException() }
		fun INPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.INPUT.id, 0)
		fun findOpenInput() : List<OpenInputContext> = getRuleContexts(solver.getType("OpenInputContext"))
		fun findOpenInput(i: Int) : OpenInputContext? = getRuleContext(solver.getType("OpenInputContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterOpenInputStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitOpenInputStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitOpenInputStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  openInputStatement() : OpenInputStatementContext {
		var _localctx : OpenInputStatementContext = OpenInputStatementContext(context, state)
		enterRule(_localctx, 782, Rules.RULE_openInputStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4666
			match(INPUT) as Token
			this.state = 4668 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4667
				openInput()
				}
				}
				this.state = 4670 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class OpenInputContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_openInput.id
	        set(value) { throw RuntimeException() }
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun REVERSED() : TerminalNode? = getToken(Cobol85Parser.Tokens.REVERSED.id, 0)
		fun NO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO.id, 0)
		fun REWIND() : TerminalNode? = getToken(Cobol85Parser.Tokens.REWIND.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterOpenInput(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitOpenInput(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitOpenInput(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  openInput() : OpenInputContext {
		var _localctx : OpenInputContext = OpenInputContext(context, state)
		enterRule(_localctx, 784, Rules.RULE_openInput.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4672
			fileName()
			this.state = 4679
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,679,context) ) {
			1   -> if (true){
			this.state = 4673
			match(REVERSED) as Token
			}
			2   -> if (true){
			this.state = 4675
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 4674
				match(WITH) as Token
				}
			}

			this.state = 4677
			match(NO) as Token
			this.state = 4678
			match(REWIND) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class OpenOutputStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_openOutputStatement.id
	        set(value) { throw RuntimeException() }
		fun OUTPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.OUTPUT.id, 0)
		fun findOpenOutput() : List<OpenOutputContext> = getRuleContexts(solver.getType("OpenOutputContext"))
		fun findOpenOutput(i: Int) : OpenOutputContext? = getRuleContext(solver.getType("OpenOutputContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterOpenOutputStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitOpenOutputStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitOpenOutputStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  openOutputStatement() : OpenOutputStatementContext {
		var _localctx : OpenOutputStatementContext = OpenOutputStatementContext(context, state)
		enterRule(_localctx, 786, Rules.RULE_openOutputStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4681
			match(OUTPUT) as Token
			this.state = 4683 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4682
				openOutput()
				}
				}
				this.state = 4685 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class OpenOutputContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_openOutput.id
	        set(value) { throw RuntimeException() }
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun NO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO.id, 0)
		fun REWIND() : TerminalNode? = getToken(Cobol85Parser.Tokens.REWIND.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterOpenOutput(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitOpenOutput(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitOpenOutput(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  openOutput() : OpenOutputContext {
		var _localctx : OpenOutputContext = OpenOutputContext(context, state)
		enterRule(_localctx, 788, Rules.RULE_openOutput.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4687
			fileName()
			this.state = 4693
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,682,context) ) {
			1   -> if (true){
			this.state = 4689
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 4688
				match(WITH) as Token
				}
			}

			this.state = 4691
			match(NO) as Token
			this.state = 4692
			match(REWIND) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class OpenIOStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_openIOStatement.id
	        set(value) { throw RuntimeException() }
		fun I_O() : TerminalNode? = getToken(Cobol85Parser.Tokens.I_O.id, 0)
		fun findFileName() : List<FileNameContext> = getRuleContexts(solver.getType("FileNameContext"))
		fun findFileName(i: Int) : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterOpenIOStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitOpenIOStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitOpenIOStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  openIOStatement() : OpenIOStatementContext {
		var _localctx : OpenIOStatementContext = OpenIOStatementContext(context, state)
		enterRule(_localctx, 790, Rules.RULE_openIOStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4695
			match(I_O) as Token
			this.state = 4697 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4696
				fileName()
				}
				}
				this.state = 4699 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class OpenExtendStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_openExtendStatement.id
	        set(value) { throw RuntimeException() }
		fun EXTEND() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXTEND.id, 0)
		fun findFileName() : List<FileNameContext> = getRuleContexts(solver.getType("FileNameContext"))
		fun findFileName(i: Int) : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterOpenExtendStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitOpenExtendStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitOpenExtendStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  openExtendStatement() : OpenExtendStatementContext {
		var _localctx : OpenExtendStatementContext = OpenExtendStatementContext(context, state)
		enterRule(_localctx, 792, Rules.RULE_openExtendStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4701
			match(EXTEND) as Token
			this.state = 4703 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4702
				fileName()
				}
				}
				this.state = 4705 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performStatement.id
	        set(value) { throw RuntimeException() }
		fun PERFORM() : TerminalNode? = getToken(Cobol85Parser.Tokens.PERFORM.id, 0)
		fun findPerformInlineStatement() : PerformInlineStatementContext? = getRuleContext(solver.getType("PerformInlineStatementContext"),0)
		fun findPerformProcedureStatement() : PerformProcedureStatementContext? = getRuleContext(solver.getType("PerformProcedureStatementContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performStatement() : PerformStatementContext {
		var _localctx : PerformStatementContext = PerformStatementContext(context, state)
		enterRule(_localctx, 794, Rules.RULE_performStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4707
			match(PERFORM) as Token
			this.state = 4710
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,685,context) ) {
			1 -> {if (true){
			this.state = 4708
			performInlineStatement()
			}}
			2 -> {if (true){
			this.state = 4709
			performProcedureStatement()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformInlineStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performInlineStatement.id
	        set(value) { throw RuntimeException() }
		fun END_PERFORM() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_PERFORM.id, 0)
		fun findPerformType() : PerformTypeContext? = getRuleContext(solver.getType("PerformTypeContext"),0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformInlineStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformInlineStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformInlineStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performInlineStatement() : PerformInlineStatementContext {
		var _localctx : PerformInlineStatementContext = PerformInlineStatementContext(context, state)
		enterRule(_localctx, 796, Rules.RULE_performInlineStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4713
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (TEST - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (UNTIL - 466)) or (1L shl (VARYING - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (WITH - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L)) {
				if (true){
				this.state = 4712
				performType()
				}
			}

			this.state = 4718
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ACCEPT) or (1L shl ADD) or (1L shl ALTER) or (1L shl CALL) or (1L shl CANCEL))) != 0L) || ((((_la - 67)) and 0x3f.inv()) == 0 && ((1L shl (_la - 67)) and ((1L shl (CLOSE - 67)) or (1L shl (COMPUTE - 67)) or (1L shl (CONTINUE - 67)))) != 0L) || ((((_la - 131)) and 0x3f.inv()) == 0 && ((1L shl (_la - 131)) and ((1L shl (DELETE - 131)) or (1L shl (DISABLE - 131)) or (1L shl (DISPLAY - 131)) or (1L shl (DIVIDE - 131)) or (1L shl (ENABLE - 131)) or (1L shl (ENTRY - 131)) or (1L shl (EVALUATE - 131)))) != 0L) || ((((_la - 198)) and 0x3f.inv()) == 0 && ((1L shl (_la - 198)) and ((1L shl (EXHIBIT - 198)) or (1L shl (EXIT - 198)) or (1L shl (GENERATE - 198)) or (1L shl (GOBACK - 198)) or (1L shl (GO - 198)) or (1L shl (IF - 198)) or (1L shl (INITIALIZE - 198)) or (1L shl (INITIATE - 198)) or (1L shl (INSPECT - 198)))) != 0L) || ((((_la - 294)) and 0x3f.inv()) == 0 && ((1L shl (_la - 294)) and ((1L shl (MERGE - 294)) or (1L shl (MOVE - 294)) or (1L shl (MULTIPLY - 294)) or (1L shl (OPEN - 294)) or (1L shl (PERFORM - 294)))) != 0L) || ((((_la - 365)) and 0x3f.inv()) == 0 && ((1L shl (_la - 365)) and ((1L shl (PURGE - 365)) or (1L shl (READ - 365)) or (1L shl (RECEIVE - 365)) or (1L shl (RELEASE - 365)) or (1L shl (RETURN - 365)) or (1L shl (REWRITE - 365)) or (1L shl (SEARCH - 365)) or (1L shl (SEND - 365)))) != 0L) || ((((_la - 430)) and 0x3f.inv()) == 0 && ((1L shl (_la - 430)) and ((1L shl (SET - 430)) or (1L shl (SORT - 430)) or (1L shl (START - 430)) or (1L shl (STOP - 430)) or (1L shl (STRING - 430)) or (1L shl (SUBTRACT - 430)) or (1L shl (TERMINATE - 430)))) != 0L) || ((((_la - 500)) and 0x3f.inv()) == 0 && ((1L shl (_la - 500)) and ((1L shl (UNSTRING - 500)) or (1L shl (WRITE - 500)) or (1L shl (EXECCICSLINE - 500)) or (1L shl (EXECSQLIMSLINE - 500)) or (1L shl (EXECSQLLINE - 500)))) != 0L)) {
				if (true){
				if (true){
				this.state = 4715
				statement()
				}
				}
				this.state = 4720
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 4721
			match(END_PERFORM) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformProcedureStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performProcedureStatement.id
	        set(value) { throw RuntimeException() }
		fun findProcedureName() : List<ProcedureNameContext> = getRuleContexts(solver.getType("ProcedureNameContext"))
		fun findProcedureName(i: Int) : ProcedureNameContext? = getRuleContext(solver.getType("ProcedureNameContext"),i)
		fun findPerformType() : PerformTypeContext? = getRuleContext(solver.getType("PerformTypeContext"),0)
		fun THROUGH() : TerminalNode? = getToken(Cobol85Parser.Tokens.THROUGH.id, 0)
		fun THRU() : TerminalNode? = getToken(Cobol85Parser.Tokens.THRU.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformProcedureStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformProcedureStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformProcedureStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performProcedureStatement() : PerformProcedureStatementContext {
		var _localctx : PerformProcedureStatementContext = PerformProcedureStatementContext(context, state)
		enterRule(_localctx, 798, Rules.RULE_performProcedureStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4723
			procedureName()
			this.state = 4726
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THROUGH || _la==THRU) {
				if (true){
				this.state = 4724
				_la = _input!!.LA(1)
				if ( !(_la==THROUGH || _la==THRU) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				this.state = 4725
				procedureName()
				}
			}

			this.state = 4729
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,689,context) ) {
			1   -> if (true){
			this.state = 4728
			performType()
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformTypeContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performType.id
	        set(value) { throw RuntimeException() }
		fun findPerformTimes() : PerformTimesContext? = getRuleContext(solver.getType("PerformTimesContext"),0)
		fun findPerformUntil() : PerformUntilContext? = getRuleContext(solver.getType("PerformUntilContext"),0)
		fun findPerformVarying() : PerformVaryingContext? = getRuleContext(solver.getType("PerformVaryingContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformType(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformType(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformType(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performType() : PerformTypeContext {
		var _localctx : PerformTypeContext = PerformTypeContext(context, state)
		enterRule(_localctx, 800, Rules.RULE_performType.id)
		try {
			this.state = 4734
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,690,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4731
			performTimes()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 4732
			performUntil()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 4733
			performVarying()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformTimesContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performTimes.id
	        set(value) { throw RuntimeException() }
		fun TIMES() : TerminalNode? = getToken(Cobol85Parser.Tokens.TIMES.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformTimes(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformTimes(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformTimes(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performTimes() : PerformTimesContext {
		var _localctx : PerformTimesContext = PerformTimesContext(context, state)
		enterRule(_localctx, 802, Rules.RULE_performTimes.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4738
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,691,context) ) {
			1 -> {if (true){
			this.state = 4736
			identifier()
			}}
			2 -> {if (true){
			this.state = 4737
			integerLiteral()
			}}
			}
			this.state = 4740
			match(TIMES) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformUntilContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performUntil.id
	        set(value) { throw RuntimeException() }
		fun UNTIL() : TerminalNode? = getToken(Cobol85Parser.Tokens.UNTIL.id, 0)
		fun findCondition() : ConditionContext? = getRuleContext(solver.getType("ConditionContext"),0)
		fun findPerformTestClause() : PerformTestClauseContext? = getRuleContext(solver.getType("PerformTestClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformUntil(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformUntil(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformUntil(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performUntil() : PerformUntilContext {
		var _localctx : PerformUntilContext = PerformUntilContext(context, state)
		enterRule(_localctx, 804, Rules.RULE_performUntil.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4743
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TEST || _la==WITH) {
				if (true){
				this.state = 4742
				performTestClause()
				}
			}

			this.state = 4745
			match(UNTIL) as Token
			this.state = 4746
			condition()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformVaryingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performVarying.id
	        set(value) { throw RuntimeException() }
		fun findPerformTestClause() : PerformTestClauseContext? = getRuleContext(solver.getType("PerformTestClauseContext"),0)
		fun findPerformVaryingClause() : PerformVaryingClauseContext? = getRuleContext(solver.getType("PerformVaryingClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformVarying(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformVarying(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformVarying(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performVarying() : PerformVaryingContext {
		var _localctx : PerformVaryingContext = PerformVaryingContext(context, state)
		enterRule(_localctx, 806, Rules.RULE_performVarying.id)
		try {
			this.state = 4755
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			TEST , WITH  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4748
			performTestClause()
			this.state = 4749
			performVaryingClause()
			}}
			VARYING  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 4751
			performVaryingClause()
			this.state = 4753
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,693,context) ) {
			1   -> if (true){
			this.state = 4752
			performTestClause()
			}
			}
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformVaryingClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performVaryingClause.id
	        set(value) { throw RuntimeException() }
		fun VARYING() : TerminalNode? = getToken(Cobol85Parser.Tokens.VARYING.id, 0)
		fun findPerformVaryingPhrase() : PerformVaryingPhraseContext? = getRuleContext(solver.getType("PerformVaryingPhraseContext"),0)
		fun findPerformAfter() : List<PerformAfterContext> = getRuleContexts(solver.getType("PerformAfterContext"))
		fun findPerformAfter(i: Int) : PerformAfterContext? = getRuleContext(solver.getType("PerformAfterContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformVaryingClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformVaryingClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformVaryingClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performVaryingClause() : PerformVaryingClauseContext {
		var _localctx : PerformVaryingClauseContext = PerformVaryingClauseContext(context, state)
		enterRule(_localctx, 808, Rules.RULE_performVaryingClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4757
			match(VARYING) as Token
			this.state = 4758
			performVaryingPhrase()
			this.state = 4762
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==AFTER) {
				if (true){
				if (true){
				this.state = 4759
				performAfter()
				}
				}
				this.state = 4764
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformVaryingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performVaryingPhrase.id
	        set(value) { throw RuntimeException() }
		fun findPerformFrom() : PerformFromContext? = getRuleContext(solver.getType("PerformFromContext"),0)
		fun findPerformBy() : PerformByContext? = getRuleContext(solver.getType("PerformByContext"),0)
		fun findPerformUntil() : PerformUntilContext? = getRuleContext(solver.getType("PerformUntilContext"),0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformVaryingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformVaryingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformVaryingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performVaryingPhrase() : PerformVaryingPhraseContext {
		var _localctx : PerformVaryingPhraseContext = PerformVaryingPhraseContext(context, state)
		enterRule(_localctx, 810, Rules.RULE_performVaryingPhrase.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4767
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,696,context) ) {
			1 -> {if (true){
			this.state = 4765
			identifier()
			}}
			2 -> {if (true){
			this.state = 4766
			literal()
			}}
			}
			this.state = 4769
			performFrom()
			this.state = 4770
			performBy()
			this.state = 4771
			performUntil()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformAfterContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performAfter.id
	        set(value) { throw RuntimeException() }
		fun AFTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.AFTER.id, 0)
		fun findPerformVaryingPhrase() : PerformVaryingPhraseContext? = getRuleContext(solver.getType("PerformVaryingPhraseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformAfter(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformAfter(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformAfter(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performAfter() : PerformAfterContext {
		var _localctx : PerformAfterContext = PerformAfterContext(context, state)
		enterRule(_localctx, 812, Rules.RULE_performAfter.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4773
			match(AFTER) as Token
			this.state = 4774
			performVaryingPhrase()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformFromContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performFrom.id
	        set(value) { throw RuntimeException() }
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformFrom(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformFrom(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformFrom(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performFrom() : PerformFromContext {
		var _localctx : PerformFromContext = PerformFromContext(context, state)
		enterRule(_localctx, 814, Rules.RULE_performFrom.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4776
			match(FROM) as Token
			this.state = 4780
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,697,context) ) {
			1 -> {if (true){
			this.state = 4777
			identifier()
			}}
			2 -> {if (true){
			this.state = 4778
			literal()
			}}
			3 -> {if (true){
			this.state = 4779
			arithmeticExpression()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformByContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performBy.id
	        set(value) { throw RuntimeException() }
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformBy(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformBy(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformBy(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performBy() : PerformByContext {
		var _localctx : PerformByContext = PerformByContext(context, state)
		enterRule(_localctx, 816, Rules.RULE_performBy.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4782
			match(BY) as Token
			this.state = 4786
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,698,context) ) {
			1 -> {if (true){
			this.state = 4783
			identifier()
			}}
			2 -> {if (true){
			this.state = 4784
			literal()
			}}
			3 -> {if (true){
			this.state = 4785
			arithmeticExpression()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PerformTestClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_performTestClause.id
	        set(value) { throw RuntimeException() }
		fun TEST() : TerminalNode? = getToken(Cobol85Parser.Tokens.TEST.id, 0)
		fun BEFORE() : TerminalNode? = getToken(Cobol85Parser.Tokens.BEFORE.id, 0)
		fun AFTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.AFTER.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPerformTestClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPerformTestClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPerformTestClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  performTestClause() : PerformTestClauseContext {
		var _localctx : PerformTestClauseContext = PerformTestClauseContext(context, state)
		enterRule(_localctx, 818, Rules.RULE_performTestClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4789
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 4788
				match(WITH) as Token
				}
			}

			this.state = 4791
			match(TEST) as Token
			this.state = 4792
			_la = _input!!.LA(1)
			if ( !(_la==AFTER || _la==BEFORE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PurgeStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_purgeStatement.id
	        set(value) { throw RuntimeException() }
		fun PURGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PURGE.id, 0)
		fun findCdName() : List<CdNameContext> = getRuleContexts(solver.getType("CdNameContext"))
		fun findCdName(i: Int) : CdNameContext? = getRuleContext(solver.getType("CdNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPurgeStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPurgeStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPurgeStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  purgeStatement() : PurgeStatementContext {
		var _localctx : PurgeStatementContext = PurgeStatementContext(context, state)
		enterRule(_localctx, 820, Rules.RULE_purgeStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4794
			match(PURGE) as Token
			this.state = 4796 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 4795
				cdName()
				}
				}
				this.state = 4798 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReadStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_readStatement.id
	        set(value) { throw RuntimeException() }
		fun READ() : TerminalNode? = getToken(Cobol85Parser.Tokens.READ.id, 0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun NEXT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NEXT.id, 0)
		fun RECORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORD.id, 0)
		fun findReadInto() : ReadIntoContext? = getRuleContext(solver.getType("ReadIntoContext"),0)
		fun findReadWith() : ReadWithContext? = getRuleContext(solver.getType("ReadWithContext"),0)
		fun findReadKey() : ReadKeyContext? = getRuleContext(solver.getType("ReadKeyContext"),0)
		fun findInvalidKeyPhrase() : InvalidKeyPhraseContext? = getRuleContext(solver.getType("InvalidKeyPhraseContext"),0)
		fun findNotInvalidKeyPhrase() : NotInvalidKeyPhraseContext? = getRuleContext(solver.getType("NotInvalidKeyPhraseContext"),0)
		fun findAtEndPhrase() : AtEndPhraseContext? = getRuleContext(solver.getType("AtEndPhraseContext"),0)
		fun findNotAtEndPhrase() : NotAtEndPhraseContext? = getRuleContext(solver.getType("NotAtEndPhraseContext"),0)
		fun END_READ() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_READ.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReadStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReadStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReadStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  readStatement() : ReadStatementContext {
		var _localctx : ReadStatementContext = ReadStatementContext(context, state)
		enterRule(_localctx, 822, Rules.RULE_readStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4800
			match(READ) as Token
			this.state = 4801
			fileName()
			this.state = 4803
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==NEXT) {
				if (true){
				this.state = 4802
				match(NEXT) as Token
				}
			}

			this.state = 4806
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==RECORD) {
				if (true){
				this.state = 4805
				match(RECORD) as Token
				}
			}

			this.state = 4809
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==INTO) {
				if (true){
				this.state = 4808
				readInto()
				}
			}

			this.state = 4812
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,704,context) ) {
			1   -> if (true){
			this.state = 4811
			readWith()
			}
			}
			this.state = 4815
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==KEY) {
				if (true){
				this.state = 4814
				readKey()
				}
			}

			this.state = 4818
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,706,context) ) {
			1   -> if (true){
			this.state = 4817
			invalidKeyPhrase()
			}
			}
			this.state = 4821
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,707,context) ) {
			1   -> if (true){
			this.state = 4820
			notInvalidKeyPhrase()
			}
			}
			this.state = 4824
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,708,context) ) {
			1   -> if (true){
			this.state = 4823
			atEndPhrase()
			}
			}
			this.state = 4827
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,709,context) ) {
			1   -> if (true){
			this.state = 4826
			notAtEndPhrase()
			}
			}
			this.state = 4830
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,710,context) ) {
			1   -> if (true){
			this.state = 4829
			match(END_READ) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReadIntoContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_readInto.id
	        set(value) { throw RuntimeException() }
		fun INTO() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTO.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReadInto(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReadInto(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReadInto(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  readInto() : ReadIntoContext {
		var _localctx : ReadIntoContext = ReadIntoContext(context, state)
		enterRule(_localctx, 824, Rules.RULE_readInto.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4832
			match(INTO) as Token
			this.state = 4833
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReadWithContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_readWith.id
	        set(value) { throw RuntimeException() }
		fun LOCK() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOCK.id, 0)
		fun WAIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.WAIT.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		fun KEPT() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEPT.id, 0)
		fun NO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReadWith(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReadWith(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReadWith(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  readWith() : ReadWithContext {
		var _localctx : ReadWithContext = ReadWithContext(context, state)
		enterRule(_localctx, 826, Rules.RULE_readWith.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4836
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 4835
				match(WITH) as Token
				}
			}

			this.state = 4841
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			KEPT , NO  ->  /*LL1AltBlock*/{if (true){
			this.state = 4838
			_la = _input!!.LA(1)
			if ( !(_la==KEPT || _la==NO) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 4839
			match(LOCK) as Token
			}}
			WAIT  ->  /*LL1AltBlock*/{if (true){
			this.state = 4840
			match(WAIT) as Token
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReadKeyContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_readKey.id
	        set(value) { throw RuntimeException() }
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReadKey(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReadKey(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReadKey(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  readKey() : ReadKeyContext {
		var _localctx : ReadKeyContext = ReadKeyContext(context, state)
		enterRule(_localctx, 828, Rules.RULE_readKey.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4843
			match(KEY) as Token
			this.state = 4845
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 4844
				match(IS) as Token
				}
			}

			this.state = 4847
			qualifiedDataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReceiveStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_receiveStatement.id
	        set(value) { throw RuntimeException() }
		fun RECEIVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECEIVE.id, 0)
		fun findReceiveFromStatement() : ReceiveFromStatementContext? = getRuleContext(solver.getType("ReceiveFromStatementContext"),0)
		fun findReceiveIntoStatement() : ReceiveIntoStatementContext? = getRuleContext(solver.getType("ReceiveIntoStatementContext"),0)
		fun findOnExceptionClause() : OnExceptionClauseContext? = getRuleContext(solver.getType("OnExceptionClauseContext"),0)
		fun findNotOnExceptionClause() : NotOnExceptionClauseContext? = getRuleContext(solver.getType("NotOnExceptionClauseContext"),0)
		fun END_RECEIVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_RECEIVE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReceiveStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReceiveStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReceiveStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  receiveStatement() : ReceiveStatementContext {
		var _localctx : ReceiveStatementContext = ReceiveStatementContext(context, state)
		enterRule(_localctx, 830, Rules.RULE_receiveStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4849
			match(RECEIVE) as Token
			this.state = 4852
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,714,context) ) {
			1 -> {if (true){
			this.state = 4850
			receiveFromStatement()
			}}
			2 -> {if (true){
			this.state = 4851
			receiveIntoStatement()
			}}
			}
			this.state = 4855
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,715,context) ) {
			1   -> if (true){
			this.state = 4854
			onExceptionClause()
			}
			}
			this.state = 4858
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,716,context) ) {
			1   -> if (true){
			this.state = 4857
			notOnExceptionClause()
			}
			}
			this.state = 4861
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,717,context) ) {
			1   -> if (true){
			this.state = 4860
			match(END_RECEIVE) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReceiveFromStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_receiveFromStatement.id
	        set(value) { throw RuntimeException() }
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun findReceiveFrom() : ReceiveFromContext? = getRuleContext(solver.getType("ReceiveFromContext"),0)
		fun findReceiveBefore() : List<ReceiveBeforeContext> = getRuleContexts(solver.getType("ReceiveBeforeContext"))
		fun findReceiveBefore(i: Int) : ReceiveBeforeContext? = getRuleContext(solver.getType("ReceiveBeforeContext"),i)
		fun findReceiveWith() : List<ReceiveWithContext> = getRuleContexts(solver.getType("ReceiveWithContext"))
		fun findReceiveWith(i: Int) : ReceiveWithContext? = getRuleContext(solver.getType("ReceiveWithContext"),i)
		fun findReceiveThread() : List<ReceiveThreadContext> = getRuleContexts(solver.getType("ReceiveThreadContext"))
		fun findReceiveThread(i: Int) : ReceiveThreadContext? = getRuleContext(solver.getType("ReceiveThreadContext"),i)
		fun findReceiveSize() : List<ReceiveSizeContext> = getRuleContexts(solver.getType("ReceiveSizeContext"))
		fun findReceiveSize(i: Int) : ReceiveSizeContext? = getRuleContext(solver.getType("ReceiveSizeContext"),i)
		fun findReceiveStatus() : List<ReceiveStatusContext> = getRuleContexts(solver.getType("ReceiveStatusContext"))
		fun findReceiveStatus(i: Int) : ReceiveStatusContext? = getRuleContext(solver.getType("ReceiveStatusContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReceiveFromStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReceiveFromStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReceiveFromStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  receiveFromStatement() : ReceiveFromStatementContext {
		var _localctx : ReceiveFromStatementContext = ReceiveFromStatementContext(context, state)
		enterRule(_localctx, 832, Rules.RULE_receiveFromStatement.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4863
			dataName()
			this.state = 4864
			match(FROM) as Token
			this.state = 4865
			receiveFrom()
			this.state = 4873
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,719,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					this.state = 4871
					errorHandler.sync(this)
					when (_input!!.LA(1)) {
					BEFORE  ->  /*LL1AltBlock*/{if (true){
					this.state = 4866
					receiveBefore()
					}}
					NO , WITH  ->  /*LL1AltBlock*/{if (true){
					this.state = 4867
					receiveWith()
					}}
					THREAD  ->  /*LL1AltBlock*/{if (true){
					this.state = 4868
					receiveThread()
					}}
					SIZE  ->  /*LL1AltBlock*/{if (true){
					this.state = 4869
					receiveSize()
					}}
					STATUS  ->  /*LL1AltBlock*/{if (true){
					this.state = 4870
					receiveStatus()
					}}
					else -> throw NoViableAltException(this)
					}
					} 
				}
				this.state = 4875
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,719,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReceiveFromContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_receiveFrom.id
	        set(value) { throw RuntimeException() }
		fun THREAD() : TerminalNode? = getToken(Cobol85Parser.Tokens.THREAD.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun LAST() : TerminalNode? = getToken(Cobol85Parser.Tokens.LAST.id, 0)
		fun ANY() : TerminalNode? = getToken(Cobol85Parser.Tokens.ANY.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReceiveFrom(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReceiveFrom(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReceiveFrom(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  receiveFrom() : ReceiveFromContext {
		var _localctx : ReceiveFromContext = ReceiveFromContext(context, state)
		enterRule(_localctx, 834, Rules.RULE_receiveFrom.id)
		try {
			this.state = 4882
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			THREAD  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4876
			match(THREAD) as Token
			this.state = 4877
			dataName()
			}}
			LAST  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 4878
			match(LAST) as Token
			this.state = 4879
			match(THREAD) as Token
			}}
			ANY  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 4880
			match(ANY) as Token
			this.state = 4881
			match(THREAD) as Token
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReceiveIntoStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_receiveIntoStatement.id
	        set(value) { throw RuntimeException() }
		fun findCdName() : CdNameContext? = getRuleContext(solver.getType("CdNameContext"),0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun MESSAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.MESSAGE.id, 0)
		fun SEGMENT() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEGMENT.id, 0)
		fun INTO() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTO.id, 0)
		fun findReceiveNoData() : ReceiveNoDataContext? = getRuleContext(solver.getType("ReceiveNoDataContext"),0)
		fun findReceiveWithData() : ReceiveWithDataContext? = getRuleContext(solver.getType("ReceiveWithDataContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReceiveIntoStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReceiveIntoStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReceiveIntoStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  receiveIntoStatement() : ReceiveIntoStatementContext {
		var _localctx : ReceiveIntoStatementContext = ReceiveIntoStatementContext(context, state)
		enterRule(_localctx, 836, Rules.RULE_receiveIntoStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4884
			cdName()
			this.state = 4885
			_la = _input!!.LA(1)
			if ( !(_la==MESSAGE || _la==SEGMENT) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 4887
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==INTO) {
				if (true){
				this.state = 4886
				match(INTO) as Token
				}
			}

			this.state = 4889
			identifier()
			this.state = 4891
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==NO) {
				if (true){
				this.state = 4890
				receiveNoData()
				}
			}

			this.state = 4894
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,723,context) ) {
			1   -> if (true){
			this.state = 4893
			receiveWithData()
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReceiveNoDataContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_receiveNoData.id
	        set(value) { throw RuntimeException() }
		fun NO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO.id, 0)
		fun DATA() : TerminalNode? = getToken(Cobol85Parser.Tokens.DATA.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReceiveNoData(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReceiveNoData(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReceiveNoData(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  receiveNoData() : ReceiveNoDataContext {
		var _localctx : ReceiveNoDataContext = ReceiveNoDataContext(context, state)
		enterRule(_localctx, 838, Rules.RULE_receiveNoData.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4896
			match(NO) as Token
			this.state = 4897
			match(DATA) as Token
			this.state = 4901
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,724,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 4898
					statement()
					}
					} 
				}
				this.state = 4903
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,724,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReceiveWithDataContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_receiveWithData.id
	        set(value) { throw RuntimeException() }
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		fun DATA() : TerminalNode? = getToken(Cobol85Parser.Tokens.DATA.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReceiveWithData(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReceiveWithData(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReceiveWithData(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  receiveWithData() : ReceiveWithDataContext {
		var _localctx : ReceiveWithDataContext = ReceiveWithDataContext(context, state)
		enterRule(_localctx, 840, Rules.RULE_receiveWithData.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4904
			match(WITH) as Token
			this.state = 4905
			match(DATA) as Token
			this.state = 4909
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,725,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 4906
					statement()
					}
					} 
				}
				this.state = 4911
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,725,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReceiveBeforeContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_receiveBefore.id
	        set(value) { throw RuntimeException() }
		fun BEFORE() : TerminalNode? = getToken(Cobol85Parser.Tokens.BEFORE.id, 0)
		fun findNumericLiteral() : NumericLiteralContext? = getRuleContext(solver.getType("NumericLiteralContext"),0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun TIME() : TerminalNode? = getToken(Cobol85Parser.Tokens.TIME.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReceiveBefore(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReceiveBefore(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReceiveBefore(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  receiveBefore() : ReceiveBeforeContext {
		var _localctx : ReceiveBeforeContext = ReceiveBeforeContext(context, state)
		enterRule(_localctx, 842, Rules.RULE_receiveBefore.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4912
			match(BEFORE) as Token
			this.state = 4914
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,726,context) ) {
			1   -> if (true){
			this.state = 4913
			match(TIME) as Token
			}
			}
			this.state = 4918
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,727,context) ) {
			1 -> {if (true){
			this.state = 4916
			numericLiteral()
			}}
			2 -> {if (true){
			this.state = 4917
			identifier()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReceiveWithContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_receiveWith.id
	        set(value) { throw RuntimeException() }
		fun NO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO.id, 0)
		fun WAIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.WAIT.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReceiveWith(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReceiveWith(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReceiveWith(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  receiveWith() : ReceiveWithContext {
		var _localctx : ReceiveWithContext = ReceiveWithContext(context, state)
		enterRule(_localctx, 844, Rules.RULE_receiveWith.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4921
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 4920
				match(WITH) as Token
				}
			}

			this.state = 4923
			match(NO) as Token
			this.state = 4924
			match(WAIT) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReceiveThreadContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_receiveThread.id
	        set(value) { throw RuntimeException() }
		fun THREAD() : TerminalNode? = getToken(Cobol85Parser.Tokens.THREAD.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReceiveThread(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReceiveThread(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReceiveThread(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  receiveThread() : ReceiveThreadContext {
		var _localctx : ReceiveThreadContext = ReceiveThreadContext(context, state)
		enterRule(_localctx, 846, Rules.RULE_receiveThread.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4926
			match(THREAD) as Token
			this.state = 4928
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IN) {
				if (true){
				this.state = 4927
				match(IN) as Token
				}
			}

			this.state = 4930
			dataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReceiveSizeContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_receiveSize.id
	        set(value) { throw RuntimeException() }
		fun SIZE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIZE.id, 0)
		fun findNumericLiteral() : NumericLiteralContext? = getRuleContext(solver.getType("NumericLiteralContext"),0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReceiveSize(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReceiveSize(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReceiveSize(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  receiveSize() : ReceiveSizeContext {
		var _localctx : ReceiveSizeContext = ReceiveSizeContext(context, state)
		enterRule(_localctx, 848, Rules.RULE_receiveSize.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4932
			match(SIZE) as Token
			this.state = 4934
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IN) {
				if (true){
				this.state = 4933
				match(IN) as Token
				}
			}

			this.state = 4938
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,731,context) ) {
			1 -> {if (true){
			this.state = 4936
			numericLiteral()
			}}
			2 -> {if (true){
			this.state = 4937
			identifier()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReceiveStatusContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_receiveStatus.id
	        set(value) { throw RuntimeException() }
		fun STATUS() : TerminalNode? = getToken(Cobol85Parser.Tokens.STATUS.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReceiveStatus(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReceiveStatus(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReceiveStatus(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  receiveStatus() : ReceiveStatusContext {
		var _localctx : ReceiveStatusContext = ReceiveStatusContext(context, state)
		enterRule(_localctx, 850, Rules.RULE_receiveStatus.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4940
			match(STATUS) as Token
			this.state = 4942
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IN) {
				if (true){
				this.state = 4941
				match(IN) as Token
				}
			}

			if (true){
			this.state = 4944
			identifier()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReleaseStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_releaseStatement.id
	        set(value) { throw RuntimeException() }
		fun RELEASE() : TerminalNode? = getToken(Cobol85Parser.Tokens.RELEASE.id, 0)
		fun findRecordName() : RecordNameContext? = getRuleContext(solver.getType("RecordNameContext"),0)
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReleaseStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReleaseStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReleaseStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  releaseStatement() : ReleaseStatementContext {
		var _localctx : ReleaseStatementContext = ReleaseStatementContext(context, state)
		enterRule(_localctx, 852, Rules.RULE_releaseStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4946
			match(RELEASE) as Token
			this.state = 4947
			recordName()
			this.state = 4950
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FROM) {
				if (true){
				this.state = 4948
				match(FROM) as Token
				this.state = 4949
				qualifiedDataName()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReturnStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_returnStatement.id
	        set(value) { throw RuntimeException() }
		fun RETURN() : TerminalNode? = getToken(Cobol85Parser.Tokens.RETURN.id, 0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun findAtEndPhrase() : AtEndPhraseContext? = getRuleContext(solver.getType("AtEndPhraseContext"),0)
		fun RECORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECORD.id, 0)
		fun findReturnInto() : ReturnIntoContext? = getRuleContext(solver.getType("ReturnIntoContext"),0)
		fun findNotAtEndPhrase() : NotAtEndPhraseContext? = getRuleContext(solver.getType("NotAtEndPhraseContext"),0)
		fun END_RETURN() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_RETURN.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReturnStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReturnStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReturnStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  returnStatement() : ReturnStatementContext {
		var _localctx : ReturnStatementContext = ReturnStatementContext(context, state)
		enterRule(_localctx, 854, Rules.RULE_returnStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4952
			match(RETURN) as Token
			this.state = 4953
			fileName()
			this.state = 4955
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==RECORD) {
				if (true){
				this.state = 4954
				match(RECORD) as Token
				}
			}

			this.state = 4958
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==INTO) {
				if (true){
				this.state = 4957
				returnInto()
				}
			}

			this.state = 4960
			atEndPhrase()
			this.state = 4962
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,736,context) ) {
			1   -> if (true){
			this.state = 4961
			notAtEndPhrase()
			}
			}
			this.state = 4965
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,737,context) ) {
			1   -> if (true){
			this.state = 4964
			match(END_RETURN) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReturnIntoContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_returnInto.id
	        set(value) { throw RuntimeException() }
		fun INTO() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTO.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReturnInto(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReturnInto(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReturnInto(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  returnInto() : ReturnIntoContext {
		var _localctx : ReturnIntoContext = ReturnIntoContext(context, state)
		enterRule(_localctx, 856, Rules.RULE_returnInto.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4967
			match(INTO) as Token
			this.state = 4968
			qualifiedDataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RewriteStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_rewriteStatement.id
	        set(value) { throw RuntimeException() }
		fun REWRITE() : TerminalNode? = getToken(Cobol85Parser.Tokens.REWRITE.id, 0)
		fun findRecordName() : RecordNameContext? = getRuleContext(solver.getType("RecordNameContext"),0)
		fun findRewriteFrom() : RewriteFromContext? = getRuleContext(solver.getType("RewriteFromContext"),0)
		fun findInvalidKeyPhrase() : InvalidKeyPhraseContext? = getRuleContext(solver.getType("InvalidKeyPhraseContext"),0)
		fun findNotInvalidKeyPhrase() : NotInvalidKeyPhraseContext? = getRuleContext(solver.getType("NotInvalidKeyPhraseContext"),0)
		fun END_REWRITE() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_REWRITE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRewriteStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRewriteStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRewriteStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  rewriteStatement() : RewriteStatementContext {
		var _localctx : RewriteStatementContext = RewriteStatementContext(context, state)
		enterRule(_localctx, 858, Rules.RULE_rewriteStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4970
			match(REWRITE) as Token
			this.state = 4971
			recordName()
			this.state = 4973
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FROM) {
				if (true){
				this.state = 4972
				rewriteFrom()
				}
			}

			this.state = 4976
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,739,context) ) {
			1   -> if (true){
			this.state = 4975
			invalidKeyPhrase()
			}
			}
			this.state = 4979
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,740,context) ) {
			1   -> if (true){
			this.state = 4978
			notInvalidKeyPhrase()
			}
			}
			this.state = 4982
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,741,context) ) {
			1   -> if (true){
			this.state = 4981
			match(END_REWRITE) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RewriteFromContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_rewriteFrom.id
	        set(value) { throw RuntimeException() }
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRewriteFrom(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRewriteFrom(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRewriteFrom(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  rewriteFrom() : RewriteFromContext {
		var _localctx : RewriteFromContext = RewriteFromContext(context, state)
		enterRule(_localctx, 860, Rules.RULE_rewriteFrom.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4984
			match(FROM) as Token
			this.state = 4985
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SearchStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_searchStatement.id
	        set(value) { throw RuntimeException() }
		fun SEARCH() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEARCH.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun ALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALL.id, 0)
		fun findSearchVarying() : SearchVaryingContext? = getRuleContext(solver.getType("SearchVaryingContext"),0)
		fun findAtEndPhrase() : AtEndPhraseContext? = getRuleContext(solver.getType("AtEndPhraseContext"),0)
		fun findSearchWhen() : List<SearchWhenContext> = getRuleContexts(solver.getType("SearchWhenContext"))
		fun findSearchWhen(i: Int) : SearchWhenContext? = getRuleContext(solver.getType("SearchWhenContext"),i)
		fun END_SEARCH() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_SEARCH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSearchStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSearchStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSearchStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  searchStatement() : SearchStatementContext {
		var _localctx : SearchStatementContext = SearchStatementContext(context, state)
		enterRule(_localctx, 862, Rules.RULE_searchStatement.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 4987
			match(SEARCH) as Token
			this.state = 4989
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ALL) {
				if (true){
				this.state = 4988
				match(ALL) as Token
				}
			}

			this.state = 4991
			qualifiedDataName()
			this.state = 4993
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==VARYING) {
				if (true){
				this.state = 4992
				searchVarying()
				}
			}

			this.state = 4996
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==AT || _la==END) {
				if (true){
				this.state = 4995
				atEndPhrase()
				}
			}

			this.state = 4999 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 4998
				searchWhen()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 5001 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,745,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			this.state = 5004
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,746,context) ) {
			1   -> if (true){
			this.state = 5003
			match(END_SEARCH) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SearchVaryingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_searchVarying.id
	        set(value) { throw RuntimeException() }
		fun VARYING() : TerminalNode? = getToken(Cobol85Parser.Tokens.VARYING.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSearchVarying(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSearchVarying(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSearchVarying(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  searchVarying() : SearchVaryingContext {
		var _localctx : SearchVaryingContext = SearchVaryingContext(context, state)
		enterRule(_localctx, 864, Rules.RULE_searchVarying.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5006
			match(VARYING) as Token
			this.state = 5007
			qualifiedDataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SearchWhenContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_searchWhen.id
	        set(value) { throw RuntimeException() }
		fun WHEN() : TerminalNode? = getToken(Cobol85Parser.Tokens.WHEN.id, 0)
		fun findCondition() : ConditionContext? = getRuleContext(solver.getType("ConditionContext"),0)
		fun NEXT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NEXT.id, 0)
		fun SENTENCE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SENTENCE.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSearchWhen(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSearchWhen(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSearchWhen(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  searchWhen() : SearchWhenContext {
		var _localctx : SearchWhenContext = SearchWhenContext(context, state)
		enterRule(_localctx, 866, Rules.RULE_searchWhen.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5009
			match(WHEN) as Token
			this.state = 5010
			condition()
			this.state = 5019
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			NEXT  ->  /*LL1AltBlock*/{if (true){
			this.state = 5011
			match(NEXT) as Token
			this.state = 5012
			match(SENTENCE) as Token
			}}
			ACCEPT , ADD , ALTER , AT , CALL , CANCEL , CLOSE , COMPUTE , CONTINUE , DELETE , DISABLE , DISPLAY , DIVIDE , ELSE , ENABLE , END , END_ACCEPT , END_ADD , END_CALL , END_COMPUTE , END_DELETE , END_DIVIDE , END_EVALUATE , END_IF , END_MULTIPLY , END_PERFORM , END_READ , END_RECEIVE , END_RETURN , END_REWRITE , END_SEARCH , END_START , END_STRING , END_SUBTRACT , END_UNSTRING , END_WRITE , ENTRY , EVALUATE , EXCEPTION , EXHIBIT , EXIT , GENERATE , GOBACK , GO , IF , INITIALIZE , INITIATE , INSPECT , INVALID , MERGE , MOVE , MULTIPLY , NOT , ON , OPEN , PERFORM , PURGE , READ , RECEIVE , RELEASE , RETURN , REWRITE , SEARCH , SEND , SET , SORT , START , STOP , STRING , SUBTRACT , TERMINATE , UNSTRING , WHEN , WITH , WRITE , DOT_FS , EXECCICSLINE , EXECSQLIMSLINE , EXECSQLLINE  ->  /*LL1AltBlock*/{if (true){
			this.state = 5016
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,747,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5013
					statement()
					}
					} 
				}
				this.state = 5018
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,747,context)
			}
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SendStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sendStatement.id
	        set(value) { throw RuntimeException() }
		fun SEND() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEND.id, 0)
		fun findSendStatementSync() : SendStatementSyncContext? = getRuleContext(solver.getType("SendStatementSyncContext"),0)
		fun findSendStatementAsync() : SendStatementAsyncContext? = getRuleContext(solver.getType("SendStatementAsyncContext"),0)
		fun findOnExceptionClause() : OnExceptionClauseContext? = getRuleContext(solver.getType("OnExceptionClauseContext"),0)
		fun findNotOnExceptionClause() : NotOnExceptionClauseContext? = getRuleContext(solver.getType("NotOnExceptionClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSendStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSendStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSendStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sendStatement() : SendStatementContext {
		var _localctx : SendStatementContext = SendStatementContext(context, state)
		enterRule(_localctx, 868, Rules.RULE_sendStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5021
			match(SEND) as Token
			this.state = 5024
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ABORT , ADDRESS , ALL , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DATE , DAY , DAY_OF_WEEK , DEBUG_CONTENTS , DEBUG_ITEM , DEBUG_LINE , DEBUG_NAME , DEBUG_SUB_1 , DEBUG_SUB_2 , DEBUG_SUB_3 , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FALSE , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTION , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , HIGH_VALUE , HIGH_VALUES , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LINAGE_COUNTER , LINE_COUNTER , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , LOW_VALUE , LOW_VALUES , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NULL , NULLS , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PAGE_COUNTER , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , QUOTE , QUOTES , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , RETURN_CODE , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHIFT_IN , SHIFT_OUT , SHORT_DATE , SORT_CONTROL , SORT_CORE_SIZE , SORT_FILE_SIZE , SORT_MESSAGE , SORT_MODE_SIZE , SORT_RETURN , SPACE , SPACES , SYMBOL , TALLY , TASK , THREAD , THREAD_LOCAL , TIME , TIMER , TODAYS_DATE , TODAYS_NAME , TRUE , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , WHEN_COMPILED , YEAR , YYYYMMDD , YYYYDDD , ZERO , ZERO_FILL , ZEROS , ZEROES , NONNUMERICLITERAL , LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL , NUMERICLITERAL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 5022
			sendStatementSync()
			}}
			TO  ->  /*LL1AltBlock*/{if (true){
			this.state = 5023
			sendStatementAsync()
			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 5027
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,750,context) ) {
			1   -> if (true){
			this.state = 5026
			onExceptionClause()
			}
			}
			this.state = 5030
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,751,context) ) {
			1   -> if (true){
			this.state = 5029
			notOnExceptionClause()
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SendStatementSyncContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sendStatementSync.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findSendFromPhrase() : SendFromPhraseContext? = getRuleContext(solver.getType("SendFromPhraseContext"),0)
		fun findSendWithPhrase() : SendWithPhraseContext? = getRuleContext(solver.getType("SendWithPhraseContext"),0)
		fun findSendReplacingPhrase() : SendReplacingPhraseContext? = getRuleContext(solver.getType("SendReplacingPhraseContext"),0)
		fun findSendAdvancingPhrase() : SendAdvancingPhraseContext? = getRuleContext(solver.getType("SendAdvancingPhraseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSendStatementSync(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSendStatementSync(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSendStatementSync(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sendStatementSync() : SendStatementSyncContext {
		var _localctx : SendStatementSyncContext = SendStatementSyncContext(context, state)
		enterRule(_localctx, 870, Rules.RULE_sendStatementSync.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5034
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,752,context) ) {
			1 -> {if (true){
			this.state = 5032
			identifier()
			}}
			2 -> {if (true){
			this.state = 5033
			literal()
			}}
			}
			this.state = 5037
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FROM) {
				if (true){
				this.state = 5036
				sendFromPhrase()
				}
			}

			this.state = 5040
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,754,context) ) {
			1   -> if (true){
			this.state = 5039
			sendWithPhrase()
			}
			}
			this.state = 5043
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==REPLACING) {
				if (true){
				this.state = 5042
				sendReplacingPhrase()
				}
			}

			this.state = 5046
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==AFTER || _la==BEFORE) {
				if (true){
				this.state = 5045
				sendAdvancingPhrase()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SendStatementAsyncContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sendStatementAsync.id
	        set(value) { throw RuntimeException() }
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun TOP() : TerminalNode? = getToken(Cobol85Parser.Tokens.TOP.id, 0)
		fun BOTTOM() : TerminalNode? = getToken(Cobol85Parser.Tokens.BOTTOM.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSendStatementAsync(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSendStatementAsync(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSendStatementAsync(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sendStatementAsync() : SendStatementAsyncContext {
		var _localctx : SendStatementAsyncContext = SendStatementAsyncContext(context, state)
		enterRule(_localctx, 872, Rules.RULE_sendStatementAsync.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5048
			match(TO) as Token
			this.state = 5049
			_la = _input!!.LA(1)
			if ( !(_la==BOTTOM || _la==TOP) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5050
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SendFromPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sendFromPhrase.id
	        set(value) { throw RuntimeException() }
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSendFromPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSendFromPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSendFromPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sendFromPhrase() : SendFromPhraseContext {
		var _localctx : SendFromPhraseContext = SendFromPhraseContext(context, state)
		enterRule(_localctx, 874, Rules.RULE_sendFromPhrase.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5052
			match(FROM) as Token
			this.state = 5053
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SendWithPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sendWithPhrase.id
	        set(value) { throw RuntimeException() }
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		fun EGI() : TerminalNode? = getToken(Cobol85Parser.Tokens.EGI.id, 0)
		fun EMI() : TerminalNode? = getToken(Cobol85Parser.Tokens.EMI.id, 0)
		fun ESI() : TerminalNode? = getToken(Cobol85Parser.Tokens.ESI.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSendWithPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSendWithPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSendWithPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sendWithPhrase() : SendWithPhraseContext {
		var _localctx : SendWithPhraseContext = SendWithPhraseContext(context, state)
		enterRule(_localctx, 876, Rules.RULE_sendWithPhrase.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5055
			match(WITH) as Token
			this.state = 5060
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			EGI  ->  /*LL1AltBlock*/{if (true){
			this.state = 5056
			match(EGI) as Token
			}}
			EMI  ->  /*LL1AltBlock*/{if (true){
			this.state = 5057
			match(EMI) as Token
			}}
			ESI  ->  /*LL1AltBlock*/{if (true){
			this.state = 5058
			match(ESI) as Token
			}}
			ABORT , ADDRESS , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DATE , DAY , DAY_OF_WEEK , DEBUG_CONTENTS , DEBUG_ITEM , DEBUG_LINE , DEBUG_NAME , DEBUG_SUB_1 , DEBUG_SUB_2 , DEBUG_SUB_3 , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTION , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LINAGE_COUNTER , LINE_COUNTER , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PAGE_COUNTER , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , RETURN_CODE , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHIFT_IN , SHIFT_OUT , SHORT_DATE , SORT_CONTROL , SORT_CORE_SIZE , SORT_FILE_SIZE , SORT_MESSAGE , SORT_MODE_SIZE , SORT_RETURN , SYMBOL , TALLY , TASK , THREAD , THREAD_LOCAL , TIME , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , WHEN_COMPILED , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 5059
			identifier()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SendReplacingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sendReplacingPhrase.id
	        set(value) { throw RuntimeException() }
		fun REPLACING() : TerminalNode? = getToken(Cobol85Parser.Tokens.REPLACING.id, 0)
		fun LINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSendReplacingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSendReplacingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSendReplacingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sendReplacingPhrase() : SendReplacingPhraseContext {
		var _localctx : SendReplacingPhraseContext = SendReplacingPhraseContext(context, state)
		enterRule(_localctx, 878, Rules.RULE_sendReplacingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5062
			match(REPLACING) as Token
			this.state = 5064
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LINE) {
				if (true){
				this.state = 5063
				match(LINE) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SendAdvancingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sendAdvancingPhrase.id
	        set(value) { throw RuntimeException() }
		fun BEFORE() : TerminalNode? = getToken(Cobol85Parser.Tokens.BEFORE.id, 0)
		fun AFTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.AFTER.id, 0)
		fun findSendAdvancingPage() : SendAdvancingPageContext? = getRuleContext(solver.getType("SendAdvancingPageContext"),0)
		fun findSendAdvancingLines() : SendAdvancingLinesContext? = getRuleContext(solver.getType("SendAdvancingLinesContext"),0)
		fun findSendAdvancingMnemonic() : SendAdvancingMnemonicContext? = getRuleContext(solver.getType("SendAdvancingMnemonicContext"),0)
		fun ADVANCING() : TerminalNode? = getToken(Cobol85Parser.Tokens.ADVANCING.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSendAdvancingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSendAdvancingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSendAdvancingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sendAdvancingPhrase() : SendAdvancingPhraseContext {
		var _localctx : SendAdvancingPhraseContext = SendAdvancingPhraseContext(context, state)
		enterRule(_localctx, 880, Rules.RULE_sendAdvancingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5066
			_la = _input!!.LA(1)
			if ( !(_la==AFTER || _la==BEFORE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5068
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ADVANCING) {
				if (true){
				this.state = 5067
				match(ADVANCING) as Token
				}
			}

			this.state = 5073
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,760,context) ) {
			1 -> {if (true){
			this.state = 5070
			sendAdvancingPage()
			}}
			2 -> {if (true){
			this.state = 5071
			sendAdvancingLines()
			}}
			3 -> {if (true){
			this.state = 5072
			sendAdvancingMnemonic()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SendAdvancingPageContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sendAdvancingPage.id
	        set(value) { throw RuntimeException() }
		fun PAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PAGE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSendAdvancingPage(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSendAdvancingPage(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSendAdvancingPage(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sendAdvancingPage() : SendAdvancingPageContext {
		var _localctx : SendAdvancingPageContext = SendAdvancingPageContext(context, state)
		enterRule(_localctx, 882, Rules.RULE_sendAdvancingPage.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5075
			match(PAGE) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SendAdvancingLinesContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sendAdvancingLines.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun LINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINE.id, 0)
		fun LINES() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINES.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSendAdvancingLines(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSendAdvancingLines(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSendAdvancingLines(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sendAdvancingLines() : SendAdvancingLinesContext {
		var _localctx : SendAdvancingLinesContext = SendAdvancingLinesContext(context, state)
		enterRule(_localctx, 884, Rules.RULE_sendAdvancingLines.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5079
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,761,context) ) {
			1 -> {if (true){
			this.state = 5077
			identifier()
			}}
			2 -> {if (true){
			this.state = 5078
			literal()
			}}
			}
			this.state = 5082
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LINE || _la==LINES) {
				if (true){
				this.state = 5081
				_la = _input!!.LA(1)
				if ( !(_la==LINE || _la==LINES) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SendAdvancingMnemonicContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sendAdvancingMnemonic.id
	        set(value) { throw RuntimeException() }
		fun findMnemonicName() : MnemonicNameContext? = getRuleContext(solver.getType("MnemonicNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSendAdvancingMnemonic(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSendAdvancingMnemonic(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSendAdvancingMnemonic(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sendAdvancingMnemonic() : SendAdvancingMnemonicContext {
		var _localctx : SendAdvancingMnemonicContext = SendAdvancingMnemonicContext(context, state)
		enterRule(_localctx, 886, Rules.RULE_sendAdvancingMnemonic.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5084
			mnemonicName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SetStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_setStatement.id
	        set(value) { throw RuntimeException() }
		fun SET() : TerminalNode? = getToken(Cobol85Parser.Tokens.SET.id, 0)
		fun findSetUpDownByStatement() : SetUpDownByStatementContext? = getRuleContext(solver.getType("SetUpDownByStatementContext"),0)
		fun findSetToStatement() : List<SetToStatementContext> = getRuleContexts(solver.getType("SetToStatementContext"))
		fun findSetToStatement(i: Int) : SetToStatementContext? = getRuleContext(solver.getType("SetToStatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSetStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSetStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSetStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  setStatement() : SetStatementContext {
		var _localctx : SetStatementContext = SetStatementContext(context, state)
		enterRule(_localctx, 888, Rules.RULE_setStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5086
			match(SET) as Token
			this.state = 5093
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,764,context) ) {
			1 -> {if (true){
			this.state = 5088 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5087
				setToStatement()
				}
				}
				this.state = 5090 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}}
			2 -> {if (true){
			this.state = 5092
			setUpDownByStatement()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SetToStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_setToStatement.id
	        set(value) { throw RuntimeException() }
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun findSetTo() : List<SetToContext> = getRuleContexts(solver.getType("SetToContext"))
		fun findSetTo(i: Int) : SetToContext? = getRuleContext(solver.getType("SetToContext"),i)
		fun findSetToValue() : List<SetToValueContext> = getRuleContexts(solver.getType("SetToValueContext"))
		fun findSetToValue(i: Int) : SetToValueContext? = getRuleContext(solver.getType("SetToValueContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSetToStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSetToStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSetToStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  setToStatement() : SetToStatementContext {
		var _localctx : SetToStatementContext = SetToStatementContext(context, state)
		enterRule(_localctx, 890, Rules.RULE_setToStatement.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5096 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5095
				setTo()
				}
				}
				this.state = 5098 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			this.state = 5100
			match(TO) as Token
			this.state = 5102 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 5101
				setToValue()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 5104 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,766,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SetUpDownByStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_setUpDownByStatement.id
	        set(value) { throw RuntimeException() }
		fun findSetByValue() : SetByValueContext? = getRuleContext(solver.getType("SetByValueContext"),0)
		fun UP() : TerminalNode? = getToken(Cobol85Parser.Tokens.UP.id, 0)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun DOWN() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOWN.id, 0)
		fun findSetTo() : List<SetToContext> = getRuleContexts(solver.getType("SetToContext"))
		fun findSetTo(i: Int) : SetToContext? = getRuleContext(solver.getType("SetToContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSetUpDownByStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSetUpDownByStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSetUpDownByStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  setUpDownByStatement() : SetUpDownByStatementContext {
		var _localctx : SetUpDownByStatementContext = SetUpDownByStatementContext(context, state)
		enterRule(_localctx, 892, Rules.RULE_setUpDownByStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5107 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5106
				setTo()
				}
				}
				this.state = 5109 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			this.state = 5115
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			UP  ->  /*LL1AltBlock*/{if (true){
			this.state = 5111
			match(UP) as Token
			this.state = 5112
			match(BY) as Token
			}}
			DOWN  ->  /*LL1AltBlock*/{if (true){
			this.state = 5113
			match(DOWN) as Token
			this.state = 5114
			match(BY) as Token
			}}
			else -> throw NoViableAltException(this)
			}
			this.state = 5117
			setByValue()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SetToContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_setTo.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSetTo(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSetTo(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSetTo(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  setTo() : SetToContext {
		var _localctx : SetToContext = SetToContext(context, state)
		enterRule(_localctx, 894, Rules.RULE_setTo.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5119
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SetToValueContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_setToValue.id
	        set(value) { throw RuntimeException() }
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun OFF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OFF.id, 0)
		fun ENTRY() : TerminalNode? = getToken(Cobol85Parser.Tokens.ENTRY.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSetToValue(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSetToValue(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSetToValue(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  setToValue() : SetToValueContext {
		var _localctx : SetToValueContext = SetToValueContext(context, state)
		enterRule(_localctx, 896, Rules.RULE_setToValue.id)
		try {
			this.state = 5130
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,770,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5121
			match(ON) as Token
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 5122
			match(OFF) as Token
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 5123
			match(ENTRY) as Token
			this.state = 5126
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,769,context) ) {
			1 -> {if (true){
			this.state = 5124
			identifier()
			}}
			2 -> {if (true){
			this.state = 5125
			literal()
			}}
			}
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 5128
			identifier()
			}}
			5 -> {
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 5129
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SetByValueContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_setByValue.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSetByValue(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSetByValue(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSetByValue(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  setByValue() : SetByValueContext {
		var _localctx : SetByValueContext = SetByValueContext(context, state)
		enterRule(_localctx, 898, Rules.RULE_setByValue.id)
		try {
			this.state = 5134
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,771,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5132
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 5133
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortStatement.id
	        set(value) { throw RuntimeException() }
		fun SORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.SORT.id, 0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun findSortOnKeyClause() : List<SortOnKeyClauseContext> = getRuleContexts(solver.getType("SortOnKeyClauseContext"))
		fun findSortOnKeyClause(i: Int) : SortOnKeyClauseContext? = getRuleContext(solver.getType("SortOnKeyClauseContext"),i)
		fun findSortDuplicatesPhrase() : SortDuplicatesPhraseContext? = getRuleContext(solver.getType("SortDuplicatesPhraseContext"),0)
		fun findSortCollatingSequencePhrase() : SortCollatingSequencePhraseContext? = getRuleContext(solver.getType("SortCollatingSequencePhraseContext"),0)
		fun findSortInputProcedurePhrase() : SortInputProcedurePhraseContext? = getRuleContext(solver.getType("SortInputProcedurePhraseContext"),0)
		fun findSortUsing() : List<SortUsingContext> = getRuleContexts(solver.getType("SortUsingContext"))
		fun findSortUsing(i: Int) : SortUsingContext? = getRuleContext(solver.getType("SortUsingContext"),i)
		fun findSortOutputProcedurePhrase() : SortOutputProcedurePhraseContext? = getRuleContext(solver.getType("SortOutputProcedurePhraseContext"),0)
		fun findSortGivingPhrase() : List<SortGivingPhraseContext> = getRuleContexts(solver.getType("SortGivingPhraseContext"))
		fun findSortGivingPhrase(i: Int) : SortGivingPhraseContext? = getRuleContext(solver.getType("SortGivingPhraseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortStatement() : SortStatementContext {
		var _localctx : SortStatementContext = SortStatementContext(context, state)
		enterRule(_localctx, 900, Rules.RULE_sortStatement.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5136
			match(SORT) as Token
			this.state = 5137
			fileName()
			this.state = 5139 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 5138
				sortOnKeyClause()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 5141 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,772,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			this.state = 5144
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,773,context) ) {
			1   -> if (true){
			this.state = 5143
			sortDuplicatesPhrase()
			}
			}
			this.state = 5147
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COLLATING || _la==SEQUENCE) {
				if (true){
				this.state = 5146
				sortCollatingSequencePhrase()
				}
			}

			this.state = 5150
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==INPUT) {
				if (true){
				this.state = 5149
				sortInputProcedurePhrase()
				}
			}

			this.state = 5155
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==USING) {
				if (true){
				if (true){
				this.state = 5152
				sortUsing()
				}
				}
				this.state = 5157
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 5159
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OUTPUT) {
				if (true){
				this.state = 5158
				sortOutputProcedurePhrase()
				}
			}

			this.state = 5164
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==GIVING) {
				if (true){
				if (true){
				this.state = 5161
				sortGivingPhrase()
				}
				}
				this.state = 5166
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortOnKeyClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortOnKeyClause.id
	        set(value) { throw RuntimeException() }
		fun ASCENDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.ASCENDING.id, 0)
		fun DESCENDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.DESCENDING.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun findQualifiedDataName() : List<QualifiedDataNameContext> = getRuleContexts(solver.getType("QualifiedDataNameContext"))
		fun findQualifiedDataName(i: Int) : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortOnKeyClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortOnKeyClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortOnKeyClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortOnKeyClause() : SortOnKeyClauseContext {
		var _localctx : SortOnKeyClauseContext = SortOnKeyClauseContext(context, state)
		enterRule(_localctx, 902, Rules.RULE_sortOnKeyClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5168
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 5167
				match(ON) as Token
				}
			}

			this.state = 5170
			_la = _input!!.LA(1)
			if ( !(_la==ASCENDING || _la==DESCENDING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5172
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==KEY) {
				if (true){
				this.state = 5171
				match(KEY) as Token
				}
			}

			this.state = 5175 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5174
				qualifiedDataName()
				}
				}
				this.state = 5177 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortDuplicatesPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortDuplicatesPhrase.id
	        set(value) { throw RuntimeException() }
		fun DUPLICATES() : TerminalNode? = getToken(Cobol85Parser.Tokens.DUPLICATES.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		fun ORDER() : TerminalNode? = getToken(Cobol85Parser.Tokens.ORDER.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortDuplicatesPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortDuplicatesPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortDuplicatesPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortDuplicatesPhrase() : SortDuplicatesPhraseContext {
		var _localctx : SortDuplicatesPhraseContext = SortDuplicatesPhraseContext(context, state)
		enterRule(_localctx, 904, Rules.RULE_sortDuplicatesPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5180
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 5179
				match(WITH) as Token
				}
			}

			this.state = 5182
			match(DUPLICATES) as Token
			this.state = 5184
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IN) {
				if (true){
				this.state = 5183
				match(IN) as Token
				}
			}

			this.state = 5187
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ORDER) {
				if (true){
				this.state = 5186
				match(ORDER) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortCollatingSequencePhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortCollatingSequencePhrase.id
	        set(value) { throw RuntimeException() }
		fun SEQUENCE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SEQUENCE.id, 0)
		fun COLLATING() : TerminalNode? = getToken(Cobol85Parser.Tokens.COLLATING.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findAlphabetName() : List<AlphabetNameContext> = getRuleContexts(solver.getType("AlphabetNameContext"))
		fun findAlphabetName(i: Int) : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),i)
		fun findSortCollatingAlphanumeric() : SortCollatingAlphanumericContext? = getRuleContext(solver.getType("SortCollatingAlphanumericContext"),0)
		fun findSortCollatingNational() : SortCollatingNationalContext? = getRuleContext(solver.getType("SortCollatingNationalContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortCollatingSequencePhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortCollatingSequencePhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortCollatingSequencePhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortCollatingSequencePhrase() : SortCollatingSequencePhraseContext {
		var _localctx : SortCollatingSequencePhraseContext = SortCollatingSequencePhraseContext(context, state)
		enterRule(_localctx, 906, Rules.RULE_sortCollatingSequencePhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5190
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COLLATING) {
				if (true){
				this.state = 5189
				match(COLLATING) as Token
				}
			}

			this.state = 5192
			match(SEQUENCE) as Token
			this.state = 5194
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 5193
				match(IS) as Token
				}
			}

			this.state = 5197 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 5196
				alphabetName()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 5199 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,787,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			this.state = 5202
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,788,context) ) {
			1   -> if (true){
			this.state = 5201
			sortCollatingAlphanumeric()
			}
			}
			this.state = 5205
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR || _la==NATIONAL) {
				if (true){
				this.state = 5204
				sortCollatingNational()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortCollatingAlphanumericContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortCollatingAlphanumeric.id
	        set(value) { throw RuntimeException() }
		fun ALPHANUMERIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHANUMERIC.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findAlphabetName() : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortCollatingAlphanumeric(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortCollatingAlphanumeric(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortCollatingAlphanumeric(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortCollatingAlphanumeric() : SortCollatingAlphanumericContext {
		var _localctx : SortCollatingAlphanumericContext = SortCollatingAlphanumericContext(context, state)
		enterRule(_localctx, 908, Rules.RULE_sortCollatingAlphanumeric.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5208
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 5207
				match(FOR) as Token
				}
			}

			this.state = 5210
			match(ALPHANUMERIC) as Token
			this.state = 5211
			match(IS) as Token
			this.state = 5212
			alphabetName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortCollatingNationalContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortCollatingNational.id
	        set(value) { throw RuntimeException() }
		fun NATIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIONAL.id, 0)
		fun findAlphabetName() : AlphabetNameContext? = getRuleContext(solver.getType("AlphabetNameContext"),0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortCollatingNational(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortCollatingNational(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortCollatingNational(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortCollatingNational() : SortCollatingNationalContext {
		var _localctx : SortCollatingNationalContext = SortCollatingNationalContext(context, state)
		enterRule(_localctx, 910, Rules.RULE_sortCollatingNational.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5215
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 5214
				match(FOR) as Token
				}
			}

			this.state = 5217
			match(NATIONAL) as Token
			this.state = 5219
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 5218
				match(IS) as Token
				}
			}

			this.state = 5221
			alphabetName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortInputProcedurePhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortInputProcedurePhrase.id
	        set(value) { throw RuntimeException() }
		fun INPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.INPUT.id, 0)
		fun PROCEDURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROCEDURE.id, 0)
		fun findProcedureName() : ProcedureNameContext? = getRuleContext(solver.getType("ProcedureNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findSortInputThrough() : SortInputThroughContext? = getRuleContext(solver.getType("SortInputThroughContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortInputProcedurePhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortInputProcedurePhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortInputProcedurePhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortInputProcedurePhrase() : SortInputProcedurePhraseContext {
		var _localctx : SortInputProcedurePhraseContext = SortInputProcedurePhraseContext(context, state)
		enterRule(_localctx, 912, Rules.RULE_sortInputProcedurePhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5223
			match(INPUT) as Token
			this.state = 5224
			match(PROCEDURE) as Token
			this.state = 5226
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 5225
				match(IS) as Token
				}
			}

			this.state = 5228
			procedureName()
			this.state = 5230
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THROUGH || _la==THRU) {
				if (true){
				this.state = 5229
				sortInputThrough()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortInputThroughContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortInputThrough.id
	        set(value) { throw RuntimeException() }
		fun findProcedureName() : ProcedureNameContext? = getRuleContext(solver.getType("ProcedureNameContext"),0)
		fun THROUGH() : TerminalNode? = getToken(Cobol85Parser.Tokens.THROUGH.id, 0)
		fun THRU() : TerminalNode? = getToken(Cobol85Parser.Tokens.THRU.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortInputThrough(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortInputThrough(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortInputThrough(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortInputThrough() : SortInputThroughContext {
		var _localctx : SortInputThroughContext = SortInputThroughContext(context, state)
		enterRule(_localctx, 914, Rules.RULE_sortInputThrough.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5232
			_la = _input!!.LA(1)
			if ( !(_la==THROUGH || _la==THRU) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5233
			procedureName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortUsingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortUsing.id
	        set(value) { throw RuntimeException() }
		fun USING() : TerminalNode? = getToken(Cobol85Parser.Tokens.USING.id, 0)
		fun findFileName() : List<FileNameContext> = getRuleContexts(solver.getType("FileNameContext"))
		fun findFileName(i: Int) : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortUsing(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortUsing(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortUsing(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortUsing() : SortUsingContext {
		var _localctx : SortUsingContext = SortUsingContext(context, state)
		enterRule(_localctx, 916, Rules.RULE_sortUsing.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5235
			match(USING) as Token
			this.state = 5237 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5236
				fileName()
				}
				}
				this.state = 5239 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortOutputProcedurePhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortOutputProcedurePhrase.id
	        set(value) { throw RuntimeException() }
		fun OUTPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.OUTPUT.id, 0)
		fun PROCEDURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROCEDURE.id, 0)
		fun findProcedureName() : ProcedureNameContext? = getRuleContext(solver.getType("ProcedureNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun findSortOutputThrough() : SortOutputThroughContext? = getRuleContext(solver.getType("SortOutputThroughContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortOutputProcedurePhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortOutputProcedurePhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortOutputProcedurePhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortOutputProcedurePhrase() : SortOutputProcedurePhraseContext {
		var _localctx : SortOutputProcedurePhraseContext = SortOutputProcedurePhraseContext(context, state)
		enterRule(_localctx, 918, Rules.RULE_sortOutputProcedurePhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5241
			match(OUTPUT) as Token
			this.state = 5242
			match(PROCEDURE) as Token
			this.state = 5244
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 5243
				match(IS) as Token
				}
			}

			this.state = 5246
			procedureName()
			this.state = 5248
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THROUGH || _la==THRU) {
				if (true){
				this.state = 5247
				sortOutputThrough()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortOutputThroughContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortOutputThrough.id
	        set(value) { throw RuntimeException() }
		fun findProcedureName() : ProcedureNameContext? = getRuleContext(solver.getType("ProcedureNameContext"),0)
		fun THROUGH() : TerminalNode? = getToken(Cobol85Parser.Tokens.THROUGH.id, 0)
		fun THRU() : TerminalNode? = getToken(Cobol85Parser.Tokens.THRU.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortOutputThrough(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortOutputThrough(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortOutputThrough(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortOutputThrough() : SortOutputThroughContext {
		var _localctx : SortOutputThroughContext = SortOutputThroughContext(context, state)
		enterRule(_localctx, 920, Rules.RULE_sortOutputThrough.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5250
			_la = _input!!.LA(1)
			if ( !(_la==THROUGH || _la==THRU) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5251
			procedureName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortGivingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortGivingPhrase.id
	        set(value) { throw RuntimeException() }
		fun GIVING() : TerminalNode? = getToken(Cobol85Parser.Tokens.GIVING.id, 0)
		fun findSortGiving() : List<SortGivingContext> = getRuleContexts(solver.getType("SortGivingContext"))
		fun findSortGiving(i: Int) : SortGivingContext? = getRuleContext(solver.getType("SortGivingContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortGivingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortGivingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortGivingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortGivingPhrase() : SortGivingPhraseContext {
		var _localctx : SortGivingPhraseContext = SortGivingPhraseContext(context, state)
		enterRule(_localctx, 922, Rules.RULE_sortGivingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5253
			match(GIVING) as Token
			this.state = 5255 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5254
				sortGiving()
				}
				}
				this.state = 5257 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SortGivingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sortGiving.id
	        set(value) { throw RuntimeException() }
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun LOCK() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOCK.id, 0)
		fun SAVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SAVE.id, 0)
		fun NO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO.id, 0)
		fun REWIND() : TerminalNode? = getToken(Cobol85Parser.Tokens.REWIND.id, 0)
		fun CRUNCH() : TerminalNode? = getToken(Cobol85Parser.Tokens.CRUNCH.id, 0)
		fun RELEASE() : TerminalNode? = getToken(Cobol85Parser.Tokens.RELEASE.id, 0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		fun REMOVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.REMOVE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSortGiving(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSortGiving(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSortGiving(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sortGiving() : SortGivingContext {
		var _localctx : SortGivingContext = SortGivingContext(context, state)
		enterRule(_localctx, 924, Rules.RULE_sortGiving.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5259
			fileName()
			this.state = 5269
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,799,context) ) {
			1   -> if (true){
			this.state = 5260
			match(LOCK) as Token
			}
			2   -> if (true){
			this.state = 5261
			match(SAVE) as Token
			}
			3   -> if (true){
			this.state = 5262
			match(NO) as Token
			this.state = 5263
			match(REWIND) as Token
			}
			4   -> if (true){
			this.state = 5264
			match(CRUNCH) as Token
			}
			5   -> if (true){
			this.state = 5265
			match(RELEASE) as Token
			}
			6   -> if (true){
			this.state = 5266
			match(WITH) as Token
			this.state = 5267
			match(REMOVE) as Token
			this.state = 5268
			match(CRUNCH) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class StartStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_startStatement.id
	        set(value) { throw RuntimeException() }
		fun START() : TerminalNode? = getToken(Cobol85Parser.Tokens.START.id, 0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun findStartKey() : StartKeyContext? = getRuleContext(solver.getType("StartKeyContext"),0)
		fun findInvalidKeyPhrase() : InvalidKeyPhraseContext? = getRuleContext(solver.getType("InvalidKeyPhraseContext"),0)
		fun findNotInvalidKeyPhrase() : NotInvalidKeyPhraseContext? = getRuleContext(solver.getType("NotInvalidKeyPhraseContext"),0)
		fun END_START() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_START.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStartStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStartStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStartStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  startStatement() : StartStatementContext {
		var _localctx : StartStatementContext = StartStatementContext(context, state)
		enterRule(_localctx, 926, Rules.RULE_startStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5271
			match(START) as Token
			this.state = 5272
			fileName()
			this.state = 5274
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==KEY) {
				if (true){
				this.state = 5273
				startKey()
				}
			}

			this.state = 5277
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,801,context) ) {
			1   -> if (true){
			this.state = 5276
			invalidKeyPhrase()
			}
			}
			this.state = 5280
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,802,context) ) {
			1   -> if (true){
			this.state = 5279
			notInvalidKeyPhrase()
			}
			}
			this.state = 5283
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,803,context) ) {
			1   -> if (true){
			this.state = 5282
			match(END_START) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class StartKeyContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_startKey.id
	        set(value) { throw RuntimeException() }
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun EQUAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.EQUAL.id, 0)
		fun EQUALCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.EQUALCHAR.id, 0)
		fun GREATER() : TerminalNode? = getToken(Cobol85Parser.Tokens.GREATER.id, 0)
		fun MORETHANCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.MORETHANCHAR.id, 0)
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		fun LESS() : TerminalNode? = getToken(Cobol85Parser.Tokens.LESS.id, 0)
		fun LESSTHANCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LESSTHANCHAR.id, 0)
		fun OR() : TerminalNode? = getToken(Cobol85Parser.Tokens.OR.id, 0)
		fun MORETHANOREQUAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.MORETHANOREQUAL.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		fun THAN() : TerminalNode? = getToken(Cobol85Parser.Tokens.THAN.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStartKey(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStartKey(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStartKey(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  startKey() : StartKeyContext {
		var _localctx : StartKeyContext = StartKeyContext(context, state)
		enterRule(_localctx, 928, Rules.RULE_startKey.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5285
			match(KEY) as Token
			this.state = 5287
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 5286
				match(IS) as Token
				}
			}

			this.state = 5316
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,810,context) ) {
			1 -> {if (true){
			this.state = 5289
			match(EQUAL) as Token
			this.state = 5291
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TO) {
				if (true){
				this.state = 5290
				match(TO) as Token
				}
			}

			}}
			2 -> {if (true){
			this.state = 5293
			match(EQUALCHAR) as Token
			}}
			3 -> {if (true){
			this.state = 5294
			match(GREATER) as Token
			this.state = 5296
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THAN) {
				if (true){
				this.state = 5295
				match(THAN) as Token
				}
			}

			}}
			4 -> {if (true){
			this.state = 5298
			match(MORETHANCHAR) as Token
			}}
			5 -> {if (true){
			this.state = 5299
			match(NOT) as Token
			this.state = 5300
			match(LESS) as Token
			this.state = 5302
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THAN) {
				if (true){
				this.state = 5301
				match(THAN) as Token
				}
			}

			}}
			6 -> {if (true){
			this.state = 5304
			match(NOT) as Token
			this.state = 5305
			match(LESSTHANCHAR) as Token
			}}
			7 -> {if (true){
			this.state = 5306
			match(GREATER) as Token
			this.state = 5308
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THAN) {
				if (true){
				this.state = 5307
				match(THAN) as Token
				}
			}

			this.state = 5310
			match(OR) as Token
			this.state = 5311
			match(EQUAL) as Token
			this.state = 5313
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TO) {
				if (true){
				this.state = 5312
				match(TO) as Token
				}
			}

			}}
			8 -> {if (true){
			this.state = 5315
			match(MORETHANOREQUAL) as Token
			}}
			}
			this.state = 5318
			qualifiedDataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class StopStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_stopStatement.id
	        set(value) { throw RuntimeException() }
		fun STOP() : TerminalNode? = getToken(Cobol85Parser.Tokens.STOP.id, 0)
		fun RUN() : TerminalNode? = getToken(Cobol85Parser.Tokens.RUN.id, 0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStopStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStopStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStopStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  stopStatement() : StopStatementContext {
		var _localctx : StopStatementContext = StopStatementContext(context, state)
		enterRule(_localctx, 930, Rules.RULE_stopStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5320
			match(STOP) as Token
			this.state = 5323
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			RUN  ->  /*LL1AltBlock*/{if (true){
			this.state = 5321
			match(RUN) as Token
			}}
			ALL , DFHRESP , DFHVALUE , FALSE , HIGH_VALUE , HIGH_VALUES , LOW_VALUE , LOW_VALUES , NULL , NULLS , QUOTE , QUOTES , SPACE , SPACES , TRUE , ZERO , ZEROS , ZEROES , NONNUMERICLITERAL , LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL , NUMERICLITERAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 5322
			literal()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class StringStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_stringStatement.id
	        set(value) { throw RuntimeException() }
		fun STRING() : TerminalNode? = getToken(Cobol85Parser.Tokens.STRING.id, 0)
		fun findStringIntoPhrase() : StringIntoPhraseContext? = getRuleContext(solver.getType("StringIntoPhraseContext"),0)
		fun findStringSendingPhrase() : List<StringSendingPhraseContext> = getRuleContexts(solver.getType("StringSendingPhraseContext"))
		fun findStringSendingPhrase(i: Int) : StringSendingPhraseContext? = getRuleContext(solver.getType("StringSendingPhraseContext"),i)
		fun findStringWithPointerPhrase() : StringWithPointerPhraseContext? = getRuleContext(solver.getType("StringWithPointerPhraseContext"),0)
		fun findOnOverflowPhrase() : OnOverflowPhraseContext? = getRuleContext(solver.getType("OnOverflowPhraseContext"),0)
		fun findNotOnOverflowPhrase() : NotOnOverflowPhraseContext? = getRuleContext(solver.getType("NotOnOverflowPhraseContext"),0)
		fun END_STRING() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_STRING.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStringStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStringStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStringStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  stringStatement() : StringStatementContext {
		var _localctx : StringStatementContext = StringStatementContext(context, state)
		enterRule(_localctx, 932, Rules.RULE_stringStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5325
			match(STRING) as Token
			this.state = 5327 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5326
				stringSendingPhrase()
				}
				}
				this.state = 5329 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)))) != 0L) || ((((_la - 551)) and 0x3f.inv()) == 0 && ((1L shl (_la - 551)) and ((1L shl (NONNUMERICLITERAL - 551)) or (1L shl (LEVEL_NUMBER_66 - 551)) or (1L shl (LEVEL_NUMBER_77 - 551)) or (1L shl (LEVEL_NUMBER_88 - 551)) or (1L shl (INTEGERLITERAL - 551)) or (1L shl (NUMERICLITERAL - 551)) or (1L shl (IDENTIFIER - 551)))) != 0L) )
			this.state = 5331
			stringIntoPhrase()
			this.state = 5333
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,813,context) ) {
			1   -> if (true){
			this.state = 5332
			stringWithPointerPhrase()
			}
			}
			this.state = 5336
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,814,context) ) {
			1   -> if (true){
			this.state = 5335
			onOverflowPhrase()
			}
			}
			this.state = 5339
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,815,context) ) {
			1   -> if (true){
			this.state = 5338
			notOnOverflowPhrase()
			}
			}
			this.state = 5342
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,816,context) ) {
			1   -> if (true){
			this.state = 5341
			match(END_STRING) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class StringSendingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_stringSendingPhrase.id
	        set(value) { throw RuntimeException() }
		fun findStringDelimitedByPhrase() : StringDelimitedByPhraseContext? = getRuleContext(solver.getType("StringDelimitedByPhraseContext"),0)
		fun findStringForPhrase() : StringForPhraseContext? = getRuleContext(solver.getType("StringForPhraseContext"),0)
		fun findStringSending() : List<StringSendingContext> = getRuleContexts(solver.getType("StringSendingContext"))
		fun findStringSending(i: Int) : StringSendingContext? = getRuleContext(solver.getType("StringSendingContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStringSendingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStringSendingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStringSendingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  stringSendingPhrase() : StringSendingPhraseContext {
		var _localctx : StringSendingPhraseContext = StringSendingPhraseContext(context, state)
		enterRule(_localctx, 934, Rules.RULE_stringSendingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5345 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5344
				stringSending()
				}
				}
				this.state = 5347 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)))) != 0L) || ((((_la - 551)) and 0x3f.inv()) == 0 && ((1L shl (_la - 551)) and ((1L shl (NONNUMERICLITERAL - 551)) or (1L shl (LEVEL_NUMBER_66 - 551)) or (1L shl (LEVEL_NUMBER_77 - 551)) or (1L shl (LEVEL_NUMBER_88 - 551)) or (1L shl (INTEGERLITERAL - 551)) or (1L shl (NUMERICLITERAL - 551)) or (1L shl (IDENTIFIER - 551)))) != 0L) )
			this.state = 5351
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			DELIMITED  ->  /*LL1AltBlock*/{if (true){
			this.state = 5349
			stringDelimitedByPhrase()
			}}
			FOR  ->  /*LL1AltBlock*/{if (true){
			this.state = 5350
			stringForPhrase()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class StringSendingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_stringSending.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStringSending(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStringSending(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStringSending(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  stringSending() : StringSendingContext {
		var _localctx : StringSendingContext = StringSendingContext(context, state)
		enterRule(_localctx, 936, Rules.RULE_stringSending.id)
		try {
			this.state = 5355
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,819,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5353
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 5354
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class StringDelimitedByPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_stringDelimitedByPhrase.id
	        set(value) { throw RuntimeException() }
		fun DELIMITED() : TerminalNode? = getToken(Cobol85Parser.Tokens.DELIMITED.id, 0)
		fun SIZE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIZE.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStringDelimitedByPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStringDelimitedByPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStringDelimitedByPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  stringDelimitedByPhrase() : StringDelimitedByPhraseContext {
		var _localctx : StringDelimitedByPhraseContext = StringDelimitedByPhraseContext(context, state)
		enterRule(_localctx, 938, Rules.RULE_stringDelimitedByPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5357
			match(DELIMITED) as Token
			this.state = 5359
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==BY) {
				if (true){
				this.state = 5358
				match(BY) as Token
				}
			}

			this.state = 5364
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,821,context) ) {
			1 -> {if (true){
			this.state = 5361
			match(SIZE) as Token
			}}
			2 -> {if (true){
			this.state = 5362
			identifier()
			}}
			3 -> {if (true){
			this.state = 5363
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class StringForPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_stringForPhrase.id
	        set(value) { throw RuntimeException() }
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStringForPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStringForPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStringForPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  stringForPhrase() : StringForPhraseContext {
		var _localctx : StringForPhraseContext = StringForPhraseContext(context, state)
		enterRule(_localctx, 940, Rules.RULE_stringForPhrase.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5366
			match(FOR) as Token
			this.state = 5369
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,822,context) ) {
			1 -> {if (true){
			this.state = 5367
			identifier()
			}}
			2 -> {if (true){
			this.state = 5368
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class StringIntoPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_stringIntoPhrase.id
	        set(value) { throw RuntimeException() }
		fun INTO() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTO.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStringIntoPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStringIntoPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStringIntoPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  stringIntoPhrase() : StringIntoPhraseContext {
		var _localctx : StringIntoPhraseContext = StringIntoPhraseContext(context, state)
		enterRule(_localctx, 942, Rules.RULE_stringIntoPhrase.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5371
			match(INTO) as Token
			this.state = 5372
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class StringWithPointerPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_stringWithPointerPhrase.id
	        set(value) { throw RuntimeException() }
		fun POINTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.POINTER.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterStringWithPointerPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitStringWithPointerPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitStringWithPointerPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  stringWithPointerPhrase() : StringWithPointerPhraseContext {
		var _localctx : StringWithPointerPhraseContext = StringWithPointerPhraseContext(context, state)
		enterRule(_localctx, 944, Rules.RULE_stringWithPointerPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5375
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 5374
				match(WITH) as Token
				}
			}

			this.state = 5377
			match(POINTER) as Token
			this.state = 5378
			qualifiedDataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SubtractStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_subtractStatement.id
	        set(value) { throw RuntimeException() }
		fun SUBTRACT() : TerminalNode? = getToken(Cobol85Parser.Tokens.SUBTRACT.id, 0)
		fun findSubtractFromStatement() : SubtractFromStatementContext? = getRuleContext(solver.getType("SubtractFromStatementContext"),0)
		fun findSubtractFromGivingStatement() : SubtractFromGivingStatementContext? = getRuleContext(solver.getType("SubtractFromGivingStatementContext"),0)
		fun findSubtractCorrespondingStatement() : SubtractCorrespondingStatementContext? = getRuleContext(solver.getType("SubtractCorrespondingStatementContext"),0)
		fun findOnSizeErrorPhrase() : OnSizeErrorPhraseContext? = getRuleContext(solver.getType("OnSizeErrorPhraseContext"),0)
		fun findNotOnSizeErrorPhrase() : NotOnSizeErrorPhraseContext? = getRuleContext(solver.getType("NotOnSizeErrorPhraseContext"),0)
		fun END_SUBTRACT() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_SUBTRACT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSubtractStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSubtractStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSubtractStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  subtractStatement() : SubtractStatementContext {
		var _localctx : SubtractStatementContext = SubtractStatementContext(context, state)
		enterRule(_localctx, 946, Rules.RULE_subtractStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5380
			match(SUBTRACT) as Token
			this.state = 5384
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,824,context) ) {
			1 -> {if (true){
			this.state = 5381
			subtractFromStatement()
			}}
			2 -> {if (true){
			this.state = 5382
			subtractFromGivingStatement()
			}}
			3 -> {if (true){
			this.state = 5383
			subtractCorrespondingStatement()
			}}
			}
			this.state = 5387
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,825,context) ) {
			1   -> if (true){
			this.state = 5386
			onSizeErrorPhrase()
			}
			}
			this.state = 5390
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,826,context) ) {
			1   -> if (true){
			this.state = 5389
			notOnSizeErrorPhrase()
			}
			}
			this.state = 5393
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,827,context) ) {
			1   -> if (true){
			this.state = 5392
			match(END_SUBTRACT) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SubtractFromStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_subtractFromStatement.id
	        set(value) { throw RuntimeException() }
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun findSubtractSubtrahend() : List<SubtractSubtrahendContext> = getRuleContexts(solver.getType("SubtractSubtrahendContext"))
		fun findSubtractSubtrahend(i: Int) : SubtractSubtrahendContext? = getRuleContext(solver.getType("SubtractSubtrahendContext"),i)
		fun findSubtractMinuend() : List<SubtractMinuendContext> = getRuleContexts(solver.getType("SubtractMinuendContext"))
		fun findSubtractMinuend(i: Int) : SubtractMinuendContext? = getRuleContext(solver.getType("SubtractMinuendContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSubtractFromStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSubtractFromStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSubtractFromStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  subtractFromStatement() : SubtractFromStatementContext {
		var _localctx : SubtractFromStatementContext = SubtractFromStatementContext(context, state)
		enterRule(_localctx, 948, Rules.RULE_subtractFromStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5396 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5395
				subtractSubtrahend()
				}
				}
				this.state = 5398 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)))) != 0L) || ((((_la - 551)) and 0x3f.inv()) == 0 && ((1L shl (_la - 551)) and ((1L shl (NONNUMERICLITERAL - 551)) or (1L shl (LEVEL_NUMBER_66 - 551)) or (1L shl (LEVEL_NUMBER_77 - 551)) or (1L shl (LEVEL_NUMBER_88 - 551)) or (1L shl (INTEGERLITERAL - 551)) or (1L shl (NUMERICLITERAL - 551)) or (1L shl (IDENTIFIER - 551)))) != 0L) )
			this.state = 5400
			match(FROM) as Token
			this.state = 5402 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5401
				subtractMinuend()
				}
				}
				this.state = 5404 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SubtractFromGivingStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_subtractFromGivingStatement.id
	        set(value) { throw RuntimeException() }
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun findSubtractMinuendGiving() : SubtractMinuendGivingContext? = getRuleContext(solver.getType("SubtractMinuendGivingContext"),0)
		fun GIVING() : TerminalNode? = getToken(Cobol85Parser.Tokens.GIVING.id, 0)
		fun findSubtractSubtrahend() : List<SubtractSubtrahendContext> = getRuleContexts(solver.getType("SubtractSubtrahendContext"))
		fun findSubtractSubtrahend(i: Int) : SubtractSubtrahendContext? = getRuleContext(solver.getType("SubtractSubtrahendContext"),i)
		fun findSubtractGiving() : List<SubtractGivingContext> = getRuleContexts(solver.getType("SubtractGivingContext"))
		fun findSubtractGiving(i: Int) : SubtractGivingContext? = getRuleContext(solver.getType("SubtractGivingContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSubtractFromGivingStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSubtractFromGivingStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSubtractFromGivingStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  subtractFromGivingStatement() : SubtractFromGivingStatementContext {
		var _localctx : SubtractFromGivingStatementContext = SubtractFromGivingStatementContext(context, state)
		enterRule(_localctx, 950, Rules.RULE_subtractFromGivingStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5407 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5406
				subtractSubtrahend()
				}
				}
				this.state = 5409 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)))) != 0L) || ((((_la - 551)) and 0x3f.inv()) == 0 && ((1L shl (_la - 551)) and ((1L shl (NONNUMERICLITERAL - 551)) or (1L shl (LEVEL_NUMBER_66 - 551)) or (1L shl (LEVEL_NUMBER_77 - 551)) or (1L shl (LEVEL_NUMBER_88 - 551)) or (1L shl (INTEGERLITERAL - 551)) or (1L shl (NUMERICLITERAL - 551)) or (1L shl (IDENTIFIER - 551)))) != 0L) )
			this.state = 5411
			match(FROM) as Token
			this.state = 5412
			subtractMinuendGiving()
			this.state = 5413
			match(GIVING) as Token
			this.state = 5415 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5414
				subtractGiving()
				}
				}
				this.state = 5417 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SubtractCorrespondingStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_subtractCorrespondingStatement.id
	        set(value) { throw RuntimeException() }
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun findSubtractMinuendCorresponding() : SubtractMinuendCorrespondingContext? = getRuleContext(solver.getType("SubtractMinuendCorrespondingContext"),0)
		fun CORRESPONDING() : TerminalNode? = getToken(Cobol85Parser.Tokens.CORRESPONDING.id, 0)
		fun CORR() : TerminalNode? = getToken(Cobol85Parser.Tokens.CORR.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSubtractCorrespondingStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSubtractCorrespondingStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSubtractCorrespondingStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  subtractCorrespondingStatement() : SubtractCorrespondingStatementContext {
		var _localctx : SubtractCorrespondingStatementContext = SubtractCorrespondingStatementContext(context, state)
		enterRule(_localctx, 952, Rules.RULE_subtractCorrespondingStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5419
			_la = _input!!.LA(1)
			if ( !(_la==CORR || _la==CORRESPONDING) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5420
			qualifiedDataName()
			this.state = 5421
			match(FROM) as Token
			this.state = 5422
			subtractMinuendCorresponding()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SubtractSubtrahendContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_subtractSubtrahend.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSubtractSubtrahend(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSubtractSubtrahend(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSubtractSubtrahend(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  subtractSubtrahend() : SubtractSubtrahendContext {
		var _localctx : SubtractSubtrahendContext = SubtractSubtrahendContext(context, state)
		enterRule(_localctx, 954, Rules.RULE_subtractSubtrahend.id)
		try {
			this.state = 5426
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,832,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5424
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 5425
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SubtractMinuendContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_subtractMinuend.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun ROUNDED() : TerminalNode? = getToken(Cobol85Parser.Tokens.ROUNDED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSubtractMinuend(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSubtractMinuend(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSubtractMinuend(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  subtractMinuend() : SubtractMinuendContext {
		var _localctx : SubtractMinuendContext = SubtractMinuendContext(context, state)
		enterRule(_localctx, 956, Rules.RULE_subtractMinuend.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5428
			identifier()
			this.state = 5430
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ROUNDED) {
				if (true){
				this.state = 5429
				match(ROUNDED) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SubtractMinuendGivingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_subtractMinuendGiving.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSubtractMinuendGiving(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSubtractMinuendGiving(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSubtractMinuendGiving(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  subtractMinuendGiving() : SubtractMinuendGivingContext {
		var _localctx : SubtractMinuendGivingContext = SubtractMinuendGivingContext(context, state)
		enterRule(_localctx, 958, Rules.RULE_subtractMinuendGiving.id)
		try {
			this.state = 5434
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,834,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5432
			identifier()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 5433
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SubtractGivingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_subtractGiving.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun ROUNDED() : TerminalNode? = getToken(Cobol85Parser.Tokens.ROUNDED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSubtractGiving(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSubtractGiving(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSubtractGiving(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  subtractGiving() : SubtractGivingContext {
		var _localctx : SubtractGivingContext = SubtractGivingContext(context, state)
		enterRule(_localctx, 960, Rules.RULE_subtractGiving.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5436
			identifier()
			this.state = 5438
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ROUNDED) {
				if (true){
				this.state = 5437
				match(ROUNDED) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SubtractMinuendCorrespondingContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_subtractMinuendCorresponding.id
	        set(value) { throw RuntimeException() }
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun ROUNDED() : TerminalNode? = getToken(Cobol85Parser.Tokens.ROUNDED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSubtractMinuendCorresponding(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSubtractMinuendCorresponding(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSubtractMinuendCorresponding(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  subtractMinuendCorresponding() : SubtractMinuendCorrespondingContext {
		var _localctx : SubtractMinuendCorrespondingContext = SubtractMinuendCorrespondingContext(context, state)
		enterRule(_localctx, 962, Rules.RULE_subtractMinuendCorresponding.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5440
			qualifiedDataName()
			this.state = 5442
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ROUNDED) {
				if (true){
				this.state = 5441
				match(ROUNDED) as Token
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class TerminateStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_terminateStatement.id
	        set(value) { throw RuntimeException() }
		fun TERMINATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.TERMINATE.id, 0)
		fun findReportName() : ReportNameContext? = getRuleContext(solver.getType("ReportNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterTerminateStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitTerminateStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitTerminateStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  terminateStatement() : TerminateStatementContext {
		var _localctx : TerminateStatementContext = TerminateStatementContext(context, state)
		enterRule(_localctx, 964, Rules.RULE_terminateStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5444
			match(TERMINATE) as Token
			this.state = 5445
			reportName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UnstringStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_unstringStatement.id
	        set(value) { throw RuntimeException() }
		fun UNSTRING() : TerminalNode? = getToken(Cobol85Parser.Tokens.UNSTRING.id, 0)
		fun findUnstringSendingPhrase() : UnstringSendingPhraseContext? = getRuleContext(solver.getType("UnstringSendingPhraseContext"),0)
		fun findUnstringIntoPhrase() : UnstringIntoPhraseContext? = getRuleContext(solver.getType("UnstringIntoPhraseContext"),0)
		fun findUnstringWithPointerPhrase() : UnstringWithPointerPhraseContext? = getRuleContext(solver.getType("UnstringWithPointerPhraseContext"),0)
		fun findUnstringTallyingPhrase() : UnstringTallyingPhraseContext? = getRuleContext(solver.getType("UnstringTallyingPhraseContext"),0)
		fun findOnOverflowPhrase() : OnOverflowPhraseContext? = getRuleContext(solver.getType("OnOverflowPhraseContext"),0)
		fun findNotOnOverflowPhrase() : NotOnOverflowPhraseContext? = getRuleContext(solver.getType("NotOnOverflowPhraseContext"),0)
		fun END_UNSTRING() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_UNSTRING.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUnstringStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUnstringStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUnstringStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  unstringStatement() : UnstringStatementContext {
		var _localctx : UnstringStatementContext = UnstringStatementContext(context, state)
		enterRule(_localctx, 966, Rules.RULE_unstringStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5447
			match(UNSTRING) as Token
			this.state = 5448
			unstringSendingPhrase()
			this.state = 5449
			unstringIntoPhrase()
			this.state = 5451
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,837,context) ) {
			1   -> if (true){
			this.state = 5450
			unstringWithPointerPhrase()
			}
			}
			this.state = 5454
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TALLYING) {
				if (true){
				this.state = 5453
				unstringTallyingPhrase()
				}
			}

			this.state = 5457
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,839,context) ) {
			1   -> if (true){
			this.state = 5456
			onOverflowPhrase()
			}
			}
			this.state = 5460
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,840,context) ) {
			1   -> if (true){
			this.state = 5459
			notOnOverflowPhrase()
			}
			}
			this.state = 5463
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,841,context) ) {
			1   -> if (true){
			this.state = 5462
			match(END_UNSTRING) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UnstringSendingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_unstringSendingPhrase.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findUnstringDelimitedByPhrase() : UnstringDelimitedByPhraseContext? = getRuleContext(solver.getType("UnstringDelimitedByPhraseContext"),0)
		fun findUnstringOrAllPhrase() : List<UnstringOrAllPhraseContext> = getRuleContexts(solver.getType("UnstringOrAllPhraseContext"))
		fun findUnstringOrAllPhrase(i: Int) : UnstringOrAllPhraseContext? = getRuleContext(solver.getType("UnstringOrAllPhraseContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUnstringSendingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUnstringSendingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUnstringSendingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  unstringSendingPhrase() : UnstringSendingPhraseContext {
		var _localctx : UnstringSendingPhraseContext = UnstringSendingPhraseContext(context, state)
		enterRule(_localctx, 968, Rules.RULE_unstringSendingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5465
			identifier()
			this.state = 5473
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DELIMITED) {
				if (true){
				this.state = 5466
				unstringDelimitedByPhrase()
				this.state = 5470
				errorHandler.sync(this);
				_la = _input!!.LA(1)
				while (_la==OR) {
					if (true){
					if (true){
					this.state = 5467
					unstringOrAllPhrase()
					}
					}
					this.state = 5472
					errorHandler.sync(this)
					_la = _input!!.LA(1)
				}
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UnstringDelimitedByPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_unstringDelimitedByPhrase.id
	        set(value) { throw RuntimeException() }
		fun DELIMITED() : TerminalNode? = getToken(Cobol85Parser.Tokens.DELIMITED.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun BY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BY.id, 0)
		fun ALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALL.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUnstringDelimitedByPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUnstringDelimitedByPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUnstringDelimitedByPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  unstringDelimitedByPhrase() : UnstringDelimitedByPhraseContext {
		var _localctx : UnstringDelimitedByPhraseContext = UnstringDelimitedByPhraseContext(context, state)
		enterRule(_localctx, 970, Rules.RULE_unstringDelimitedByPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5475
			match(DELIMITED) as Token
			this.state = 5477
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==BY) {
				if (true){
				this.state = 5476
				match(BY) as Token
				}
			}

			this.state = 5480
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,845,context) ) {
			1   -> if (true){
			this.state = 5479
			match(ALL) as Token
			}
			}
			this.state = 5484
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,846,context) ) {
			1 -> {if (true){
			this.state = 5482
			identifier()
			}}
			2 -> {if (true){
			this.state = 5483
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UnstringOrAllPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_unstringOrAllPhrase.id
	        set(value) { throw RuntimeException() }
		fun OR() : TerminalNode? = getToken(Cobol85Parser.Tokens.OR.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun ALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALL.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUnstringOrAllPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUnstringOrAllPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUnstringOrAllPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  unstringOrAllPhrase() : UnstringOrAllPhraseContext {
		var _localctx : UnstringOrAllPhraseContext = UnstringOrAllPhraseContext(context, state)
		enterRule(_localctx, 972, Rules.RULE_unstringOrAllPhrase.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5486
			match(OR) as Token
			this.state = 5488
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,847,context) ) {
			1   -> if (true){
			this.state = 5487
			match(ALL) as Token
			}
			}
			this.state = 5492
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,848,context) ) {
			1 -> {if (true){
			this.state = 5490
			identifier()
			}}
			2 -> {if (true){
			this.state = 5491
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UnstringIntoPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_unstringIntoPhrase.id
	        set(value) { throw RuntimeException() }
		fun INTO() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTO.id, 0)
		fun findUnstringInto() : List<UnstringIntoContext> = getRuleContexts(solver.getType("UnstringIntoContext"))
		fun findUnstringInto(i: Int) : UnstringIntoContext? = getRuleContext(solver.getType("UnstringIntoContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUnstringIntoPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUnstringIntoPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUnstringIntoPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  unstringIntoPhrase() : UnstringIntoPhraseContext {
		var _localctx : UnstringIntoPhraseContext = UnstringIntoPhraseContext(context, state)
		enterRule(_localctx, 974, Rules.RULE_unstringIntoPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5494
			match(INTO) as Token
			this.state = 5496 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5495
				unstringInto()
				}
				}
				this.state = 5498 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UnstringIntoContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_unstringInto.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findUnstringDelimiterIn() : UnstringDelimiterInContext? = getRuleContext(solver.getType("UnstringDelimiterInContext"),0)
		fun findUnstringCountIn() : UnstringCountInContext? = getRuleContext(solver.getType("UnstringCountInContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUnstringInto(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUnstringInto(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUnstringInto(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  unstringInto() : UnstringIntoContext {
		var _localctx : UnstringIntoContext = UnstringIntoContext(context, state)
		enterRule(_localctx, 976, Rules.RULE_unstringInto.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5500
			identifier()
			this.state = 5502
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==DELIMITER) {
				if (true){
				this.state = 5501
				unstringDelimiterIn()
				}
			}

			this.state = 5505
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==COUNT) {
				if (true){
				this.state = 5504
				unstringCountIn()
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UnstringDelimiterInContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_unstringDelimiterIn.id
	        set(value) { throw RuntimeException() }
		fun DELIMITER() : TerminalNode? = getToken(Cobol85Parser.Tokens.DELIMITER.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUnstringDelimiterIn(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUnstringDelimiterIn(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUnstringDelimiterIn(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  unstringDelimiterIn() : UnstringDelimiterInContext {
		var _localctx : UnstringDelimiterInContext = UnstringDelimiterInContext(context, state)
		enterRule(_localctx, 978, Rules.RULE_unstringDelimiterIn.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5507
			match(DELIMITER) as Token
			this.state = 5509
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IN) {
				if (true){
				this.state = 5508
				match(IN) as Token
				}
			}

			this.state = 5511
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UnstringCountInContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_unstringCountIn.id
	        set(value) { throw RuntimeException() }
		fun COUNT() : TerminalNode? = getToken(Cobol85Parser.Tokens.COUNT.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUnstringCountIn(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUnstringCountIn(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUnstringCountIn(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  unstringCountIn() : UnstringCountInContext {
		var _localctx : UnstringCountInContext = UnstringCountInContext(context, state)
		enterRule(_localctx, 980, Rules.RULE_unstringCountIn.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5513
			match(COUNT) as Token
			this.state = 5515
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IN) {
				if (true){
				this.state = 5514
				match(IN) as Token
				}
			}

			this.state = 5517
			identifier()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UnstringWithPointerPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_unstringWithPointerPhrase.id
	        set(value) { throw RuntimeException() }
		fun POINTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.POINTER.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun WITH() : TerminalNode? = getToken(Cobol85Parser.Tokens.WITH.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUnstringWithPointerPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUnstringWithPointerPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUnstringWithPointerPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  unstringWithPointerPhrase() : UnstringWithPointerPhraseContext {
		var _localctx : UnstringWithPointerPhraseContext = UnstringWithPointerPhraseContext(context, state)
		enterRule(_localctx, 982, Rules.RULE_unstringWithPointerPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5520
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==WITH) {
				if (true){
				this.state = 5519
				match(WITH) as Token
				}
			}

			this.state = 5522
			match(POINTER) as Token
			this.state = 5523
			qualifiedDataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UnstringTallyingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_unstringTallyingPhrase.id
	        set(value) { throw RuntimeException() }
		fun TALLYING() : TerminalNode? = getToken(Cobol85Parser.Tokens.TALLYING.id, 0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUnstringTallyingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUnstringTallyingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUnstringTallyingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  unstringTallyingPhrase() : UnstringTallyingPhraseContext {
		var _localctx : UnstringTallyingPhraseContext = UnstringTallyingPhraseContext(context, state)
		enterRule(_localctx, 984, Rules.RULE_unstringTallyingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5525
			match(TALLYING) as Token
			this.state = 5527
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IN) {
				if (true){
				this.state = 5526
				match(IN) as Token
				}
			}

			this.state = 5529
			qualifiedDataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UseStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_useStatement.id
	        set(value) { throw RuntimeException() }
		fun USE() : TerminalNode? = getToken(Cobol85Parser.Tokens.USE.id, 0)
		fun findUseAfterClause() : UseAfterClauseContext? = getRuleContext(solver.getType("UseAfterClauseContext"),0)
		fun findUseDebugClause() : UseDebugClauseContext? = getRuleContext(solver.getType("UseDebugClauseContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUseStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUseStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUseStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  useStatement() : UseStatementContext {
		var _localctx : UseStatementContext = UseStatementContext(context, state)
		enterRule(_localctx, 986, Rules.RULE_useStatement.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5531
			match(USE) as Token
			this.state = 5534
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			AFTER , GLOBAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 5532
			useAfterClause()
			}}
			DEBUGGING , FOR  ->  /*LL1AltBlock*/{if (true){
			this.state = 5533
			useDebugClause()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UseAfterClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_useAfterClause.id
	        set(value) { throw RuntimeException() }
		fun AFTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.AFTER.id, 0)
		fun PROCEDURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROCEDURE.id, 0)
		fun findUseAfterOn() : UseAfterOnContext? = getRuleContext(solver.getType("UseAfterOnContext"),0)
		fun EXCEPTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXCEPTION.id, 0)
		fun ERROR() : TerminalNode? = getToken(Cobol85Parser.Tokens.ERROR.id, 0)
		fun GLOBAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.GLOBAL.id, 0)
		fun STANDARD() : TerminalNode? = getToken(Cobol85Parser.Tokens.STANDARD.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUseAfterClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUseAfterClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUseAfterClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  useAfterClause() : UseAfterClauseContext {
		var _localctx : UseAfterClauseContext = UseAfterClauseContext(context, state)
		enterRule(_localctx, 988, Rules.RULE_useAfterClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5537
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==GLOBAL) {
				if (true){
				this.state = 5536
				match(GLOBAL) as Token
				}
			}

			this.state = 5539
			match(AFTER) as Token
			this.state = 5541
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==STANDARD) {
				if (true){
				this.state = 5540
				match(STANDARD) as Token
				}
			}

			this.state = 5543
			_la = _input!!.LA(1)
			if ( !(_la==ERROR || _la==EXCEPTION) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5544
			match(PROCEDURE) as Token
			this.state = 5546
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 5545
				match(ON) as Token
				}
			}

			this.state = 5548
			useAfterOn()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UseAfterOnContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_useAfterOn.id
	        set(value) { throw RuntimeException() }
		fun INPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.INPUT.id, 0)
		fun OUTPUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.OUTPUT.id, 0)
		fun I_O() : TerminalNode? = getToken(Cobol85Parser.Tokens.I_O.id, 0)
		fun EXTEND() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXTEND.id, 0)
		fun findFileName() : List<FileNameContext> = getRuleContexts(solver.getType("FileNameContext"))
		fun findFileName(i: Int) : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUseAfterOn(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUseAfterOn(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUseAfterOn(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  useAfterOn() : UseAfterOnContext {
		var _localctx : UseAfterOnContext = UseAfterOnContext(context, state)
		enterRule(_localctx, 990, Rules.RULE_useAfterOn.id)
		var _la: Int
		try {
			this.state = 5559
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			INPUT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5550
			match(INPUT) as Token
			}}
			OUTPUT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 5551
			match(OUTPUT) as Token
			}}
			I_O  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 5552
			match(I_O) as Token
			}}
			EXTEND  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 5553
			match(EXTEND) as Token
			}}
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 5555 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5554
				fileName()
				}
				}
				this.state = 5557 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER )
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UseDebugClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_useDebugClause.id
	        set(value) { throw RuntimeException() }
		fun DEBUGGING() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEBUGGING.id, 0)
		fun FOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOR.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun findUseDebugOn() : List<UseDebugOnContext> = getRuleContexts(solver.getType("UseDebugOnContext"))
		fun findUseDebugOn(i: Int) : UseDebugOnContext? = getRuleContext(solver.getType("UseDebugOnContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUseDebugClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUseDebugClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUseDebugClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  useDebugClause() : UseDebugClauseContext {
		var _localctx : UseDebugClauseContext = UseDebugClauseContext(context, state)
		enterRule(_localctx, 992, Rules.RULE_useDebugClause.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5562
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FOR) {
				if (true){
				this.state = 5561
				match(FOR) as Token
				}
			}

			this.state = 5564
			match(DEBUGGING) as Token
			this.state = 5566
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 5565
				match(ON) as Token
				}
			}

			this.state = 5569 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5568
				useDebugOn()
				}
				}
				this.state = 5571 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( (((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || ((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)) or (1L shl (IDENTIFIER - 552)))) != 0L) )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class UseDebugOnContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_useDebugOn.id
	        set(value) { throw RuntimeException() }
		fun ALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALL.id, 0)
		fun PROCEDURES() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROCEDURES.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun REFERENCES() : TerminalNode? = getToken(Cobol85Parser.Tokens.REFERENCES.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		fun findProcedureName() : ProcedureNameContext? = getRuleContext(solver.getType("ProcedureNameContext"),0)
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterUseDebugOn(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitUseDebugOn(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitUseDebugOn(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  useDebugOn() : UseDebugOnContext {
		var _localctx : UseDebugOnContext = UseDebugOnContext(context, state)
		enterRule(_localctx, 994, Rules.RULE_useDebugOn.id)
		var _la: Int
		try {
			this.state = 5585
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,867,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5573
			match(ALL) as Token
			this.state = 5574
			match(PROCEDURES) as Token
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 5575
			match(ALL) as Token
			this.state = 5577
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==REFERENCES) {
				if (true){
				this.state = 5576
				match(REFERENCES) as Token
				}
			}

			this.state = 5580
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OF) {
				if (true){
				this.state = 5579
				match(OF) as Token
				}
			}

			this.state = 5582
			identifier()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 5583
			procedureName()
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 5584
			fileName()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class WriteStatementContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_writeStatement.id
	        set(value) { throw RuntimeException() }
		fun WRITE() : TerminalNode? = getToken(Cobol85Parser.Tokens.WRITE.id, 0)
		fun findRecordName() : RecordNameContext? = getRuleContext(solver.getType("RecordNameContext"),0)
		fun findWriteFromPhrase() : WriteFromPhraseContext? = getRuleContext(solver.getType("WriteFromPhraseContext"),0)
		fun findWriteAdvancingPhrase() : WriteAdvancingPhraseContext? = getRuleContext(solver.getType("WriteAdvancingPhraseContext"),0)
		fun findWriteAtEndOfPagePhrase() : WriteAtEndOfPagePhraseContext? = getRuleContext(solver.getType("WriteAtEndOfPagePhraseContext"),0)
		fun findWriteNotAtEndOfPagePhrase() : WriteNotAtEndOfPagePhraseContext? = getRuleContext(solver.getType("WriteNotAtEndOfPagePhraseContext"),0)
		fun findInvalidKeyPhrase() : InvalidKeyPhraseContext? = getRuleContext(solver.getType("InvalidKeyPhraseContext"),0)
		fun findNotInvalidKeyPhrase() : NotInvalidKeyPhraseContext? = getRuleContext(solver.getType("NotInvalidKeyPhraseContext"),0)
		fun END_WRITE() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_WRITE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterWriteStatement(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitWriteStatement(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitWriteStatement(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  writeStatement() : WriteStatementContext {
		var _localctx : WriteStatementContext = WriteStatementContext(context, state)
		enterRule(_localctx, 996, Rules.RULE_writeStatement.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5587
			match(WRITE) as Token
			this.state = 5588
			recordName()
			this.state = 5590
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==FROM) {
				if (true){
				this.state = 5589
				writeFromPhrase()
				}
			}

			this.state = 5593
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==AFTER || _la==BEFORE) {
				if (true){
				this.state = 5592
				writeAdvancingPhrase()
				}
			}

			this.state = 5596
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,870,context) ) {
			1   -> if (true){
			this.state = 5595
			writeAtEndOfPagePhrase()
			}
			}
			this.state = 5599
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,871,context) ) {
			1   -> if (true){
			this.state = 5598
			writeNotAtEndOfPagePhrase()
			}
			}
			this.state = 5602
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,872,context) ) {
			1   -> if (true){
			this.state = 5601
			invalidKeyPhrase()
			}
			}
			this.state = 5605
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,873,context) ) {
			1   -> if (true){
			this.state = 5604
			notInvalidKeyPhrase()
			}
			}
			this.state = 5608
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,874,context) ) {
			1   -> if (true){
			this.state = 5607
			match(END_WRITE) as Token
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class WriteFromPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_writeFromPhrase.id
	        set(value) { throw RuntimeException() }
		fun FROM() : TerminalNode? = getToken(Cobol85Parser.Tokens.FROM.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterWriteFromPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitWriteFromPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitWriteFromPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  writeFromPhrase() : WriteFromPhraseContext {
		var _localctx : WriteFromPhraseContext = WriteFromPhraseContext(context, state)
		enterRule(_localctx, 998, Rules.RULE_writeFromPhrase.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5610
			match(FROM) as Token
			this.state = 5613
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,875,context) ) {
			1 -> {if (true){
			this.state = 5611
			identifier()
			}}
			2 -> {if (true){
			this.state = 5612
			literal()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class WriteAdvancingPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_writeAdvancingPhrase.id
	        set(value) { throw RuntimeException() }
		fun BEFORE() : TerminalNode? = getToken(Cobol85Parser.Tokens.BEFORE.id, 0)
		fun AFTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.AFTER.id, 0)
		fun findWriteAdvancingPage() : WriteAdvancingPageContext? = getRuleContext(solver.getType("WriteAdvancingPageContext"),0)
		fun findWriteAdvancingLines() : WriteAdvancingLinesContext? = getRuleContext(solver.getType("WriteAdvancingLinesContext"),0)
		fun findWriteAdvancingMnemonic() : WriteAdvancingMnemonicContext? = getRuleContext(solver.getType("WriteAdvancingMnemonicContext"),0)
		fun ADVANCING() : TerminalNode? = getToken(Cobol85Parser.Tokens.ADVANCING.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterWriteAdvancingPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitWriteAdvancingPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitWriteAdvancingPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  writeAdvancingPhrase() : WriteAdvancingPhraseContext {
		var _localctx : WriteAdvancingPhraseContext = WriteAdvancingPhraseContext(context, state)
		enterRule(_localctx, 1000, Rules.RULE_writeAdvancingPhrase.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5615
			_la = _input!!.LA(1)
			if ( !(_la==AFTER || _la==BEFORE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5617
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ADVANCING) {
				if (true){
				this.state = 5616
				match(ADVANCING) as Token
				}
			}

			this.state = 5622
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,877,context) ) {
			1 -> {if (true){
			this.state = 5619
			writeAdvancingPage()
			}}
			2 -> {if (true){
			this.state = 5620
			writeAdvancingLines()
			}}
			3 -> {if (true){
			this.state = 5621
			writeAdvancingMnemonic()
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class WriteAdvancingPageContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_writeAdvancingPage.id
	        set(value) { throw RuntimeException() }
		fun PAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PAGE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterWriteAdvancingPage(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitWriteAdvancingPage(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitWriteAdvancingPage(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  writeAdvancingPage() : WriteAdvancingPageContext {
		var _localctx : WriteAdvancingPageContext = WriteAdvancingPageContext(context, state)
		enterRule(_localctx, 1002, Rules.RULE_writeAdvancingPage.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5624
			match(PAGE) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class WriteAdvancingLinesContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_writeAdvancingLines.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun LINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINE.id, 0)
		fun LINES() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINES.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterWriteAdvancingLines(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitWriteAdvancingLines(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitWriteAdvancingLines(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  writeAdvancingLines() : WriteAdvancingLinesContext {
		var _localctx : WriteAdvancingLinesContext = WriteAdvancingLinesContext(context, state)
		enterRule(_localctx, 1004, Rules.RULE_writeAdvancingLines.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5628
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,878,context) ) {
			1 -> {if (true){
			this.state = 5626
			identifier()
			}}
			2 -> {if (true){
			this.state = 5627
			literal()
			}}
			}
			this.state = 5631
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==LINE || _la==LINES) {
				if (true){
				this.state = 5630
				_la = _input!!.LA(1)
				if ( !(_la==LINE || _la==LINES) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class WriteAdvancingMnemonicContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_writeAdvancingMnemonic.id
	        set(value) { throw RuntimeException() }
		fun findMnemonicName() : MnemonicNameContext? = getRuleContext(solver.getType("MnemonicNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterWriteAdvancingMnemonic(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitWriteAdvancingMnemonic(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitWriteAdvancingMnemonic(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  writeAdvancingMnemonic() : WriteAdvancingMnemonicContext {
		var _localctx : WriteAdvancingMnemonicContext = WriteAdvancingMnemonicContext(context, state)
		enterRule(_localctx, 1006, Rules.RULE_writeAdvancingMnemonic.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5633
			mnemonicName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class WriteAtEndOfPagePhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_writeAtEndOfPagePhrase.id
	        set(value) { throw RuntimeException() }
		fun END_OF_PAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_OF_PAGE.id, 0)
		fun EOP() : TerminalNode? = getToken(Cobol85Parser.Tokens.EOP.id, 0)
		fun AT() : TerminalNode? = getToken(Cobol85Parser.Tokens.AT.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterWriteAtEndOfPagePhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitWriteAtEndOfPagePhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitWriteAtEndOfPagePhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  writeAtEndOfPagePhrase() : WriteAtEndOfPagePhraseContext {
		var _localctx : WriteAtEndOfPagePhraseContext = WriteAtEndOfPagePhraseContext(context, state)
		enterRule(_localctx, 1008, Rules.RULE_writeAtEndOfPagePhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5636
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==AT) {
				if (true){
				this.state = 5635
				match(AT) as Token
				}
			}

			this.state = 5638
			_la = _input!!.LA(1)
			if ( !(_la==END_OF_PAGE || _la==EOP) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5642
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,881,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5639
					statement()
					}
					} 
				}
				this.state = 5644
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,881,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class WriteNotAtEndOfPagePhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_writeNotAtEndOfPagePhrase.id
	        set(value) { throw RuntimeException() }
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		fun END_OF_PAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.END_OF_PAGE.id, 0)
		fun EOP() : TerminalNode? = getToken(Cobol85Parser.Tokens.EOP.id, 0)
		fun AT() : TerminalNode? = getToken(Cobol85Parser.Tokens.AT.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterWriteNotAtEndOfPagePhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitWriteNotAtEndOfPagePhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitWriteNotAtEndOfPagePhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  writeNotAtEndOfPagePhrase() : WriteNotAtEndOfPagePhraseContext {
		var _localctx : WriteNotAtEndOfPagePhraseContext = WriteNotAtEndOfPagePhraseContext(context, state)
		enterRule(_localctx, 1010, Rules.RULE_writeNotAtEndOfPagePhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5645
			match(NOT) as Token
			this.state = 5647
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==AT) {
				if (true){
				this.state = 5646
				match(AT) as Token
				}
			}

			this.state = 5649
			_la = _input!!.LA(1)
			if ( !(_la==END_OF_PAGE || _la==EOP) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5653
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,883,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5650
					statement()
					}
					} 
				}
				this.state = 5655
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,883,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AtEndPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_atEndPhrase.id
	        set(value) { throw RuntimeException() }
		fun END() : TerminalNode? = getToken(Cobol85Parser.Tokens.END.id, 0)
		fun AT() : TerminalNode? = getToken(Cobol85Parser.Tokens.AT.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAtEndPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAtEndPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAtEndPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  atEndPhrase() : AtEndPhraseContext {
		var _localctx : AtEndPhraseContext = AtEndPhraseContext(context, state)
		enterRule(_localctx, 1012, Rules.RULE_atEndPhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5657
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==AT) {
				if (true){
				this.state = 5656
				match(AT) as Token
				}
			}

			this.state = 5659
			match(END) as Token
			this.state = 5663
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,885,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5660
					statement()
					}
					} 
				}
				this.state = 5665
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,885,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class NotAtEndPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_notAtEndPhrase.id
	        set(value) { throw RuntimeException() }
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		fun END() : TerminalNode? = getToken(Cobol85Parser.Tokens.END.id, 0)
		fun AT() : TerminalNode? = getToken(Cobol85Parser.Tokens.AT.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterNotAtEndPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitNotAtEndPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitNotAtEndPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  notAtEndPhrase() : NotAtEndPhraseContext {
		var _localctx : NotAtEndPhraseContext = NotAtEndPhraseContext(context, state)
		enterRule(_localctx, 1014, Rules.RULE_notAtEndPhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5666
			match(NOT) as Token
			this.state = 5668
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==AT) {
				if (true){
				this.state = 5667
				match(AT) as Token
				}
			}

			this.state = 5670
			match(END) as Token
			this.state = 5674
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,887,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5671
					statement()
					}
					} 
				}
				this.state = 5676
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,887,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InvalidKeyPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_invalidKeyPhrase.id
	        set(value) { throw RuntimeException() }
		fun INVALID() : TerminalNode? = getToken(Cobol85Parser.Tokens.INVALID.id, 0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInvalidKeyPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInvalidKeyPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInvalidKeyPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  invalidKeyPhrase() : InvalidKeyPhraseContext {
		var _localctx : InvalidKeyPhraseContext = InvalidKeyPhraseContext(context, state)
		enterRule(_localctx, 1016, Rules.RULE_invalidKeyPhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5677
			match(INVALID) as Token
			this.state = 5679
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==KEY) {
				if (true){
				this.state = 5678
				match(KEY) as Token
				}
			}

			this.state = 5684
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,889,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5681
					statement()
					}
					} 
				}
				this.state = 5686
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,889,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class NotInvalidKeyPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_notInvalidKeyPhrase.id
	        set(value) { throw RuntimeException() }
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		fun INVALID() : TerminalNode? = getToken(Cobol85Parser.Tokens.INVALID.id, 0)
		fun KEY() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEY.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterNotInvalidKeyPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitNotInvalidKeyPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitNotInvalidKeyPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  notInvalidKeyPhrase() : NotInvalidKeyPhraseContext {
		var _localctx : NotInvalidKeyPhraseContext = NotInvalidKeyPhraseContext(context, state)
		enterRule(_localctx, 1018, Rules.RULE_notInvalidKeyPhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5687
			match(NOT) as Token
			this.state = 5688
			match(INVALID) as Token
			this.state = 5690
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==KEY) {
				if (true){
				this.state = 5689
				match(KEY) as Token
				}
			}

			this.state = 5695
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,891,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5692
					statement()
					}
					} 
				}
				this.state = 5697
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,891,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class OnOverflowPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_onOverflowPhrase.id
	        set(value) { throw RuntimeException() }
		fun OVERFLOW() : TerminalNode? = getToken(Cobol85Parser.Tokens.OVERFLOW.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterOnOverflowPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitOnOverflowPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitOnOverflowPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  onOverflowPhrase() : OnOverflowPhraseContext {
		var _localctx : OnOverflowPhraseContext = OnOverflowPhraseContext(context, state)
		enterRule(_localctx, 1020, Rules.RULE_onOverflowPhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5699
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 5698
				match(ON) as Token
				}
			}

			this.state = 5701
			match(OVERFLOW) as Token
			this.state = 5705
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,893,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5702
					statement()
					}
					} 
				}
				this.state = 5707
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,893,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class NotOnOverflowPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_notOnOverflowPhrase.id
	        set(value) { throw RuntimeException() }
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		fun OVERFLOW() : TerminalNode? = getToken(Cobol85Parser.Tokens.OVERFLOW.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterNotOnOverflowPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitNotOnOverflowPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitNotOnOverflowPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  notOnOverflowPhrase() : NotOnOverflowPhraseContext {
		var _localctx : NotOnOverflowPhraseContext = NotOnOverflowPhraseContext(context, state)
		enterRule(_localctx, 1022, Rules.RULE_notOnOverflowPhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5708
			match(NOT) as Token
			this.state = 5710
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 5709
				match(ON) as Token
				}
			}

			this.state = 5712
			match(OVERFLOW) as Token
			this.state = 5716
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,895,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5713
					statement()
					}
					} 
				}
				this.state = 5718
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,895,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class OnSizeErrorPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_onSizeErrorPhrase.id
	        set(value) { throw RuntimeException() }
		fun SIZE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIZE.id, 0)
		fun ERROR() : TerminalNode? = getToken(Cobol85Parser.Tokens.ERROR.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterOnSizeErrorPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitOnSizeErrorPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitOnSizeErrorPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  onSizeErrorPhrase() : OnSizeErrorPhraseContext {
		var _localctx : OnSizeErrorPhraseContext = OnSizeErrorPhraseContext(context, state)
		enterRule(_localctx, 1024, Rules.RULE_onSizeErrorPhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5720
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 5719
				match(ON) as Token
				}
			}

			this.state = 5722
			match(SIZE) as Token
			this.state = 5723
			match(ERROR) as Token
			this.state = 5727
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,897,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5724
					statement()
					}
					} 
				}
				this.state = 5729
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,897,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class NotOnSizeErrorPhraseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_notOnSizeErrorPhrase.id
	        set(value) { throw RuntimeException() }
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		fun SIZE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SIZE.id, 0)
		fun ERROR() : TerminalNode? = getToken(Cobol85Parser.Tokens.ERROR.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterNotOnSizeErrorPhrase(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitNotOnSizeErrorPhrase(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitNotOnSizeErrorPhrase(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  notOnSizeErrorPhrase() : NotOnSizeErrorPhraseContext {
		var _localctx : NotOnSizeErrorPhraseContext = NotOnSizeErrorPhraseContext(context, state)
		enterRule(_localctx, 1026, Rules.RULE_notOnSizeErrorPhrase.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5730
			match(NOT) as Token
			this.state = 5732
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 5731
				match(ON) as Token
				}
			}

			this.state = 5734
			match(SIZE) as Token
			this.state = 5735
			match(ERROR) as Token
			this.state = 5739
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,899,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5736
					statement()
					}
					} 
				}
				this.state = 5741
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,899,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class OnExceptionClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_onExceptionClause.id
	        set(value) { throw RuntimeException() }
		fun EXCEPTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXCEPTION.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterOnExceptionClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitOnExceptionClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitOnExceptionClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  onExceptionClause() : OnExceptionClauseContext {
		var _localctx : OnExceptionClauseContext = OnExceptionClauseContext(context, state)
		enterRule(_localctx, 1028, Rules.RULE_onExceptionClause.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5743
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 5742
				match(ON) as Token
				}
			}

			this.state = 5745
			match(EXCEPTION) as Token
			this.state = 5749
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,901,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5746
					statement()
					}
					} 
				}
				this.state = 5751
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,901,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class NotOnExceptionClauseContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_notOnExceptionClause.id
	        set(value) { throw RuntimeException() }
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		fun EXCEPTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXCEPTION.id, 0)
		fun ON() : TerminalNode? = getToken(Cobol85Parser.Tokens.ON.id, 0)
		fun findStatement() : List<StatementContext> = getRuleContexts(solver.getType("StatementContext"))
		fun findStatement(i: Int) : StatementContext? = getRuleContext(solver.getType("StatementContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterNotOnExceptionClause(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitNotOnExceptionClause(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitNotOnExceptionClause(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  notOnExceptionClause() : NotOnExceptionClauseContext {
		var _localctx : NotOnExceptionClauseContext = NotOnExceptionClauseContext(context, state)
		enterRule(_localctx, 1030, Rules.RULE_notOnExceptionClause.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5752
			match(NOT) as Token
			this.state = 5754
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ON) {
				if (true){
				this.state = 5753
				match(ON) as Token
				}
			}

			this.state = 5756
			match(EXCEPTION) as Token
			this.state = 5760
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,903,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5757
					statement()
					}
					} 
				}
				this.state = 5762
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,903,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ArithmeticExpressionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_arithmeticExpression.id
	        set(value) { throw RuntimeException() }
		fun findMultDivs() : MultDivsContext? = getRuleContext(solver.getType("MultDivsContext"),0)
		fun findPlusMinus() : List<PlusMinusContext> = getRuleContexts(solver.getType("PlusMinusContext"))
		fun findPlusMinus(i: Int) : PlusMinusContext? = getRuleContext(solver.getType("PlusMinusContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterArithmeticExpression(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitArithmeticExpression(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitArithmeticExpression(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  arithmeticExpression() : ArithmeticExpressionContext {
		var _localctx : ArithmeticExpressionContext = ArithmeticExpressionContext(context, state)
		enterRule(_localctx, 1032, Rules.RULE_arithmeticExpression.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5763
			multDivs()
			this.state = 5767
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,904,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5764
					plusMinus()
					}
					} 
				}
				this.state = 5769
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,904,context)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PlusMinusContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_plusMinus.id
	        set(value) { throw RuntimeException() }
		fun findMultDivs() : MultDivsContext? = getRuleContext(solver.getType("MultDivsContext"),0)
		fun PLUSCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.PLUSCHAR.id, 0)
		fun MINUSCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.MINUSCHAR.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPlusMinus(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPlusMinus(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPlusMinus(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  plusMinus() : PlusMinusContext {
		var _localctx : PlusMinusContext = PlusMinusContext(context, state)
		enterRule(_localctx, 1034, Rules.RULE_plusMinus.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5770
			_la = _input!!.LA(1)
			if ( !(_la==MINUSCHAR || _la==PLUSCHAR) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5771
			multDivs()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MultDivsContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_multDivs.id
	        set(value) { throw RuntimeException() }
		fun findPowers() : PowersContext? = getRuleContext(solver.getType("PowersContext"),0)
		fun findMultDiv() : List<MultDivContext> = getRuleContexts(solver.getType("MultDivContext"))
		fun findMultDiv(i: Int) : MultDivContext? = getRuleContext(solver.getType("MultDivContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMultDivs(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMultDivs(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMultDivs(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  multDivs() : MultDivsContext {
		var _localctx : MultDivsContext = MultDivsContext(context, state)
		enterRule(_localctx, 1036, Rules.RULE_multDivs.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5773
			powers()
			this.state = 5777
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==ASTERISKCHAR || _la==SLASHCHAR) {
				if (true){
				if (true){
				this.state = 5774
				multDiv()
				}
				}
				this.state = 5779
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MultDivContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_multDiv.id
	        set(value) { throw RuntimeException() }
		fun findPowers() : PowersContext? = getRuleContext(solver.getType("PowersContext"),0)
		fun ASTERISKCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.ASTERISKCHAR.id, 0)
		fun SLASHCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.SLASHCHAR.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMultDiv(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMultDiv(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMultDiv(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  multDiv() : MultDivContext {
		var _localctx : MultDivContext = MultDivContext(context, state)
		enterRule(_localctx, 1038, Rules.RULE_multDiv.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5780
			_la = _input!!.LA(1)
			if ( !(_la==ASTERISKCHAR || _la==SLASHCHAR) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5781
			powers()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PowersContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_powers.id
	        set(value) { throw RuntimeException() }
		fun findBasis() : BasisContext? = getRuleContext(solver.getType("BasisContext"),0)
		fun findPower() : List<PowerContext> = getRuleContexts(solver.getType("PowerContext"))
		fun findPower(i: Int) : PowerContext? = getRuleContext(solver.getType("PowerContext"),i)
		fun PLUSCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.PLUSCHAR.id, 0)
		fun MINUSCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.MINUSCHAR.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPowers(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPowers(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPowers(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  powers() : PowersContext {
		var _localctx : PowersContext = PowersContext(context, state)
		enterRule(_localctx, 1040, Rules.RULE_powers.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5784
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==MINUSCHAR || _la==PLUSCHAR) {
				if (true){
				this.state = 5783
				_la = _input!!.LA(1)
				if ( !(_la==MINUSCHAR || _la==PLUSCHAR) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			this.state = 5786
			basis()
			this.state = 5790
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==DOUBLEASTERISKCHAR) {
				if (true){
				if (true){
				this.state = 5787
				power()
				}
				}
				this.state = 5792
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class PowerContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_power.id
	        set(value) { throw RuntimeException() }
		fun DOUBLEASTERISKCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOUBLEASTERISKCHAR.id, 0)
		fun findBasis() : BasisContext? = getRuleContext(solver.getType("BasisContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterPower(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitPower(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitPower(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  power() : PowerContext {
		var _localctx : PowerContext = PowerContext(context, state)
		enterRule(_localctx, 1042, Rules.RULE_power.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5793
			match(DOUBLEASTERISKCHAR) as Token
			this.state = 5794
			basis()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class BasisContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_basis.id
	        set(value) { throw RuntimeException() }
		fun LPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LPARENCHAR.id, 0)
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		fun RPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.RPARENCHAR.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterBasis(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitBasis(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitBasis(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  basis() : BasisContext {
		var _localctx : BasisContext = BasisContext(context, state)
		enterRule(_localctx, 1044, Rules.RULE_basis.id)
		try {
			this.state = 5802
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,908,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5796
			match(LPARENCHAR) as Token
			this.state = 5797
			arithmeticExpression()
			this.state = 5798
			match(RPARENCHAR) as Token
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 5800
			identifier()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 5801
			literal()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ConditionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_condition.id
	        set(value) { throw RuntimeException() }
		fun findCombinableCondition() : CombinableConditionContext? = getRuleContext(solver.getType("CombinableConditionContext"),0)
		fun findAndOrCondition() : List<AndOrConditionContext> = getRuleContexts(solver.getType("AndOrConditionContext"))
		fun findAndOrCondition(i: Int) : AndOrConditionContext? = getRuleContext(solver.getType("AndOrConditionContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCondition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCondition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCondition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  condition() : ConditionContext {
		var _localctx : ConditionContext = ConditionContext(context, state)
		enterRule(_localctx, 1046, Rules.RULE_condition.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5804
			combinableCondition()
			this.state = 5808
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==AND || _la==OR) {
				if (true){
				if (true){
				this.state = 5805
				andOrCondition()
				}
				}
				this.state = 5810
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AndOrConditionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_andOrCondition.id
	        set(value) { throw RuntimeException() }
		fun AND() : TerminalNode? = getToken(Cobol85Parser.Tokens.AND.id, 0)
		fun OR() : TerminalNode? = getToken(Cobol85Parser.Tokens.OR.id, 0)
		fun findCombinableCondition() : CombinableConditionContext? = getRuleContext(solver.getType("CombinableConditionContext"),0)
		fun findAbbreviation() : List<AbbreviationContext> = getRuleContexts(solver.getType("AbbreviationContext"))
		fun findAbbreviation(i: Int) : AbbreviationContext? = getRuleContext(solver.getType("AbbreviationContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAndOrCondition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAndOrCondition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAndOrCondition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  andOrCondition() : AndOrConditionContext {
		var _localctx : AndOrConditionContext = AndOrConditionContext(context, state)
		enterRule(_localctx, 1048, Rules.RULE_andOrCondition.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5811
			_la = _input!!.LA(1)
			if ( !(_la==AND || _la==OR) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 5818
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,911,context) ) {
			1 -> {if (true){
			this.state = 5812
			combinableCondition()
			}}
			2 -> {if (true){
			this.state = 5814 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 5813
				abbreviation()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 5816 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,910,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CombinableConditionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_combinableCondition.id
	        set(value) { throw RuntimeException() }
		fun findSimpleCondition() : SimpleConditionContext? = getRuleContext(solver.getType("SimpleConditionContext"),0)
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCombinableCondition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCombinableCondition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCombinableCondition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  combinableCondition() : CombinableConditionContext {
		var _localctx : CombinableConditionContext = CombinableConditionContext(context, state)
		enterRule(_localctx, 1050, Rules.RULE_combinableCondition.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5821
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==NOT) {
				if (true){
				this.state = 5820
				match(NOT) as Token
				}
			}

			this.state = 5823
			simpleCondition()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SimpleConditionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_simpleCondition.id
	        set(value) { throw RuntimeException() }
		fun LPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LPARENCHAR.id, 0)
		fun findCondition() : ConditionContext? = getRuleContext(solver.getType("ConditionContext"),0)
		fun RPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.RPARENCHAR.id, 0)
		fun findRelationCondition() : RelationConditionContext? = getRuleContext(solver.getType("RelationConditionContext"),0)
		fun findClassCondition() : ClassConditionContext? = getRuleContext(solver.getType("ClassConditionContext"),0)
		fun findConditionNameReference() : ConditionNameReferenceContext? = getRuleContext(solver.getType("ConditionNameReferenceContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSimpleCondition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSimpleCondition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSimpleCondition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  simpleCondition() : SimpleConditionContext {
		var _localctx : SimpleConditionContext = SimpleConditionContext(context, state)
		enterRule(_localctx, 1052, Rules.RULE_simpleCondition.id)
		try {
			this.state = 5832
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,913,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5825
			match(LPARENCHAR) as Token
			this.state = 5826
			condition()
			this.state = 5827
			match(RPARENCHAR) as Token
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 5829
			relationCondition()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 5830
			classCondition()
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 5831
			conditionNameReference()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ClassConditionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_classCondition.id
	        set(value) { throw RuntimeException() }
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun NUMERIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMERIC.id, 0)
		fun ALPHABETIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHABETIC.id, 0)
		fun ALPHABETIC_LOWER() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHABETIC_LOWER.id, 0)
		fun ALPHABETIC_UPPER() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALPHABETIC_UPPER.id, 0)
		fun DBCS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DBCS.id, 0)
		fun KANJI() : TerminalNode? = getToken(Cobol85Parser.Tokens.KANJI.id, 0)
		fun findClassName() : ClassNameContext? = getRuleContext(solver.getType("ClassNameContext"),0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterClassCondition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitClassCondition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitClassCondition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  classCondition() : ClassConditionContext {
		var _localctx : ClassConditionContext = ClassConditionContext(context, state)
		enterRule(_localctx, 1054, Rules.RULE_classCondition.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5834
			identifier()
			this.state = 5836
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 5835
				match(IS) as Token
				}
			}

			this.state = 5839
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==NOT) {
				if (true){
				this.state = 5838
				match(NOT) as Token
				}
			}

			this.state = 5848
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			NUMERIC  ->  /*LL1AltBlock*/{if (true){
			this.state = 5841
			match(NUMERIC) as Token
			}}
			ALPHABETIC  ->  /*LL1AltBlock*/{if (true){
			this.state = 5842
			match(ALPHABETIC) as Token
			}}
			ALPHABETIC_LOWER  ->  /*LL1AltBlock*/{if (true){
			this.state = 5843
			match(ALPHABETIC_LOWER) as Token
			}}
			ALPHABETIC_UPPER  ->  /*LL1AltBlock*/{if (true){
			this.state = 5844
			match(ALPHABETIC_UPPER) as Token
			}}
			DBCS  ->  /*LL1AltBlock*/{if (true){
			this.state = 5845
			match(DBCS) as Token
			}}
			KANJI  ->  /*LL1AltBlock*/{if (true){
			this.state = 5846
			match(KANJI) as Token
			}}
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{if (true){
			this.state = 5847
			className()
			}}
			else -> throw NoViableAltException(this)
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ConditionNameReferenceContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_conditionNameReference.id
	        set(value) { throw RuntimeException() }
		fun findConditionName() : ConditionNameContext? = getRuleContext(solver.getType("ConditionNameContext"),0)
		fun findInData() : List<InDataContext> = getRuleContexts(solver.getType("InDataContext"))
		fun findInData(i: Int) : InDataContext? = getRuleContext(solver.getType("InDataContext"),i)
		fun findInFile() : InFileContext? = getRuleContext(solver.getType("InFileContext"),0)
		fun findConditionNameSubscriptReference() : List<ConditionNameSubscriptReferenceContext> = getRuleContexts(solver.getType("ConditionNameSubscriptReferenceContext"))
		fun findConditionNameSubscriptReference(i: Int) : ConditionNameSubscriptReferenceContext? = getRuleContext(solver.getType("ConditionNameSubscriptReferenceContext"),i)
		fun findInMnemonic() : List<InMnemonicContext> = getRuleContexts(solver.getType("InMnemonicContext"))
		fun findInMnemonic(i: Int) : InMnemonicContext? = getRuleContext(solver.getType("InMnemonicContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterConditionNameReference(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitConditionNameReference(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitConditionNameReference(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  conditionNameReference() : ConditionNameReferenceContext {
		var _localctx : ConditionNameReferenceContext = ConditionNameReferenceContext(context, state)
		enterRule(_localctx, 1056, Rules.RULE_conditionNameReference.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5850
			conditionName()
			this.state = 5872
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,921,context) ) {
			1 -> {if (true){
			this.state = 5854
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,917,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5851
					inData()
					}
					} 
				}
				this.state = 5856
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,917,context)
			}
			this.state = 5858
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IN || _la==OF) {
				if (true){
				this.state = 5857
				inFile()
				}
			}

			this.state = 5863
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==LPARENCHAR) {
				if (true){
				if (true){
				this.state = 5860
				conditionNameSubscriptReference()
				}
				}
				this.state = 5865
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}}
			2 -> {if (true){
			this.state = 5869
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while (_la==IN || _la==OF) {
				if (true){
				if (true){
				this.state = 5866
				inMnemonic()
				}
				}
				this.state = 5871
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ConditionNameSubscriptReferenceContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_conditionNameSubscriptReference.id
	        set(value) { throw RuntimeException() }
		fun LPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LPARENCHAR.id, 0)
		fun findSubscript() : List<SubscriptContext> = getRuleContexts(solver.getType("SubscriptContext"))
		fun findSubscript(i: Int) : SubscriptContext? = getRuleContext(solver.getType("SubscriptContext"),i)
		fun RPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.RPARENCHAR.id, 0)
		fun COMMACHAR() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.COMMACHAR.id)
		fun COMMACHAR(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.COMMACHAR.id, i) as TerminalNode
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterConditionNameSubscriptReference(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitConditionNameSubscriptReference(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitConditionNameSubscriptReference(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  conditionNameSubscriptReference() : ConditionNameSubscriptReferenceContext {
		var _localctx : ConditionNameSubscriptReferenceContext = ConditionNameSubscriptReferenceContext(context, state)
		enterRule(_localctx, 1058, Rules.RULE_conditionNameSubscriptReference.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5874
			match(LPARENCHAR) as Token
			this.state = 5875
			subscript()
			this.state = 5882
			errorHandler.sync(this);
			_la = _input!!.LA(1)
			while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)) or (1L shl (COMMACHAR - 466)))) != 0L) || ((((_la - 542)) and 0x3f.inv()) == 0 && ((1L shl (_la - 542)) and ((1L shl (LPARENCHAR - 542)) or (1L shl (MINUSCHAR - 542)) or (1L shl (PLUSCHAR - 542)) or (1L shl (NONNUMERICLITERAL - 542)) or (1L shl (LEVEL_NUMBER_66 - 542)) or (1L shl (LEVEL_NUMBER_77 - 542)) or (1L shl (LEVEL_NUMBER_88 - 542)) or (1L shl (INTEGERLITERAL - 542)) or (1L shl (NUMERICLITERAL - 542)) or (1L shl (IDENTIFIER - 542)))) != 0L)) {
				if (true){
				if (true){
				this.state = 5877
				errorHandler.sync(this)
				_la = _input!!.LA(1)
				if (_la==COMMACHAR) {
					if (true){
					this.state = 5876
					match(COMMACHAR) as Token
					}
				}

				this.state = 5879
				subscript()
				}
				}
				this.state = 5884
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			}
			this.state = 5885
			match(RPARENCHAR) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RelationConditionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_relationCondition.id
	        set(value) { throw RuntimeException() }
		fun findRelationSignCondition() : RelationSignConditionContext? = getRuleContext(solver.getType("RelationSignConditionContext"),0)
		fun findRelationArithmeticComparison() : RelationArithmeticComparisonContext? = getRuleContext(solver.getType("RelationArithmeticComparisonContext"),0)
		fun findRelationCombinedComparison() : RelationCombinedComparisonContext? = getRuleContext(solver.getType("RelationCombinedComparisonContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRelationCondition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRelationCondition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRelationCondition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  relationCondition() : RelationConditionContext {
		var _localctx : RelationConditionContext = RelationConditionContext(context, state)
		enterRule(_localctx, 1060, Rules.RULE_relationCondition.id)
		try {
			this.state = 5890
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,924,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5887
			relationSignCondition()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 5888
			relationArithmeticComparison()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 5889
			relationCombinedComparison()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RelationSignConditionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_relationSignCondition.id
	        set(value) { throw RuntimeException() }
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		fun POSITIVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.POSITIVE.id, 0)
		fun NEGATIVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.NEGATIVE.id, 0)
		fun ZERO() : TerminalNode? = getToken(Cobol85Parser.Tokens.ZERO.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRelationSignCondition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRelationSignCondition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRelationSignCondition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  relationSignCondition() : RelationSignConditionContext {
		var _localctx : RelationSignConditionContext = RelationSignConditionContext(context, state)
		enterRule(_localctx, 1062, Rules.RULE_relationSignCondition.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5892
			arithmeticExpression()
			this.state = 5894
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IS) {
				if (true){
				this.state = 5893
				match(IS) as Token
				}
			}

			this.state = 5897
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==NOT) {
				if (true){
				this.state = 5896
				match(NOT) as Token
				}
			}

			this.state = 5899
			_la = _input!!.LA(1)
			if ( !(_la==NEGATIVE || _la==POSITIVE || _la==ZERO) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RelationArithmeticComparisonContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_relationArithmeticComparison.id
	        set(value) { throw RuntimeException() }
		fun findArithmeticExpression() : List<ArithmeticExpressionContext> = getRuleContexts(solver.getType("ArithmeticExpressionContext"))
		fun findArithmeticExpression(i: Int) : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),i)
		fun findRelationalOperator() : RelationalOperatorContext? = getRuleContext(solver.getType("RelationalOperatorContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRelationArithmeticComparison(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRelationArithmeticComparison(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRelationArithmeticComparison(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  relationArithmeticComparison() : RelationArithmeticComparisonContext {
		var _localctx : RelationArithmeticComparisonContext = RelationArithmeticComparisonContext(context, state)
		enterRule(_localctx, 1064, Rules.RULE_relationArithmeticComparison.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5901
			arithmeticExpression()
			this.state = 5902
			relationalOperator()
			this.state = 5903
			arithmeticExpression()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RelationCombinedComparisonContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_relationCombinedComparison.id
	        set(value) { throw RuntimeException() }
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		fun findRelationalOperator() : RelationalOperatorContext? = getRuleContext(solver.getType("RelationalOperatorContext"),0)
		fun LPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LPARENCHAR.id, 0)
		fun findRelationCombinedCondition() : RelationCombinedConditionContext? = getRuleContext(solver.getType("RelationCombinedConditionContext"),0)
		fun RPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.RPARENCHAR.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRelationCombinedComparison(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRelationCombinedComparison(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRelationCombinedComparison(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  relationCombinedComparison() : RelationCombinedComparisonContext {
		var _localctx : RelationCombinedComparisonContext = RelationCombinedComparisonContext(context, state)
		enterRule(_localctx, 1066, Rules.RULE_relationCombinedComparison.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5905
			arithmeticExpression()
			this.state = 5906
			relationalOperator()
			this.state = 5907
			match(LPARENCHAR) as Token
			this.state = 5908
			relationCombinedCondition()
			this.state = 5909
			match(RPARENCHAR) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RelationCombinedConditionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_relationCombinedCondition.id
	        set(value) { throw RuntimeException() }
		fun findArithmeticExpression() : List<ArithmeticExpressionContext> = getRuleContexts(solver.getType("ArithmeticExpressionContext"))
		fun findArithmeticExpression(i: Int) : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),i)
		fun AND() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.AND.id)
		fun AND(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.AND.id, i) as TerminalNode
		fun OR() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.OR.id)
		fun OR(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.OR.id, i) as TerminalNode
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRelationCombinedCondition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRelationCombinedCondition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRelationCombinedCondition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  relationCombinedCondition() : RelationCombinedConditionContext {
		var _localctx : RelationCombinedConditionContext = RelationCombinedConditionContext(context, state)
		enterRule(_localctx, 1068, Rules.RULE_relationCombinedCondition.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5911
			arithmeticExpression()
			this.state = 5914 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 5912
				_la = _input!!.LA(1)
				if ( !(_la==AND || _la==OR) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				this.state = 5913
				arithmeticExpression()
				}
				}
				this.state = 5916 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( _la==AND || _la==OR )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RelationalOperatorContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_relationalOperator.id
	        set(value) { throw RuntimeException() }
		fun NOTEQUALCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOTEQUALCHAR.id, 0)
		fun GREATER() : TerminalNode? = getToken(Cobol85Parser.Tokens.GREATER.id, 0)
		fun OR() : TerminalNode? = getToken(Cobol85Parser.Tokens.OR.id, 0)
		fun EQUAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.EQUAL.id, 0)
		fun MORETHANOREQUAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.MORETHANOREQUAL.id, 0)
		fun LESS() : TerminalNode? = getToken(Cobol85Parser.Tokens.LESS.id, 0)
		fun LESSTHANOREQUAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.LESSTHANOREQUAL.id, 0)
		fun IS() : TerminalNode? = getToken(Cobol85Parser.Tokens.IS.id, 0)
		fun ARE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ARE.id, 0)
		fun MORETHANCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.MORETHANCHAR.id, 0)
		fun LESSTHANCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LESSTHANCHAR.id, 0)
		fun EQUALCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.EQUALCHAR.id, 0)
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		fun THAN() : TerminalNode? = getToken(Cobol85Parser.Tokens.THAN.id, 0)
		fun TO() : TerminalNode? = getToken(Cobol85Parser.Tokens.TO.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRelationalOperator(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRelationalOperator(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRelationalOperator(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  relationalOperator() : RelationalOperatorContext {
		var _localctx : RelationalOperatorContext = RelationalOperatorContext(context, state)
		enterRule(_localctx, 1070, Rules.RULE_relationalOperator.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5919
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ARE || _la==IS) {
				if (true){
				this.state = 5918
				_la = _input!!.LA(1)
				if ( !(_la==ARE || _la==IS) ) {
					errorHandler.recoverInline(this)
				}
				else {
					if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
					errorHandler.reportMatch(this)
					consume()
				}
				}
			}

			this.state = 5962
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,938,context) ) {
			1 -> {if (true){
			this.state = 5922
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==NOT) {
				if (true){
				this.state = 5921
				match(NOT) as Token
				}
			}

			this.state = 5939
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			GREATER  ->  /*LL1AltBlock*/{if (true){
			this.state = 5924
			match(GREATER) as Token
			this.state = 5926
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THAN) {
				if (true){
				this.state = 5925
				match(THAN) as Token
				}
			}

			}}
			MORETHANCHAR  ->  /*LL1AltBlock*/{if (true){
			this.state = 5928
			match(MORETHANCHAR) as Token
			}}
			LESS  ->  /*LL1AltBlock*/{if (true){
			this.state = 5929
			match(LESS) as Token
			this.state = 5931
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THAN) {
				if (true){
				this.state = 5930
				match(THAN) as Token
				}
			}

			}}
			LESSTHANCHAR  ->  /*LL1AltBlock*/{if (true){
			this.state = 5933
			match(LESSTHANCHAR) as Token
			}}
			EQUAL  ->  /*LL1AltBlock*/{if (true){
			this.state = 5934
			match(EQUAL) as Token
			this.state = 5936
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TO) {
				if (true){
				this.state = 5935
				match(TO) as Token
				}
			}

			}}
			EQUALCHAR  ->  /*LL1AltBlock*/{if (true){
			this.state = 5938
			match(EQUALCHAR) as Token
			}}
			else -> throw NoViableAltException(this)
			}
			}}
			2 -> {if (true){
			this.state = 5941
			match(NOTEQUALCHAR) as Token
			}}
			3 -> {if (true){
			this.state = 5942
			match(GREATER) as Token
			this.state = 5944
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THAN) {
				if (true){
				this.state = 5943
				match(THAN) as Token
				}
			}

			this.state = 5946
			match(OR) as Token
			this.state = 5947
			match(EQUAL) as Token
			this.state = 5949
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TO) {
				if (true){
				this.state = 5948
				match(TO) as Token
				}
			}

			}}
			4 -> {if (true){
			this.state = 5951
			match(MORETHANOREQUAL) as Token
			}}
			5 -> {if (true){
			this.state = 5952
			match(LESS) as Token
			this.state = 5954
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==THAN) {
				if (true){
				this.state = 5953
				match(THAN) as Token
				}
			}

			this.state = 5956
			match(OR) as Token
			this.state = 5957
			match(EQUAL) as Token
			this.state = 5959
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==TO) {
				if (true){
				this.state = 5958
				match(TO) as Token
				}
			}

			}}
			6 -> {if (true){
			this.state = 5961
			match(LESSTHANOREQUAL) as Token
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AbbreviationContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_abbreviation.id
	        set(value) { throw RuntimeException() }
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		fun LPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LPARENCHAR.id, 0)
		fun findAbbreviation() : AbbreviationContext? = getRuleContext(solver.getType("AbbreviationContext"),0)
		fun RPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.RPARENCHAR.id, 0)
		fun NOT() : TerminalNode? = getToken(Cobol85Parser.Tokens.NOT.id, 0)
		fun findRelationalOperator() : RelationalOperatorContext? = getRuleContext(solver.getType("RelationalOperatorContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAbbreviation(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAbbreviation(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAbbreviation(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  abbreviation() : AbbreviationContext {
		var _localctx : AbbreviationContext = AbbreviationContext(context, state)
		enterRule(_localctx, 1072, Rules.RULE_abbreviation.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5965
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,939,context) ) {
			1   -> if (true){
			this.state = 5964
			match(NOT) as Token
			}
			}
			this.state = 5968
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==ARE || _la==EQUAL || _la==GREATER || ((((_la - 254)) and 0x3f.inv()) == 0 && ((1L shl (_la - 254)) and ((1L shl (IS - 254)) or (1L shl (LESS - 254)) or (1L shl (NOT - 254)))) != 0L) || ((((_la - 536)) and 0x3f.inv()) == 0 && ((1L shl (_la - 536)) and ((1L shl (EQUALCHAR - 536)) or (1L shl (LESSTHANCHAR - 536)) or (1L shl (LESSTHANOREQUAL - 536)) or (1L shl (MORETHANCHAR - 536)) or (1L shl (MORETHANOREQUAL - 536)) or (1L shl (NOTEQUALCHAR - 536)))) != 0L)) {
				if (true){
				this.state = 5967
				relationalOperator()
				}
			}

			this.state = 5976
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,941,context) ) {
			1 -> {if (true){
			this.state = 5970
			arithmeticExpression()
			}}
			2 -> {if (true){
			this.state = 5971
			match(LPARENCHAR) as Token
			this.state = 5972
			arithmeticExpression()
			this.state = 5973
			abbreviation()
			this.state = 5974
			match(RPARENCHAR) as Token
			}}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class IdentifierContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_identifier.id
	        set(value) { throw RuntimeException() }
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun findTableCall() : TableCallContext? = getRuleContext(solver.getType("TableCallContext"),0)
		fun findFunctionCall() : FunctionCallContext? = getRuleContext(solver.getType("FunctionCallContext"),0)
		fun findSpecialRegister() : SpecialRegisterContext? = getRuleContext(solver.getType("SpecialRegisterContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterIdentifier(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitIdentifier(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitIdentifier(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  identifier() : IdentifierContext {
		var _localctx : IdentifierContext = IdentifierContext(context, state)
		enterRule(_localctx, 1074, Rules.RULE_identifier.id)
		try {
			this.state = 5982
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,942,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5978
			qualifiedDataName()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 5979
			tableCall()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 5980
			functionCall()
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 5981
			specialRegister()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class TableCallContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_tableCall.id
	        set(value) { throw RuntimeException() }
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun LPARENCHAR() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.LPARENCHAR.id)
		fun LPARENCHAR(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.LPARENCHAR.id, i) as TerminalNode
		fun findSubscript() : List<SubscriptContext> = getRuleContexts(solver.getType("SubscriptContext"))
		fun findSubscript(i: Int) : SubscriptContext? = getRuleContext(solver.getType("SubscriptContext"),i)
		fun RPARENCHAR() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.RPARENCHAR.id)
		fun RPARENCHAR(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.RPARENCHAR.id, i) as TerminalNode
		fun findReferenceModifier() : ReferenceModifierContext? = getRuleContext(solver.getType("ReferenceModifierContext"),0)
		fun COMMACHAR() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.COMMACHAR.id)
		fun COMMACHAR(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.COMMACHAR.id, i) as TerminalNode
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterTableCall(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitTableCall(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitTableCall(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  tableCall() : TableCallContext {
		var _localctx : TableCallContext = TableCallContext(context, state)
		enterRule(_localctx, 1076, Rules.RULE_tableCall.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 5984
			qualifiedDataName()
			this.state = 6000
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,945,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 5985
					match(LPARENCHAR) as Token
					this.state = 5986
					subscript()
					this.state = 5993
					errorHandler.sync(this);
					_la = _input!!.LA(1)
					while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)) or (1L shl (COMMACHAR - 466)))) != 0L) || ((((_la - 542)) and 0x3f.inv()) == 0 && ((1L shl (_la - 542)) and ((1L shl (LPARENCHAR - 542)) or (1L shl (MINUSCHAR - 542)) or (1L shl (PLUSCHAR - 542)) or (1L shl (NONNUMERICLITERAL - 542)) or (1L shl (LEVEL_NUMBER_66 - 542)) or (1L shl (LEVEL_NUMBER_77 - 542)) or (1L shl (LEVEL_NUMBER_88 - 542)) or (1L shl (INTEGERLITERAL - 542)) or (1L shl (NUMERICLITERAL - 542)) or (1L shl (IDENTIFIER - 542)))) != 0L)) {
						if (true){
						if (true){
						this.state = 5988
						errorHandler.sync(this)
						_la = _input!!.LA(1)
						if (_la==COMMACHAR) {
							if (true){
							this.state = 5987
							match(COMMACHAR) as Token
							}
						}

						this.state = 5990
						subscript()
						}
						}
						this.state = 5995
						errorHandler.sync(this)
						_la = _input!!.LA(1)
					}
					this.state = 5996
					match(RPARENCHAR) as Token
					}
					} 
				}
				this.state = 6002
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,945,context)
			}
			this.state = 6004
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,946,context) ) {
			1   -> if (true){
			this.state = 6003
			referenceModifier()
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class FunctionCallContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_functionCall.id
	        set(value) { throw RuntimeException() }
		fun FUNCTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.FUNCTION.id, 0)
		fun findFunctionName() : FunctionNameContext? = getRuleContext(solver.getType("FunctionNameContext"),0)
		fun LPARENCHAR() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.LPARENCHAR.id)
		fun LPARENCHAR(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.LPARENCHAR.id, i) as TerminalNode
		fun findArgument() : List<ArgumentContext> = getRuleContexts(solver.getType("ArgumentContext"))
		fun findArgument(i: Int) : ArgumentContext? = getRuleContext(solver.getType("ArgumentContext"),i)
		fun RPARENCHAR() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.RPARENCHAR.id)
		fun RPARENCHAR(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.RPARENCHAR.id, i) as TerminalNode
		fun findReferenceModifier() : ReferenceModifierContext? = getRuleContext(solver.getType("ReferenceModifierContext"),0)
		fun COMMACHAR() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.COMMACHAR.id)
		fun COMMACHAR(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.COMMACHAR.id, i) as TerminalNode
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterFunctionCall(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitFunctionCall(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitFunctionCall(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  functionCall() : FunctionCallContext {
		var _localctx : FunctionCallContext = FunctionCallContext(context, state)
		enterRule(_localctx, 1078, Rules.RULE_functionCall.id)
		var _la: Int
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6006
			match(FUNCTION) as Token
			this.state = 6007
			functionName()
			this.state = 6023
			errorHandler.sync(this)
			_alt = interpreter!!.adaptivePredict(_input!!,949,context)
			while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					if (true){
					if (true){
					this.state = 6008
					match(LPARENCHAR) as Token
					this.state = 6009
					argument()
					this.state = 6016
					errorHandler.sync(this);
					_la = _input!!.LA(1)
					while ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)) or (1L shl (COMMACHAR - 466)))) != 0L) || ((((_la - 542)) and 0x3f.inv()) == 0 && ((1L shl (_la - 542)) and ((1L shl (LPARENCHAR - 542)) or (1L shl (MINUSCHAR - 542)) or (1L shl (PLUSCHAR - 542)) or (1L shl (NONNUMERICLITERAL - 542)) or (1L shl (LEVEL_NUMBER_66 - 542)) or (1L shl (LEVEL_NUMBER_77 - 542)) or (1L shl (LEVEL_NUMBER_88 - 542)) or (1L shl (INTEGERLITERAL - 542)) or (1L shl (NUMERICLITERAL - 542)) or (1L shl (IDENTIFIER - 542)))) != 0L)) {
						if (true){
						if (true){
						this.state = 6011
						errorHandler.sync(this)
						_la = _input!!.LA(1)
						if (_la==COMMACHAR) {
							if (true){
							this.state = 6010
							match(COMMACHAR) as Token
							}
						}

						this.state = 6013
						argument()
						}
						}
						this.state = 6018
						errorHandler.sync(this)
						_la = _input!!.LA(1)
					}
					this.state = 6019
					match(RPARENCHAR) as Token
					}
					} 
				}
				this.state = 6025
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,949,context)
			}
			this.state = 6027
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,950,context) ) {
			1   -> if (true){
			this.state = 6026
			referenceModifier()
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReferenceModifierContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_referenceModifier.id
	        set(value) { throw RuntimeException() }
		fun LPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LPARENCHAR.id, 0)
		fun findCharacterPosition() : CharacterPositionContext? = getRuleContext(solver.getType("CharacterPositionContext"),0)
		fun COLONCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.COLONCHAR.id, 0)
		fun RPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.RPARENCHAR.id, 0)
		fun findLength() : LengthContext? = getRuleContext(solver.getType("LengthContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReferenceModifier(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReferenceModifier(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReferenceModifier(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  referenceModifier() : ReferenceModifierContext {
		var _localctx : ReferenceModifierContext = ReferenceModifierContext(context, state)
		enterRule(_localctx, 1080, Rules.RULE_referenceModifier.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6029
			match(LPARENCHAR) as Token
			this.state = 6030
			characterPosition()
			this.state = 6031
			match(COLONCHAR) as Token
			this.state = 6033
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if ((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl ADDRESS) or (1L shl ALL) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DATE - 68)) or (1L shl (DAY - 68)) or (1L shl (DAY_OF_WEEK - 68)) or (1L shl (DEBUG_CONTENTS - 68)) or (1L shl (DEBUG_ITEM - 68)) or (1L shl (DEBUG_LINE - 68)) or (1L shl (DEBUG_NAME - 68)) or (1L shl (DEBUG_SUB_1 - 68)) or (1L shl (DEBUG_SUB_2 - 68)) or (1L shl (DEBUG_SUB_3 - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FALSE - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTION - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (HIGH_VALUE - 202)) or (1L shl (HIGH_VALUES - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LINAGE_COUNTER - 268)) or (1L shl (LINE_COUNTER - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (LOW_VALUE - 268)) or (1L shl (LOW_VALUES - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NULL - 268)) or (1L shl (NULLS - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PAGE_COUNTER - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (QUOTE - 336)) or (1L shl (QUOTES - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (RETURN_CODE - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHIFT_IN - 401)) or (1L shl (SHIFT_OUT - 401)) or (1L shl (SHORT_DATE - 401)) or (1L shl (SORT_CONTROL - 401)) or (1L shl (SORT_CORE_SIZE - 401)) or (1L shl (SORT_FILE_SIZE - 401)) or (1L shl (SORT_MESSAGE - 401)) or (1L shl (SORT_MODE_SIZE - 401)) or (1L shl (SORT_RETURN - 401)) or (1L shl (SPACE - 401)) or (1L shl (SPACES - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TALLY - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIME - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUE - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (WHEN_COMPILED - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO - 466)) or (1L shl (ZERO_FILL - 466)) or (1L shl (ZEROS - 466)) or (1L shl (ZEROES - 466)))) != 0L) || ((((_la - 542)) and 0x3f.inv()) == 0 && ((1L shl (_la - 542)) and ((1L shl (LPARENCHAR - 542)) or (1L shl (MINUSCHAR - 542)) or (1L shl (PLUSCHAR - 542)) or (1L shl (NONNUMERICLITERAL - 542)) or (1L shl (LEVEL_NUMBER_66 - 542)) or (1L shl (LEVEL_NUMBER_77 - 542)) or (1L shl (LEVEL_NUMBER_88 - 542)) or (1L shl (INTEGERLITERAL - 542)) or (1L shl (NUMERICLITERAL - 542)) or (1L shl (IDENTIFIER - 542)))) != 0L)) {
				if (true){
				this.state = 6032
				length()
				}
			}

			this.state = 6035
			match(RPARENCHAR) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CharacterPositionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_characterPosition.id
	        set(value) { throw RuntimeException() }
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCharacterPosition(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCharacterPosition(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCharacterPosition(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  characterPosition() : CharacterPositionContext {
		var _localctx : CharacterPositionContext = CharacterPositionContext(context, state)
		enterRule(_localctx, 1082, Rules.RULE_characterPosition.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6037
			arithmeticExpression()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LengthContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_length.id
	        set(value) { throw RuntimeException() }
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLength(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLength(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLength(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  length() : LengthContext {
		var _localctx : LengthContext = LengthContext(context, state)
		enterRule(_localctx, 1084, Rules.RULE_length.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6039
			arithmeticExpression()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SubscriptContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_subscript.id
	        set(value) { throw RuntimeException() }
		fun ALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALL.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun findIndexName() : IndexNameContext? = getRuleContext(solver.getType("IndexNameContext"),0)
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSubscript(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSubscript(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSubscript(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  subscript() : SubscriptContext {
		var _localctx : SubscriptContext = SubscriptContext(context, state)
		enterRule(_localctx, 1086, Rules.RULE_subscript.id)
		try {
			this.state = 6052
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,954,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6041
			match(ALL) as Token
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6042
			integerLiteral()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 6043
			qualifiedDataName()
			this.state = 6045
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,952,context) ) {
			1   -> if (true){
			this.state = 6044
			integerLiteral()
			}
			}
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 6047
			indexName()
			this.state = 6049
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,953,context) ) {
			1   -> if (true){
			this.state = 6048
			integerLiteral()
			}
			}
			}}
			5 -> {
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 6051
			arithmeticExpression()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ArgumentContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_argument.id
	        set(value) { throw RuntimeException() }
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		fun findIndexName() : IndexNameContext? = getRuleContext(solver.getType("IndexNameContext"),0)
		fun findArithmeticExpression() : ArithmeticExpressionContext? = getRuleContext(solver.getType("ArithmeticExpressionContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterArgument(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitArgument(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitArgument(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  argument() : ArgumentContext {
		var _localctx : ArgumentContext = ArgumentContext(context, state)
		enterRule(_localctx, 1088, Rules.RULE_argument.id)
		try {
			this.state = 6065
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,957,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6054
			literal()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6055
			identifier()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 6056
			qualifiedDataName()
			this.state = 6058
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,955,context) ) {
			1   -> if (true){
			this.state = 6057
			integerLiteral()
			}
			}
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 6060
			indexName()
			this.state = 6062
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,956,context) ) {
			1   -> if (true){
			this.state = 6061
			integerLiteral()
			}
			}
			}}
			5 -> {
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 6064
			arithmeticExpression()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class QualifiedDataNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_qualifiedDataName.id
	        set(value) { throw RuntimeException() }
		fun findQualifiedDataNameFormat1() : QualifiedDataNameFormat1Context? = getRuleContext(solver.getType("QualifiedDataNameFormat1Context"),0)
		fun findQualifiedDataNameFormat2() : QualifiedDataNameFormat2Context? = getRuleContext(solver.getType("QualifiedDataNameFormat2Context"),0)
		fun findQualifiedDataNameFormat3() : QualifiedDataNameFormat3Context? = getRuleContext(solver.getType("QualifiedDataNameFormat3Context"),0)
		fun findQualifiedDataNameFormat4() : QualifiedDataNameFormat4Context? = getRuleContext(solver.getType("QualifiedDataNameFormat4Context"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterQualifiedDataName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitQualifiedDataName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitQualifiedDataName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  qualifiedDataName() : QualifiedDataNameContext {
		var _localctx : QualifiedDataNameContext = QualifiedDataNameContext(context, state)
		enterRule(_localctx, 1090, Rules.RULE_qualifiedDataName.id)
		try {
			this.state = 6071
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,958,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6067
			qualifiedDataNameFormat1()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6068
			qualifiedDataNameFormat2()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 6069
			qualifiedDataNameFormat3()
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 6070
			qualifiedDataNameFormat4()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class QualifiedDataNameFormat1Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_qualifiedDataNameFormat1.id
	        set(value) { throw RuntimeException() }
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun findConditionName() : ConditionNameContext? = getRuleContext(solver.getType("ConditionNameContext"),0)
		fun findInFile() : InFileContext? = getRuleContext(solver.getType("InFileContext"),0)
		fun findQualifiedInData() : List<QualifiedInDataContext> = getRuleContexts(solver.getType("QualifiedInDataContext"))
		fun findQualifiedInData(i: Int) : QualifiedInDataContext? = getRuleContext(solver.getType("QualifiedInDataContext"),i)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterQualifiedDataNameFormat1(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitQualifiedDataNameFormat1(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitQualifiedDataNameFormat1(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  qualifiedDataNameFormat1() : QualifiedDataNameFormat1Context {
		var _localctx : QualifiedDataNameFormat1Context = QualifiedDataNameFormat1Context(context, state)
		enterRule(_localctx, 1092, Rules.RULE_qualifiedDataNameFormat1.id)
		try {
			var _alt: Int
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6075
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,959,context) ) {
			1 -> {if (true){
			this.state = 6073
			dataName()
			}}
			2 -> {if (true){
			this.state = 6074
			conditionName()
			}}
			}
			this.state = 6086
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,962,context) ) {
			1   -> if (true){
			this.state = 6078 
			errorHandler.sync(this)
			_alt = 1
			do {
				when (_alt) {
				    1 -> if (true){
				if (true){
				this.state = 6077
				qualifiedInData()
				}
				}
				else -> throw NoViableAltException(this)
				}
				this.state = 6080 
				errorHandler.sync(this)
				_alt = interpreter!!.adaptivePredict(_input!!,960,context)
			} while ( _alt!=2 && _alt!=INVALID_ALT_NUMBER )
			this.state = 6083
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,961,context) ) {
			1   -> if (true){
			this.state = 6082
			inFile()
			}
			}
			}
			2   -> if (true){
			this.state = 6085
			inFile()
			}
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class QualifiedDataNameFormat2Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_qualifiedDataNameFormat2.id
	        set(value) { throw RuntimeException() }
		fun findParagraphName() : ParagraphNameContext? = getRuleContext(solver.getType("ParagraphNameContext"),0)
		fun findInSection() : InSectionContext? = getRuleContext(solver.getType("InSectionContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterQualifiedDataNameFormat2(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitQualifiedDataNameFormat2(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitQualifiedDataNameFormat2(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  qualifiedDataNameFormat2() : QualifiedDataNameFormat2Context {
		var _localctx : QualifiedDataNameFormat2Context = QualifiedDataNameFormat2Context(context, state)
		enterRule(_localctx, 1094, Rules.RULE_qualifiedDataNameFormat2.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6088
			paragraphName()
			this.state = 6089
			inSection()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class QualifiedDataNameFormat3Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_qualifiedDataNameFormat3.id
	        set(value) { throw RuntimeException() }
		fun findTextName() : TextNameContext? = getRuleContext(solver.getType("TextNameContext"),0)
		fun findInLibrary() : InLibraryContext? = getRuleContext(solver.getType("InLibraryContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterQualifiedDataNameFormat3(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitQualifiedDataNameFormat3(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitQualifiedDataNameFormat3(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  qualifiedDataNameFormat3() : QualifiedDataNameFormat3Context {
		var _localctx : QualifiedDataNameFormat3Context = QualifiedDataNameFormat3Context(context, state)
		enterRule(_localctx, 1096, Rules.RULE_qualifiedDataNameFormat3.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6091
			textName()
			this.state = 6092
			inLibrary()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class QualifiedDataNameFormat4Context : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_qualifiedDataNameFormat4.id
	        set(value) { throw RuntimeException() }
		fun LINAGE_COUNTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINAGE_COUNTER.id, 0)
		fun findInFile() : InFileContext? = getRuleContext(solver.getType("InFileContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterQualifiedDataNameFormat4(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitQualifiedDataNameFormat4(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitQualifiedDataNameFormat4(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  qualifiedDataNameFormat4() : QualifiedDataNameFormat4Context {
		var _localctx : QualifiedDataNameFormat4Context = QualifiedDataNameFormat4Context(context, state)
		enterRule(_localctx, 1098, Rules.RULE_qualifiedDataNameFormat4.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6094
			match(LINAGE_COUNTER) as Token
			this.state = 6095
			inFile()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class QualifiedInDataContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_qualifiedInData.id
	        set(value) { throw RuntimeException() }
		fun findInData() : InDataContext? = getRuleContext(solver.getType("InDataContext"),0)
		fun findInTable() : InTableContext? = getRuleContext(solver.getType("InTableContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterQualifiedInData(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitQualifiedInData(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitQualifiedInData(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  qualifiedInData() : QualifiedInDataContext {
		var _localctx : QualifiedInDataContext = QualifiedInDataContext(context, state)
		enterRule(_localctx, 1100, Rules.RULE_qualifiedInData.id)
		try {
			this.state = 6099
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,963,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6097
			inData()
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6098
			inTable()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InDataContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inData.id
	        set(value) { throw RuntimeException() }
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInData(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInData(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInData(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inData() : InDataContext {
		var _localctx : InDataContext = InDataContext(context, state)
		enterRule(_localctx, 1102, Rules.RULE_inData.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6101
			_la = _input!!.LA(1)
			if ( !(_la==IN || _la==OF) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 6102
			dataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InFileContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inFile.id
	        set(value) { throw RuntimeException() }
		fun findFileName() : FileNameContext? = getRuleContext(solver.getType("FileNameContext"),0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInFile(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInFile(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInFile(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inFile() : InFileContext {
		var _localctx : InFileContext = InFileContext(context, state)
		enterRule(_localctx, 1104, Rules.RULE_inFile.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6104
			_la = _input!!.LA(1)
			if ( !(_la==IN || _la==OF) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 6105
			fileName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InMnemonicContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inMnemonic.id
	        set(value) { throw RuntimeException() }
		fun findMnemonicName() : MnemonicNameContext? = getRuleContext(solver.getType("MnemonicNameContext"),0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInMnemonic(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInMnemonic(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInMnemonic(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inMnemonic() : InMnemonicContext {
		var _localctx : InMnemonicContext = InMnemonicContext(context, state)
		enterRule(_localctx, 1106, Rules.RULE_inMnemonic.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6107
			_la = _input!!.LA(1)
			if ( !(_la==IN || _la==OF) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 6108
			mnemonicName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InSectionContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inSection.id
	        set(value) { throw RuntimeException() }
		fun findSectionName() : SectionNameContext? = getRuleContext(solver.getType("SectionNameContext"),0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInSection(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInSection(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInSection(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inSection() : InSectionContext {
		var _localctx : InSectionContext = InSectionContext(context, state)
		enterRule(_localctx, 1108, Rules.RULE_inSection.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6110
			_la = _input!!.LA(1)
			if ( !(_la==IN || _la==OF) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 6111
			sectionName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InLibraryContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inLibrary.id
	        set(value) { throw RuntimeException() }
		fun findLibraryName() : LibraryNameContext? = getRuleContext(solver.getType("LibraryNameContext"),0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInLibrary(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInLibrary(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInLibrary(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inLibrary() : InLibraryContext {
		var _localctx : InLibraryContext = InLibraryContext(context, state)
		enterRule(_localctx, 1110, Rules.RULE_inLibrary.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6113
			_la = _input!!.LA(1)
			if ( !(_la==IN || _la==OF) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 6114
			libraryName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class InTableContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_inTable.id
	        set(value) { throw RuntimeException() }
		fun findTableCall() : TableCallContext? = getRuleContext(solver.getType("TableCallContext"),0)
		fun IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.IN.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterInTable(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitInTable(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitInTable(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  inTable() : InTableContext {
		var _localctx : InTableContext = InTableContext(context, state)
		enterRule(_localctx, 1112, Rules.RULE_inTable.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6116
			_la = _input!!.LA(1)
			if ( !(_la==IN || _la==OF) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			this.state = 6117
			tableCall()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AlphabetNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_alphabetName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAlphabetName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAlphabetName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAlphabetName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  alphabetName() : AlphabetNameContext {
		var _localctx : AlphabetNameContext = AlphabetNameContext(context, state)
		enterRule(_localctx, 1114, Rules.RULE_alphabetName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6119
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class AssignmentNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_assignmentName.id
	        set(value) { throw RuntimeException() }
		fun findSystemName() : SystemNameContext? = getRuleContext(solver.getType("SystemNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterAssignmentName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitAssignmentName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitAssignmentName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  assignmentName() : AssignmentNameContext {
		var _localctx : AssignmentNameContext = AssignmentNameContext(context, state)
		enterRule(_localctx, 1116, Rules.RULE_assignmentName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6121
			systemName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class BasisNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_basisName.id
	        set(value) { throw RuntimeException() }
		fun findProgramName() : ProgramNameContext? = getRuleContext(solver.getType("ProgramNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterBasisName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitBasisName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitBasisName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  basisName() : BasisNameContext {
		var _localctx : BasisNameContext = BasisNameContext(context, state)
		enterRule(_localctx, 1118, Rules.RULE_basisName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6123
			programName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CdNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_cdName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCdName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCdName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCdName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  cdName() : CdNameContext {
		var _localctx : CdNameContext = CdNameContext(context, state)
		enterRule(_localctx, 1120, Rules.RULE_cdName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6125
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ClassNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_className.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterClassName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitClassName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitClassName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  className() : ClassNameContext {
		var _localctx : ClassNameContext = ClassNameContext(context, state)
		enterRule(_localctx, 1122, Rules.RULE_className.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6127
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ComputerNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_computerName.id
	        set(value) { throw RuntimeException() }
		fun findSystemName() : SystemNameContext? = getRuleContext(solver.getType("SystemNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterComputerName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitComputerName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitComputerName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  computerName() : ComputerNameContext {
		var _localctx : ComputerNameContext = ComputerNameContext(context, state)
		enterRule(_localctx, 1124, Rules.RULE_computerName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6129
			systemName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ConditionNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_conditionName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterConditionName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitConditionName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitConditionName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  conditionName() : ConditionNameContext {
		var _localctx : ConditionNameContext = ConditionNameContext(context, state)
		enterRule(_localctx, 1126, Rules.RULE_conditionName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6131
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataName() : DataNameContext {
		var _localctx : DataNameContext = DataNameContext(context, state)
		enterRule(_localctx, 1128, Rules.RULE_dataName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6133
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class DataDescNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_dataDescName.id
	        set(value) { throw RuntimeException() }
		fun FILLER() : TerminalNode? = getToken(Cobol85Parser.Tokens.FILLER.id, 0)
		fun CURSOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.CURSOR.id, 0)
		fun findDataName() : DataNameContext? = getRuleContext(solver.getType("DataNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterDataDescName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitDataDescName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitDataDescName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  dataDescName() : DataDescNameContext {
		var _localctx : DataDescNameContext = DataDescNameContext(context, state)
		enterRule(_localctx, 1130, Rules.RULE_dataDescName.id)
		try {
			this.state = 6138
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,964,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6135
			match(FILLER) as Token
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6136
			match(CURSOR) as Token
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 6137
			dataName()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class EnvironmentNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_environmentName.id
	        set(value) { throw RuntimeException() }
		fun findSystemName() : SystemNameContext? = getRuleContext(solver.getType("SystemNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterEnvironmentName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitEnvironmentName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitEnvironmentName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  environmentName() : EnvironmentNameContext {
		var _localctx : EnvironmentNameContext = EnvironmentNameContext(context, state)
		enterRule(_localctx, 1132, Rules.RULE_environmentName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6140
			systemName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class FileNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_fileName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterFileName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitFileName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitFileName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  fileName() : FileNameContext {
		var _localctx : FileNameContext = FileNameContext(context, state)
		enterRule(_localctx, 1134, Rules.RULE_fileName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6142
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class FunctionNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_functionName.id
	        set(value) { throw RuntimeException() }
		fun INTEGER() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTEGER.id, 0)
		fun LENGTH() : TerminalNode? = getToken(Cobol85Parser.Tokens.LENGTH.id, 0)
		fun RANDOM() : TerminalNode? = getToken(Cobol85Parser.Tokens.RANDOM.id, 0)
		fun SUM() : TerminalNode? = getToken(Cobol85Parser.Tokens.SUM.id, 0)
		fun WHEN_COMPILED() : TerminalNode? = getToken(Cobol85Parser.Tokens.WHEN_COMPILED.id, 0)
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterFunctionName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitFunctionName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitFunctionName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  functionName() : FunctionNameContext {
		var _localctx : FunctionNameContext = FunctionNameContext(context, state)
		enterRule(_localctx, 1136, Rules.RULE_functionName.id)
		try {
			this.state = 6150
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,965,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6144
			match(INTEGER) as Token
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6145
			match(LENGTH) as Token
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 6146
			match(RANDOM) as Token
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 6147
			match(SUM) as Token
			}}
			5 -> {
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 6148
			match(WHEN_COMPILED) as Token
			}}
			6 -> {
			enterOuterAlt(_localctx, 6)
			if (true){
			this.state = 6149
			cobolWord()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class IndexNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_indexName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterIndexName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitIndexName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitIndexName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  indexName() : IndexNameContext {
		var _localctx : IndexNameContext = IndexNameContext(context, state)
		enterRule(_localctx, 1138, Rules.RULE_indexName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6152
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LanguageNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_languageName.id
	        set(value) { throw RuntimeException() }
		fun findSystemName() : SystemNameContext? = getRuleContext(solver.getType("SystemNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLanguageName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLanguageName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLanguageName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  languageName() : LanguageNameContext {
		var _localctx : LanguageNameContext = LanguageNameContext(context, state)
		enterRule(_localctx, 1140, Rules.RULE_languageName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6154
			systemName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LibraryNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_libraryName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLibraryName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLibraryName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLibraryName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  libraryName() : LibraryNameContext {
		var _localctx : LibraryNameContext = LibraryNameContext(context, state)
		enterRule(_localctx, 1142, Rules.RULE_libraryName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6156
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LocalNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_localName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLocalName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLocalName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLocalName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  localName() : LocalNameContext {
		var _localctx : LocalNameContext = LocalNameContext(context, state)
		enterRule(_localctx, 1144, Rules.RULE_localName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6158
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class MnemonicNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_mnemonicName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterMnemonicName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitMnemonicName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitMnemonicName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  mnemonicName() : MnemonicNameContext {
		var _localctx : MnemonicNameContext = MnemonicNameContext(context, state)
		enterRule(_localctx, 1146, Rules.RULE_mnemonicName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6160
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ParagraphNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_paragraphName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterParagraphName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitParagraphName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitParagraphName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  paragraphName() : ParagraphNameContext {
		var _localctx : ParagraphNameContext = ParagraphNameContext(context, state)
		enterRule(_localctx, 1148, Rules.RULE_paragraphName.id)
		try {
			this.state = 6164
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6162
			cobolWord()
			}}
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6163
			integerLiteral()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProcedureNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_procedureName.id
	        set(value) { throw RuntimeException() }
		fun findParagraphName() : ParagraphNameContext? = getRuleContext(solver.getType("ParagraphNameContext"),0)
		fun findInSection() : InSectionContext? = getRuleContext(solver.getType("InSectionContext"),0)
		fun findSectionName() : SectionNameContext? = getRuleContext(solver.getType("SectionNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProcedureName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProcedureName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProcedureName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  procedureName() : ProcedureNameContext {
		var _localctx : ProcedureNameContext = ProcedureNameContext(context, state)
		enterRule(_localctx, 1150, Rules.RULE_procedureName.id)
		var _la: Int
		try {
			this.state = 6171
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,968,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6166
			paragraphName()
			this.state = 6168
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==IN || _la==OF) {
				if (true){
				this.state = 6167
				inSection()
				}
			}

			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6170
			sectionName()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ProgramNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_programName.id
	        set(value) { throw RuntimeException() }
		fun NONNUMERICLITERAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NONNUMERICLITERAL.id, 0)
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterProgramName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitProgramName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitProgramName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  programName() : ProgramNameContext {
		var _localctx : ProgramNameContext = ProgramNameContext(context, state)
		enterRule(_localctx, 1152, Rules.RULE_programName.id)
		try {
			this.state = 6175
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			NONNUMERICLITERAL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6173
			match(NONNUMERICLITERAL) as Token
			}}
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6174
			cobolWord()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RecordNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_recordName.id
	        set(value) { throw RuntimeException() }
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRecordName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRecordName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRecordName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  recordName() : RecordNameContext {
		var _localctx : RecordNameContext = RecordNameContext(context, state)
		enterRule(_localctx, 1154, Rules.RULE_recordName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6177
			qualifiedDataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ReportNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_reportName.id
	        set(value) { throw RuntimeException() }
		fun findQualifiedDataName() : QualifiedDataNameContext? = getRuleContext(solver.getType("QualifiedDataNameContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterReportName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitReportName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitReportName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  reportName() : ReportNameContext {
		var _localctx : ReportNameContext = ReportNameContext(context, state)
		enterRule(_localctx, 1156, Rules.RULE_reportName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6179
			qualifiedDataName()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class RoutineNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_routineName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterRoutineName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitRoutineName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitRoutineName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  routineName() : RoutineNameContext {
		var _localctx : RoutineNameContext = RoutineNameContext(context, state)
		enterRule(_localctx, 1158, Rules.RULE_routineName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6181
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class ScreenNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_screenName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterScreenName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitScreenName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitScreenName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  screenName() : ScreenNameContext {
		var _localctx : ScreenNameContext = ScreenNameContext(context, state)
		enterRule(_localctx, 1160, Rules.RULE_screenName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6183
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SectionNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_sectionName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSectionName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSectionName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSectionName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  sectionName() : SectionNameContext {
		var _localctx : SectionNameContext = SectionNameContext(context, state)
		enterRule(_localctx, 1162, Rules.RULE_sectionName.id)
		try {
			this.state = 6187
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ABORT , AS , ASCII , ASSOCIATED_DATA , ASSOCIATED_DATA_LENGTH , ATTRIBUTE , AUTO , AUTO_SKIP , BACKGROUND_COLOR , BACKGROUND_COLOUR , BEEP , BELL , BINARY , BIT , BLINK , BOUNDS , CAPABLE , CCSVERSION , CHANGED , CHANNEL , CLOSE_DISPOSITION , COBOL , COMMITMENT , CONTROL_POINT , CONVENTION , CRUNCH , CURSOR , DEFAULT , DEFAULT_DISPLAY , DEFINITION , DFHRESP , DFHVALUE , DISK , DONTCARE , DOUBLE , EBCDIC , EMPTY_CHECK , ENTER , ENTRY_PROCEDURE , ERASE , EOL , EOS , ESCAPE , EVENT , EXCLUSIVE , EXPORT , EXTENDED , FOREGROUND_COLOR , FOREGROUND_COLOUR , FULL , FUNCTIONNAME , FUNCTION_POINTER , GRID , HIGHLIGHT , IMPLICIT , IMPORT , INTEGER , KEPT , KEYBOARD , LANGUAGE , LB , LD , LEFTLINE , LENGTH_CHECK , LIBACCESS , LIBPARAMETER , LIBRARY , LIST , LOCAL , LONG_DATE , LONG_TIME , LOWER , LOWLIGHT , MMDDYYYY , NAMED , NATIONAL , NATIONAL_EDITED , NETWORK , NO_ECHO , NUMERIC_DATE , NUMERIC_TIME , ODT , ORDERLY , OVERLINE , OWN , PASSWORD , PORT , PRINTER , PRIVATE , PROCESS , PROGRAM , PROMPT , READER , REMOTE , REAL , RECEIVED , RECURSIVE , REF , REMOVE , REQUIRED , REVERSE_VIDEO , SAVE , SECURE , SHARED , SHAREDBYALL , SHAREDBYRUNUNIT , SHARING , SHORT_DATE , SYMBOL , TASK , THREAD , THREAD_LOCAL , TIMER , TODAYS_DATE , TODAYS_NAME , TRUNCATED , TYPEDEF , UNDERLINE , VIRTUAL , WAIT , YEAR , YYYYMMDD , YYYYDDD , ZERO_FILL , IDENTIFIER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6185
			cobolWord()
			}}
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6186
			integerLiteral()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SystemNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_systemName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSystemName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSystemName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSystemName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  systemName() : SystemNameContext {
		var _localctx : SystemNameContext = SystemNameContext(context, state)
		enterRule(_localctx, 1164, Rules.RULE_systemName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6189
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SymbolicCharacterContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_symbolicCharacter.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSymbolicCharacter(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSymbolicCharacter(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSymbolicCharacter(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  symbolicCharacter() : SymbolicCharacterContext {
		var _localctx : SymbolicCharacterContext = SymbolicCharacterContext(context, state)
		enterRule(_localctx, 1166, Rules.RULE_symbolicCharacter.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6191
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class TextNameContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_textName.id
	        set(value) { throw RuntimeException() }
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterTextName(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitTextName(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitTextName(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  textName() : TextNameContext {
		var _localctx : TextNameContext = TextNameContext(context, state)
		enterRule(_localctx, 1168, Rules.RULE_textName.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6193
			cobolWord()
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CobolWordContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_cobolWord.id
	        set(value) { throw RuntimeException() }
		fun IDENTIFIER() : TerminalNode? = getToken(Cobol85Parser.Tokens.IDENTIFIER.id, 0)
		fun COBOL() : TerminalNode? = getToken(Cobol85Parser.Tokens.COBOL.id, 0)
		fun PROGRAM() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROGRAM.id, 0)
		fun ABORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.ABORT.id, 0)
		fun AS() : TerminalNode? = getToken(Cobol85Parser.Tokens.AS.id, 0)
		fun ASCII() : TerminalNode? = getToken(Cobol85Parser.Tokens.ASCII.id, 0)
		fun ASSOCIATED_DATA() : TerminalNode? = getToken(Cobol85Parser.Tokens.ASSOCIATED_DATA.id, 0)
		fun ASSOCIATED_DATA_LENGTH() : TerminalNode? = getToken(Cobol85Parser.Tokens.ASSOCIATED_DATA_LENGTH.id, 0)
		fun ATTRIBUTE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ATTRIBUTE.id, 0)
		fun AUTO() : TerminalNode? = getToken(Cobol85Parser.Tokens.AUTO.id, 0)
		fun AUTO_SKIP() : TerminalNode? = getToken(Cobol85Parser.Tokens.AUTO_SKIP.id, 0)
		fun BACKGROUND_COLOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.BACKGROUND_COLOR.id, 0)
		fun BACKGROUND_COLOUR() : TerminalNode? = getToken(Cobol85Parser.Tokens.BACKGROUND_COLOUR.id, 0)
		fun BEEP() : TerminalNode? = getToken(Cobol85Parser.Tokens.BEEP.id, 0)
		fun BELL() : TerminalNode? = getToken(Cobol85Parser.Tokens.BELL.id, 0)
		fun BINARY() : TerminalNode? = getToken(Cobol85Parser.Tokens.BINARY.id, 0)
		fun BIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.BIT.id, 0)
		fun BLINK() : TerminalNode? = getToken(Cobol85Parser.Tokens.BLINK.id, 0)
		fun BOUNDS() : TerminalNode? = getToken(Cobol85Parser.Tokens.BOUNDS.id, 0)
		fun CAPABLE() : TerminalNode? = getToken(Cobol85Parser.Tokens.CAPABLE.id, 0)
		fun CCSVERSION() : TerminalNode? = getToken(Cobol85Parser.Tokens.CCSVERSION.id, 0)
		fun CHANGED() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHANGED.id, 0)
		fun CHANNEL() : TerminalNode? = getToken(Cobol85Parser.Tokens.CHANNEL.id, 0)
		fun CLOSE_DISPOSITION() : TerminalNode? = getToken(Cobol85Parser.Tokens.CLOSE_DISPOSITION.id, 0)
		fun COMMITMENT() : TerminalNode? = getToken(Cobol85Parser.Tokens.COMMITMENT.id, 0)
		fun CONTROL_POINT() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONTROL_POINT.id, 0)
		fun CONVENTION() : TerminalNode? = getToken(Cobol85Parser.Tokens.CONVENTION.id, 0)
		fun CRUNCH() : TerminalNode? = getToken(Cobol85Parser.Tokens.CRUNCH.id, 0)
		fun CURSOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.CURSOR.id, 0)
		fun DEFAULT() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEFAULT.id, 0)
		fun DEFAULT_DISPLAY() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEFAULT_DISPLAY.id, 0)
		fun DEFINITION() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEFINITION.id, 0)
		fun DFHRESP() : TerminalNode? = getToken(Cobol85Parser.Tokens.DFHRESP.id, 0)
		fun DFHVALUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DFHVALUE.id, 0)
		fun DISK() : TerminalNode? = getToken(Cobol85Parser.Tokens.DISK.id, 0)
		fun DONTCARE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DONTCARE.id, 0)
		fun DOUBLE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DOUBLE.id, 0)
		fun EBCDIC() : TerminalNode? = getToken(Cobol85Parser.Tokens.EBCDIC.id, 0)
		fun EMPTY_CHECK() : TerminalNode? = getToken(Cobol85Parser.Tokens.EMPTY_CHECK.id, 0)
		fun ENTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.ENTER.id, 0)
		fun ENTRY_PROCEDURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ENTRY_PROCEDURE.id, 0)
		fun EOL() : TerminalNode? = getToken(Cobol85Parser.Tokens.EOL.id, 0)
		fun EOS() : TerminalNode? = getToken(Cobol85Parser.Tokens.EOS.id, 0)
		fun ERASE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ERASE.id, 0)
		fun ESCAPE() : TerminalNode? = getToken(Cobol85Parser.Tokens.ESCAPE.id, 0)
		fun EVENT() : TerminalNode? = getToken(Cobol85Parser.Tokens.EVENT.id, 0)
		fun EXCLUSIVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXCLUSIVE.id, 0)
		fun EXPORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXPORT.id, 0)
		fun EXTENDED() : TerminalNode? = getToken(Cobol85Parser.Tokens.EXTENDED.id, 0)
		fun FOREGROUND_COLOR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOREGROUND_COLOR.id, 0)
		fun FOREGROUND_COLOUR() : TerminalNode? = getToken(Cobol85Parser.Tokens.FOREGROUND_COLOUR.id, 0)
		fun FULL() : TerminalNode? = getToken(Cobol85Parser.Tokens.FULL.id, 0)
		fun FUNCTIONNAME() : TerminalNode? = getToken(Cobol85Parser.Tokens.FUNCTIONNAME.id, 0)
		fun FUNCTION_POINTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.FUNCTION_POINTER.id, 0)
		fun GRID() : TerminalNode? = getToken(Cobol85Parser.Tokens.GRID.id, 0)
		fun HIGHLIGHT() : TerminalNode? = getToken(Cobol85Parser.Tokens.HIGHLIGHT.id, 0)
		fun IMPLICIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.IMPLICIT.id, 0)
		fun IMPORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.IMPORT.id, 0)
		fun INTEGER() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTEGER.id, 0)
		fun KEPT() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEPT.id, 0)
		fun KEYBOARD() : TerminalNode? = getToken(Cobol85Parser.Tokens.KEYBOARD.id, 0)
		fun LANGUAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LANGUAGE.id, 0)
		fun LB() : TerminalNode? = getToken(Cobol85Parser.Tokens.LB.id, 0)
		fun LD() : TerminalNode? = getToken(Cobol85Parser.Tokens.LD.id, 0)
		fun LEFTLINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEFTLINE.id, 0)
		fun LENGTH_CHECK() : TerminalNode? = getToken(Cobol85Parser.Tokens.LENGTH_CHECK.id, 0)
		fun LIBACCESS() : TerminalNode? = getToken(Cobol85Parser.Tokens.LIBACCESS.id, 0)
		fun LIBPARAMETER() : TerminalNode? = getToken(Cobol85Parser.Tokens.LIBPARAMETER.id, 0)
		fun LIBRARY() : TerminalNode? = getToken(Cobol85Parser.Tokens.LIBRARY.id, 0)
		fun LIST() : TerminalNode? = getToken(Cobol85Parser.Tokens.LIST.id, 0)
		fun LOCAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOCAL.id, 0)
		fun LONG_DATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LONG_DATE.id, 0)
		fun LONG_TIME() : TerminalNode? = getToken(Cobol85Parser.Tokens.LONG_TIME.id, 0)
		fun LOWER() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOWER.id, 0)
		fun LOWLIGHT() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOWLIGHT.id, 0)
		fun MMDDYYYY() : TerminalNode? = getToken(Cobol85Parser.Tokens.MMDDYYYY.id, 0)
		fun NAMED() : TerminalNode? = getToken(Cobol85Parser.Tokens.NAMED.id, 0)
		fun NATIONAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIONAL.id, 0)
		fun NATIONAL_EDITED() : TerminalNode? = getToken(Cobol85Parser.Tokens.NATIONAL_EDITED.id, 0)
		fun NETWORK() : TerminalNode? = getToken(Cobol85Parser.Tokens.NETWORK.id, 0)
		fun NO_ECHO() : TerminalNode? = getToken(Cobol85Parser.Tokens.NO_ECHO.id, 0)
		fun NUMERIC_DATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMERIC_DATE.id, 0)
		fun NUMERIC_TIME() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMERIC_TIME.id, 0)
		fun ODT() : TerminalNode? = getToken(Cobol85Parser.Tokens.ODT.id, 0)
		fun ORDERLY() : TerminalNode? = getToken(Cobol85Parser.Tokens.ORDERLY.id, 0)
		fun OVERLINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.OVERLINE.id, 0)
		fun OWN() : TerminalNode? = getToken(Cobol85Parser.Tokens.OWN.id, 0)
		fun PASSWORD() : TerminalNode? = getToken(Cobol85Parser.Tokens.PASSWORD.id, 0)
		fun PORT() : TerminalNode? = getToken(Cobol85Parser.Tokens.PORT.id, 0)
		fun PRINTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.PRINTER.id, 0)
		fun PRIVATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.PRIVATE.id, 0)
		fun PROCESS() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROCESS.id, 0)
		fun PROMPT() : TerminalNode? = getToken(Cobol85Parser.Tokens.PROMPT.id, 0)
		fun READER() : TerminalNode? = getToken(Cobol85Parser.Tokens.READER.id, 0)
		fun REAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.REAL.id, 0)
		fun RECEIVED() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECEIVED.id, 0)
		fun RECURSIVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.RECURSIVE.id, 0)
		fun REF() : TerminalNode? = getToken(Cobol85Parser.Tokens.REF.id, 0)
		fun REMOTE() : TerminalNode? = getToken(Cobol85Parser.Tokens.REMOTE.id, 0)
		fun REMOVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.REMOVE.id, 0)
		fun REQUIRED() : TerminalNode? = getToken(Cobol85Parser.Tokens.REQUIRED.id, 0)
		fun REVERSE_VIDEO() : TerminalNode? = getToken(Cobol85Parser.Tokens.REVERSE_VIDEO.id, 0)
		fun SAVE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SAVE.id, 0)
		fun SECURE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SECURE.id, 0)
		fun SHARED() : TerminalNode? = getToken(Cobol85Parser.Tokens.SHARED.id, 0)
		fun SHAREDBYALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.SHAREDBYALL.id, 0)
		fun SHAREDBYRUNUNIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.SHAREDBYRUNUNIT.id, 0)
		fun SHARING() : TerminalNode? = getToken(Cobol85Parser.Tokens.SHARING.id, 0)
		fun SHORT_DATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SHORT_DATE.id, 0)
		fun SYMBOL() : TerminalNode? = getToken(Cobol85Parser.Tokens.SYMBOL.id, 0)
		fun TASK() : TerminalNode? = getToken(Cobol85Parser.Tokens.TASK.id, 0)
		fun THREAD() : TerminalNode? = getToken(Cobol85Parser.Tokens.THREAD.id, 0)
		fun THREAD_LOCAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.THREAD_LOCAL.id, 0)
		fun TIMER() : TerminalNode? = getToken(Cobol85Parser.Tokens.TIMER.id, 0)
		fun TODAYS_DATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.TODAYS_DATE.id, 0)
		fun TODAYS_NAME() : TerminalNode? = getToken(Cobol85Parser.Tokens.TODAYS_NAME.id, 0)
		fun TRUNCATED() : TerminalNode? = getToken(Cobol85Parser.Tokens.TRUNCATED.id, 0)
		fun TYPEDEF() : TerminalNode? = getToken(Cobol85Parser.Tokens.TYPEDEF.id, 0)
		fun UNDERLINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.UNDERLINE.id, 0)
		fun VIRTUAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.VIRTUAL.id, 0)
		fun WAIT() : TerminalNode? = getToken(Cobol85Parser.Tokens.WAIT.id, 0)
		fun YEAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.YEAR.id, 0)
		fun YYYYMMDD() : TerminalNode? = getToken(Cobol85Parser.Tokens.YYYYMMDD.id, 0)
		fun YYYYDDD() : TerminalNode? = getToken(Cobol85Parser.Tokens.YYYYDDD.id, 0)
		fun ZERO_FILL() : TerminalNode? = getToken(Cobol85Parser.Tokens.ZERO_FILL.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCobolWord(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCobolWord(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCobolWord(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  cobolWord() : CobolWordContext {
		var _localctx : CobolWordContext = CobolWordContext(context, state)
		enterRule(_localctx, 1170, Rules.RULE_cobolWord.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6195
			_la = _input!!.LA(1)
			if ( !((((_la) and 0x3f.inv()) == 0 && ((1L shl _la) and ((1L shl ABORT) or (1L shl AS) or (1L shl ASCII) or (1L shl ASSOCIATED_DATA) or (1L shl ASSOCIATED_DATA_LENGTH) or (1L shl ATTRIBUTE) or (1L shl AUTO) or (1L shl AUTO_SKIP) or (1L shl BACKGROUND_COLOR) or (1L shl BACKGROUND_COLOUR) or (1L shl BEEP) or (1L shl BELL) or (1L shl BINARY) or (1L shl BIT) or (1L shl BLINK) or (1L shl BOUNDS) or (1L shl CAPABLE) or (1L shl CCSVERSION) or (1L shl CHANGED) or (1L shl CHANNEL))) != 0L) || ((((_la - 68)) and 0x3f.inv()) == 0 && ((1L shl (_la - 68)) and ((1L shl (CLOSE_DISPOSITION - 68)) or (1L shl (COBOL - 68)) or (1L shl (COMMITMENT - 68)) or (1L shl (CONTROL_POINT - 68)) or (1L shl (CONVENTION - 68)) or (1L shl (CRUNCH - 68)) or (1L shl (CURSOR - 68)) or (1L shl (DEFAULT - 68)) or (1L shl (DEFAULT_DISPLAY - 68)) or (1L shl (DEFINITION - 68)))) != 0L) || ((((_la - 138)) and 0x3f.inv()) == 0 && ((1L shl (_la - 138)) and ((1L shl (DFHRESP - 138)) or (1L shl (DFHVALUE - 138)) or (1L shl (DISK - 138)) or (1L shl (DONTCARE - 138)) or (1L shl (DOUBLE - 138)) or (1L shl (EBCDIC - 138)) or (1L shl (EMPTY_CHECK - 138)) or (1L shl (ENTER - 138)) or (1L shl (ENTRY_PROCEDURE - 138)) or (1L shl (ERASE - 138)) or (1L shl (EOL - 138)) or (1L shl (EOS - 138)) or (1L shl (ESCAPE - 138)) or (1L shl (EVENT - 138)) or (1L shl (EXCLUSIVE - 138)) or (1L shl (EXPORT - 138)))) != 0L) || ((((_la - 202)) and 0x3f.inv()) == 0 && ((1L shl (_la - 202)) and ((1L shl (EXTENDED - 202)) or (1L shl (FOREGROUND_COLOR - 202)) or (1L shl (FOREGROUND_COLOUR - 202)) or (1L shl (FULL - 202)) or (1L shl (FUNCTIONNAME - 202)) or (1L shl (FUNCTION_POINTER - 202)) or (1L shl (GRID - 202)) or (1L shl (HIGHLIGHT - 202)) or (1L shl (IMPLICIT - 202)) or (1L shl (IMPORT - 202)) or (1L shl (INTEGER - 202)) or (1L shl (KEPT - 202)) or (1L shl (KEYBOARD - 202)) or (1L shl (LANGUAGE - 202)) or (1L shl (LB - 202)) or (1L shl (LD - 202)))) != 0L) || ((((_la - 268)) and 0x3f.inv()) == 0 && ((1L shl (_la - 268)) and ((1L shl (LEFTLINE - 268)) or (1L shl (LENGTH_CHECK - 268)) or (1L shl (LIBACCESS - 268)) or (1L shl (LIBPARAMETER - 268)) or (1L shl (LIBRARY - 268)) or (1L shl (LIST - 268)) or (1L shl (LOCAL - 268)) or (1L shl (LONG_DATE - 268)) or (1L shl (LONG_TIME - 268)) or (1L shl (LOWER - 268)) or (1L shl (LOWLIGHT - 268)) or (1L shl (MMDDYYYY - 268)) or (1L shl (NAMED - 268)) or (1L shl (NATIONAL - 268)) or (1L shl (NATIONAL_EDITED - 268)) or (1L shl (NETWORK - 268)) or (1L shl (NO_ECHO - 268)) or (1L shl (NUMERIC_DATE - 268)) or (1L shl (NUMERIC_TIME - 268)) or (1L shl (ODT - 268)) or (1L shl (ORDERLY - 268)))) != 0L) || ((((_la - 336)) and 0x3f.inv()) == 0 && ((1L shl (_la - 336)) and ((1L shl (OVERLINE - 336)) or (1L shl (OWN - 336)) or (1L shl (PASSWORD - 336)) or (1L shl (PORT - 336)) or (1L shl (PRINTER - 336)) or (1L shl (PRIVATE - 336)) or (1L shl (PROCESS - 336)) or (1L shl (PROGRAM - 336)) or (1L shl (PROMPT - 336)) or (1L shl (READER - 336)) or (1L shl (REMOTE - 336)) or (1L shl (REAL - 336)) or (1L shl (RECEIVED - 336)) or (1L shl (RECURSIVE - 336)) or (1L shl (REF - 336)) or (1L shl (REMOVE - 336)) or (1L shl (REQUIRED - 336)))) != 0L) || ((((_la - 401)) and 0x3f.inv()) == 0 && ((1L shl (_la - 401)) and ((1L shl (REVERSE_VIDEO - 401)) or (1L shl (SAVE - 401)) or (1L shl (SECURE - 401)) or (1L shl (SHARED - 401)) or (1L shl (SHAREDBYALL - 401)) or (1L shl (SHAREDBYRUNUNIT - 401)) or (1L shl (SHARING - 401)) or (1L shl (SHORT_DATE - 401)))) != 0L) || ((((_la - 466)) and 0x3f.inv()) == 0 && ((1L shl (_la - 466)) and ((1L shl (SYMBOL - 466)) or (1L shl (TASK - 466)) or (1L shl (THREAD - 466)) or (1L shl (THREAD_LOCAL - 466)) or (1L shl (TIMER - 466)) or (1L shl (TODAYS_DATE - 466)) or (1L shl (TODAYS_NAME - 466)) or (1L shl (TRUNCATED - 466)) or (1L shl (TYPEDEF - 466)) or (1L shl (UNDERLINE - 466)) or (1L shl (VIRTUAL - 466)) or (1L shl (WAIT - 466)) or (1L shl (YEAR - 466)) or (1L shl (YYYYMMDD - 466)) or (1L shl (YYYYDDD - 466)) or (1L shl (ZERO_FILL - 466)))) != 0L) || _la==IDENTIFIER) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class LiteralContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_literal.id
	        set(value) { throw RuntimeException() }
		fun NONNUMERICLITERAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NONNUMERICLITERAL.id, 0)
		fun findFigurativeConstant() : FigurativeConstantContext? = getRuleContext(solver.getType("FigurativeConstantContext"),0)
		fun findNumericLiteral() : NumericLiteralContext? = getRuleContext(solver.getType("NumericLiteralContext"),0)
		fun findBooleanLiteral() : BooleanLiteralContext? = getRuleContext(solver.getType("BooleanLiteralContext"),0)
		fun findCicsDfhRespLiteral() : CicsDfhRespLiteralContext? = getRuleContext(solver.getType("CicsDfhRespLiteralContext"),0)
		fun findCicsDfhValueLiteral() : CicsDfhValueLiteralContext? = getRuleContext(solver.getType("CicsDfhValueLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterLiteral(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitLiteral(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitLiteral(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  literal() : LiteralContext {
		var _localctx : LiteralContext = LiteralContext(context, state)
		enterRule(_localctx, 1172, Rules.RULE_literal.id)
		try {
			this.state = 6203
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,971,context) ) {
			1 -> {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6197
			match(NONNUMERICLITERAL) as Token
			}}
			2 -> {
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6198
			figurativeConstant()
			}}
			3 -> {
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 6199
			numericLiteral()
			}}
			4 -> {
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 6200
			booleanLiteral()
			}}
			5 -> {
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 6201
			cicsDfhRespLiteral()
			}}
			6 -> {
			enterOuterAlt(_localctx, 6)
			if (true){
			this.state = 6202
			cicsDfhValueLiteral()
			}}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class BooleanLiteralContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_booleanLiteral.id
	        set(value) { throw RuntimeException() }
		fun TRUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.TRUE.id, 0)
		fun FALSE() : TerminalNode? = getToken(Cobol85Parser.Tokens.FALSE.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterBooleanLiteral(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitBooleanLiteral(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitBooleanLiteral(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  booleanLiteral() : BooleanLiteralContext {
		var _localctx : BooleanLiteralContext = BooleanLiteralContext(context, state)
		enterRule(_localctx, 1174, Rules.RULE_booleanLiteral.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6205
			_la = _input!!.LA(1)
			if ( !(_la==FALSE || _la==TRUE) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class NumericLiteralContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_numericLiteral.id
	        set(value) { throw RuntimeException() }
		fun NUMERICLITERAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NUMERICLITERAL.id, 0)
		fun ZERO() : TerminalNode? = getToken(Cobol85Parser.Tokens.ZERO.id, 0)
		fun findIntegerLiteral() : IntegerLiteralContext? = getRuleContext(solver.getType("IntegerLiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterNumericLiteral(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitNumericLiteral(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitNumericLiteral(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  numericLiteral() : NumericLiteralContext {
		var _localctx : NumericLiteralContext = NumericLiteralContext(context, state)
		enterRule(_localctx, 1176, Rules.RULE_numericLiteral.id)
		try {
			this.state = 6210
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			NUMERICLITERAL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6207
			match(NUMERICLITERAL) as Token
			}}
			ZERO  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6208
			match(ZERO) as Token
			}}
			LEVEL_NUMBER_66 , LEVEL_NUMBER_77 , LEVEL_NUMBER_88 , INTEGERLITERAL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 6209
			integerLiteral()
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class IntegerLiteralContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_integerLiteral.id
	        set(value) { throw RuntimeException() }
		fun INTEGERLITERAL() : TerminalNode? = getToken(Cobol85Parser.Tokens.INTEGERLITERAL.id, 0)
		fun LEVEL_NUMBER_66() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEVEL_NUMBER_66.id, 0)
		fun LEVEL_NUMBER_77() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEVEL_NUMBER_77.id, 0)
		fun LEVEL_NUMBER_88() : TerminalNode? = getToken(Cobol85Parser.Tokens.LEVEL_NUMBER_88.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterIntegerLiteral(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitIntegerLiteral(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitIntegerLiteral(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  integerLiteral() : IntegerLiteralContext {
		var _localctx : IntegerLiteralContext = IntegerLiteralContext(context, state)
		enterRule(_localctx, 1178, Rules.RULE_integerLiteral.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6212
			_la = _input!!.LA(1)
			if ( !(((((_la - 552)) and 0x3f.inv()) == 0 && ((1L shl (_la - 552)) and ((1L shl (LEVEL_NUMBER_66 - 552)) or (1L shl (LEVEL_NUMBER_77 - 552)) or (1L shl (LEVEL_NUMBER_88 - 552)) or (1L shl (INTEGERLITERAL - 552)))) != 0L)) ) {
				errorHandler.recoverInline(this)
			}
			else {
				if ( _input!!.LA(1)==Tokens.EOF.id ) isMatchedEOF = true
				errorHandler.reportMatch(this)
				consume()
			}
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CicsDfhRespLiteralContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_cicsDfhRespLiteral.id
	        set(value) { throw RuntimeException() }
		fun DFHRESP() : TerminalNode? = getToken(Cobol85Parser.Tokens.DFHRESP.id, 0)
		fun LPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LPARENCHAR.id, 0)
		fun RPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.RPARENCHAR.id, 0)
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCicsDfhRespLiteral(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCicsDfhRespLiteral(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCicsDfhRespLiteral(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  cicsDfhRespLiteral() : CicsDfhRespLiteralContext {
		var _localctx : CicsDfhRespLiteralContext = CicsDfhRespLiteralContext(context, state)
		enterRule(_localctx, 1180, Rules.RULE_cicsDfhRespLiteral.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6214
			match(DFHRESP) as Token
			this.state = 6215
			match(LPARENCHAR) as Token
			this.state = 6218
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,973,context) ) {
			1 -> {if (true){
			this.state = 6216
			cobolWord()
			}}
			2 -> {if (true){
			this.state = 6217
			literal()
			}}
			}
			this.state = 6220
			match(RPARENCHAR) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CicsDfhValueLiteralContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_cicsDfhValueLiteral.id
	        set(value) { throw RuntimeException() }
		fun DFHVALUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DFHVALUE.id, 0)
		fun LPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.LPARENCHAR.id, 0)
		fun RPARENCHAR() : TerminalNode? = getToken(Cobol85Parser.Tokens.RPARENCHAR.id, 0)
		fun findCobolWord() : CobolWordContext? = getRuleContext(solver.getType("CobolWordContext"),0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCicsDfhValueLiteral(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCicsDfhValueLiteral(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCicsDfhValueLiteral(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  cicsDfhValueLiteral() : CicsDfhValueLiteralContext {
		var _localctx : CicsDfhValueLiteralContext = CicsDfhValueLiteralContext(context, state)
		enterRule(_localctx, 1182, Rules.RULE_cicsDfhValueLiteral.id)
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6222
			match(DFHVALUE) as Token
			this.state = 6223
			match(LPARENCHAR) as Token
			this.state = 6226
			errorHandler.sync(this)
			when ( interpreter!!.adaptivePredict(_input!!,974,context) ) {
			1 -> {if (true){
			this.state = 6224
			cobolWord()
			}}
			2 -> {if (true){
			this.state = 6225
			literal()
			}}
			}
			this.state = 6228
			match(RPARENCHAR) as Token
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class FigurativeConstantContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_figurativeConstant.id
	        set(value) { throw RuntimeException() }
		fun ALL() : TerminalNode? = getToken(Cobol85Parser.Tokens.ALL.id, 0)
		fun findLiteral() : LiteralContext? = getRuleContext(solver.getType("LiteralContext"),0)
		fun HIGH_VALUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.HIGH_VALUE.id, 0)
		fun HIGH_VALUES() : TerminalNode? = getToken(Cobol85Parser.Tokens.HIGH_VALUES.id, 0)
		fun LOW_VALUE() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOW_VALUE.id, 0)
		fun LOW_VALUES() : TerminalNode? = getToken(Cobol85Parser.Tokens.LOW_VALUES.id, 0)
		fun NULL() : TerminalNode? = getToken(Cobol85Parser.Tokens.NULL.id, 0)
		fun NULLS() : TerminalNode? = getToken(Cobol85Parser.Tokens.NULLS.id, 0)
		fun QUOTE() : TerminalNode? = getToken(Cobol85Parser.Tokens.QUOTE.id, 0)
		fun QUOTES() : TerminalNode? = getToken(Cobol85Parser.Tokens.QUOTES.id, 0)
		fun SPACE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SPACE.id, 0)
		fun SPACES() : TerminalNode? = getToken(Cobol85Parser.Tokens.SPACES.id, 0)
		fun ZERO() : TerminalNode? = getToken(Cobol85Parser.Tokens.ZERO.id, 0)
		fun ZEROS() : TerminalNode? = getToken(Cobol85Parser.Tokens.ZEROS.id, 0)
		fun ZEROES() : TerminalNode? = getToken(Cobol85Parser.Tokens.ZEROES.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterFigurativeConstant(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitFigurativeConstant(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitFigurativeConstant(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  figurativeConstant() : FigurativeConstantContext {
		var _localctx : FigurativeConstantContext = FigurativeConstantContext(context, state)
		enterRule(_localctx, 1184, Rules.RULE_figurativeConstant.id)
		try {
			this.state = 6245
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ALL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6230
			match(ALL) as Token
			this.state = 6231
			literal()
			}}
			HIGH_VALUE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6232
			match(HIGH_VALUE) as Token
			}}
			HIGH_VALUES  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 6233
			match(HIGH_VALUES) as Token
			}}
			LOW_VALUE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 6234
			match(LOW_VALUE) as Token
			}}
			LOW_VALUES  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 6235
			match(LOW_VALUES) as Token
			}}
			NULL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 6)
			if (true){
			this.state = 6236
			match(NULL) as Token
			}}
			NULLS  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 7)
			if (true){
			this.state = 6237
			match(NULLS) as Token
			}}
			QUOTE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 8)
			if (true){
			this.state = 6238
			match(QUOTE) as Token
			}}
			QUOTES  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 9)
			if (true){
			this.state = 6239
			match(QUOTES) as Token
			}}
			SPACE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 10)
			if (true){
			this.state = 6240
			match(SPACE) as Token
			}}
			SPACES  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 11)
			if (true){
			this.state = 6241
			match(SPACES) as Token
			}}
			ZERO  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 12)
			if (true){
			this.state = 6242
			match(ZERO) as Token
			}}
			ZEROS  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 13)
			if (true){
			this.state = 6243
			match(ZEROS) as Token
			}}
			ZEROES  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 14)
			if (true){
			this.state = 6244
			match(ZEROES) as Token
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class SpecialRegisterContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_specialRegister.id
	        set(value) { throw RuntimeException() }
		fun ADDRESS() : TerminalNode? = getToken(Cobol85Parser.Tokens.ADDRESS.id, 0)
		fun OF() : TerminalNode? = getToken(Cobol85Parser.Tokens.OF.id, 0)
		fun findIdentifier() : IdentifierContext? = getRuleContext(solver.getType("IdentifierContext"),0)
		fun DATE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DATE.id, 0)
		fun DAY() : TerminalNode? = getToken(Cobol85Parser.Tokens.DAY.id, 0)
		fun DAY_OF_WEEK() : TerminalNode? = getToken(Cobol85Parser.Tokens.DAY_OF_WEEK.id, 0)
		fun DEBUG_CONTENTS() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEBUG_CONTENTS.id, 0)
		fun DEBUG_ITEM() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEBUG_ITEM.id, 0)
		fun DEBUG_LINE() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEBUG_LINE.id, 0)
		fun DEBUG_NAME() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEBUG_NAME.id, 0)
		fun DEBUG_SUB_1() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEBUG_SUB_1.id, 0)
		fun DEBUG_SUB_2() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEBUG_SUB_2.id, 0)
		fun DEBUG_SUB_3() : TerminalNode? = getToken(Cobol85Parser.Tokens.DEBUG_SUB_3.id, 0)
		fun LENGTH() : TerminalNode? = getToken(Cobol85Parser.Tokens.LENGTH.id, 0)
		fun LINAGE_COUNTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINAGE_COUNTER.id, 0)
		fun LINE_COUNTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.LINE_COUNTER.id, 0)
		fun PAGE_COUNTER() : TerminalNode? = getToken(Cobol85Parser.Tokens.PAGE_COUNTER.id, 0)
		fun RETURN_CODE() : TerminalNode? = getToken(Cobol85Parser.Tokens.RETURN_CODE.id, 0)
		fun SHIFT_IN() : TerminalNode? = getToken(Cobol85Parser.Tokens.SHIFT_IN.id, 0)
		fun SHIFT_OUT() : TerminalNode? = getToken(Cobol85Parser.Tokens.SHIFT_OUT.id, 0)
		fun SORT_CONTROL() : TerminalNode? = getToken(Cobol85Parser.Tokens.SORT_CONTROL.id, 0)
		fun SORT_CORE_SIZE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SORT_CORE_SIZE.id, 0)
		fun SORT_FILE_SIZE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SORT_FILE_SIZE.id, 0)
		fun SORT_MESSAGE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SORT_MESSAGE.id, 0)
		fun SORT_MODE_SIZE() : TerminalNode? = getToken(Cobol85Parser.Tokens.SORT_MODE_SIZE.id, 0)
		fun SORT_RETURN() : TerminalNode? = getToken(Cobol85Parser.Tokens.SORT_RETURN.id, 0)
		fun TALLY() : TerminalNode? = getToken(Cobol85Parser.Tokens.TALLY.id, 0)
		fun TIME() : TerminalNode? = getToken(Cobol85Parser.Tokens.TIME.id, 0)
		fun WHEN_COMPILED() : TerminalNode? = getToken(Cobol85Parser.Tokens.WHEN_COMPILED.id, 0)
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterSpecialRegister(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitSpecialRegister(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitSpecialRegister(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  specialRegister() : SpecialRegisterContext {
		var _localctx : SpecialRegisterContext = SpecialRegisterContext(context, state)
		enterRule(_localctx, 1186, Rules.RULE_specialRegister.id)
		var _la: Int
		try {
			this.state = 6280
			errorHandler.sync(this)
			when (_input!!.LA(1)) {
			ADDRESS  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6247
			match(ADDRESS) as Token
			this.state = 6248
			match(OF) as Token
			this.state = 6249
			identifier()
			}}
			DATE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 2)
			if (true){
			this.state = 6250
			match(DATE) as Token
			}}
			DAY  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 3)
			if (true){
			this.state = 6251
			match(DAY) as Token
			}}
			DAY_OF_WEEK  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 4)
			if (true){
			this.state = 6252
			match(DAY_OF_WEEK) as Token
			}}
			DEBUG_CONTENTS  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 5)
			if (true){
			this.state = 6253
			match(DEBUG_CONTENTS) as Token
			}}
			DEBUG_ITEM  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 6)
			if (true){
			this.state = 6254
			match(DEBUG_ITEM) as Token
			}}
			DEBUG_LINE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 7)
			if (true){
			this.state = 6255
			match(DEBUG_LINE) as Token
			}}
			DEBUG_NAME  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 8)
			if (true){
			this.state = 6256
			match(DEBUG_NAME) as Token
			}}
			DEBUG_SUB_1  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 9)
			if (true){
			this.state = 6257
			match(DEBUG_SUB_1) as Token
			}}
			DEBUG_SUB_2  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 10)
			if (true){
			this.state = 6258
			match(DEBUG_SUB_2) as Token
			}}
			DEBUG_SUB_3  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 11)
			if (true){
			this.state = 6259
			match(DEBUG_SUB_3) as Token
			}}
			LENGTH  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 12)
			if (true){
			this.state = 6260
			match(LENGTH) as Token
			this.state = 6262
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			if (_la==OF) {
				if (true){
				this.state = 6261
				match(OF) as Token
				}
			}

			this.state = 6264
			identifier()
			}}
			LINAGE_COUNTER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 13)
			if (true){
			this.state = 6265
			match(LINAGE_COUNTER) as Token
			}}
			LINE_COUNTER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 14)
			if (true){
			this.state = 6266
			match(LINE_COUNTER) as Token
			}}
			PAGE_COUNTER  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 15)
			if (true){
			this.state = 6267
			match(PAGE_COUNTER) as Token
			}}
			RETURN_CODE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 16)
			if (true){
			this.state = 6268
			match(RETURN_CODE) as Token
			}}
			SHIFT_IN  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 17)
			if (true){
			this.state = 6269
			match(SHIFT_IN) as Token
			}}
			SHIFT_OUT  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 18)
			if (true){
			this.state = 6270
			match(SHIFT_OUT) as Token
			}}
			SORT_CONTROL  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 19)
			if (true){
			this.state = 6271
			match(SORT_CONTROL) as Token
			}}
			SORT_CORE_SIZE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 20)
			if (true){
			this.state = 6272
			match(SORT_CORE_SIZE) as Token
			}}
			SORT_FILE_SIZE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 21)
			if (true){
			this.state = 6273
			match(SORT_FILE_SIZE) as Token
			}}
			SORT_MESSAGE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 22)
			if (true){
			this.state = 6274
			match(SORT_MESSAGE) as Token
			}}
			SORT_MODE_SIZE  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 23)
			if (true){
			this.state = 6275
			match(SORT_MODE_SIZE) as Token
			}}
			SORT_RETURN  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 24)
			if (true){
			this.state = 6276
			match(SORT_RETURN) as Token
			}}
			TALLY  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 25)
			if (true){
			this.state = 6277
			match(TALLY) as Token
			}}
			TIME  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 26)
			if (true){
			this.state = 6278
			match(TIME) as Token
			}}
			WHEN_COMPILED  ->  /*LL1AltBlock*/{
			enterOuterAlt(_localctx, 27)
			if (true){
			this.state = 6279
			match(WHEN_COMPILED) as Token
			}}
			else -> throw NoViableAltException(this)
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

	open class CommentEntryContext : ParserRuleContext {
	    override var ruleIndex: Int
	        get() = Rules.RULE_commentEntry.id
	        set(value) { throw RuntimeException() }
		fun COMMENTENTRYLINE() : List<TerminalNode> = getTokens(Cobol85Parser.Tokens.COMMENTENTRYLINE.id)
		fun COMMENTENTRYLINE(i: Int) : TerminalNode = getToken(Cobol85Parser.Tokens.COMMENTENTRYLINE.id, i) as TerminalNode
		constructor(parent: ParserRuleContext?, invokingState: Int) : super(parent, invokingState){
		}
		override fun enterRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).enterCommentEntry(this)
		}
		override fun exitRule(listener: ParseTreeListener) {
			if ( listener is Cobol85Listener ) (listener as Cobol85Listener).exitCommentEntry(this)
		}
		override fun <T> accept(visitor : ParseTreeVisitor<out T>) : T {
			if ( visitor is Cobol85Visitor ) return (visitor as Cobol85Visitor<out T>).visitCommentEntry(this)
			else return visitor.visitChildren(this)!!
		}
	}

	fun  commentEntry() : CommentEntryContext {
		var _localctx : CommentEntryContext = CommentEntryContext(context, state)
		enterRule(_localctx, 1188, Rules.RULE_commentEntry.id)
		var _la: Int
		try {
			enterOuterAlt(_localctx, 1)
			if (true){
			this.state = 6283 
			errorHandler.sync(this)
			_la = _input!!.LA(1)
			do {
				if (true){
				if (true){
				this.state = 6282
				match(COMMENTENTRYLINE) as Token
				}
				}
				this.state = 6285 
				errorHandler.sync(this)
				_la = _input!!.LA(1)
			} while ( _la==COMMENTENTRYLINE )
			}
		}
		catch (re: RecognitionException) {
			_localctx.exception = re
			errorHandler.reportError(this, re)
			errorHandler.recover(this, re)
		}
		finally {
			exitRule()
		}
		return _localctx
	}

}